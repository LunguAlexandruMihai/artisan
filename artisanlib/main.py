#!/usr/bin/python
# -*- coding: utf-8 -*-

from artisanlib import __version__
from artisanlib import __revision__

# ABOUT
# This program shows how to plot the temperature and its rate of change from a
# Fuji PID or a thermocouple meter

# LICENSE
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 2 of the License, or
# version 3 of the License, or (at your option) any later versiSon. It is
# provided for educational purposes and is distributed in the hope that
# it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
# the GNU General Public License for more details.
#

#########################   POLICIES  ###########################################################################
# 1  STRINGS
#
# When possible, use QString and Unicode characters in user inputs. Use ASCII only for serial comm (raw data).
# There are two ways to create a unicode string: u"one way" and unicode("second way").
# There are two ways to create a QString: QString("one way") and the return of QTfunction()
# There are several ways to create ASCII strings: "one way", str("second way"), and return of python function().
# Inmideately convert ascii strings to Unicode at return of functions by using unicode().
# There is 7 bits Ascii, and then there is 8 bit Western Europe Ascii.
# WARNING: If an ascii str contains characters outside the 7 bit range, Python raises UnicodeEncodeError exception.
#################################################################################################################


import os
import imp
import sys
import ast
import platform
import serial
import serial.tools.list_ports
import math
import binascii
import time as libtime
#import glob
import warnings
import string as libstring
import cgi
import codecs
import numpy
import requests
import subprocess


import artisanlib.arabic_reshaper

# write logtrace to Console on OS X:
#try:
#..
#except Exception as e:
#    import syslog
#    syslog.openlog("artisan")
#    syslog.syslog(syslog.LOG_ALERT, str(e))
#    import traceback
#    syslog.syslog(syslog.LOG_ALERT, str(traceback.format_exc()))


import sip
sip.setapi('QString', 1)
sip.setapi('QVariant', 1)

from PyQt4.QtGui import (QLayout, QAction, QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog,
                         QInputDialog, QGroupBox, QDialog, QLineEdit, QTimeEdit, QTableWidgetSelectionRange,
                         QSizePolicy, QGridLayout, QVBoxLayout, QHBoxLayout, QPushButton, QDialogButtonBox,
                         QLCDNumber, QKeySequence, QSpinBox, QComboBox, QHeaderView, QStandardItem,
                         QSlider, QTabWidget, QStackedWidget, QTextEdit, QPrinter, QPrintDialog, QRadioButton,
                         QPixmap, QImage, QColor, QColorDialog, QPalette, QFrame, QCheckBox, QDesktopServices, QIcon,
                         QStatusBar, QRegExpValidator, QDoubleValidator, QIntValidator, QPainter, QFont, QBrush, QRadialGradient,
                         QStyleFactory, QTableWidget, QTableWidgetItem, QMenu, QCursor, QDoubleSpinBox, QTextDocument)
from PyQt4.QtCore import (QString, QStringList, QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, 
                          QT_VERSION_STR,SIGNAL, QTime, QTimer, QFile, QIODevice, QTextStream, QSettings, SLOT,
                          QRegExp, QDate, QUrl, QDir, QVariant, Qt, QPoint, QEvent, QDateTime, QThread, QSemaphore)


import matplotlib as mpl
from functools import reduce as freduce
mpl.use('qt4agg')

from matplotlib.figure import Figure
from matplotlib.colors import cnames as cnames
from matplotlib import rcParams
import matplotlib.patches as patches
import matplotlib.transforms as transforms
#import matplotlib.font_manager as font_manager
import matplotlib.ticker as ticker
import matplotlib.patheffects as PathEffects
#import matplotlib.dates as md

import qrcode

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar

try:
    import matplotlib.backends.qt_editor.figureoptions as figureoptions # for matplotlib >= v1.4
except ImportError:
    import matplotlib.backends.qt4_editor.figureoptions as figureoptions # for matplotlib <v1.4
    
from Phidgets.Devices.TemperatureSensor import TemperatureSensor as PhidgetTemperatureSensor, ThermocoupleType
from Phidgets.Devices.Bridge import Bridge as Phidget1046TemperatureSensor
from Phidgets.Devices.InterfaceKit import InterfaceKit as Phidget1018IO
from Phidgets.Manager import Manager as PhidgetManager

# import Yoctopuce Pyhton library (installed form PyPI)
from yoctopuce.yocto_api import YAPI, YRefParam
from yoctopuce.yocto_temperature import YTemperature

# fix socket.inet_pton on Windows (used by pymodbus TCP/UDP)
try:
    if str(platform.system()).startswith("Windows"):
        import win_inet_pton
except:
    pass

#import minimalmodbus
from pymodbus.client.sync import ModbusSerialClient, ModbusUdpClient, ModbusTcpClient, BaseModbusClient
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder, BinaryPayloadBuilder
from pymodbus.pdu import ExceptionResponse
import socket
from pymodbus.constants import Defaults
from pymodbus.transaction import ModbusSocketFramer
from pymodbus.factory import ClientDecoder



#---------------------------------------------------------------------------# 
# configure the service logging
#---------------------------------------------------------------------------# 
#import logging
#logging.basicConfig()
#log = logging.getLogger()
#log.setLevel(logging.DEBUG)
#---------------------------------------------------------------------------# 


import json
import unicodedata

from artisanlib.weblcds import startWeb, stopWeb

# platform dependent imports:
if sys.platform.startswith("darwin"):
    # control app napping on OS X >= 10.9
    import appnope
    # to establish a thread pool on OS X
    import objc
    import Foundation
    # on OS X load the Makerbot modified list_ports module patched for P3k
    from artisanlib.list_ports_osx import comports
    serial.tools.list_ports.comports = comports
    from artisanlib.list_ports_vid_pid_osx_posix import *
elif os.name == 'posix':
    from artisanlib.list_ports_vid_pid_osx_posix import *


# to make py2exe happy with scipy >0.11
def __dependencies_for_freezing():
    from scipy.sparse.csgraph import _validation
    from scipy.interpolate import UnivariateSpline
    import PyQt4.QtSvg
    import PyQt4.QtXml
    # for gevent bundling
    from gevent import core, resolver_thread, resolver_ares, socket,\
        threadpool, thread, threading, select, subprocess,\
        pywsgi, server, baseserver, event, hub

del __dependencies_for_freezing

if sys.version < '3':
    def stringp(x):
        return isinstance(x, basestring)
    def uchr(x):
        return unichr(x)
    def o(x): # converts char to byte
        return ord(x)
    def u(x): # convert to unicode string
        return unicode(x)
    def d(x):
        if x is not None:
            try:
                return codecs.unicode_escape_decode(x)[0]
            except Exception:
                return x
        else:
            return None
    def encodeLocal(x):
        if x is not None:
            return codecs.unicode_escape_encode(unicode(x))[0]
        else:
            return None
    def hex2int(h1,h2=""):
        return int(binascii.hexlify(h1+h2),16)
    def str2cmd(s):
        return s
    def cmd2str(c):
        return c
else:
    def stringp(x):
        return isinstance(x, str)
    def uchr(x):
        return chr(x)
    def o(x): # converts char to byte
        return x
    def u(x): # convert to unicode string
        return str(x)
    def d(x):
        if x is not None:
            return codecs.unicode_escape_decode(x)[0]
        else:
            return None
    def encodeLocal(x):
        if x is not None:
            return codecs.unicode_escape_encode(str(x))[0].decode("utf8")
        else:
            return None
    def hex2int(h1,h2=None):
        if h2:
            return int(h1*256 + h2)
        else:
            return int(h1)
    def str2cmd(s):
        return bytes(s,"ascii")
    def cmd2str(c):
        return str(c,"latin1")

platf = str(platform.system())



#######################################################################################
#################### minimal modbus monkey patch to support little-endian  ############
#################### little-endian in addition to big-endian for floats    ############
#######################################################################################

#def littleEndianBytestringToFloat(bytestring, numberOfRegisters=2):
#    """Convert a four-byte string to a float.
#
#    """
#    minimalmodbus._checkString(bytestring, minlength=4, maxlength=8, description='bytestring')
#    minimalmodbus._checkInt(numberOfRegisters, minvalue=2, maxvalue=4, description='number of registers')
#
#    numberOfBytes = minimalmodbus._NUMBER_OF_BYTES_PER_REGISTER * numberOfRegisters
#
#    formatcode = '<'  # Little-endian
#    if numberOfRegisters == 2:
#        formatcode += 'f'  # Float (4 bytes)
#    elif numberOfRegisters == 4:
#        formatcode += 'd'  # Double (8 bytes)
#    else:
#        raise ValueError('Wrong number of registers! Given value is {0!r}'.format(numberOfRegisters))
#
#    if len(bytestring) != numberOfBytes:
#        raise ValueError('Wrong length of the byte string! Given value is {0!r}, and numberOfRegisters is {1!r}.'.\
#            format(bytestring, numberOfRegisters))
#
#    return minimalmodbus._unpack(formatcode, bytestring)
#    
#bigEndianBytestringToFloat = minimalmodbus._bytestringToFloat

#######################################################################################
#################### Main Application  ################################################
#######################################################################################

class Artisan(QApplication):
    def __init__(self, args):
        super(Artisan, self).__init__(args)

    def event(self, event):
        if event.type() == QEvent.FileOpen:
            try:
                filename = u(event.file())
                qfile = QFileInfo(filename)
                file_suffix = u(qfile.suffix())
                if file_suffix == "alog":
                    # load Artisan profile on double-click on *.alog file
                    if not aw.qmc.flagon: # only if not yet monitoring
                        aw.loadFile(filename)
                elif file_suffix == "alrm":
                    # load Artisan alarms on double-click on *.alrm file
                    if not aw.qmc.flagstart:
                        aw.loadAlarms(filename)
                elif file_suffix == "apal":
                    # load Artisan palettes on double-click on *.apal file
                    if not aw.qmc.flagstart:
                        aw.loadPalettes(filename)
            except Exception:
                pass
            return 1
        return super(Artisan, self).event(event)


app = Artisan(sys.argv)
app.setApplicationName("Artisan")                                       #needed by QSettings() to store windows geometry in operating system
app.setOrganizationName("YourQuest")                                    #needed by QSettings() to store windows geometry in operating system
app.setOrganizationDomain("p.code.google.com")                          #needed by QSettings() to store windows geometry in operating system
if platf == 'Windows':
    app.setWindowIcon(QIcon("artisan.png"))

#Localization support
global locale

if not QSettings().value('resetqsettings').toInt()[0]:
    locale = QSettings().value('locale').toString()
    if locale == "en_US":
        locale = "en"
else:
    locale = ""
supported_languages = [
    "en"
    "ar",
    "de",
    "el",
    "es",
    "fi",
    "fr",
    "he",
    "hu",
    "it",
    "ja",
    "ko",
    "nl",
    "no",
    "pt",
    "ru",
    "sv",
    "tr",
    "zh",
]
if len(locale) == 0:
    if platform.system() == 'Darwin':
        from Cocoa import NSUserDefaults
        defs = NSUserDefaults.standardUserDefaults()
        langs = defs.objectForKey_("AppleLanguages")
        locale = langs.objectAtIndex_(0)
    else:
        locale = QLocale.system().name()[:2]
    if locale in supported_languages:
        QSettings().setValue('locale', locale)

qtTranslator = QTranslator()
#load Qt default translations from QLibrary
if qtTranslator.load("qt_" + locale, QLibraryInfo.location(QLibraryInfo.TranslationsPath)):
    app.installTranslator(qtTranslator)
#find Qt default translations in Mac binary
elif qtTranslator.load("qt_" + locale, QApplication.applicationDirPath() + "/../translations"):
    app.installTranslator(qtTranslator)
#load Artisan translations
appTranslator = QTranslator()
#find application translations in source folder
if appTranslator.load("artisan_" + locale, "translations"):
    app.installTranslator(appTranslator)
#find application translations in Mac binary
elif appTranslator.load("artisan_" + locale, QApplication.applicationDirPath() + "/../translations"):
    app.installTranslator(appTranslator)

from const import UIconst

# should not be needed anymore for minimalmodbus > v0.4
#if platf == 'Windows':
#    minimalmodbus.CLOSE_PORT_AFTER_EACH_CALL=True
#else:
#    minimalmodbus.CLOSE_PORT_AFTER_EACH_CALL=False

#######################################################################################
#################### GRAPH DRAWING WINDOW  ############################################
#######################################################################################

class tgraphcanvas(FigureCanvas):
    def __init__(self,parent):

        #default palette of colors
        self.palette = {"background":'white',"grid":'green',"ylabel":'0.20',"xlabel":'0.20',"title":'0.20',"rect1":'green',
                        "rect2":'orange',"rect3":'#996633',"rect4":'lightblue',"et":'red',"bt":'#00007f',"deltaet":'orange',
                        "deltabt":'blue',"markers":'black',"text":'black',"watermarks":'yellow',"Cline":'blue'}

        self.artisanflavordefaultlabels = [QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Clean Cup",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Head",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Sweetness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8)]

        # custom labels are stored in the application settings and can be edited by the user
        self.customflavorlabels = self.artisanflavordefaultlabels

        self.SCCAflavordefaultlabels = [QApplication.translate("Textbox", "Sour",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Critical\nStimulus",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Bitter",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Astringency",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Solubles\nConcentration",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Mouthfeel",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Other",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aromatic\nComplexity",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Roast\nColor",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aromatic\nPungency",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Sweet",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "pH",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]

        self.CQIflavordefaultlabels =  [QApplication.translate("Textbox", "Fragance",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8)]

        self.SweetMariasflavordefaultlabels = [QApplication.translate("Textbox", "Dry Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Uniformity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Complexity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Clean Cup",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Sweetness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Finish",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Brightness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Wet Aroma",None, QApplication.UnicodeUTF8)]

        self.Cflavordefaultlabels = [QApplication.translate("Textbox", "Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Taste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Nose",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8)]

        self.Eflavordefaultlabels = [QApplication.translate("Textbox", "Fragrance-Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]


        self.coffeegeekflavordefaultlabels = [QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Mouthfeel",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Flavour",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]


        self.Intelligentsiaflavordefaultlabels = [QApplication.translate("Textbox", "Sweetness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Finish",None, QApplication.UnicodeUTF8)]

        self.IstitutoInternazionaleAssaggiatoriCaffe = [QApplication.translate("Textbox", "Roast Color",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Crema Texture",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Crema Volume",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Bitterness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Defects",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma Intensity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma Persistence",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]

        self.ax1 = self.ax2 = None

        self.flavorlabels = list(self.artisanflavordefaultlabels)
        #Initial flavor parameters. 
        self.flavors = [5., 5., 5., 5., 5., 5., 5., 5., 5.]
        self.flavorstartangle = 90
        self.flavoraspect = 1.0  #aspect ratio

        #F = Fahrenheit; C = Celsius
        self.mode = "F"
        self.errorlog = []

        # default delay between readings in miliseconds
        self.default_delay = 3000 # default 3s
        self.delay = self.default_delay
        self.min_delay = 1000
        
        # oversampling flag
        self.oversampling = False
        self.oversampling_min_delay = 3000

        #watermarks limits: dryphase1, dryphase2, midphase, and finish phase Y limits
        self.phases_fahrenheit_defaults = [200,300,390,450]
        self.phases_celsius_defaults = [95,150,200,230]
        self.phases = list(self.phases_fahrenheit_defaults) # contains either the phases_filter or phases_espresso, depending on the mode
        self.phases_mode = 0 # indicates the active phases mode: 0: filter; 1: espresso
        self.phases_filter = self.phases
        self.phases_espresso = self.phases
        #this flag makes the main push buttons DryEnd, and FCstart change the phases[1] and phases[2] respectively
        self.phasesbuttonflag = True #False no change; True make the DRY and FC buttons change the phases during roast automatically
        self.watermarksflag = True

        #show phases LCDs during roasts
        self.phasesLCDflag = True
        self.phasesLCDmode = 0 # one of 0: time, 1: percentage, 2: temp mode
        

        #statistics flags selects to display: stat. time, stat. bar, stat. flavors, stat. area, stat. deg/min, stat. ETBTarea
        self.statisticsflags = [1,1,0,1,1,0]
        self.statisticsmode = 0 # one of 0: standard computed values, 1: roast properties
        #conditions to estimate bad flavor:dry[min,max],mid[min,max],finish[min,max] in seconds
        self.defaultstatisticsconditions = [180,360,180,600,180,360,180,300]
        self.statisticsconditions = self.defaultstatisticsconditions
        #records length in seconds of total time [0], dry phase [1],mid phase[2],finish phase[3], cool phase[4]
        self.statisticstimes = [0,0,0,0,0]

        #DEVICES
        self.device = 18                                    # default device selected to None (18). Calls appropiate function
        
        # Phidget variables
        self.phidget1048_types = [
            ThermocoupleType.PHIDGET_TEMPERATURE_SENSOR_K_TYPE,
            ThermocoupleType.PHIDGET_TEMPERATURE_SENSOR_K_TYPE,
            ThermocoupleType.PHIDGET_TEMPERATURE_SENSOR_K_TYPE,
            ThermocoupleType.PHIDGET_TEMPERATURE_SENSOR_K_TYPE] # probe types (ThermocoupleType)
        self.phidget1048_async = [False]*4
        self.phidget1048_changeTriggers = [1.0]*4
        self.phidget1048_changeTriggersValues = [x / 10.0 for x in range(1, 11, 1)]
        self.phidget1048_changeTriggersStrings = list(map(lambda x:str(x) + "C",self.phidget1048_changeTriggersValues))
        self.phidget1045_async = False
        self.phidget1045_changeTrigger = 1.0
        self.phidget1045_changeTriggersValues = [x / 10.0 for x in range(1, 11, 1)]
        self.phidget1045_changeTriggersStrings = list(map(lambda x:str(x) + "C",self.phidget1045_changeTriggersValues))
        self.phidget1045_emissivity = 1.0

        self.phidget_dataRatesStrings = ["0.25s","0.5s","0.75s","1s"] # too fast: "8ms","16ms","32ms","64ms","0.12s",
        self.phidget_dataRatesValues = [256,512,768,1000] # 8,16,32,64,128,

        self.phidget1046_async = [False]*4
        self.phidget1046_gain = [1]*4
        self.phidget1046_gainValues = ["1", "8","16","32","64","128"] # 1 for no gain
        self.phidget1046_formula = [1]*4 # 0: 1K Ohm Wheatstone Bridge, 1: 1K Ohm Voltage Divider, 2: raw
        self.phidget1046_formulaValues = ["WS", "Div","raw"]
        self.phidget1046_dataRate = 1000 # in ms; (Phidgets default 8ms, 16ms if wireless is active)
        
        self.phidgetRemoteFlag = False
        self.phidgetServerID = ""
        self.phidgetPassword = ""
        
        self.phidget1018_async = [False]*8
        self.phidget1018_raws = [False]*8
        self.phidget1018_dataRates = [1000]*8 # in ms; (Phidgets default 8ms, 16ms if wireless is active)
        self.phidget1018_changeTriggers = [10]*8
        self.phidget1018_changeTriggersValues = range(0,51,1)
        self.phidget1018_changeTriggersStrings = list(map(lambda x:str(x),self.phidget1018_changeTriggersValues))
        self.phidget1018Ratiometric = True

        #menu of thermocouple devices
        #device with first letter + only shows in extra device tab
        #device with first letter - does not show in any tab (but its position in the list is important)
        # device labels (used in Dialog config).

        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:" in the code
        # - add to self.devices
        self.devices = [#Fuji PID               #0
                       "Omega HH806AU",         #1
                       "Omega HH506RA",         #2
                       "CENTER 309",            #3
                       "CENTER 306",            #4
                       "CENTER 305",            #5
                       "CENTER 304",            #6
                       "CENTER 303",            #7
                       "CENTER 302",            #8
                       "CENTER 301",            #9
                       "CENTER 300",            #10
                       "VOLTCRAFT K204",        #11
                       "VOLTCRAFT K202",        #12
                       "VOLTCRAFT 300K",        #13
                       "VOLTCRAFT 302KJ",       #14
                       "EXTECH 421509",         #15
                       "Omega HH802U",          #16
                       "Omega HH309",           #17
                       "NONE",                  #18
                       "-ARDUINOTC4",           #19
                       "TE VA18B",              #20
                       "+CENTER 309_34",        #21
                       "+FUJI DUTY %/SV",       #22
                       "Omega HHM28[6]",        #23
                       "+VOLTCRAFT K204_34",    #24
                       "+Virtual",              #25
                       "-DTAtemperature",       #26
                       "Program",               #27
                       "+ArduinoTC4_34",        #28
                       "MODBUS",                #29
                       "VOLTCRAFT K201",        #30
                       "Amprobe TMD-56",        #31
                       "+ArduinoTC4_56",        #32
                       "+MODBUS_34",            #33
                       "Phidget 1048",          #34
                       "+Phidget 1048_34",      #35
                       "+Phidget 1048_AT",      #36
                       "Phidget 1046 RTD",      #37
                       "+Phidget 1046_34 RTD",  #38
                       "Mastech MS6514",        #39
                       "Phidget IO 12",         #40
                       "+Phidget IO 34",        #41
                       "+Phidget IO 56",        #42
                       "+Phidget IO 78",        #43
                       "+ArduinoTC4_78",        #44
                       "Yocto Thermocouple",    #45
                       "Yocto PT100",           #46
                       "Phidget 1045 IR",       #47
                       "+Program_34",           #48
                       "+Program_56",           #49
                       "DUMMY",                 #50
                       "+CENTER 304_34",        #52
                       "-Omega HH806W"          #52 NOT WORKING 
                       ]

        #extra devices
        self.extradevices = []                                      # list with indexes for extra devices
        self.extratimex = []                                        # individual time for each extra device (more accurate). List of lists (2 dimension)
        self.extradevicecolor1 = []                                 # extra line 1 color. list with colors.
        self.extradevicecolor2 = []                                 # extra line 2 color. list with colors.
        self.extratemp1,self.extratemp2 = [],[]                     # extra temp1, temp2. List of lists
        self.extrastemp1,self.extrastemp2 = [],[]                   # smoothed extra temp1, temp2. List of lists
        self.extratemp1lines,self.extratemp2lines = [],[]           # lists with extra lines for speed drawing
        self.extraname1,self.extraname2 = [],[]                     # name of labels for line (like ET or BT) - legend
        self.extramathexpression1,self.extramathexpression2 = [],[]           # list with user defined math evaluating strings. Example "2*cos(x)"
        self.extralinestyles1,self.extralinestyles2 = [],[]         # list of extra curve line styles
        self.extradrawstyles1,self.extradrawstyles2 = [],[]         # list of extra curve drawing styles
        self.extralinewidths1,self.extralinewidths2 = [],[]         # list of extra curve linewidth
        self.extramarkers1,self.extramarkers2 = [],[]               # list of extra curve marker styles
        self.extramarkersizes1,self.extramarkersizes2 = [],[]       # list of extra curve marker size

        #holds math expressions to plot
        self.plotcurves=["", "", "", "", "", ""]
        self.plotcurvecolor = ["black","black","black","black","black","black"]

        self.fig = Figure(tight_layout={"pad":.2},frameon=True) # ,"h_pad":0.0,"w_pad":0.0
        # with tight_layout=True, the matplotlib canvas expands to the maximum using figure.autolayout

        #figure back color
        if platf == 'Darwin':
            self.backcolor ="#EEEEEE"
        else:
            self.backcolor = "white"
        self.fig.patch.set_facecolor(self.backcolor)
        self.fig.patch.set_edgecolor(self.backcolor)

        self.ax = self.fig.add_subplot(111, axisbg= self.palette["background"])
        self.delta_ax = self.ax.twinx()

        #legend location
        self.legendloc = 2
        self.fig.subplots_adjust(
            # all values in percent
            top=0.93, # the top of the subplots of the figure (default: 0.9)
            bottom=0.1, # the bottom of the subplots of the figure (default: 0.1)
            left=0.067, # the left side of the subplots of the figure (default: 0.125)
            right=.925) # the right side of the subplots of the figure (default: 0.9
        FigureCanvas.__init__(self, self.fig)

        self.fig.canvas.mpl_connect('button_press_event', self.onclick)

        # set the parent widget
        self.setParent(parent)
        # we define the widget as
        FigureCanvas.setSizePolicy(self,QSizePolicy.Expanding,QSizePolicy.Expanding)
        # notify the system of updated policy
        FigureCanvas.updateGeometry(self)

        # the rate of chage of temperature
        self.rateofchange1 = 0.0
        self.rateofchange2 = 0.0

        #read and plot on/off flag
        self.flagon = False  # Artisan turned on
        self.flagstart = False # Artisan logging
        self.flagsampling = False # if True, Artisan is still in the sampling phase and one has to wait for its end to turn OFF
        self.flagsamplingthreadrunning = False
        #log flag that tells to log ET when using device 18 (manual mode)
        self.manuallogETflag = 0
        
        self.flagalignFCs = False

        self.roastpropertiesflag = 1  #resets roast properties if not zero
        self.title = QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8)
        self.ambientTemp = 0.
        self.ambientTempSource = 0 # indicates the temperature curve that is used to automatically fill the ambient temperature on DROP
#                                  # 0 : None; 1 : ET, 2 : BT, 3 : 0xT1, 4 : 0xT2,
        self.ambient_humidity = 0.
        #relative humidity percentage [0], corresponding temperature [1]
        
        self.moisture_greens = 0.
        self.moisture_roasted = 0.
        
        self.beansize = 0.0

        self.whole_color = 0
        self.ground_color = 0
        self.color_systems = ["","Tonino","ColorTest","Colorette","ColorTrack","Agtron"]
        self.color_system_idx = 0

        # roast property flags
        self.heavyFC_flag = False
        self.lowFC_flag = False
        self.lightCut_flag = False
        self.darkCut_flag = False
        self.drops_flag = False
        self.oily_flag = False
        self.uneven_flag = False
        self.tipping_flag = False
        self.scorching_flag = False
        self.divots_flag = False

        #list to store the time of each reading. Most IMPORTANT variable.
        self.timex = []

        #lists to store temps and rates of change. Second most IMPORTANT variables. All need same dimension.
        #self.temp1 = ET ; self.temp2 = BT; self.delta1 = deltaMET; self.delta2 = deltaBT
        self.temp1,self.temp2,self.delta1, self.delta2 = [],[],[],[]
        self.stemp1,self.stemp2 = [],[] # smoothed versions of temp1/temp2 usind in redraw()
        self.unfiltereddelta1, self.unfiltereddelta2 = [],[] # used in sample()

        #indexes for CHARGE[0],DRYe[1],FCs[2],FCe[3],SCs[4],SCe[5],DROP[6] and COOLe[7]
        #Example: Use as self.timex[self.timeindex[1]] to get the time of DryEnd
        #Example: Use self.temp2[self.timeindex[4]] to get the BT temperature of SCs

        self.timeindex = [-1,0,0,0,0,0,0,0] #CHARGE index init set to -1 as 0 could be an actal index used

        #applies a Y(x) function to ET or BT 
        self.ETfunction,self.BTfunction = "",""

        #put a "aw.qmc.safesaveflag = True" whenever there is a change of a profile like at [DROP], edit properties Dialog, etc
        #prevents accidentally deleting a modified profile.
        self.safesaveflag = False

        #background profile
        self.background = False
        self.backgroundDetails = False
        self.backgroundeventsflag = False
        self.backgroundpath = ""
        self.titleB = ""
        self.temp1B,self.temp2B,self.timeB = [],[],[]
        self.stemp1B,self.stemp2B = [],[] # smoothed versions of the background courves
        self.delta1B,self.delta2B = [],[]
        self.timeindexB = [-1,0,0,0,0,0,0,0]
        self.backgroundEvents = [] #indexes of background events
        self.backgroundEtypes = []
        self.backgroundEvalues = []
        self.backgroundEStrings = []
        self.backgroundalpha = 0.3
        self.backgroundmetcolor = self.palette["et"]
        self.backgroundbtcolor = self.palette["bt"]
        self.backgrounddeltaetcolor = self.palette["deltaet"]
        self.backgrounddeltabtcolor = self.palette["deltabt"]
        self.backmoveflag = 1
        self.detectBackgroundEventTime = 20 #seconds
        self.backgroundReproduce = False
        self.Betypes = [QApplication.translate("Scope Annotation", "Speed",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Scope Annotation", "Heater",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Scope Annotation", "Damper",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Scope Annotation", "Fan",None, QApplication.UnicodeUTF8),
                        "--"]
        self.backgroundFlavors = []
        self.flavorbackgroundflag = False
        #background by value
        self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
        self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
        self.l_backgroundeventtype1dots, = self.ax.plot(self.E1backgroundtimex, self.E1backgroundvalues, color="grey")
        self.l_backgroundeventtype2dots, = self.ax.plot(self.E2backgroundtimex, self.E2backgroundvalues, color="darkgrey")
        self.l_backgroundeventtype3dots, = self.ax.plot(self.E3backgroundtimex, self.E3backgroundvalues, color="slategrey")
        self.l_backgroundeventtype4dots, = self.ax.plot(self.E4backgroundtimex, self.E4backgroundvalues, color="slateblue")
        # background Deltas
        self.DeltaETBflag = False
        self.DeltaBTBflag = False

        # projection variables of change of rate
        self.HUDflag = False
        self.hudresizeflag = False
        self.ETtarget = 300
        self.ET2target = 350
        self.BTtarget = 200
        self.BT2target = 250
        self.hudETpid = [5,240,60]    # HUD pid: p = 20, i = 60, d = 13
        self.pidpreviouserror = 0  # temporary storage of pid error

        #General notes. Accessible through "edit graph properties" of graph menu. WYSIWYG viewer/editor.
        self.roastertype = ""
        self.operator = ""
        self.roastingnotes = ""
        self.cuppingnotes = ""
        self.roastdate = QDate.currentDate()
        self.beans = ""

        #flags to show projections, draw Delta ET, and draw Delta BT
        self.projectFlag = False
        self.ETcurve = True
        self.BTcurve = True
        self.ETlcd = True
        self.BTlcd = True
        self.LCDdecimalplaces = 1
        self.DeltaETflag = False
        self.DeltaBTflag = False
        self.DeltaETlcdflag = True
        self.DeltaBTlcdflag = True
        self.HUDbuttonflag = False
        self.PIDbuttonflag = True
        # user filter values x are translated as follows to internal filter values: y = x*2 + 1 (to go the other direction: x = y/2)
        # this is to ensure, that only uneven window values are used and no wrong shift is happening through smoothing
        self.deltafilter = 5 # => corresponds to 2 on the user interface
        self.curvefilter = 3 # => corresponds to 1 on the user interface
        self.deltaspan = 6 # the time period taken to compute one deltaBT/ET value (1-15sec)
        self.deltasamples = 2 # the number of samples that make up the delta span, to be used in the delta computations (> 0!)
        self.profile_sampling_interval = None # will be updated on loading a profile
        
        self.altsmoothing = False # toggle between standard and alternative smoothing approach
        self.smoothingwindowsize = 3 # window size of the alternative smoothing approach

        self.patheffects = 3
        self.graphstyle = 0
        self.graphfont = 0

        #variables to configure the 8 default buttons
        # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END
        self.buttonvisibility = [True]*8
        self.buttonactions = [0]*8
        self.buttonactionstrings = [""]*8
        #variables to configure the 0: ON, 1: OFF buttons and 2: SAMPLE action
        self.extrabuttonactions = [0]*3
        self.extrabuttonactionstrings = [""]*3

        #flag to activate the automatic marking of the CHARGE and DROP events
        #self.autoChargeDropFlag = False # has been replaced by the following two separate flags
        self.autoChargeFlag = False
        self.autoDropFlag = False
        #autodetected CHARGE and DROP index
        self.autoChargeIdx = 0
        self.autoDropIdx = 0

        self.markTPflag = True
        self.autoTPIdx = 0 # set by sample() on recognition and cleared once TP is marked

        # flags to control automatic DRY and FCs events based on phases limits
        self.autoDRYflag = False
        self.autoFCsFlag = False
        self.autoDryIdx = 0 # set by sample() on recognition and cleared once DRY is marked
        self.autoFCsIdx = 0 # set by sample() on recognition and cleared once FCs is marked

        # projection variables of change of rate
        self.projectionconstant = 1
        self.projectionmode = 0     # 0 = linear; 1 = newton

        #[0]weight in, [1]weight out, [2]units (string)
        self.weight = [0,0,"g"]
        #[0]volume in, [1]volume out, [2]units (string)
        self.volume = [0,0,"l"]
        #[0]probe weight, [1]weight unit, [2]probe volume, [3]volume unit
        self.density = [0.,"g",1.,"l"]
        
        self.volumeCalcUnit = 0
        self.volumeCalcWeightInStr = ""
        self.volumeCalcWeightOutStr = ""
        
        # container scale tare
        self.container_names = []
        self.container_weights = [] # all weights in g and as int
        self.container_idx = -1 # the empty field (as -1 + 2 = 1)

        #stores _indexes_ of self.timex to record events. Use as self.timex[self.specialevents[x]] to get the time of an event
        # use self.temp2[self.specialevents[x]] to get the BT temperature of an event.
        self.specialevents = []
        #ComboBox text event types. They can be modified in eventsDlg()
        self.etypes = [QApplication.translate("ComboBox", "Speed",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Power",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Damper",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Fan",None, QApplication.UnicodeUTF8),
                       "--"]
        #default etype settings to restore
        self.etypesdefault = [QApplication.translate("ComboBox", "Speed",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox", "Power",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox", "Damper",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox", "Fan",None, QApplication.UnicodeUTF8),
                              "--"]
        #stores the type of each event as index of self.etypes. None = 0, Power = 1, etc.
        self.specialeventstype = []
        #stores text string descriptions for each event.
        self.specialeventsStrings = []
        #event values are from 0-10
        #stores the value for each event
        self.specialeventsvalue = []
        #flag that makes the events location type bars (horizontal bars) appear on the plot. flag read on redraw()
        # 0 = no event bars; 1 = type bars (4 bars); 2 = value bars (10 bars)
        self.eventsGraphflag = 0
        #flag that shows events in the graph
        self.eventsshowflag = 0
        #plot events by value
        self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
        self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
        self.EvalueColor = ["brown","blue","purple","grey"]
        self.EvalueMarker = ["o","s","h","D"]
        self.EvalueMarkerSize = [8,8,8,8]
        self.Evaluelinethickness = [2,2,2,2]
        self.Evaluealpha = [.8,.8,.8,.8]
        #the event value position bars are calculated at redraw()
        self.eventpositionbars = [0.]*12

        #curve styles
        self.linestyle_default = "-"
        self.drawstyle_default = "default"
        self.linewidth_default = 2
        self.marker_default = None
        self.markersize_default = 6

        self.BTlinestyle = self.linestyle_default
        self.BTdrawstyle = self.drawstyle_default
        self.BTlinewidth = self.linewidth_default
        self.BTmarker = self.marker_default
        self.BTmarkersize = self.markersize_default
        self.ETlinestyle = self.linestyle_default
        self.ETdrawstyle = self.drawstyle_default
        self.ETlinewidth = self.linewidth_default
        self.ETmarker = self.marker_default
        self.ETmarkersize = self.markersize_default
        self.BTdeltalinestyle = self.linestyle_default
        self.BTdeltadrawstyle = self.drawstyle_default
        self.BTdeltalinewidth = self.linewidth_default
        self.BTdeltamarker = self.marker_default
        self.BTdeltamarkersize = self.markersize_default
        self.ETdeltalinestyle = self.linestyle_default
        self.ETdeltadrawstyle = self.drawstyle_default
        self.ETdeltalinewidth = self.linewidth_default
        self.ETdeltamarker = self.marker_default
        self.ETdeltamarkersize = self.markersize_default
        self.BTbacklinestyle = self.linestyle_default
        self.BTbackdrawstyle = self.drawstyle_default
        self.BTbacklinewidth = self.linewidth_default
        self.BTbackmarker = self.marker_default
        self.BTbackmarkersize = self.markersize_default
        self.ETbacklinestyle = self.linestyle_default
        self.ETbackdrawstyle = self.drawstyle_default
        self.ETbacklinewidth = self.linewidth_default
        self.ETbackmarker = self.marker_default
        self.ETbackmarkersize = self.markersize_default
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default

        #Temperature Alarms lists. Data is written in  alarmDlg 
        self.alarmflag = []    # 0 = OFF; 1 = ON flags
        self.alarmguard = []   # points to another alarm by index that has to be triggered before; -1 indicates no guard
        self.alarmnegguard = []   # points to another alarm by index that should not has been triggered before; -1 indicates no guard
        self.alarmtime = []    # times after which each alarm becomes efective. Usage: self.timeindex[self.alarmtime[i]]
#                              # -1 equals None
        self.alarmoffset = []  # for timed alarms, the seconds after alarmtime the alarm is triggered
        self.alarmtime2menuidx = [2,4,5,6,7,8,9,10,3,0,1] # maps self.alarmtime index to menu idx (to move TP in menu from index 9 to 3)
        self.menuidx2alarmtime = [9,-1,0,8,1,2,3,4,5,6,7] # inverse of above (note that those two are only inverse in one direction!)
        self.alarmcond = []    # 0 = falls below; 1 = rises above
        # alarmstate is set to 'not triggered' on reset()
        self.alarmstate = []   # 1=triggered, 0=not triggered. Needed so that the user does not have to turn the alarms ON next roast after alarm being used once.
        self.alarmsource = []   # -3=None, -2=DeltaET, -1=DeltaBT, 0=ET , 1=BT, 2=extratemp1[0], 3=extratemp2[0], 4=extratemp2[1],....
        self.alarmtemperature = []  # set temperature number (example 500)
        self.alarmaction = []       # -1 = no action; 0 = open a window; 1 = call program with a filepath equal to alarmstring; 2 = activate button with number given in description; 
                                    # 3,4,5,6 = move slider with value given in description
                                    # 7 (START), 8 (DRY), 9 (FCs), 10 (FCe), 11 (SCs), 12 (SCe), 13 (DROP), 14 (COOL), 15 (OFF)
        self.alarmbeep = []    # 0 = OFF; 1 = ON flags
        self.alarmstrings = []      # text descriptions, action to take, or filepath to call another program

        self.loadalarmsfromprofile = False # if set, alarms are loaded from profile (even background profiles)
        self.alarmsfile = "" # filename alarms were loaded from
        self.temporaryalarmflag = -3 #holds temporary index value of triggered alarm in updategraphics()
        self.TPalarmtimeindex = None # is set to the current  aw.qmc.timeindex by sample(), if alarms are defined and once the TP is detected
        
        self.quantifiedEvent = [] # holds an event quantified during sample(), a tuple [<eventnr>,<value>]q

        # set initial limits for X and Y axes. But they change after reading the previous seetings at aw.settingsload()
        self.ylimit = 600
        self.ylimit_min = 0
        self.zlimit = 100
        self.zlimit_min = 0
        self.RoRlimitF = 80
        self.RoRlimitC = 45
        self.endofx = 60
        self.startofx = 0
        self.resetmaxtime = 60  #time when pressing reset
        self.fixmaxtime = False # if true, do not automatically extend the endofx by 3min if needed because the measurements get out of the x-axis
        self.locktimex = False # if true, do not set time axis min and max from profile on load
        self.locktimex_start = 0 # seconds of x-axis min as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.xgrid = 60   #initial time separation; 60 = 1 minute
        self.ygrid = 100  #initial temperature separation
        self.zgrid = 10   #initial RoR separation
        self.gridstyles =    ["-","--","-.",":"," "]  #solid,dashed,dash-dot,dotted,None
        self.gridlinestyle = 0
        self.gridthickness = 1
        self.gridalpha = .2
        self.xrotation = 0

        #height of statistics bar
        self.statisticsheight = 650
        self.statisticsupper = 655
        self.statisticslower = 617

        # autosave
        self.autosaveflag = 0
        self.autosaveprefix = ""
        self.autosavepath = ""

        #used to place correct height of text to avoid placing text over text (annotations)
        self.ystep_down = 0
        self.ystep_up = 0

        self.ax.set_xlim(self.startofx, self.endofx)
        self.ax.set_ylim(self.ylimit_min,self.ylimit)
        
        if self.delta_ax:
            self.delta_ax.set_xlim(self.startofx, self.endofx)
            self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
            self.delta_ax.set_autoscale_on(False)

        # disable figure autoscale
        self.ax.set_autoscale_on(False)

        #set grid + axle labels + title
        self.ax.grid(True,color=self.palette["grid"],linestyle = self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha)

        #change label colors
        for label in self.ax.yaxis.get_ticklabels():
            label.set_color(self.palette["ylabel"])

        for label in self.ax.xaxis.get_ticklabels():
            label.set_color(self.palette["xlabel"])

        # generates first "empty" plot (lists are empty) of temperature and deltaT
        self.l_temp1, = self.ax.plot(self.timex,self.temp1,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=u(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
        self.l_temp2, = self.ax.plot(self.timex,self.temp2,markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTlinestyle,color=self.palette["bt"],label=u(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))
        self.l_delta1, = self.ax.plot(self.timex,self.delta1,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],label=u(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))
        self.l_delta2, = self.ax.plot(self.timex,self.delta2,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],label=u(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))
        self.l_back1 = None
        self.l_back2 = None
        self.l_delta1B = None
        self.l_delta2B = None

        self.l_BTprojection = None
        self.l_ETprojection = None

        self.l_horizontalcrossline = None
        self.l_verticalcrossline = None

        self.l_timeline = None

        self.l_eventtype1dots, = self.ax.plot(self.E1timex, self.E1values, color=self.EvalueColor[0], marker=self.EvalueMarker[0])
        self.l_eventtype2dots, = self.ax.plot(self.E2timex, self.E2values, color=self.EvalueColor[1], marker=self.EvalueMarker[1])
        self.l_eventtype3dots, = self.ax.plot(self.E3timex, self.E3values, color=self.EvalueColor[2], marker=self.EvalueMarker[2])
        self.l_eventtype4dots, = self.ax.plot(self.E4timex, self.E4values, color=self.EvalueColor[3], marker=self.EvalueMarker[3])

        ###########################  TIME  CLOCK     ##########################
        # create an object time to measure and record time (in miliseconds)

        self.timeclock = QTime()
        self.timeclock.setHMS(0,0,0,0)

        ############################  Thread Server #################################################
        #server that spawns a thread dynamically to sample temperature (press button ON to make a thread press OFF button to kill it)
        self.threadserver = Athreadserver()

        ##########################     Designer variables       #################################
        self.designerflag = False
        self.designerconnections = [0,0,0,0]   #mouse event ids
        self.mousepress = None
        self.indexpoint = 0
        self.workingline = 2  #selects ET or BT
        self.eventtimecopy = []
        self.specialeventsStringscopy = []
        self.specialeventsvaluecopy = []
        self.specialeventstypecopy = []
        self.currentx = 0               #used to add point when right click
        self.currenty = 0               #used to add point when right click
        self.designertimeinit = [50,300,540,560,660,700,800,900]
        if self.mode == "C":
#                                     #CH, DE, Fcs,Fce,Scs,Sce,Drop
            self.designertemp1init = [290,290,290,290,290,290,290,290]
            self.designertemp2init = [200,150,200,210,220,225,240,240]   #CHARGE,DRY END,FCs, FCe,SCs,SCe,DROP,COOL
        elif self.mode == "F":
            self.designertemp1init = [500,500,500,500,500,500,500,500]
            self.designertemp2init = [380,300,390,395,410,412,420,420]
        self.BTsplinedegree = 3
        self.ETsplinedegree = 3
        self.reproducedesigner = 0      #flag to add events to help reproduce (replay) the profile: 0 = none; 1 = sv; 2 = ramp

        ###########################         filterDropOut variables     ################################

        # constants

        self.filterDropOut_replaceRoR_period = 3
        self.filterDropOut_spikeRoR_period = 3

        # defaults

        self.filterDropOut_tmin_C_default = 10
        self.filterDropOut_tmax_C_default = 700
        self.filterDropOut_tmin_F_default = 50
        self.filterDropOut_tmax_F_default = 1292
        self.filterDropOut_spikeRoR_dRoR_limit_C_default = 4.2
        self.filterDropOut_spikeRoR_dRoR_limit_F_default = 7

        # variables

        self.filterDropOuts = True
        self.filterDropOut_tmin = self.filterDropOut_tmin_F_default
        self.filterDropOut_tmax = self.filterDropOut_tmax_F_default
        self.filterDropOut_spikeRoR_dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit_F_default # the limit of additional RoR in temp/sec compared to previous readings
        self.minmaxLimits = False
        self.dropSpikes = False

        self.swapETBT = False

        ###########################         wheel graph variables     ################################
        self.wheelflag = False
        #data containers for wheel
        self.wheelnames,self.segmentlengths,self.segmentsalpha,self.wheellabelparent,self.wheelcolor = [],[],[],[],[]

        #crerate starting wheel
        wheels = [4,6,12,50]
        for i in range(len(wheels)):
            w,a,c,co = [],[],[],[]
            for x in range(wheels[i]):
                w.append("W%i %i"%(i+1,x+1))
                a.append(0.3)
                c.append(0)
                color = QColor()
                color.setHsv((360/wheels[i])*x,255,255,255)
                co.append(str(color.name()))

            self.wheelnames.append(w)
            self.segmentsalpha.append(a)
            self.segmentlengths.append([100./len(self.wheelnames[i])]*len(self.wheelnames[i]))
            self.wheellabelparent.append(c)
            self.wheelcolor.append(co)

        #properties
        #store radius of each circle as percentage(sum of all must at all times add up to 100.0%)
        self.wradii = [25.,20.,20.,35.]
        #starting angle for each circle (0-360).
        self.startangle = [0,0,0,0]
        #text projection: 0 = Flat, 1 = perpendicular to center, 2 = radial from center
        self.projection = [0,1,1,2]
        self.wheeltextsize = [10,10,10,10]
        self.wheelcolorpattern = 0                  #pattern
        self.wheeledge = .02                        #overlaping decorative edge
        self.wheellinewidth = 1
        self.wheellinecolor = "black"               #initial color of lines
        self.wheelconnections = [0,0,0]
        self.wheelx,self.wheelz = 0,0                   #temp variables to pass index values
        self.wheellocationx,self.wheellocationz = 0.,0.  #temp vars to pass mouse location (angleX+radiusZ)
        self.wheelaspect = 1.0

        self.samplingsemaphore = QSemaphore(1)
        self.messagesemaphore = QSemaphore(1)
        self.errorsemaphore = QSemaphore(1)
        self.serialsemaphore = QSemaphore(1)

        #flag to plot cross lines from mouse
        self.crossmarker = False
        self.crossmouseid = 0

        #########  temporary serial variables
        #temporary storage to pass values. Holds extra T3 and T4 values for center 309
        self.extra309T3 = -1
        self.extra309T4 = -1
        self.extra309TX = 0.
        
        #temporary storage to pass values. Holds extra T3 and T4 values for MODBUS connected devices
        self.extraMODBUSt3 = -1
        self.extraMODBUSt4 = -1
        self.extraMODBUStx = 0.

        #used by extra device +ArduinoTC4_XX to pass values
        self.extraArduinoT1 = 0.
        self.extraArduinoT2 = 0.
        self.extraArduinoT3 = 0. # heater duty %
        self.extraArduinoT4 = 0. # fan duty %
        self.extraArduinoT5 = 0. # SV
        self.extraArduinoT6 = 0. # TC4 internal ambient temperature
        
        #used by extra device +Program_34 and +Program_56 to pass values
        self.program_t3 = -1
        self.program_t4 = -1
        self.program_t5 = -1
        self.program_t6 = -1

        #temporary storage to pass values. Holds the power % ducty cycle of Fuji PIDs  and ET-BT
        self.dutycycle = 0.
        self.dutycycleTX = 0.
        self.currentpidsv = 0.

        self.linecount = None # linecount cache for resetlines(); has to be reseted if visibility of ET/BT or extra lines or background ET/BT changes
        self.deltalinecount = None # deltalinecoutn cache for resetdeltalines(); has to be reseted if visibility of deltaET/deltaBT or background deltaET/deltaBT

        #variables to organize the delayed update of the backgrounds for bitblitting
        self.ax_background = None
        self.redrawEnabled = True
        self._resizeTimer = QTimer()
        self._resizeTimer.timeout.connect(self.updateBackground)
        self.delayTimeout = 100
        
        # flag to toggle between Temp and RoR scale of xy-display
        self.fmt_data_RoR = True #False

    #NOTE: empty Figure is initialy drawn at the end of aw.settingsload()
    #################################    FUNCTIONS    ###################################
    #####################################################################################
    
    # update the aw.qmc.deltaspan from the given sampling interval and aw.qmc.deltasamples
    # interval is expected in seconds (either from the profile on load or from the sampling interval set for recording)
    def updateDeltaSamples(self):
        if self.flagstart or self.profile_sampling_interval == None:
            interval = self.delay
        else:
            interval = self.profile_sampling_interval
        self.deltasamples = max(1,self.deltaspan / int(interval))
    
    # hack to make self.ax receive onPick events although it is drawn behind self.delta_ax
    def draw(self):
        if self.designerflag and self.ax and self.delta_ax:
            self.ax.set_zorder(0)
            self.delta_ax.set_zorder(0.1)
        FigureCanvas.draw(self)
        if self.designerflag and self.ax and self.delta_ax:
            self.ax.set_zorder(0.1)
            self.delta_ax.set_zorder(0)
    
    # returns the prefix of length l of s and adds eclipse
    def abbrevString(self,s,l):
        if len(s) > l:
            return s[:l-1] + "..."
        else:
            return s

    def resizeEvent(self,event):
        self.redrawEnabled = False
        super(tgraphcanvas,self).resizeEvent(event)
        self._resizeTimer.start(self.delayTimeout) # triggeres the updateBackground after timeout

    def updateBackground(self):
        if not self.designerflag:
            self._resizeTimer.stop()
            self.redrawEnabled = False
            self.resetlinecountcaches() # ensure that the line counts are up to date
            self.resetlines() # get rid of HUD, projection and cross lines
            self.resetdeltalines() # just in case
            self.fig.canvas.draw()
            self.ax_background = self.fig.canvas.copy_from_bbox(aw.qmc.ax.bbox)
            self.redrawEnabled = True

    def getetypes(self):
        if len(self.etypes) == 4:
            self.etypes.append("--")
        return self.etypes

    def etypesf(self, i):
        if len(self.etypes) == 4:
            self.etypes.append("--")
        return self.etypes[i]

    def Betypesf(self, i):
        if len(self.Betypes) == 4:
            self.Betypes.append("--")
        return self.Betypes[i]

    def ambientTempSourceAvg(self):
        res = None
        if self.ambientTempSource:
            start = 0
            end = len(aw.qmc.temp1) - 1
            if self.timeindex[1] > -1: # CHARGE
                start = self.timeindex[1]
            if self.timeindex[6] > -1: # DROP
                end = self.timeindex[6]
            if self.ambientTempSource == 1: # from ET
                res = numpy.mean(aw.qmc.temp1[start:end])
            elif self.ambientTempSource == 2: # from BT
                res = numpy.mean(aw.qmc.temp2[start:end])
            elif self.ambientTempSource > 2 and ((self.ambientTempSource - 3) < (2*len(aw.qmc.extradevices))): 
                # from an extra device
                if (self.ambientTempSource)%2==0:
                    res = numpy.mean(aw.qmc.extratemp2[(self.ambientTempSource - 3)//2][start:end])
                else:
                    res = numpy.mean(aw.qmc.extratemp1[(self.ambientTempSource - 3)//2][start:end])
        if res:
            res = aw.float2float(res)
        return res

    def updateAmbientTemp(self):
        if aw.qmc.device == 34: # Phidget 1048 (use internal temp)
            try:
                if aw.ser.PhidgetTemperatureSensor != None and aw.ser.PhidgetTemperatureSensor.isAttached():
                    t = aw.ser.PhidgetTemperatureSensor.getAmbientTemperature()
                    if aw.qmc.mode == "F":
                        aw.qmc.ambientTemp = aw.float2float(aw.qmc.fromCtoF(t))
                    else:
                        aw.qmc.ambientTemp = aw.float2float(t)
            except:
                pass
        else:
            res = aw.qmc.ambientTempSourceAvg()
            if res != None and (isinstance(res, float) or isinstance(res, int)) and not math.isnan(res):
                aw.qmc.ambientTemp = aw.float2float(float(res))

    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0.0-10.0]
    # negative values are mapped to -1
    def eventsInternal2ExternalValue(self,v):
        if v == None:
            return -1
        else:
            if v < 1:
                return -1
        return int(round(v*10)) - 10

    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0-10]
    # negative values are mapped to ""
    # 0.1 to "1"
    # ..
    # 1.0 to "10"
    # .. 
    # 10.0 to "100"
    def eventsvalues(self,v):
        value = self.eventsInternal2ExternalValue(v)
        if value < 0:
            return ""
        else:
            return u(value)

    # 100.0 to "10" and 10.1 to "1"
    def eventsvaluesShort(self,v):
        value = v*10. - 10.
        if value < 0:
            return ""
        else:
            if aw.qmc.LCDdecimalplaces:
                return u(int(round(value)))
            else:
                return u(int(round(value / 10)))

    # the inverse to eventsvalues above (string -> value)
    def str2eventsvalue(self,s):
        st = s.strip()
        if st == None or len(st) == 0:
            return -1
        else:
            return aw.float2float(float(st)/10. + 1.0)

    def onclick(self,event):
        try:
            if event.inaxes == None and not aw.qmc.flagstart and not aw.qmc.flagon and event.button==3:
                aw.qmc.statisticsmode = (aw.qmc.statisticsmode + 1)%2
                aw.qmc.writecharacteristics()
                aw.qmc.fig.canvas.draw()
            elif event.button==3 and event.inaxes and not self.designerflag and not self.wheelflag:# and not self.flagon:
                timex = self.time2index(event.xdata)
                if timex > 0:
                    menu = QMenu(self) 
                    # populate menu
                    ac = QAction(menu)
                    if self.timeindex[0] > -1:
                        ac.setText(u(QApplication.translate("Label", "at")) + u(" ") + self.stringfromseconds(event.xdata - self.timex[self.timeindex[0]]))
                    else:
                        ac.setText(u(QApplication.translate("Label", "at")) + u(" ") + self.stringfromseconds(event.xdata))
                    ac.setEnabled(False)
                    menu.addAction(ac)
                    for k in [(u(QApplication.translate("Label","CHARGE")),0),
                              (u(QApplication.translate("Label","DRY END")),1),
                              (u(QApplication.translate("Label","FC START")),2),
                              (u(QApplication.translate("Label","FC END")),3),
                              (u(QApplication.translate("Label","SC START")),4),
                              (u(QApplication.translate("Label","SC END")),5),
                              (u(QApplication.translate("Label","DROP")),6),
                              (u(QApplication.translate("Label","COOL")),7)]:
                        idx_before = idx_after = 0
                        for i in range(k[1]):
                            if self.timeindex[i] and self.timeindex[i] != -1:
                                idx_before = self.timeindex[i]
                        for i in range(6,k[1],-1) :
                            if self.timeindex[i] and self.timeindex[i] != -1:
                                idx_after = self.timeindex[i]
                        if ((not idx_before) or timex > idx_before) and ((not idx_after) or timex < idx_after):
                            ac = QAction(menu)
                            ac.key = (k[1],timex)
                            ac.setText(" " + k[0])
                            menu.addAction(ac)
                    # add user EVENT entry
                    ac = QAction(menu)
                    ac.setText(u(" ") + u(QApplication.translate("Label", "EVENT")))
                    ac.key = (-1,timex)
                    menu.addAction(ac)
                    # show menu
                    menu.triggered.connect(self.event_popup_action)
                    menu.popup(QCursor.pos())
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " onclick() %1").arg(str(e)),exc_tb.tb_lineno)

    def event_popup_action(self,action):
        if action.key[0] >= 0:
            self.timeindex[action.key[0]] = action.key[1]
        else:
            # add a special event at the current timepoint
            self.specialevents.append(action.key[1]) # absolut time index
            self.specialeventstype.append(4) # "--"
            self.specialeventsStrings.append("")
            self.specialeventsvalue.append(0)
        aw.qmc.safesaveflag = True
        self.redraw()
        
    def updateWebLCDs(self,bt=None,et=None,time=None,alertTitle=None,alertText=None,alertTimeout=None):
        try:
            url = "http://127.0.0.1:" + str(aw.WebLCDsPort) + "/send"
            headers = {'content-type': 'application/json'}
            payload = {'data': {}}
            if bt != None:
                payload['data']['bt'] = bt
            if et != None:
                payload['data']['et'] = et
            if time != None:
                payload['data']['time'] = time
            if alertText != None:
                payload['alert'] = {}
                payload['alert']['text'] = alertText
                if alertTitle:
                    payload['alert']['title'] = alertTitle
                if alertTimeout:
                    payload['alert']['timeout'] = alertTimeout
            requests.post(url, data=json.dumps(payload),headers=headers,timeout=0.1)
        except:
            pass
            
    def updateLargeLCDs(self,bt=None,et=None,time=None):
        try:
            if time:
                aw.largeLCDs_dialog.lcd1.display(time)
            if et:
                aw.largeLCDs_dialog.lcd2.display(et)
            if bt:
                aw.largeLCDs_dialog.lcd3.display(bt)
        except:
            pass

    # runs from GUI thread.
    # this function is called by a signal at the end of the thread sample()
    # during sample, updates to GUI widgets or anything GUI must be done here (never from thread)
    def updategraphics(self):
        try:
            if self.flagon:
                if len(self.timex):
                    if self.LCDdecimalplaces:
                        lcdformat = "%.1f"
                    else:
                        lcdformat = "%.0f"
                    if -100 < self.temp1[-1] < 1000:
                        aw.lcd2.display(lcdformat%float(self.temp1[-1]))            # ET
                    else:
                        aw.lcd2.display("--")
                    if -100 < self.temp2[-1] < 1000:
                        aw.lcd3.display(lcdformat%float(self.temp2[-1]))            # BT
                    else:
                        aw.lcd3.display("--")
                    if -100 < self.rateofchange1 < 100:
                        aw.lcd4.display(lcdformat%float(self.rateofchange1))        # rate of change MET (degress per minute)
                    else:
                        aw.lcd4.display("--")
                    if -100 < self.rateofchange2 < 1000:
                        aw.lcd5.display(lcdformat%float(self.rateofchange2))        # rate of change BT (degrees per minute)
                    else:
                        aw.lcd5.display("--")
                    
                    if self.device == 0 or self.device == 26:         #extra LCDs for Fuji or DTA pid  
                        aw.lcd6.display(self.currentpidsv)
                        aw.lcd7.display(self.dutycycle)

                    ndev = len(self.extradevices)
                    for i in range(ndev):
                        if i < aw.nLCDS:
                            if self.extratemp1[i]:
                                if -100 < self.extratemp1[i][-1] < 1000:
                                    aw.extraLCD1[i].display(lcdformat%float(self.extratemp1[i][-1]))
                                else:
                                    aw.extraLCD1[i].display("--")
                            if self.extratemp2[i]:
                                if -100 < self.extratemp2[i][-1] < 1000:
                                    aw.extraLCD2[i].display(lcdformat%float(self.extratemp2[i][-1]))
                                else:
                                    aw.extraLCD2[i].display("--")
                                    
                    # update large LCDs (incl. Web LCDs)
                    timestr = None
                    if not self.flagstart:
                        timestr = "00:00"
                    digits = (1 if aw.qmc.LCDdecimalplaces else 0)
                    btstr = str(aw.float2float(self.temp2[-1],digits))
                    etstr = str(aw.float2float(self.temp1[-1],digits))
                    if aw.WebLCDs:                       
                        self.updateWebLCDs(bt=btstr,et=etstr,time=timestr)
                    if aw.largeLCDs_dialog:
                        self.updateLargeLCDs(bt=btstr,et=etstr,time=timestr)

                if self.flagstart:          
                    if aw.qmc.patheffects:
                        rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground="w")]
                    else:
                        rcParams['path.effects'] = []

                    ##### updated canvas
                    if self.redrawEnabled:
                        if self.ax_background:
                            self.fig.canvas.restore_region(self.ax_background)
                            # draw eventtypes
                            if self.eventsshowflag and self.eventsGraphflag == 2:
                                aw.qmc.ax.draw_artist(self.l_eventtype1dots)
                                aw.qmc.ax.draw_artist(self.l_eventtype2dots)
                                aw.qmc.ax.draw_artist(self.l_eventtype3dots)
                                aw.qmc.ax.draw_artist(self.l_eventtype4dots)
                            # draw extra curves
                            xtra_dev_lines1 = 0
                            xtra_dev_lines2 = 0
                            for i in range(min(len(aw.extraCurveVisibility1),len(aw.extraCurveVisibility1),len(self.extratimex),len(self.extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(self.extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                                if aw.extraCurveVisibility1[i] and len(self.extratemp1lines) > xtra_dev_lines1:
                                    aw.qmc.ax.draw_artist(self.extratemp1lines[xtra_dev_lines1])
                                    xtra_dev_lines1 = xtra_dev_lines1 + 1
                                if aw.extraCurveVisibility2[i] and len(self.extratemp2lines) > xtra_dev_lines2:
                                    aw.qmc.ax.draw_artist(self.extratemp2lines[xtra_dev_lines2])
                                    xtra_dev_lines2 = xtra_dev_lines2 + 1
                            # draw ET
                            if aw.qmc.ETcurve:
                                aw.qmc.ax.draw_artist(self.l_temp1)
                            # draw BT
                            if aw.qmc.BTcurve:
                                aw.qmc.ax.draw_artist(self.l_temp2)
                             
#                            for l in aw.qmc.ax.get_lines():
#                                # we do not redraw the background curves nor the projection (drawn separately)
#                                if not l in [self.l_BTprojection,self.l_ETprojection,self.l_back1,self.l_back2,self.l_delta1B,self.l_delta2B,self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots]:
#                                    aw.qmc.ax.draw_artist(l)

                            if aw.qmc.device == 18 and aw.qmc.l_timeline != None: # not NONE device
                                aw.qmc.ax.draw_artist(aw.qmc.l_timeline)

                            if aw.qmc.projectFlag:
                                if self.l_BTprojection != None:
                                    aw.qmc.ax.draw_artist(self.l_BTprojection)
                                if self.l_ETprojection != None:
                                    aw.qmc.ax.draw_artist(self.l_ETprojection)
                            # draw delta lines
                            if self.DeltaETflag and self.l_delta1 != None:
                                aw.qmc.delta_ax.draw_artist(self.l_delta1)
                            if self.DeltaBTflag and self.l_delta2 != None:
                                aw.qmc.delta_ax.draw_artist(self.l_delta2)

                            self.fig.canvas.blit(aw.qmc.ax.bbox)
                        else:
                            # we do not have a background to bitblit, so do a full redraw
                            #self.fig.canvas.draw()
                            self.updateBackground() # does the canvas draw, but also fills the ax_background cache
                    #####

                    #update phase lcds
                    if aw.qmc.phasesLCDflag:
                        aw.updatePhasesLCDs()

                    #check if HUD is ON (done after self.fig.canvas.draw())
                    if self.HUDflag:
                        aw.showHUD[aw.HUDfunction]()

                    #auto mark CHARGE/TP/DRY/FCs/DROP
                    if self.autoChargeIdx and aw.qmc.timeindex[0] < 0:
                        self.markCharge() # we do not reset the autoChargeIdx to avoid another trigger
                    if self.autoTPIdx != 0:
                        self.autoTPIdx = 0
                        self.markTP()
                    if self.autoDryIdx != 0:
                        self.autoDryIdx = 0
                        self.markDryEnd()
                    if self.autoFCsIdx != 0:
                        self.autoFCsIdx = 0
                        self.mark1Cstart()
                    if self.autoDropIdx != 0 and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6]:
                        self.markDrop() # we do not reset the autoDropIdx to avoid another trigger

                #check triggered alarms
                if self.temporaryalarmflag > -3:
                    i = self.temporaryalarmflag  # reset self.temporaryalarmflag before calling alarm
                    self.temporaryalarmflag = -3 # self.setalarm(i) can take longer to run than the sampling interval 
                    self.setalarm(i)
                    
                #check quantified events
                for el in self.quantifiedEvent:
                    aw.moveslider(el[0],el[1])
                    if aw.qmc.flagstart:
                        value = aw.float2float((el[1] + 10.0) / 10.0)
                        aw.qmc.EventRecordAction(extraevent = 1,eventtype=el[0],eventvalue=value,eventdescription=u("Q"))
                self.quantifiedEvent = []

                    

        except Exception as e:
            self.flagon = False
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " updategraphics() %1").arg(str(e)),exc_tb.tb_lineno)

    def updateLCDtime(self):
        if self.flagon and self.flagstart:
            tx = self.timeclock.elapsed()/1000.
            if self.timeindex[0] != -1:
                ts = tx - self.timex[self.timeindex[0]]
            else:
                ts = tx
            nextreading = 1000. - 1000.*(tx%1.)

            # if more than max cool (from statistics) past DROP and not yet COOLend turn the time LCD red:
            if aw.qmc.timeindex[0]!=-1 and aw.qmc.timeindex[6] and not aw.qmc.timeindex[7] and (tx - aw.qmc.timex[aw.qmc.timeindex[6]]) > aw.qmc.statisticsconditions[7]:
                aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%("red",aw.lcdpaletteB["timer"]))

            timestr = self.stringfromseconds(int(round(ts)))
            aw.lcd1.display(QString(timestr))
            
            # update connected WebLCDs
            if aw.WebLCDs:
                self.updateWebLCDs(time=timestr)
            if aw.largeLCDs_dialog:
                self.updateLargeLCDs(time=timestr)
            
            QTimer.singleShot(nextreading,self.updateLCDtime)

    def toggleHUD(self):
        aw.soundpop()
        #OFF
        if self.HUDflag:
            self.HUDflag = False
            aw.HUD.clear()
            aw.button_18.setStyleSheet("QPushButton { background-color: #b5baff }")
            aw.stack.setCurrentIndex(0)
            self.resetlines()
            aw.sendmessage(QApplication.translate("Message","HUD OFF", None, QApplication.UnicodeUTF8))
            
        #ON
        else:
#            if len(self.temp2) > 1:  #Need this because viewProjections use rate of change (two values needed)
            #load
            img = QPixmap().grabWidget(self)
#            img = self.grab()
            aw.HUD.setPixmap(img)
            
            self.HUDflag = True
            aw.button_18.setStyleSheet("QPushButton { background-color: #60ffed }")
            aw.stack.setCurrentIndex(1)
            aw.sendmessage(QApplication.translate("Message","HUD ON", None, QApplication.UnicodeUTF8))
#            else:
#                aw.sendmessage(QApplication.translate("Message","Need some data for HUD to work", None, QApplication.UnicodeUTF8))


    # redraws at least the canvas if redraw=True, if FCs=True align to FCs if set, otherwise CHARGE (if set)
    def timealign(self,redraw=True,recompute=False,FCs=False):
        try:
            ptime = None
            btime = None
            if FCs and self.timeindexB[2] and self.timeindex[2]:
                ptime = self.timex[self.timeindex[2]]
                btime = self.timeB[self.timeindexB[2]]
            elif self.timeindexB[0] != -1 and self.timeindex[0] != -1:
                ptime = self.timex[self.timeindex[0]]
                btime = self.timeB[self.timeindexB[0]]
            if ptime and btime:
                difference = ptime - btime
                if difference > 0:
                    self.movebackground("right",abs(difference))
                    self.backmoveflag = 0
                    if redraw:
                        self.redraw(recompute)
                elif difference < 0:
                    self.movebackground("left",abs(difference))
                    self.backmoveflag = 0
                    if redraw:
                        self.redraw(recompute)
                elif redraw and not FCs: # ensure that we at least redraw the canvas
                    self.updateBackground()
            elif redraw and not FCs: # only on aligning with CHARGE we redraw even if nothing is moved to redraw the time axis
                    self.updateBackground()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " timealign() %1").arg(str(ex)),exc_tb.tb_lineno)

    def lenaxlines(self):
        active_curves = len(self.extratimex)
        curves = aw.extraCurveVisibility1[0:active_curves] + aw.extraCurveVisibility2[0:active_curves] + [aw.qmc.ETcurve,aw.qmc.BTcurve]
        c = curves.count(True)
        if aw.qmc.background:
            c += 2
            if aw.qmc.backgroundeventsflag and aw.qmc.eventsGraphflag == 2:
                c += 4
        if aw.qmc.eventsshowflag and aw.qmc.eventsGraphflag == 2:
            c += 4
        return c

    def lendeltaaxlines(self):
        linecount = 0 
        if self.DeltaETflag:
            linecount += 1
        if  self.DeltaBTflag:
            linecount += 1
        if aw.qmc.background:
            if self.DeltaETBflag:
                linecount += 1
            if self.DeltaBTBflag:
                linecount += 1
        return linecount

    def resetlinecountcaches(self):
        aw.qmc.linecount = None
        aw.qmc.deltalinecount = None

    def resetlines(self):
        #note: delta curves are now in self.delta_ax and have been removed from the count of resetlines()
        if self.linecount == None:
            self.linecount = self.lenaxlines()
        self.ax.lines = self.ax.lines[0:self.linecount]

    def resetdeltalines(self):
        if self.deltalinecount == None:
            self.deltalinecount = self.lendeltaaxlines()
        if self.delta_ax:
            self.delta_ax.lines = self.delta_ax.lines[0:self.deltalinecount]

    def setalarm(self,alarmnumber):
        self.alarmstate[alarmnumber] = 1    #turn off flag as it has been read
        aw.sendmessage(QApplication.translate("Message","Alarm %1 triggered", None, QApplication.UnicodeUTF8).arg(alarmnumber + 1))
        if len(self.alarmbeep) > alarmnumber and self.alarmbeep[alarmnumber]:
            QApplication.beep()
        try:
            if self.alarmaction[alarmnumber] == 0:
                # alarm popup message
                #QMessageBox.information(self,QApplication.translate("Message", "Alarm notice",None, QApplication.UnicodeUTF8),self.alarmstrings[alarmnumber])
                # alarm popup message with 10sec timeout
                amb = ArtisanMessageBox(self,QApplication.translate("Message", "Alarm notice",None, QApplication.UnicodeUTF8),u(self.alarmstrings[alarmnumber]),timeout=10)
                amb.show()
                #send alarm also to connected WebLCDs clients
                if aw.WebLCDs and aw.WebLCDsAlerts:
                    aw.qmc.updateWebLCDs(alertText=u(self.alarmstrings[alarmnumber]),alertTimeout=10)
            elif self.alarmaction[alarmnumber] == 1:
                # alarm call program
                fname = u(self.alarmstrings[alarmnumber])
# take care, the QDir().current() directory changes with loads and saves                
#                QDesktopServices.openUrl(QUrl("file:///" + u(QDir().current().absolutePath()) + "/" + fname, QUrl.TolerantMode))
                if platf in ['Windows','Linux']:
                    f = u("file:///") + u(QApplication.applicationDirPath()) + "/" + u(fname)
                else: # MacOS X: script is expected to sit next to the Artisan.app
                    f = u("file:///") + u(QApplication.applicationDirPath()) + "/../../../" + u(fname)
                res = QDesktopServices.openUrl(QUrl(f, QUrl.TolerantMode))
                if res:
                    aw.sendmessage(QApplication.translate("Message","Alarm is calling: %1",None, QApplication.UnicodeUTF8).arg(u(self.alarmstrings[alarmnumber])))
                else:
                    aw.qmc.adderror(QApplication.translate("Message","Calling alarm failed on %1",None, QApplication.UnicodeUTF8).arg(f))
            elif self.alarmaction[alarmnumber] == 2:
                # alarm event button
                button_number = None
                try:
                    button_number = int(str(self.alarmstrings[alarmnumber])) - 1 # the event buttons presented to the user are numbered from 1 on
                except:
                    aw.sendmessage(QApplication.translate("Message","Alarm trigger button error, description '%1' not a number",None, QApplication.UnicodeUTF8).arg(u(self.alarmstrings[alarmnumber])))
                if button_number != None:
                    if button_number > -1 and button_number < len(aw.buttonlist):
                        aw.recordextraevent(button_number)
            elif self.alarmaction[alarmnumber] in [3,4,5,6]:
                # alarm slider 1-4
                slidernr = None
                try:
                    slidervalue = max(0,min(100,int(str(self.alarmstrings[alarmnumber]))))
                    if slidervalue < 0 or slidervalue > 100:
                        raise Exception()
                    if self.alarmaction[alarmnumber] == 3:
                        slidernr = 0
                    elif self.alarmaction[alarmnumber] == 4:
                        slidernr = 1
                    elif self.alarmaction[alarmnumber] == 5:
                        slidernr = 2
                    elif self.alarmaction[alarmnumber] == 6:
                        slidernr = 3
                    if slidernr != None:
                        aw.moveslider(slidernr,slidervalue)
                        if aw.qmc.flagstart:
                            value = aw.float2float((slidervalue + 10.0) / 10.0)
                            aw.qmc.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,eventdescription=str("A%d (S%d)"%(alarmnumber,slidernr)))
                        aw.fireslideraction(slidernr)
                except Exception as e:
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setalarm() %1").arg(str(e)),exc_tb.tb_lineno)
                    aw.sendmessage(QApplication.translate("Message","Alarm trigger slider error, description '%1' not a valid number [0-100]",None, QApplication.UnicodeUTF8).arg(u(self.alarmstrings[alarmnumber])))
                    
            elif self.alarmaction[alarmnumber] == 7:
                # START
                if aw.button_2.isEnabled():
                    aw.qmc.ToggleRecorder()
            elif self.alarmaction[alarmnumber] == 8:
                # DRY
                if aw.button_19.isEnabled():
                    aw.qmc.markDryEnd()
            elif self.alarmaction[alarmnumber] == 9:
                # FCs
                if aw.button_3.isEnabled():
                    aw.qmc.mark1Cstart()
            elif self.alarmaction[alarmnumber] == 10:
                # FCe
                if aw.button_4.isEnabled():
                    aw.qmc.mark1Cend()
            elif self.alarmaction[alarmnumber] == 11:
                # SCs
                if aw.button_5.isEnabled():
                    aw.qmc.mark2Cstart()
            elif self.alarmaction[alarmnumber] == 12:
                # SCe
                if aw.button_6.isEnabled():
                    aw.qmc.mark2Cend()
            elif self.alarmaction[alarmnumber] == 13:
                # DROP
                if aw.button_9.isEnabled():
                    aw.qmc.markDrop()
            elif self.alarmaction[alarmnumber] == 14:
                # COOL
                if aw.button_20.isEnabled():
                    aw.qmc.markCoolEnd()
            elif self.alarmaction[alarmnumber] == 15:
                # OFF
                if aw.button_1.isEnabled():
                    aw.qmc.ToggleMonitor()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setalarm() %1").arg(str(ex)),exc_tb.tb_lineno)

    def playbackevent(self):
        try:
            #needed when using device NONE
            if len(self.timex):
                #find time distances
                for i in range(len(self.backgroundEvents)):
                    timed = int(self.timeB[self.backgroundEvents[i]] - self.timeclock.elapsed()/1000.)
                    if  timed > 0 and timed < self.detectBackgroundEventTime:
                        #write text message
                        message = "> " +  self.stringfromseconds(timed) + " [" + u(self.Betypesf(self.backgroundEtypes[i]))
                        message += "] [" + self.eventsvalues(self.backgroundEvalues[i]) + "] : " + self.backgroundEStrings[i]
                        #rotate colors to get attention
                        if timed%2:
                            aw.messagelabel.setStyleSheet("background-color:'transparent';")
                        else:
                            aw.messagelabel.setStyleSheet("background-color:'yellow';")
                            
                        aw.sendmessage(message)
                        break

                    elif timed == 0:
                        #for devices that support automatic roaster control
                        #if Fuji PID
                        if self.device == 0:

                            # COMMAND SET STRINGS
                            #  (adjust the SV PID to the float VALUE1)
                            # SETRS::VALUE1::VALUE2::VALUE3  (VALUE1 = target SV. float VALUE2 = time to reach int VALUE 1 (ramp) in minutes. int VALUE3 = hold (soak) time in minutes)

                            # IMPORTANT: VALUES are for controlling ET only (not BT). The PID should control ET not BT. The PID should be connected to ET only.
                            # Therefore, these values don't reflect a BT defined profile. They define an ET profile.
                            # They reflect the changes in ET, which indirectly define BT after some time lag

                            # There are two ways to record a roast. One is by changing Set Values (SV) during the roast,
                            # the other is by using ramp/soaks segments (RS). 
                            # Examples:

                            # SETSV::560.3           sets an SV value of 560.3F in the PID at the time of the recorded background event

                            # SETRS::440.2::2::0     starts Ramp Soak mode so that it reaches 440.2F in 2 minutes and holds (soaks) 440.2F for zero minutes

                            # SETRS::300.0::2::3::SETRS::540.0::6::0::SETRS::560.0::4::0::SETRS::560::0::0
                            #       this command has 4 comsecutive commands inside (4 segments)
                            #       1 SETRS::300.0::2::3 reach 300.0F in 2 minutes and hold it for 3 minutes (ie. total dry phase time = 5 minutes)
                            #       2 SETRS::540.0::6::0 then reach 540.0F in 6 minutes and hold it there 0 minutes (ie. total mid phase time = 6 minutes )
                            #       3 SETRS::560.0::4::0 then reach 560.0F in 4 minutes and hold it there 0 minutes (ie. total finish phase time = 4 minutes)
                            #       4 SETRS::560::0::0 then do nothing (because ramp time and soak time are both 0)
                            #       END ramp soak mode

                            if "::" in self.backgroundEStrings[i]:
                                aw.fujipid.replay(self.backgroundEStrings[i])
                                libtime.sleep(.5)  #avoid possible close times (rounding off)

                        #future Arduino
                        #if self.device == 19:

                    #delete message
                    else:
                        text = str(aw.messagelabel.text())
                        if len(text):
                            if text[0] == ">":
                                aw.sendmessage("")
                                aw.messagelabel.setStyleSheet("background-color:'transparent';")
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " playbackevent() %1").arg(str(ex)),exc_tb.tb_lineno)

    #make a projection of change of rate of BT on the graph
    def updateProjection(self):
        try:
            if len(aw.qmc.temp2) > 1:  #Need this because viewProjections use rate of change (two values needed)
                #self.resetlines()
                if self.timeindex[0] != -1:
                    starttime = self.timex[self.timeindex[0]]
                else:
                    starttime = 0
                if self.projectionmode == 0:
                    #calculate the temperature endpoint at endofx acording to the latest rate of change
                    if self.l_BTprojection != None:
                        if aw.qmc.BTcurve and len(aw.qmc.delta2) > 0 and aw.qmc.delta2[-1] != None:
                            BTprojection = self.temp2[-1] + aw.qmc.delta2[-1]*(self.endofx - self.timex[-1]+ starttime)/60.
                            #plot projections
                            self.l_BTprojection.set_data([self.timex[-1],self.endofx+starttime], [self.temp2[-1], BTprojection])
                        elif self.l_BTprojection:
                            self.l_BTprojection.set_data([],[])
                    if self.l_ETprojection != None:
                        if aw.qmc.ETcurve and len(aw.qmc.delta1) > 0 and aw.qmc.delta1[-1] != None:
                            ETprojection = self.temp1[-1] + aw.qmc.delta1[-1]*(self.endofx - self.timex[-1]+ starttime)/60.
                            self.l_ETprojection.set_data([self.timex[-1],self.endofx+starttime], [self.temp1[-1], ETprojection])
                        elif self.l_ETprojection:
                            self.l_ETprojection.set_data([],[])
                elif self.projectionmode == 1:
                    # Under Test. Newton's Law of Cooling
                    # This comes from the formula of heating (with ET) a cool (colder) object (BT).
                    # The difference equation (discrete with n elements) is: DeltaT = T(n+1) - T(n) = K*(ET - BT)
                    # The formula is a natural decay towards ET. The closer BT to ET, the smaller the change in DeltaT
                    # projectionconstant is a multiplier factor. It depends on
                    # 1 Damper or fan. Heating by convection is _faster_ than heat by conduction,
                    # 2 Mass of beans. The heavier the mass, the _slower_ the heating of BT
                    # 3 Gas or electric power: gas heats BT _faster_ because of hoter air.
                    # Every roaster will have a different constantN.

                    den = self.temp1[-1] - self.temp2[-1]  #denominator ETn - BTn 
                    if den > 0 and len(aw.qmc.delta2)>0 and aw.qmc.delta2[-1]: # if ETn > BTn
                        #get x points
                        xpoints = list(numpy.arange(self.timex[-1],self.endofx + starttime, self.delay/1000.))  #do two minutes after endofx (+ 120 seconds); why? now +starttime
                        #get y points
                        ypoints = [self.temp2[-1]]                                  # start initializing with last BT
                        K =  self.projectionconstant*aw.qmc.delta2[-1]/den/60.                 # multiplier
                        for _ in range(len(xpoints)-1):                                     # create new points from previous points
                            DeltaT = K*(self.temp1[-1]- ypoints[-1])                        # DeltaT = K*(ET - BT)
                            ypoints.append(ypoints[-1]+ DeltaT)                             # add DeltaT to the next ypoint

                        #plot ET level (straight line) and BT curve
                        if self.l_ETprojection != None:
                            self.l_ETprojection.set_data([self.timex[-1],self.endofx + starttime], [self.temp1[-1], self.temp1[-1]])
                        if self.l_BTprojection != None:
                            self.l_BTprojection.set_data(xpoints, ypoints)
                    else:
                        if self.l_ETprojection:
                            self.l_ETprojection.set_data([],[])
                        if self.l_BTprojection:
                            self.l_BTprojection.set_data([],[])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " updateProjection() %1").arg(str(ex)),exc_tb.tb_lineno)

    # this function is called from the HUD DLg and reports the linear time (straight line) it would take to reach a temperature target
    # acording to the current rate of change
    def getTargetTime(self):

        if self.rateofchange1 > 0:
            ETreachTime = (self.ETtarget - self.temp1[-1])/(self.rateofchange1/60.)
            ET2reachTime = (self.ET2target - self.temp1[-1])/(self.rateofchange1/60.)
        else:
            ETreachTime = -1
            ET2reachTime = -1
            
        if self.rateofchange2 > 0:
            BTreachTime = (self.BTtarget - self.temp2[-1])/(self.rateofchange2/60.)
            BT2reachTime = (self.BT2target - self.temp2[-1])/(self.rateofchange2/60.)
        else:
            BTreachTime = -1
            BT2reachTime = -1

        return ETreachTime, BTreachTime, ET2reachTime, BT2reachTime

    #single variable (x) mathematical expression evaluator for user defined functions to convert sensor readings from HHM28 multimeter
    #example: eval_math_expression("pow(e,2*cos(x))",.3) returns 6.75763501
    def eval_math_expression(self,mathexpression,x,tx):
        if mathexpression == None or len(mathexpression) == 0 or (x == -1 and "x" in mathexpression):
            return x

        #Since eval() is very powerful, for security reasons, only the functions in this dictionary will be allowed
        mathdictionary = {"min":min,"max":max,"sin":math.sin,"cos":math.cos,"tan":math.tan,"pow":math.pow,"exp":math.exp,"pi":math.pi,"e":math.e,
                          "abs":abs,"acos":math.acos,"asin":math.asin,"atan":math.atan,"log":math.log,"radians":math.radians,
                          "sqrt":math.sqrt,"atan2":math.atan,"degrees":math.degrees}
        try:
            x = float(x)
            mathdictionary['x'] = x         #add x to the math dictionary assigning the key "x" to its float value
            #add ETB and BTB (background ET and BT)
            etb = btb = 0
            try:
                if aw.qmc.background and ("ETB" in mathexpression or "BTB" in mathexpression):
                    #first compute closest index at that time point in the background data
                    j = aw.qmc.backgroundtime2index(tx)
                    etb = aw.qmc.temp1B[j]
                    btb = aw.qmc.temp2B[j]
            except:
                pass
            mathdictionary["ETB"] = etb
            mathdictionary["BTB"] = btb
            #if Ys in expression
            if "Y" in mathexpression:
                #extract Ys
                Yval = []                   #extract value number example Y9 = 9
                mlen = len(mathexpression)
                for i in range(mlen):
                    if mathexpression[i] == "Y":
                        #find Y number
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                number = mathexpression[i+1]
                            else:
                                number = "1"
                        #check for double digit
                        if i+2 < mlen:
                            if mathexpression[i+2].isdigit() and mathexpression[i+1].isdigit():
                                number += mathexpression[i+2]
                        Yval.append(number)
                #build Ys float values
                if len(self.timex) > 0:
                    Y = [self.temp1[-1],self.temp2[-1]]
                else:
                    Y = [-1,-1]
                for i in range(len(self.extradevices)):
                    if len(self.extratimex[i]):
                        try:
                            Y.append(self.extratemp1[i][-1])
                        except:
                            Y.append(-1)
                        try:
                            Y.append(self.extratemp2[i][-1])
                        except:
                            Y.append(-1)
                    else:
                        Y.append(-1)
                        Y.append(-1)
                    #add Ys and their value to math dictionary 
                    for i in range(len(Yval)):
                        idx = int(Yval[i])-1
                        if idx >= len(Y):
                            mathdictionary["Y"+ Yval[i]] = 0
                        else:
                        	mathdictionary["Y"+ Yval[i]] = Y[idx]
            return round(eval(mathexpression,{"__builtins__":None},mathdictionary),3)

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " eval_math_expression() %1").arg(str(e)),exc_tb.tb_lineno)
            return 0

    #format X axis labels
    def xaxistosm(self,redraw=True):

        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        endtime = self.endofx + starttime
        self.ax.set_xlim(self.startofx,endtime)

        if not self.xgrid:
            self.xgrid = 60.

        mfactor1 =  round(float(2. + int(starttime)/int(self.xgrid)))
        mfactor2 =  round(float(2. + int(self.endofx)/int(self.xgrid)))

        majorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid)
#        minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid/5.)
        if self.xgrid == 60:
            minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 30)
        else:
            minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 60)
        
#        list(map(round,majorloc))
#        list(map(round,minorloc))

        #majorlocator = ticker.IndexLocator(self.xgrid, starttime)  #IndexLocator does not work right when updating (new value)self.endofx
        #majorlocator = ticker.MultipleLocator(self.xgrid)          #MultipleLocator does not provide an offset for starttime
        majorlocator = ticker.FixedLocator(majorloc)
        minorlocator = ticker.FixedLocator(minorloc)

        self.ax.xaxis.set_major_locator(majorlocator)
        self.ax.xaxis.set_minor_locator(minorlocator)

        formatter = ticker.FuncFormatter(self.formtime)
        self.ax.xaxis.set_major_formatter(formatter)

        #adjust the length of the minor ticks
        for i in self.ax.xaxis.get_minorticklines() + self.ax.yaxis.get_minorticklines():
            i.set_markersize(5)

        #adjust the length of the major ticks
        for i in self.ax.get_xticklines() + self.ax.get_yticklines():
            i.set_markersize(10)
            #i.set_markeredgewidth(2)   #adjust the width

        # check x labels rotation
        if self.xrotation:     
            for label in self.ax.xaxis.get_ticklabels():
                label.set_rotation(self.xrotation)
        # we have to update the canvas cache
        if redraw:
            self.updateBackground()
        else:
            self.ax_background = None

    def fmt_timedata(self,x):
        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0
        if x >=  starttime:
            sign = ""
        else:
            sign = "-"
        m,s = divmod(abs(x - round(starttime)), 60)
        s = int(round(s))
        m = int(m)
        return '%s%d:%02d'%(sign,m,s)
        
    def fmt_data(self,x):
        if self.fmt_data_RoR and self.delta_ax:
            try:
                v = (self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,x))[1]))[1])
                if aw.qmc.LCDdecimalplaces:
                    return aw.float2float(v)
                else:
                    return int(round(v))
            except:
                pass
        return aw.float2float(x) #int(round(x))

    #used by xaxistosm(). Provides also negative time
    def formtime(self,x,pos):
        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        if x >=  starttime:
            m,s = divmod((x - round(starttime)), 60)  #**NOTE**: divmod() returns here type numpy.float64, which could create problems
            #print type(m),type(s)                    #it is used in: formatter = ticker.FuncFormatter(self.formtime) in xaxistosm()
            s = int(round(s))
            m = int(m)

            if s >= 59:
                return '%d'%(m+1)
            elif abs(s - 30) < 1:
                return '%d.5'%m
            elif s > 1:
                return  '%d:%02d'%(m,s)
            else:
                return '%d'%m

        else:
            m,s = divmod(abs(x - round(starttime)), 60)
            s = int(round(s))
            m = int(m)
            
            if s >= 59:
                return '-%d'%(m+1)
            elif abs(s-30) < 1:
                return '-%d.5'%m
            elif s > 1:
                return  '-%d:%02d'%(m,s)
            else:
                if m == 0:
                    return '0'
                else:
                    return '-%d'%m

    # returns True if nothing to save, discard or save was selected and False if canceled by the user
    def checkSaved(self):
        #prevents deleting accidentally a finished roast
        if self.safesaveflag == True:
            string = QApplication.translate("Message","Save the profile, Discard the profile (Reset), or Cancel?", None, QApplication.UnicodeUTF8)
            reply = QMessageBox.warning(self,QApplication.translate("Message","Profile unsaved", None, QApplication.UnicodeUTF8),string,
                                QMessageBox.Discard |QMessageBox.Save|QMessageBox.Cancel)
            if reply == QMessageBox.Save:
                aw.fileSave(None)  #if accepted, makes safesaveflag = False
                return True
            elif reply == QMessageBox.Discard:
                self.safesaveflag = False
                return True
            elif reply == QMessageBox.Cancel:
                aw.sendmessage(QApplication.translate("Message","Action canceled",None, QApplication.UnicodeUTF8))
                return False
        else:
            # nothing to be saved
            return True

    def clearMeasurements(self,andLCDs=True):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            self.safesaveflag = False  #now flag is cleared (OFF)
            self.rateofchange1 = 0.0
            self.rateofchange2 = 0.0
            self.temp1, self.temp2, self.delta1, self.delta2, self.timex, self.stemp1, self.stemp2 = [],[],[],[],[],[],[]
            self.unfiltereddelta1,self.unfiltereddelta2 = [],[]
            self.timeindex = [-1,0,0,0,0,0,0,0]
            #extra devices
            for i in range(min(len(self.extradevices),len(self.extratimex),len(self.extratemp1),len(self.extratemp2),len(self.extrastemp1),len(self.extrastemp2))):
                self.extratimex[i],self.extratemp1[i],self.extratemp2[i],self.extrastemp1[i],self.extrastemp2[i] = [],[],[],[],[]            #reset all variables that need to be reset (but for the actually measurements that will be treated separately at the end of this function)
            self.specialevents=[]
            aw.lcd1.display("00:00")
            if aw.WebLCDs:
                self.updateWebLCDs(time="00:00")
            if aw.largeLCDs_dialog:
                self.updateLargeLCDs(time="00:00")
            if andLCDs:
                if self.LCDdecimalplaces:
                    zz = "0.0"
                else:
                    zz = "0"
                aw.lcd2.display(zz)
                aw.lcd3.display(zz)
                aw.lcd4.display(zz)
                aw.lcd5.display(zz)
                aw.lcd6.display(zz)
                aw.lcd7.display(zz)
                for i in range(aw.nLCDS):
                    aw.extraLCD1[i].display(zz)
                    aw.extraLCD2[i].display(zz)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " reset() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    #Resets graph. Called from reset button. Deletes all data. Calls redraw() at the end
    # returns False if action was canceled, True otherwise
    def reset(self,redraw=True,soundOn=True):
        if not self.checkSaved():
            return False
        else:
            if soundOn:
                aw.soundpop()
            try:
                
                #### lock shared resources #####
                aw.qmc.samplingsemaphore.acquire(1)
                if self.flagon:
                    self.OffMonitor()

                #reset time
                aw.qmc.timeclock.start()

                if self.HUDflag:
                    self.toggleHUD()
                self.hudresizeflag = False

                aw.sendmessage(QApplication.translate("Message","Scope has been reset",None, QApplication.UnicodeUTF8))
                aw.button_3.setDisabled(False)
                aw.button_4.setDisabled(False)
                aw.button_5.setDisabled(False)
                aw.button_6.setDisabled(False)
                aw.button_7.setDisabled(False)
                aw.button_8.setDisabled(False)
                aw.button_9.setDisabled(False)
                aw.button_19.setDisabled(False)
                aw.button_20.setDisabled(False)
                aw.button_3.setFlat(False)
                aw.button_4.setFlat(False)
                aw.button_5.setFlat(False)
                aw.button_6.setFlat(False)
                aw.button_7.setFlat(False)
                aw.button_8.setFlat(False)
                aw.button_9.setFlat(False)
                aw.button_19.setFlat(False)
                aw.button_20.setFlat(False)
                aw.button_1.setText(QApplication.translate("Button", "ON",None, QApplication.UnicodeUTF8))
                aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
                aw.button_2.setText(QApplication.translate("Button", "START",None, QApplication.UnicodeUTF8))
                aw.button_2.setStyleSheet(aw.pushbuttonstyles["OFF"])

                aw.setWindowTitle(aw.windowTitle)

                if self.roastpropertiesflag:
                    self.title = QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8)
                    self.roastingnotes = ""
                    self.cuppingnotes = ""
                    self.beans = ""
                    self.weight = [0,0,self.weight[2]]
                    self.volume = [0,0,self.volume[2]]
                    self.density = [0,self.density[1],0,self.density[3]]
                    self.ambientTemp = 0.
                    self.ambient_humidity = 0.
                    self.beansize = 0.
                    self.whole_color = 0
                    self.ground_color = 0
                    self.moisture_greens = 0.
                    self.moisture_roasted = 0.
                    self.volumeCalcWeightInStr = ""
                    self.volumeCalcWeightOutStr = ""
                else:
                    self.weight = [self.weight[0],0,self.weight[2]]
                    self.volume = [self.volume[0],0,self.volume[2]]
                    

                self.roastdate = QDate.currentDate()
                self.errorlog = []
                aw.seriallog = []

                self.specialevents = []
                self.specialeventstype = []
                self.specialeventsStrings = []
                self.specialeventsvalue = []
                self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                aw.eNumberSpinBox.setValue(0)
                aw.lineEvent.setText("")
                aw.etypeComboBox.setCurrentIndex(0)
                aw.valueEdit.setText("")
                aw.curFile = None                 #current file name
                #used to find length of arms in annotations
                self.ystep_down = 0
                self.ystep_up = 0

                # reset keyboard mode
                aw.keyboardmoveindex = 0
                aw.keyboardmoveflag = 0
                aw.resetKeyboardButtonMarks()
                
                if not self.locktimex:
                    self.startofx = 0
                    self.endofx = self.resetmaxtime
                if self.endofx < 1:
                    self.endofx = 60

                #roast flags
                aw.qmc.heavyFC_flag = False
                aw.qmc.lowFC_flag = False
                aw.qmc.lightCut_flag = False
                aw.qmc.darkCut_flag = False
                aw.qmc.drops_flag = False
                aw.qmc.oily_flag = False
                aw.qmc.uneven_flag = False
                aw.qmc.tipping_flag = False
                aw.qmc.scorching_flag = False
                aw.qmc.divots_flag = False

                #color variables
                aw.qmc.whole_color = 0
                aw.qmc.ground_color = 0

                #Designer variables
                self.indexpoint = 0
                self.workingline = 2            #selects ET or BT
                self.currentx = 0               #used to add point when right click
                self.currenty = 0               #used to add point when right click
                self.designertemp1init = []
                self.designertemp2init = []
                if self.mode == "C":
        #                                     #CH, DE, Fcs,Fce,Scs,Sce,Drop
                    self.designertemp1init = [290,290,290,290,290,290,290]
                    self.designertemp2init = [200,150,200,210,220,225,240]
                elif self.mode == "F":
                    self.designertemp1init = [500,500,500,500,500,500,500]
                    self.designertemp2init = [380,300,390,395,410,412,420]
                self.disconnect_designer()  #sets designer flag false
                self.setCursor(Qt.ArrowCursor)

                self.temporaryalarmflag = -3

                #reset alarms that have been triggered
                self.alarmstate = [0]*len(self.alarmflag)  #0 = not triggered; 1 = triggered
                #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
                aw.qmc.TPalarmtimeindex = None

                #reset cupping flavor values
                self.flavors = [5.]*len(self.flavorlabels)

                try:
                    # reset color of last pressed button
                    if aw.lastbuttonpressed != -1:
                        normalstyle = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[aw.lastbuttonpressed],aw.extraeventbuttoncolor[aw.lastbuttonpressed])
                        aw.buttonlist[aw.lastbuttonpressed].setStyleSheet(normalstyle)
                    # reset lastbuttonpressed
                    aw.lastbuttonpressed = -1
                except:
                    pass

                # reset sliders
                aw.moveslider(0,0)
                aw.moveslider(1,0)
                aw.moveslider(2,0)
                aw.moveslider(3,0)
                
                # reset Arduino/TC4 PID SV
                aw.moveSVslider(0)
                aw.arduino.sv = 0

                #autodetected CHARGE and DROP index
                self.autoChargeIdx = 0
                self.autoDropIdx = 0
                self.autoTPIdx = 0
                self.autoDryIdx = 0
                self.autoFCsIdx = 0

                aw.hideDefaultButtons()
                aw.hideExtraButtons()
                aw.hideLCDs()
                aw.hideSliders()

                self.wheelflag = False
                self.designerflag = False

                #check and turn off mouse cross marker
                if self.crossmarker:
                    self.togglecrosslines()
            except Exception as ex:
    #            import traceback
    #            traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " reset() %1").arg(str(ex)),exc_tb.tb_lineno)
            finally:
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)
            # now clear all measurements and redraw
            self.clearMeasurements()
            ### REDRAW  ##
            if redraw:
                self.redraw(False)
            return True

    def medfilt(self, x, k):
        """Apply a length-k median filter to a 1D array x.
        Boundaries are extended by repeating endpoints.
        """
        assert k % 2 == 1, "Median filter length must be odd."
        assert x.ndim == 1, "Input must be one-dimensional."
        k2 = (k - 1) // 2
        y = numpy.zeros ((len (x), k), dtype=x.dtype)
        y[:,k2] = x
        for i in range (k2):
            j = k2 - i
            y[j:,i] = x[:-j]
            y[:j,i] = x[0]
            y[:-j,-(i+1)] = x[j:]
            y[-j:,-(i+1)] = x[-1]
        return numpy.median(y, axis=1)

    # smoothes a list of values 'y' at taken at times indicated by the numbers in list 'x'
    # 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
    # 'flat' results in moving average
    # window_len should be odd
    # based on http://wiki.scipy.org/Cookbook/SignalSmooth
#    def smooth(self, x, y, window_len=15, window='hanning'):
#        try:
#            if len(x) == len(y) and len(x) > 1:
#                # filter spikes
#                if aw.qmc.filterDropOuts:
#                    y = self.medfilt(y,5) # k=3 seems not to catch all spikes in all cases
#                if window_len > 2 and len(x) == len(y) and len(x) > 1:
#                    # smooth curves
#                    s = numpy.r_[2*x[0]-y[window_len:1:-1],y,2*y[-1]-y[-1:-window_len:-1]]
#                    if window == 'flat': #moving average
#                        w = numpy.ones(window_len,'d')
#                    else:
#                        w = eval('numpy.'+window+'(window_len)')
#                    ys = numpy.convolve(w/w.sum(),s,mode='same')
#                    res = (ys[window_len-1:-window_len+1])
#    #                res = (ys[window_len-2:-window_len]) # this one seems to move the curve slightly to the right
#                    if len(res) != len(y):
#                        return y
#                    else:
#                        return res
#                else:
#                    return y
#            else:
#                return y
#        except Exception as ex:
##            import traceback
##            traceback.print_exc(file=sys.stdout)
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " smooth() %1").arg(str(ex)),exc_tb.tb_lineno)
#            return x

    def smooth(self, x, y, window_len=15, window='hanning'):
        try:
            if len(x) == len(y) and len(x) > 1:
                # filter spikes
                if aw.qmc.filterDropOuts:
                    y = self.medfilt(y,5) # k=3 seems not to catch all spikes in all cases
                if window_len > 2 and len(x) == len(y) and len(x) > 1:
                    # smooth curves
                    #s = numpy.r_[2*x[0]-y[window_len:1:-1],y,2*y[-1]-y[-1:-window_len:-1]]
                    s=numpy.r_[y[window_len-1:0:-1],y,y[-1:-window_len:-1]]
                    if window == 'flat': #moving average
                        w = numpy.ones(window_len,'d')
                    else:
                        w = eval('numpy.'+window+'(window_len)')
                    ys = numpy.convolve(w/w.sum(),s,mode='valid')
                    res = ys[(window_len/2):-(window_len/2)]
                    if len(res) != len(y):
                        return y
                    else:
                        return res
                else:
                    return y
            else:
                return y
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " smooth() %1").arg(str(ex)),exc_tb.tb_lineno)
            return x

    def smooth_list(self, a, b, window_len=7, window='hanning',fromIndex=-1):  # default 'hanning'
        #pylint: disable=E1103        
        win_len = max(0,window_len)
        if win_len != 1: # at the lowest level we turn smoothing completely off
            if fromIndex > -1: # if fromIndex is set, replace prefix up to fromIndex by None
                return numpy.concatenate(([None]*(fromIndex),
                    self.smooth(numpy.array(a),numpy.array(b),window_len,window).tolist()[fromIndex:])).tolist()
            elif aw.qmc.timeindex[0] != -1: # we do not smooth before CHARGE
                return numpy.concatenate((b[:aw.qmc.timeindex[0]+1],
                    self.smooth(numpy.array(a),numpy.array(b),win_len,window).tolist()[aw.qmc.timeindex[0]+1:])).tolist()            
            else:
                return self.smooth(numpy.array(a),numpy.array(b),win_len,window).tolist()
        else:
            return b

    def annotate(self, temp, time_str, x, y, yup, ydown,e=0,a=1.):                
        if aw.qmc.patheffects:
            rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground="w")]
        else:
            rcParams['path.effects'] = []
        #annotate temp
        if aw.qmc.LCDdecimalplaces:
            fmtstr = "%.1f"
        else:
            fmtstr = "%.0f"        
        self.ax.annotate(fmtstr%(temp), xy=(x,y),xytext=(x+e,y + yup),
                            color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["text"],alpha=a),fontsize="x-small",alpha=a,fontproperties=aw.mpl_fontproperties)
        #anotate time
        self.ax.annotate(time_str,xy=(x,y),xytext=(x+e,y - ydown),
                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["text"],alpha=a),fontsize="x-small",alpha=a,fontproperties=aw.mpl_fontproperties)

    def place_annotations(self,TP_index,d,timex,timeindex,temp,stemp,startB=None,time2=None,timeindex2=None,path_effects=None):
        ystep_down = ystep_up = 0
        #Add markers for CHARGE
        try: 
            if timeindex[0] != -1 and len(timex) > timeindex[0]:
                t0idx = timeindex[0]
                t0 = timex[t0idx]
                y = stemp[t0idx]
                ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y,y,d)
                if startB != None:
                    st1 = str(self.stringfromseconds(t0 - startB))
                    t0 = startB
                    e = 40
                    a = aw.qmc.backgroundalpha
                else:
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation", "CHARGE", None, QApplication.UnicodeUTF8))
                    e = 0
                    a = 1.  
                self.annotate(temp[t0idx],st1,t0,y,ystep_up,ystep_down,e,a)
                #Add TP marker
                if self.markTPflag and TP_index and TP_index > 0:
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","TP %1", None, QApplication.UnicodeUTF8),u(self.stringfromseconds(timex[TP_index]-t0,False)))
                    a = 1.
                    e = 0
                    self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a)
                #Add Dry End markers
                if timeindex[1]:
                    tidx = timeindex[1]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DE %1", None, QApplication.UnicodeUTF8),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[1] and timex[timeindex[1]] < time2[timeindex2[1]]:
                        e = -80
                    else:
                        e = 0
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                #Add 1Cs markers            
                if timeindex[2]:
                    tidx = timeindex[2]
                    if timeindex[1]: #if dryend
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[1]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCs %1", None, QApplication.UnicodeUTF8),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[2] and timex[timeindex[2]] < time2[timeindex2[2]]:
                        e = -80
                    else:
                        e = 0
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                #Add 1Ce markers
                if timeindex[3]:
                    tidx = timeindex[3]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[2]],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCe %1", None, QApplication.UnicodeUTF8),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[3] and timex[timeindex[3]] < time2[timeindex2[3]]:
                        e = -80
                    else:
                        e = 0
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                    #add a water mark if FCs
                    if timeindex[2] and not timeindex2:
                        self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                #Add 2Cs markers
                if timeindex[4]:
                    tidx = timeindex[4]
                    if timeindex[3]:
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[3]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCs %1", None, QApplication.UnicodeUTF8),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[4] and timex[timeindex[4]] < time2[timeindex2[4]]:
                        e = -80
                    else:
                        e = 0
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                #Add 2Ce markers
                if timeindex[5]:
                    tidx = timeindex[5]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[4]],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCe %1", None, QApplication.UnicodeUTF8),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[5] and timex[timeindex[5]] < time2[timeindex2[5]]:
                        e = -80
                    else:
                        e = 0
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                    #do water mark if SCs
                    if timeindex[4] and not timeindex2:
                        self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                #Add DROP markers
                if timeindex[6]:
                    tidx = timeindex[6]
                    if timeindex[5]:
                        tx = timeindex[5]
                    elif timeindex[4]:
                        tx = timeindex[4]
                    elif timeindex[3]:
                        tx = timeindex[3]
                    elif timeindex[2]:
                        tx = timeindex[2]
                    elif timeindex[1]:
                        tx = timeindex[1]
                    else:
                        tx = t0idx
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DROP %1", None, QApplication.UnicodeUTF8),str(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[6] and timex[timeindex[6]] < time2[timeindex2[6]]:
                        e = -80
                    else:
                        e = 0
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                    
                    #do water mark if FCs, but no FCe nor SCs nor SCe
                    if timeindex[2] and not timeindex[3] and not timeindex[4] and not timeindex[5] and not timeindex2:
                        self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                    #do water mark if SCs, but no SCe
                    if timeindex[4] and not timeindex[5] and not timeindex2:
                        self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                # add COOL mark
                if timeindex[7] and not timeindex2:
                    tidx = timeindex[7]
                    endidx = self.ax.get_xlim()[1] # or timex[-1]
                    if timex[tidx] < endidx:
                        self.ax.axvspan(timex[tidx],endidx, facecolor=self.palette["rect4"], ec='none', alpha=0.3, clip_on=False, clip_path=None, lw=None,lod=False)
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " place_annotations() %1").arg(str(e)),exc_tb.tb_lineno)

    #Redraws data
    # if recomputeAllDeltas, the delta arrays; if smooth the smoothed line arrays are recomputed
    def redraw(self, recomputeAllDeltas=True, smooth=False):
        try:
            #### lock shared resources   ####
            aw.qmc.samplingsemaphore.acquire(1)

            rcParams['path.effects'] = []
            if aw.qmc.graphstyle == 1:
                scale = 1
            else:
                scale = 0            
            length = 700 # 100 (128 the default)
            randomness = 12 # 2 (16 default)
            rcParams['path.sketch'] = (scale, length, randomness)

            rcParams['axes.linewidth'] = 1.5
            rcParams['xtick.major.size'] = 8
            rcParams['xtick.major.width'] = 1.5
            rcParams['xtick.minor.width'] = 1
            rcParams['ytick.major.size'] = 8
            rcParams['ytick.major.width'] = 1.5
            rcParams['ytick.minor.width'] = 1
            rcParams['xtick.color'] = self.palette["xlabel"]
            rcParams['ytick.color'] = self.palette["ylabel"]

            self.fig.clf()   #wipe out figure. keep_observers=False

            self.ax = self.fig.add_subplot(111,axisbg=self.palette["background"])

            #Set axes same as in __init__
            if self.endofx == 0:            #fixes possible condition of endofx being ZERO when application starts (after aw.settingsload)
                self.endofx = 60
            self.ax.set_ylim(self.ylimit_min, self.ylimit)
            self.ax.set_autoscale_on(False)
            fontprop_medium = aw.mpl_fontproperties.copy()
            fontprop_medium.set_size("medium")
            fontprop_large = aw.mpl_fontproperties.copy()
            fontprop_large.set_size("large")
            fontprop_xlarge = aw.mpl_fontproperties.copy()
            fontprop_xlarge.set_size("x-large")
            self.ax.grid(True,color=self.palette["grid"],linestyle=self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha,sketch_params=0,path_effects=[])
            if aw.qmc.flagstart:
                self.ax.set_ylabel("")
                self.ax.set_xlabel("")
                self.ax.set_title("")
                self.fig.suptitle("")
            else:
                self.ax.set_ylabel(self.mode,color=self.palette["ylabel"],rotation=0,labelpad=10,fontproperties=fontprop_large)
                self.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8)),color = self.palette["xlabel"],fontproperties=fontprop_medium)
                self.ax.set_title(aw.arabicReshape(self.title), color=self.palette["title"],
                    fontproperties=fontprop_xlarge,horizontalalignment="left",x=0)
            
            two_ax_mode = (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag)))

            if self.background:
                fontprop_small = aw.mpl_fontproperties.copy()
                fontprop_small.set_size("xx-small")
                if len(self.title) > 20:
                    stl = 25
                else:
                    stl = 30
                if two_ax_mode:
                    suptitleX = 0.93
                else:
                    suptitleX = 1
                if aw.qmc.flagstart:
                    self.fig.suptitle("")
                else:
                    self.fig.suptitle("\n" + aw.qmc.abbrevString(self.titleB,stl),
                        horizontalalignment="right",fontproperties=fontprop_small,x=suptitleX,y=1)
            
#            self.fig.patch.set_facecolor(self.palette["background"]) # facecolor='lightgrey'
            #self.ax.spines['top'].set_color('none')
            self.ax.tick_params(\
                axis='x',           # changes apply to the x-axis
                which='both',       # both major and minor ticks are affected
                bottom='on',        # ticks along the bottom edge are on
                top='off',          # ticks along the top edge are off
                labelbottom='on')   # labels along the bottom edge are on

            prop = aw.mpl_fontproperties.copy()
            prop.set_size("medium")
            for label in self.ax.get_xticklabels() :
                label.set_fontproperties(prop)
            for label in self.ax.get_yticklabels() :
                label.set_fontproperties(prop)

            # format temperature as int, not float in the cursor position coordinate indicator
            self.ax.fmt_ydata = self.fmt_data
            self.ax.fmt_xdata = self.fmt_timedata

            if two_ax_mode:
                #create a second set of axes in the same position as self.ax
                self.delta_ax = self.ax.twinx()
                self.ax.set_zorder(self.delta_ax.get_zorder()-1) # put delta_ax in front of ax
                self.ax.patch.set_visible(True)
                if aw.qmc.flagstart:
                    self.delta_ax.set_ylabel("")
                else:
                    self.delta_ax.set_ylabel(aw.qmc.mode + aw.arabicReshape(QApplication.translate("Label", "/min", None, QApplication.UnicodeUTF8)),color = self.palette["ylabel"],fontproperties=fontprop_large)
                self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                for i in self.delta_ax.get_yticklines():
                    i.set_markersize(10)
                for i in self.delta_ax.yaxis.get_minorticklines():
                    i.set_markersize(5)
                for label in self.delta_ax.get_yticklabels() :
                    label.set_fontproperties(prop)

                # translate y-coordinate from delta into temp range to ensure the cursor position display (x,y) coordinate in the temp axis
                self.delta_ax.fmt_ydata = self.fmt_data
                self.delta_ax.fmt_xdata = self.fmt_timedata
            #put a right tick on the graph
            else:
                self.delta_ax = None
#                if aw.qmc.graphstyle:
#                    self.ax.spines['right'].set_color('none')
#                    self.ax.spines['top'].set_color('none')
##                for tick in self.ax.yaxis.get_major_ticks():
##                    tick.label2On = True
                self.ax.tick_params(\
                    axis='y', 
                    which='both',
                    right='off',
                    labelright='off') 

            self.ax.spines['top'].set_color("0.40")
            self.ax.spines['bottom'].set_color("0.40")
            self.ax.spines['left'].set_color("0.40")
            self.ax.spines['right'].set_color("0.40")

            self.ax.yaxis.set_major_locator(ticker.MultipleLocator(self.ygrid))
            self.ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
            for i in self.ax.get_yticklines():
                i.set_markersize(10)
            for i in self.ax.yaxis.get_minorticklines():
                i.set_markersize(5)

            #update X ticks, labels, and colors
            self.xaxistosm()

            rcParams['path.sketch'] = (0,0,0)
            trans = transforms.blended_transform_factory(self.ax.transAxes,self.ax.transData)

            #draw water marks for dry phase region, mid phase region, and finish phase region
            if aw.qmc.watermarksflag:
                rect1 = patches.Rectangle((0,self.phases[0]), width=1, height=(self.phases[1]-self.phases[0]),
                                          transform=trans, color=self.palette["rect1"],alpha=0.15)
                rect2 = patches.Rectangle((0,self.phases[1]), width=1, height=(self.phases[2]-self.phases[1]),
                                          transform=trans, color=self.palette["rect2"],alpha=0.15)
                rect3 = patches.Rectangle((0,self.phases[2]), width=1, height=(self.phases[3] - self.phases[2]),
                                          transform=trans, color=self.palette["rect3"],alpha=0.15)
                self.ax.add_patch(rect1)
                self.ax.add_patch(rect2)
                self.ax.add_patch(rect3)

            #if self.eventsGraphflag == 0 then that means don't plot event bars

            if self.eventsGraphflag == 1: #plot event bars by type
                # make blended transformations to help identify EVENT types
                if self.mode == "C":
                    step = 5
                    start = 20
                else:
                    step = 10
                    start = 60
                jump = 20
                for i in range(4):
                    rectEvent = patches.Rectangle((0,self.phases[0]-start-jump), width=1, height = step, transform=trans, color=self.palette["rect1"],alpha=.15)
                    self.ax.add_patch(rectEvent)
                    if self.mode == "C":
                        jump -= 10
                    else:
                        jump -= 20

            #plot events bars by value
            elif self.eventsGraphflag == 2:
                # make blended transformations to help identify EVENT types
                if self.mode == "C":
                    step = 2
                    start = 40
                else:
                    step = 5
                    start = 100
                jump = 20

                for i in range(12):
                    if i == 0:
                        color = self.palette["rect3"]
                    elif i%2:
                        color = self.palette["rect2"]
                    else:
                        color = self.palette["rect1"]
                    barposition = self.phases[0]-start-jump    
                    rectEvent = patches.Rectangle((0,barposition), width=1, height = step, transform=trans, color=color,alpha=.15)
                    self.ax.add_patch(rectEvent)
                    self.eventpositionbars[i] = barposition
                    if self.mode == "C":
                        jump -= 5
                    else:
                        jump -= 10

            rcParams['path.sketch'] = (scale, length, randomness)

            #check BACKGROUND flag
            if self.background: 
                #check to see if there is both a profile loaded and a background loaded
                if self.backmoveflag:
                    self.timealign(redraw=False,recompute=False,FCs=self.flagalignFCs)

                #draw background
                self.l_back1, = self.ax.plot(self.timeB, self.temp1B,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                            sketch_params=None,path_effects=[],
                                            linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                            alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundET", None, QApplication.UnicodeUTF8)))
                self.l_back2, = self.ax.plot(self.timeB, self.temp2B,markersize=self.BTbackmarkersize,marker=self.BTbackmarker, 
                                            linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                            sketch_params=None,path_effects=[],
                                            alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundBT", None, QApplication.UnicodeUTF8)))

                #populate background delta ET (self.delta1B) and delta BT (self.delta2B)
                if self.DeltaETBflag or self.DeltaBTBflag:
                    if True: # recomputeAllDeltas:
                        tx = numpy.array(self.timeB)
                        dtx = numpy.diff(self.timeB) / 60.
                        with numpy.errstate(divide='ignore'):
                            z1 = numpy.diff(self.temp1B) / dtx
                            z2 = numpy.diff(self.temp2B) / dtx
                        lt,ld1,ld2 = len(self.timeB),len(z1),len(z2)
                        if lt > ld1:
                            z1 = numpy.append(z1,[z1[-1] if ld1 else 0.]*(lt - ld1))
                        if lt > ld2:
                            z2 = numpy.append(z2,[z2[-1] if ld2 else 0.]*(lt - ld2))
                        self.delta1B = self.smooth_list(tx,z1,window_len=self.deltafilter,fromIndex=self.timeindexB[0]) # CHARGE is the charge for the foreground, so we have to disable this here
                        self.delta2B = self.smooth_list(tx,z2,window_len=self.deltafilter,fromIndex=self.timeindexB[0])
                        # cut out the part after DROP
                        if aw.qmc.timeindexB[6]:
                            self.delta1B = numpy.append(self.delta1B[:self.timeindexB[6]+1],[None]*(len(self.delta1B)-self.timeindexB[6]-1))
                            self.delta2B = numpy.append(self.delta2B[:self.timeindexB[6]+1],[None]*(len(self.delta2B)-self.timeindexB[6]-1))
                        # cut out the part before CHARGE
                        if aw.qmc.timeindexB[0] > -1 and aw.qmc.timeindexB[0] < aw.qmc.timeindexB[6]:
                            self.delta1B = numpy.append([None]*(aw.qmc.timeindexB[0]),self.delta1B[aw.qmc.timeindexB[0]:])
                            self.delta2B = numpy.append([None]*(aw.qmc.timeindexB[0]),self.delta2B[aw.qmc.timeindexB[0]:])
                        # filter out values beyond the delta limits
                        if aw.qmc.mode == "C":
                            rorlimit = aw.qmc.RoRlimitC
                        else:
                            rorlimit = aw.qmc.RoRlimitF
                        self.delta1B = [d if d and (-rorlimit < d < rorlimit) else None for d in self.delta1B]
                        self.delta2B = [d if d and (-rorlimit < d < rorlimit) else None for d in self.delta2B]
                    
                    ##### DeltaETB,DeltaBTB curves
                    if self.DeltaETBflag:
                        self.l_delta1B, = self.delta_ax.plot(self.timeB, self.delta1B,markersize=self.ETBdeltamarkersize,
                        sketch_params=None,path_effects=[],
                        marker=self.ETBdeltamarker,linewidth=self.ETBdeltalinewidth,linestyle=self.ETBdeltalinestyle,drawstyle=self.ETBdeltadrawstyle,color=self.backgrounddeltaetcolor,alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundDeltaET", None, QApplication.UnicodeUTF8)))
                    if self.DeltaBTBflag:
                        self.l_delta2B, = self.delta_ax.plot(self.timeB, self.delta2B,markersize=self.BTBdeltamarkersize,
                        sketch_params=None,path_effects=[],
                        marker=self.BTBdeltamarker,linewidth=self.BTBdeltalinewidth,linestyle=self.BTBdeltalinestyle,drawstyle=self.BTBdeltadrawstyle,color=self.backgrounddeltabtcolor,alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundDeltaBT", None, QApplication.UnicodeUTF8)))

                #check backgroundevents flag
                if self.backgroundeventsflag:
                    if self.eventsGraphflag != 2:
                        if self.mode == "F":
                            height = 50
                        else:
                            height = 20

                        for p in range(len(self.backgroundEvents)):
                            st1 = u(self.Betypesf(self.backgroundEtypes[p])[0] + self.eventsvaluesShort(self.backgroundEvalues[p]))
                            if self.temp1B[self.backgroundEvents[p]] > self.temp2B[self.backgroundEvents[p]]:
                                temp = self.temp1B[self.backgroundEvents[p]]
                            else:
                                temp = self.temp2B[self.backgroundEvents[p]]
                            self.ax.annotate(st1, xy=(self.timeB[self.backgroundEvents[p]], temp),path_effects=[],
                                                xytext=(self.timeB[self.backgroundEvents[p]], temp+height),
                                                fontsize="x-small",fontproperties=aw.mpl_fontproperties,color=self.palette["text"],arrowprops=dict(arrowstyle='wedge',color="yellow",
                                                alpha=self.backgroundalpha,relpos=(0,0)),alpha=self.backgroundalpha)
                    #background events by value
                    else:
                        self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
                        self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
                        for i in range(len(self.backgroundEvents)):
                            if self.backgroundEtypes[i] == 0:
                                self.E1backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E1backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])
                            elif self.backgroundEtypes[i] == 1:
                                self.E2backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E2backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])
                            elif self.backgroundEtypes[i] == 2:
                                self.E3backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E3backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])
                            elif self.backgroundEtypes[i] == 3:
                                self.E4backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E4backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])

                        self.l_backgroundeventtype1dots, = self.ax.plot(self.E1backgroundtimex, self.E1backgroundvalues, color=self.EvalueColor[0], marker=self.EvalueMarker[0],markersize = self.EvalueMarkerSize[0],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[0],alpha = aw.qmc.backgroundalpha)
                        self.l_backgroundeventtype2dots, = self.ax.plot(self.E2backgroundtimex, self.E2backgroundvalues, color=self.EvalueColor[1], marker=self.EvalueMarker[1],markersize = self.EvalueMarkerSize[1],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[1],alpha = aw.qmc.backgroundalpha)
                        self.l_backgroundeventtype3dots, = self.ax.plot(self.E3backgroundtimex, self.E3backgroundvalues, color=self.EvalueColor[2], marker=self.EvalueMarker[2],markersize = self.EvalueMarkerSize[2],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[2],alpha = aw.qmc.backgroundalpha)
                        self.l_backgroundeventtype4dots, = self.ax.plot(self.E4backgroundtimex, self.E4backgroundvalues, color=self.EvalueColor[3], marker=self.EvalueMarker[3],markersize = self.EvalueMarkerSize[3],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[3],alpha = aw.qmc.backgroundalpha)
                #check backgroundDetails flag
                if self.backgroundDetails:
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min 
                    d = d - d/5
                    #if there is a profile loaded with CHARGE, then save time to get the relative time
                    if self.timeindex[0] != -1:   #verify it exists before loading it, otherwise the list could go out of index
                        startB = self.timex[self.timeindex[0]]
                    else:
                        if self.timeindexB[0] > 0:
                            startB = self.timeB[self.timeindexB[0]]
                        else:
                            startB = 0
                    self.place_annotations(-1,d,self.timeB,self.timeindexB,self.temp2B,self.stemp2B,startB,self.timex,self.timeindex)
                    
                #END of Background
                
            if aw.qmc.patheffects:
                rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground="w")]

            ##### Extra devices-curves
            self.extratemp1lines,self.extratemp2lines = [],[]
            for i in range(min(len(self.extratimex),len(self.extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(self.extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                if aw.extraCurveVisibility1[i]:
                    if aw.qmc.flagon:
                        self.extratemp1lines.append(self.ax.plot(self.extratimex[i], self.extratemp1[i],color=self.extradevicecolor1[i],
                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths1[i]+aw.qmc.patheffects,foreground="w")],
                        markersize=self.extramarkersizes1[i],marker=self.extramarkers1[i],linewidth=self.extralinewidths1[i],linestyle=self.extralinestyles1[i],drawstyle=self.extradrawstyles1[i],label= self.extraname1[i])[0])
                    else:
                        if smooth or len(self.extrastemp1[i]) != len(self.extratimex[i]):
                            self.extrastemp1[i] = self.smooth_list(self.extratimex[i],self.extratemp1[i],window_len=self.curvefilter)
                        self.extratemp1lines.append(self.ax.plot(self.extratimex[i], self.extrastemp1[i],color=self.extradevicecolor1[i],
                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths1[i]+aw.qmc.patheffects,foreground="w")],
                        markersize=self.extramarkersizes1[i],marker=self.extramarkers1[i],linewidth=self.extralinewidths1[i],linestyle=self.extralinestyles1[i],drawstyle=self.extradrawstyles1[i],label= self.extraname1[i])[0])
                if aw.extraCurveVisibility2[i]:
                    if aw.qmc.flagon:
                        self.extratemp2lines.append(self.ax.plot(self.extratimex[i], self.extratemp2[i],color=self.extradevicecolor2[i],
                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths2[i]+aw.qmc.patheffects,foreground="w")],
                        markersize=self.extramarkersizes2[i],marker=self.extramarkers2[i],linewidth=self.extralinewidths2[i],linestyle=self.extralinestyles2[i],drawstyle=self.extradrawstyles2[i],label= self.extraname2[i])[0])
                    else:
                        if smooth or len(self.extrastemp2[i]) != len(self.extratimex[i]):
                            self.extrastemp2[i] = self.smooth_list(self.extratimex[i],self.extratemp2[i],window_len=self.curvefilter)
                        self.extratemp2lines.append(self.ax.plot(self.extratimex[i], self.extrastemp2[i],color=self.extradevicecolor2[i],
                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths2[i]+aw.qmc.patheffects,foreground="w")],
                        markersize=self.extramarkersizes2[i],marker=self.extramarkers2[i],linewidth=self.extralinewidths2[i],linestyle=self.extralinestyles2[i],drawstyle=self.extradrawstyles2[i],label= self.extraname2[i])[0])

            ##### ET,BT curves
            if smooth or len(self.stemp1) != len(self.timex):
                self.stemp1 = self.smooth_list(self.timex,self.temp1,window_len=self.curvefilter)
            if smooth or len(self.stemp2) != len(self.timex):
                self.stemp2 = self.smooth_list(self.timex,self.temp2,window_len=self.curvefilter)
            if aw.qmc.ETcurve:
                if aw.qmc.flagon:
                    self.l_temp1, = self.ax.plot(self.timex,self.temp1,markersize=self.ETmarkersize,marker=self.ETmarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETlinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=aw.arabicReshape(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
                else:
                    self.l_temp1, = self.ax.plot(self.timex,self.stemp1,markersize=self.ETmarkersize,marker=self.ETmarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETlinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=aw.arabicReshape(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
            if aw.qmc.BTcurve:
                if aw.qmc.flagon:
                    self.l_temp2, = self.ax.plot(self.timex,self.temp2,markersize=self.BTmarkersize,marker=self.BTmarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTlinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette["bt"],label=aw.arabicReshape(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))
                else:
                    self.l_temp2, = self.ax.plot(self.timex,self.stemp2,markersize=self.BTmarkersize,marker=self.BTmarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTlinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette["bt"],label=aw.arabicReshape(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))

            handles = []
            labels = []
            if aw.qmc.ETcurve:
                handles.append(self.l_temp1)
                labels.append(aw.arabicReshape(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
            if aw.qmc.BTcurve:
                handles.append(self.l_temp2)
                labels.append(aw.arabicReshape(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))

            #populate delta ET (self.delta1) and delta BT (self.delta2)
            if self.DeltaETflag or self.DeltaBTflag:
                if recomputeAllDeltas:
#                    dtx = numpy.diff(self.timex) / 60.
                    tx = numpy.array(self.timex)
                    if aw.qmc.flagon or len(tx) != len(self.stemp1):
                        t1 = self.temp1
                    else:
                        t1 = self.stemp1
                    with numpy.errstate(divide='ignore'):
#                        z1 = numpy.diff(t1) / dtx
                        nt1 = numpy.array(t1)
                        z1 = (nt1[aw.qmc.deltasamples:] - nt1[:-aw.qmc.deltasamples]) / ((tx[aw.qmc.deltasamples:] - tx[:-aw.qmc.deltasamples])/60.)

                    if aw.qmc.flagon or len(tx) != len(self.stemp2):
                        t2 = self.temp2
                    else:
                        t2 = self.stemp2
                    with numpy.errstate(divide='ignore'):
#                        z2 = numpy.diff(t2) / dtx
                        nt2 = numpy.array(t2)
                        z2 = (nt2[aw.qmc.deltasamples:] - nt2[:-aw.qmc.deltasamples]) / ((tx[aw.qmc.deltasamples:] - tx[:-aw.qmc.deltasamples])/60.)
                            
                    lt,ld1,ld2 = len(self.timex),len(z1),len(z2)
                    # make lists equal in length
                    if lt > ld1:
                        z1 = numpy.append(z1,[z1[-1] if ld1 else 0.]*(lt - ld1))
                    if lt > ld2:
                        z2 = numpy.append(z2,[z2[-1] if ld2 else 0.]*(lt - ld2))
                    self.delta1 = self.smooth_list(tx,z1,window_len=self.deltafilter,fromIndex=aw.qmc.timeindex[0])
                    self.delta2 = self.smooth_list(tx,z2,window_len=self.deltafilter,fromIndex=aw.qmc.timeindex[0])
                    # filter out values beyond the delta limits
                    # cut out the part after DROP
                    if aw.qmc.timeindex[6]:
                        self.delta1 = numpy.append(self.delta1[:aw.qmc.timeindex[6]+1],[None]*(len(self.delta1)-aw.qmc.timeindex[6]-1))
                        self.delta2 = numpy.append(self.delta2[:aw.qmc.timeindex[6]+1],[None]*(len(self.delta2)-aw.qmc.timeindex[6]-1))
                    # cut out the part before CHARGE
                    if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[0] < aw.qmc.timeindex[6]:
                        self.delta1 = numpy.append([None]*(aw.qmc.timeindex[0]),self.delta1[aw.qmc.timeindex[0]:])
                        self.delta2 = numpy.append([None]*(aw.qmc.timeindex[0]),self.delta2[aw.qmc.timeindex[0]:])
                    # remove values beyond the RoRlimit
                    if aw.qmc.mode == "C":
                        rorlimit = aw.qmc.RoRlimitC
                    else:
                        rorlimit = aw.qmc.RoRlimitF
                    self.delta1 = [d if d and (-rorlimit < d < rorlimit) else None for d in self.delta1]
                    self.delta2 = [d if d and (-rorlimit < d < rorlimit) else None for d in self.delta2]
                    
                ##### DeltaET,DeltaBT curves
                if self.DeltaETflag: 
                    self.l_delta1, = self.delta_ax.plot(self.timex, self.delta1,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],label=aw.arabicReshape(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))
                    handles.append(self.l_delta1)
                    labels.append(aw.arabicReshape(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))
                    
                if self.DeltaBTflag:
                    self.l_delta2, = self.delta_ax.plot(self.timex, self.delta2,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],label=aw.arabicReshape(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))
                    handles.append(self.l_delta2)
                    labels.append(aw.arabicReshape(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))

            nrdevices = len(self.extradevices)
            
            if nrdevices and not self.designerflag:
                xtmpl1idx = 0
                xtmpl2idx = 0
                for i in range(nrdevices):
                    if aw.extraCurveVisibility1[i]:
                        handles.append(self.extratemp1lines[xtmpl1idx])
                        xtmpl1idx = xtmpl1idx + 1
                        labels.append(aw.arabicReshape(self.extraname1[i]))
                    if aw.extraCurveVisibility2[i]:
                        handles.append(self.extratemp2lines[xtmpl2idx])
                        xtmpl2idx = xtmpl2idx + 1
                        labels.append(aw.arabicReshape(self.extraname2[i]))
                        
            if not self.designerflag and aw.qmc.BTcurve:
                if self.flagon: # no smoothed lines in this case, pass normal BT
                    self.place_annotations(aw.qmc.TPalarmtimeindex,aw.qmc.ylimit - aw.qmc.ylimit_min,self.timex,self.timeindex,self.temp2,self.temp2)
                else:
                    TP_index = aw.findTP()
                    self.place_annotations(TP_index,aw.qmc.ylimit - aw.qmc.ylimit_min,self.timex,self.timeindex,self.temp2,self.stemp2)
                    if self.timeindex[6]:
                        self.writestatistics(TP_index)

            if self.eventsshowflag:
                Nevents = len(self.specialevents)
                #three modes of drawing events.
                # the first mode just places annotations. They are text annotations.
                # The second mode aligns the events types to a bar height so that they can be visually identified by type. They are text annotations
                # the third mode plots the events by value. They are not annotations but actual lines.

                if Nevents:
                    for i in range(Nevents):
                        if self.specialeventstype[i] == 4 or self.eventsGraphflag == 0:
                            if self.specialeventstype[i] < 4:
                                etype = self.etypesf(self.specialeventstype[i])
                                firstletter = u(etype[0])
                                secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                            else:
                                firstletter = "E"
                                secondletter = ""
                            if self.mode == "F":
                                height = 50
                            else:
                                height = 20
                            #some times ET is not drawn (ET = 0) when using device NONE
                            if self.temp1[int(self.specialevents[i])] > self.temp2[int(self.specialevents[i])] and aw.qmc.ETcurve:
                                if aw.qmc.flagon:
                                    temp = self.temp1[int(self.specialevents[i])]
                                else:
                                    temp = self.stemp1[int(self.specialevents[i])]
                            elif aw.qmc.BTcurve:
                                if aw.qmc.flagon:
                                    temp = self.temp2[int(self.specialevents[i])]
                                else:
                                    temp = self.stemp2[int(self.specialevents[i])]
                            else:
                                temp = None
                            if temp:
                                self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], temp),
                                             xytext=(self.timex[int(self.specialevents[i])],temp+height),alpha=0.9,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')

                if self.eventsGraphflag == 1 and Nevents:
                    char1 = self.etypes[0][0]
                    char2 = self.etypes[1][0]
                    char3 = self.etypes[2][0]
                    char4 = self.etypes[3][0]

                    if self.mode == "F":
                        row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                    else:
                        row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}

                    #draw lines of color between events of the same type to help identify areas of events.
                    #count (as length of the list) and collect their times for each different type. Each type will have a different plot heigh
                    netypes=[[],[],[],[]]
                    for i in range(Nevents):
                        if self.specialeventstype[i] == 0:
                            netypes[0].append(self.timex[self.specialevents[i]])
                        elif self.specialeventstype[i] == 1:
                            netypes[1].append(self.timex[self.specialevents[i]])
                        elif self.specialeventstype[i] == 2:
                            netypes[2].append(self.timex[self.specialevents[i]])
                        elif self.specialeventstype[i] == 3:
                            netypes[3].append(self.timex[self.specialevents[i]])
                            
                    letters = char1+char2+char3+char4   #"NPDF" fisrt letter for each type (None, Power, Damper, Fan)
                    colors = [self.palette["rect2"],self.palette["rect3"]] #rotating colors
                    for p in range(len(letters)):    
                        if len(netypes[p]) > 1:
                            for i in range(len(netypes[p])-1):
                                #draw differentiating color bars between events and place then in a different height acording with type
                                rect = patches.Rectangle((netypes[p][i], row[letters[p]]), width = (netypes[p][i+1]-netypes[p][i]), height = step, color = colors[i%2],alpha=0.5)
                                self.ax.add_patch(rect)

                    # annotate event
                    for i in range(Nevents):
                        if self.specialeventstype[i] > 3:
                            # a special event of type "--"
                            pass
                        else:
                            firstletter = self.etypes[self.specialeventstype[i]][0]
                            secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                            #some times ET is not drawn (ET = 0) when using device NONE
                            if self.temp1[int(self.specialevents[i])] >= self.temp2[int(self.specialevents[i])]:                            
                                if aw.qmc.flagon:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.temp1[int(self.specialevents[i])]),
                                                 xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                                else:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.stemp1[int(self.specialevents[i])]),
                                                 xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                            else:
                                if aw.qmc.flagon:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.temp2[int(self.specialevents[i])]),
                                             xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                                else:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.stemp2[int(self.specialevents[i])]),
                                             xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')

                elif self.eventsGraphflag == 2:
                    self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                    self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                    E1_nonempty = E2_nonempty = E3_nonempty = E4_nonempty = False
                    for i in range(Nevents):
                        if self.specialeventstype[i] == 0:           
                            self.E1timex.append(self.timex[self.specialevents[i]])
                            self.E1values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                            E1_nonempty = True
                        elif self.specialeventstype[i] == 1:
                            self.E2timex.append(self.timex[self.specialevents[i]])
                            self.E2values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                            E2_nonempty = True
                        elif self.specialeventstype[i] == 2:
                            self.E3timex.append(self.timex[self.specialevents[i]])
                            self.E3values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                            E3_nonempty = True
                        elif self.specialeventstype[i] == 3:
                            self.E4timex.append(self.timex[self.specialevents[i]])
                            self.E4values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                            E4_nonempty = True

                    self.l_eventtype1dots, = self.ax.plot(self.E1timex, self.E1values, color=self.EvalueColor[0], marker=self.EvalueMarker[0],markersize = self.EvalueMarkerSize[0],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[0],alpha = self.Evaluealpha[0],label=self.etypesf(0))
                    self.l_eventtype2dots, = self.ax.plot(self.E2timex, self.E2values, color=self.EvalueColor[1], marker=self.EvalueMarker[1],markersize = self.EvalueMarkerSize[1],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[1],alpha = self.Evaluealpha[1],label=self.etypesf(1))
                    self.l_eventtype3dots, = self.ax.plot(self.E3timex, self.E3values, color=self.EvalueColor[2], marker=self.EvalueMarker[2],markersize = self.EvalueMarkerSize[2],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[2],alpha = self.Evaluealpha[2],label=self.etypesf(2))
                    self.l_eventtype4dots, = self.ax.plot(self.E4timex, self.E4values, color=self.EvalueColor[3], marker=self.EvalueMarker[3],markersize = self.EvalueMarkerSize[3],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[3],alpha = self.Evaluealpha[3],label=self.etypesf(3))

                    if E1_nonempty:
                        handles.append(self.l_eventtype1dots)
                        labels.append(aw.arabicReshape(self.etypesf(0)))
                    if E2_nonempty:
                        handles.append(self.l_eventtype2dots)
                        labels.append(aw.arabicReshape(self.etypesf(1)))
                    if E3_nonempty:
                        handles.append(self.l_eventtype3dots)
                        labels.append(aw.arabicReshape(self.etypesf(2)))
                    if E4_nonempty:
                        handles.append(self.l_eventtype4dots)
                        labels.append(aw.arabicReshape(self.etypesf(3)))

                #if recorder on
                if self.flagon:
                    #update to last event
                    if Nevents:
                        aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                        aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                    else:
                        aw.etypeComboBox.setCurrentIndex(0)
                        aw.valueEdit.setText("")
                    aw.eNumberSpinBox.setValue(Nevents)

            #update label colors
            for label in self.ax.xaxis.get_ticklabels():
                label.set_color(self.palette["xlabel"])
            for label in self.ax.yaxis.get_ticklabels():
                label.set_color(self.palette["ylabel"])
            if two_ax_mode:
                for label in self.delta_ax.yaxis.get_ticklabels():
                    label.set_color(self.palette["ylabel"])

            #write legend
            if self.legendloc:
                rcParams['path.effects'] = []
                prop = aw.mpl_fontproperties.copy()
                prop.set_size("x-small")
                if len(handles) > 3:
                    ncol = int(math.ceil(len(handles)/2.))
                else:
                    ncol = int(math.ceil(len(handles)))
                if two_ax_mode:
                    leg = self.delta_ax.legend(handles,labels,loc=self.legendloc,ncol=ncol,fancybox=True,prop=prop)
                else:
                    leg = self.ax.legend(handles,labels,loc=self.legendloc,ncol=ncol,fancybox=True,prop=prop)
                if aw.qmc.graphstyle == 1:
                    leg.legendPatch.set_path_effects([PathEffects.withSimplePatchShadow(offset_xy=(8,-8),patch_alpha=0.9, shadow_rgbFace=(0.25,0.25,0.25))])

            # we create here the project line plots to have the accurate time axis after CHARGE
            self.l_BTprojection, = self.ax.plot([], [],color = self.palette["bt"],
                                            linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
            self.l_ETprojection, = self.ax.plot([], [],color = self.palette["et"],
                                            linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])

            ############  ready to plot ############
            #self.fig.canvas.draw() # done by updateBackground()
            self.updateBackground() # update bitlblit backgrounds
            #######################################

            # if designer ON
            if self.designerflag:
                if self.background:
                    self.ax.lines = self.ax.lines[2:]
                if len(self.timex):
                    self.xaxistosm()
                    self.redrawdesigner()

        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()    
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " redraw() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    # adjusts height of annotations
    #supporting function for self.redraw() used to find best height of annotations in graph to avoid annotating over previous annotations (unreadable) when close to each other
    def findtextgap(self,ystep_down,ystep_up,height1,height2,dd=0):
        if dd <= 0:
            d = aw.qmc.ylimit - aw.qmc.ylimit_min
        else:
            d = dd
        init = int(d/15.0)
        gap = int(d/20.0)
        maxx = int(d/3.6)
        for i in range(init,maxx):
            if abs((height1 + ystep_up) - (height2+i)) > gap:
                break      
        for j in range(init,maxx):
            if abs((height1 - ystep_down) - (height2 - j)) > gap:
                break
        return j,i  #return height of arm

    # used to convert time from int seconds to string (like in the LCD clock timer). input int, output string xx:xx
    def stringfromseconds(self, seconds, leadingzero=True):
        if seconds >= 0:
            if leadingzero:
                return "%02d:%02d"% divmod(seconds, 60)
            else:
                return ("%2d:%02d"% divmod(seconds, 60)).strip()
        else:
            #usually the timex[timeindex[0]] is alreday taken away in seconds before calling stringfromseconds()
            negtime = abs(seconds)
            return "-%02d:%02d"% divmod(negtime, 60)

    #Converts a string into a seconds integer. Use for example to interpret times from Roaster Properties Dlg inputs
    #acepted formats: "00:00","-00:00"
    def stringtoseconds(self, string,errormsg=False):
        timeparts = string.split(":")
        if len(timeparts) != 2:
            if errormsg:
                aw.sendmessage(QApplication.translate("Message","Time format error encountered", None, QApplication.UnicodeUTF8))
            return -1
        else:
            if timeparts[0][0] != "-":  #if number is positive
                seconds = int(timeparts[1])
                seconds += int(timeparts[0])*60
                return seconds
            else:
                seconds = int(timeparts[0])*60
                seconds -= int(timeparts[1])
                return seconds    #return negative number

    def fromFtoC(self,Ffloat):
        if Ffloat != None:
            return (Ffloat-32.0)*(5.0/9.0)
        else:
            return None

    def fromCtoF(self,CFloat):
        if CFloat != None:
            return (CFloat*9.0/5.0)+32.0
        else:
            return None

    #sets the graph display in Fahrenheit mode
    def fahrenheitMode(self):
        # just set it to the defaults to avoid strange conversion issues
        self.ylimit = 600
        self.ylimit_min = 0
        self.ygrid = 100
        self.zlimit = 50
        self.zlimit_min = 0
        self.zgrid = 10
        if self.mode == "C":
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(self.fromCtoF(self.phases[i])))
                self.phases_espresso[i] = int(round(self.fromCtoF(self.phases_espresso[i])))
                self.phases_filter[i] = int(round(self.fromCtoF(self.phases_filter[i])))
            self.ETtarget = int(round(self.fromCtoF(self.ETtarget)))
            self.ET2target = int(round(self.fromCtoF(self.ET2target)))
            self.BTtarget = int(round(self.fromCtoF(self.BTtarget)))
            self.BT2target = int(round(self.fromCtoF(self.BT2target)))
            # conv Arduino mode
            if aw:
                aw.arduino.conv2fahrenheit()
        self.ax.set_ylabel("F",size=16,color = self.palette["ylabel"]) #Write "F" on Y axis
        self.mode = "F"
        if aw: # during initialization aw is still None!
            aw.FahrenheitAction.setDisabled(True)
            aw.CelsiusAction.setEnabled(True)
            aw.ConvertToFahrenheitAction.setDisabled(True)
            aw.ConvertToCelsiusAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_F_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_F_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_F_default

    #sets the graph display in Celsius mode
    def celsiusMode(self):
        self.ylimit = 350
        self.ylimit_min = 0
        self.ygrid = 50
        self.zlimit = 50
        self.zlimit_min = 0
        self.zgrid = 10
        if self.mode == "F":
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(self.fromFtoC(self.phases[i])))
                self.phases_espresso[i] = int(round(self.fromFtoC(self.phases_espresso[i])))
                self.phases_filter[i] = int(round(self.fromFtoC(self.phases_filter[i])))
            self.ETtarget = int(round(self.fromFtoC(self.ETtarget)))
            self.ET2target = int(round(self.fromFtoC(self.ET2target)))
            self.BTtarget = int(round(self.fromFtoC(self.BTtarget)))
            self.BT2target = int(round(self.fromFtoC(self.BT2target)))
            # conv Arduino mode
            if aw:
                aw.arduino.conv2celsius()
        self.ax.set_ylabel("C",size=16,color = self.palette["ylabel"]) #Write "C" on Y axis
        self.mode = "C"
        if aw: # during initialization aw is still None
            aw.CelsiusAction.setDisabled(True)
            aw.FahrenheitAction.setEnabled(True)
            aw.ConvertToCelsiusAction.setDisabled(True)
            aw.ConvertToFahrenheitAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_C_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_C_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_C_default

    def fahrenheitModeRedraw(self):
        self.fahrenheitMode()
        self.redraw()

    def celsiusModeRedraw(self):
        self.celsiusMode()
        self.redraw()

    #converts a loaded profile to a different temperature scale. t input is the requested mode (F or C).
    def convertTemperature(self,t):
        #verify there is a loaded profile
        profilelength = len(self.timex)
        if profilelength > 0:
            if t == "F":
                string = QApplication.translate("Message", "Convert profile data to Fahrenheit?",None, QApplication.UnicodeUTF8)
                reply = QMessageBox.question(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),string,
                        QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                elif reply == QMessageBox.Yes:
                    if self.mode == "C":
                        aw.CelsiusAction.setDisabled(True)
                        aw.FahrenheitAction.setEnabled(True)
                        aw.ConvertToCelsiusAction.setDisabled(True)
                        aw.ConvertToFahrenheitAction.setEnabled(True)
                        for i in range(profilelength):
                            self.temp1[i] = self.fromCtoF(self.temp1[i])    #ET
                            self.temp2[i] = self.fromCtoF(self.temp2[i])    #BT
                            if len(self.delta1):
                                self.delta1[i] = self.fromCtoF(self.delta1[i])  #Delta ET
                            if len(self.delta2):
                                self.delta2[i] = self.fromCtoF(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)   
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        aw.qmc.extratemp1[e][i] = self.fromCtoF(aw.qmc.extratemp1[e][i])
                                        aw.qmc.extratemp2[e][i] = self.fromCtoF(aw.qmc.extratemp2[e][i])
                                    except:
                                        pass

                        self.ambientTemp = self.fromCtoF(self.ambientTemp)  #ambient temperature

                        #prevents accidentally deleting a modified profile. 
                        self.safesaveflag = True

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = self.fromCtoF(self.temp1B[i])
                            self.temp2B[i] = self.fromCtoF(self.temp2B[i])

                        self.fahrenheitMode()
                        aw.sendmessage(QApplication.translate("Message","Profile changed to Fahrenheit", None, QApplication.UnicodeUTF8))

                    else:
                        QMessageBox.information(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),
                                                QApplication.translate("Message", "Unable to comply. You already are in Fahrenheit", None, QApplication.UnicodeUTF8))
                        aw.sendmessage(QApplication.translate("Message","Profile not changed", None, QApplication.UnicodeUTF8))
                        return

            elif t == "C":
                string = QApplication.translate("Message", "Convert profile data to Celsius?",None, QApplication.UnicodeUTF8)
                reply = QMessageBox.question(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),string,
                        QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                elif reply == QMessageBox.Yes:
                    if self.mode == "F":    
                        aw.ConvertToFahrenheitAction.setDisabled(True)
                        aw.ConvertToCelsiusAction.setEnabled(True) 
                        aw.FahrenheitAction.setDisabled(True)
                        aw.CelsiusAction.setEnabled(True)   
                        for i in range(profilelength):
                            self.temp1[i] = self.fromFtoC(self.temp1[i])    #ET
                            self.temp2[i] = self.fromFtoC(self.temp2[i])    #BT
                            if self.device != 18:
                                if len(self.delta1):
                                    self.delta1[i] = self.fromFtoC(self.delta1[i])  #Delta ET
                                if len(self.delta2):
                                    self.delta2[i] = self.fromFtoC(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    aw.qmc.extratemp1[e][i] = self.fromFtoC(aw.qmc.extratemp1[e][i])
                                    aw.qmc.extratemp2[e][i] = self.fromFtoC(aw.qmc.extratemp2[e][i])

                        self.ambientTemp = self.fromFtoC(self.ambientTemp)  #ambient temperature

                        for i in range(len(self.timeB)):
                            self.temp1B[i] = self.fromFtoC(self.temp1B[i]) #ET B
                            self.temp2B[i] = self.fromFtoC(self.temp2B[i]) #BT B

                    else:
                        QMessageBox.information(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),
                                                QApplication.translate("Message", "Unable to comply. You already are in Celsius",None, QApplication.UnicodeUTF8))
                        aw.sendmessage(QApplication.translate("Message","Profile not changed", None, QApplication.UnicodeUTF8))
                        return

                    self.celsiusMode()
                    aw.sendmessage(QApplication.translate("Message","Profile changed to Celsius", None, QApplication.UnicodeUTF8))

            self.redraw(recomputeAllDeltas=True,smooth=True)

        else:
            QMessageBox.information(self,QApplication.translate("Message", "Convert Profile Scale",None, QApplication.UnicodeUTF8),
                                          QApplication.translate("Message", "No profile data found",None, QApplication.UnicodeUTF8))

    #selects color mode: input 1=color mode; input 2=black and white mode (printing); input 3 = customize colors
    def changeGColor(self,color):
        #COLOR (option 1) Default
        palette1 = {"background":'white',"grid":'green',"ylabel":'black',"xlabel":'black',"title":'black',"rect1":'green',
                        "rect2":'orange',"rect3":'#996633',"rect4":'lightblue',"et":'red',"bt":'#00007f',"deltaet":'orange',
                        "deltabt":'blue',"markers":'black',"text":'black',"watermarks":'yellow',"Cline":'blue'}

        #BLACK & WHITE (option 2) best for printing
        palette2 = {"background":'white',"grid":'grey',"ylabel":'black',"xlabel":'black',"title":'black',"rect1":'lightgrey',
                   "rect2":'darkgrey',"rect3":'grey',"rect4":'lightgrey',"et":'black',"bt":'black',"deltaet":'grey',
                   "deltabt":'grey',"markers":'grey',"text":'black',"watermarks":'lightgrey',"Cline":'grey'}

        #load selected dictionary
        if color == 1:
            aw.sendmessage(QApplication.translate("Message","Colors set to defaults", None, QApplication.UnicodeUTF8))
            for key in list(palette1.keys()):
                self.palette[key] = palette1[key]
            
        if color == 2:
            aw.sendmessage(QApplication.translate("Message","Colors set to grey", None, QApplication.UnicodeUTF8))
            for key in list(palette1.keys()):
                self.palette[key] = palette2[key]
                
        if color == 3:
            dialog = graphColorDlg(self)
            if dialog.exec_():
                self.palette["background"] = str(dialog.backgroundLabel.text())
                self.palette["grid"] = str(dialog.gridLabel.text())
                self.palette["ylabel"] = str(dialog.yLabel.text())
                self.palette["xlabel"] = str(dialog.xLabel.text())
                self.palette["title"] = str(dialog.titleLabel.text())
                self.palette["rect1"] = str(dialog.rect1Label.text())
                self.palette["rect2"] = str(dialog.rect2Label.text())
                self.palette["rect3"] = str(dialog.rect3Label.text())
                self.palette["rect4"] = str(dialog.rect4Label.text())
                self.palette["et"] = str(dialog.metLabel.text())
                self.palette["bt"] = str(dialog.btLabel.text())
                self.palette["deltaet"] = str(dialog.deltametLabel.text())
                self.palette["deltabt"] = str(dialog.deltabtLabel.text())
                self.palette["markers"] = str(dialog.markersLabel.text())
                self.palette["text"] = str(dialog.textLabel.text())
                self.palette["watermarks"] = str(dialog.watermarksLabel.text())
                self.palette["Cline"] = str(dialog.ClineLabel.text())

        #update screen with new colors
        self.fig.canvas.redraw()

    #draws a polar star graph to score cupping. It does not delete any profile data.
    def flavorchart(self):

        pi = math.pi
        self.fig.clf()
        #create a new name ax1 instead of ax (ax is used when plotting profiles)

        self.ax1 = self.fig.add_subplot(111,projection='polar', axisbg=self.backcolor) #) radar green axisbg='#d5de9c'
        self.ax1.set_aspect(self.flavoraspect)

        #find number of divisions
        nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])

        g_angle = numpy.arange(self.flavorstartangle,(360.+self.flavorstartangle),(360./nflavors))  #angles in degree
        self.ax1.set_thetagrids(g_angle)
        self.ax1.set_rmax(1.)
        self.ax1.set_autoscale_on(False)
        self.ax1.grid(True,linewidth=1.,color='green', linestyle = "-",alpha=.3)
        # hack to make flavor labels visible also on top and bottom
        self.ax1.set_xlabel(" -\n ", alpha=0.0)
        self.ax1.set_title(" -\n ", alpha=0.0)

        #create water marks 6-7 anf 8-9
        self.ax1.bar(.1, .1, width=2.*pi, bottom=.6,color="green",linewidth=0.,alpha = .1)
        self.ax1.bar(.1, .1, width=2.*pi, bottom=.8,color="green",linewidth=0.,alpha = .1)

        #delete degrees ticks to anotate flavor characteristics 
        for tick in self.ax1.xaxis.get_major_ticks():
            tick.label1On = False

        #rename yaxis 
        locs = self.ax1.get_yticks()
        labels = []
        for i in range(len(locs)):
            stringlabel = str(locs[i]*10.)
            labels.append(stringlabel)
        self.ax1.set_yticklabels(labels,color=self.palette["xlabel"])

        step = 2.*pi/nflavors
        angles = [math.radians(self.flavorstartangle)]   #angles in radians
        for i in range(nflavors-1): angles.append(angles[-1] + step)

        #To close circle we need one more element. angle and values need same dimension in order to plot.
        plotf = self.flavors[:]
        plotf.append(self.flavors[0])
        #normalize flavor values to 0-1 range
        for i in range(len(plotf)):
            plotf[i] /= 10.
        angles.append(angles[-1]+step)
        
        #anotate labels
        for i in range(len(self.flavorlabels)):
            if angles[i] > 2.*pi or angles[i] < 0.:
                _,angles[i] = divmod(angles[i],(2.*pi))
            if angles[i] <= (pi/2.) or angles[i] >= (1.5*pi): #if < 90 or smaller than 270 degress
                ha = "left"
            else:
                ha = "right"
            self.ax1.annotate(aw.arabicReshape(self.flavorlabels[i]) + " = " + str("%.2f"%self.flavors[i]),xy =(angles[i],.9),
                              xytext=(angles[i],1.1),horizontalalignment=ha,verticalalignment='bottom')

        score = 0.
        for i in range(nflavors):
            score += self.flavors[i]
        score /= (nflavors)
        score *= 10.

        txt = "%.2f" %score
        self.ax1.text(0.,0.,txt,fontsize="x-large",fontproperties=aw.mpl_fontproperties,color="blue",horizontalalignment="center",bbox={"facecolor":"yellow", "alpha":0.3, "pad":10})

        #add background to plot if found
        if self.background:
            if self.flavorbackgroundflag:
                backgroundplotf = self.backgroundFlavors[:]
                backgroundplotf.append(self.backgroundFlavors[0])
                #normalize flavor values to 0-1 range
                for i in range(len(backgroundplotf)):
                    backgroundplotf[i] /= 10.

                self.ax1.plot(angles,backgroundplotf,color="orange",marker="o",alpha=.5)
                #needs matplotlib 1.0.0+
                if mpl.__version__.split(".")[0] == '1':
                    self.ax1.fill_between(angles,0,backgroundplotf, facecolor="yellow", alpha=0.1, interpolate=True)

        #add to plot
        self.ax1.plot(angles,plotf,color="blue",marker="o")
        
        #needs matplotlib 1.0.0+
        if mpl.__version__.split(".")[0] == '1':
            self.ax1.fill_between(angles,0,plotf, facecolor='green', alpha=0.1, interpolate=True)

        self.fig.canvas.draw()

    def OnMonitor(self):
        try:
            try:
                appnope.nope()
            except:
                pass
            try:
                a = aw.qmc.extrabuttonactions[0]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.extrabuttonactionstrings[0])
            except:
                pass
            aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
            aw.qmc.clearMeasurements()
            self.timeclock.start()   #set time to the current computer time
            self.flagon = True
            if self.designerflag: return
            aw.sendmessage(QApplication.translate("Message","Scope monitoring...", None, QApplication.UnicodeUTF8))
            #disable RESET button:
            aw.button_7.setEnabled(False)
            aw.button_7.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
            aw.button_1.setStyleSheet(aw.pushbuttonstyles["ON"])
            aw.button_1.setText(QApplication.translate("Button", "OFF",None, QApplication.UnicodeUTF8)) # text means click to turn OFF (it is ON)
            aw.button_1.setToolTip(QApplication.translate("Tooltip", "Stop monitoring", None, QApplication.UnicodeUTF8))
            aw.button_2.setEnabled(True) # ensure that the START button is enabled
            aw.showLCDs()
            aw.showSliders()
            aw.disableEditMenus()
            if aw.extraeventsbuttonsflag:
                aw.update_extraeventbuttons_visibility()
                aw.showExtraButtons()
            aw.arduino.activateONOFFeasySV(aw.arduino.svButtons)
            aw.arduino.activateSVSlider(aw.arduino.svSlider)
            self.threadserver.createSampleThread()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " OffMonitor() %1").arg(str(ex)),exc_tb.tb_lineno)

    def OffMonitor(self):
        try:
            # first activate "Stopping Mode" to ensure that sample() is not reseting the timer now (independent of the flagstart state)
            if self.HUDflag:
                self.toggleHUD()
            # stop Recorder if still running
            if self.flagstart:
                self.OffRecorder()
            self.flagon = False
            # now wait until the current sampling round is done
            while self.flagsampling:
                libtime.sleep(.01)
            # clear data from monitoring-only mode
            if len(self.timex) == 1:
                aw.qmc.clearMeasurements()
            self.disconnectProbes()
            #enable RESET button:
            aw.button_7.setStyleSheet(aw.pushbuttonstyles["RESET"])
            aw.button_7.setEnabled(True)
            aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
            aw.button_1.setToolTip(QApplication.translate("Tooltip", "Start monitoring", None, QApplication.UnicodeUTF8))
            aw.sendmessage(QApplication.translate("Message","Scope stopped", None, QApplication.UnicodeUTF8))
            aw.button_1.setText(QApplication.translate("Button", "ON",None, QApplication.UnicodeUTF8)) # text means click to turn OFF (it is ON)
            # reset time LCD color to the default (might have been changed to red due to long cooling!)
            aw.hideLCDs()
            # reset WebLCDs
            if aw.qmc.LCDdecimalplaces:
                resLCD = "-.-"
            else:
                resLCD = "--"
            if aw.WebLCDs: 
                self.updateWebLCDs(bt=resLCD,et=resLCD)
            if aw.largeLCDs_dialog:
                self.updateLargeLCDs(bt=resLCD,et=resLCD)
            aw.hideSliders()
            aw.hideExtraButtons()
            aw.enableEditMenus()
            aw.arduino.activateONOFFeasySV(False)
            aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
            #appnope.nap()
            try:
                a = aw.qmc.extrabuttonactions[1]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.extrabuttonactionstrings[1])
            except:
                pass
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " OffMonitor() %1").arg(str(ex)),exc_tb.tb_lineno)

    # close serial port, Phidgets and Yocto ports
    def disconnectProbesFromSerialDevice(self,ser):
        # close main serial port
        try:
            ser.closeport()
        except:
            pass
        # disconnect phidgets
        if ser.PhidgetTemperatureSensor:
            try:
                ser.PhidgetTemperatureSensorAttached = False
                ser.PhidgetTemperatureSensor.closePhidget()
                ser.PhidgetTemperatureSensor = None
            except:
                pass
        if ser.PhidgetIRSensor:
            try:
                ser.PhidgetIRSensorSensorAttached = False
                ser.PhidgetIRSensor.closePhidget()
                ser.PhidgetIRSensor = None
            except:
                pass
        if ser.PhidgetBridgeSensor:
            try:
                ser.PhidgetBridgeSensorAttached = False
                ser.PhidgetBridgeSensor.closePhidget()
                ser.PhidgetBridgeSensor = None
            except:
                pass
        if ser.PhidgetIO:
            try:
                ser.PhidgetIOAttached = False
                ser.PhidgetIO.closePhidget()
                ser.PhidgetIO = None
            except:
                pass
        if ser.PhidgetManager:
            ser.PhidgetManager.closeManager()
            ser.PhidgetManager = None
        if ser.YOCTOsensor:
            try:
                YAPI.UnregisterHub("usb")
            except:
                pass
            ser.YOCTOsensor = None
            ser.YOCTOchan1 = None
            ser.YOCTOchan2 = None

    def disconnectProbes(self):
        # close ports of main device
        self.disconnectProbesFromSerialDevice(aw.ser)
        # close serial port of Modbus device
        aw.modbus.disconnect()
        # close ports of extra devices
        for i in range(len(aw.extraser)):
            self.disconnectProbesFromSerialDevice(aw.extraser[i])

    #Turns ON/OFF flag self.flagon to read and print values. Called from push button_1.
    def ToggleMonitor(self):
        #turn ON
        if not self.flagon:
            aw.soundpop()
            if self.timex != []:
                aw.qmc.reset(True,False)
            self.OnMonitor()
        #turn OFF
        else:
            aw.soundpop()
            self.OffMonitor()

    def OnRecorder(self):
        try:
            # start Monitor if not yet running
            if not self.flagon:
                self.OnMonitor()
            self.flagstart = True
            aw.qmc.fig.suptitle("")
            aw.qmc.updateDeltaSamples()
            aw.disableSaveActions()
            aw.sendmessage(QApplication.translate("Message","Scope recording...", None, QApplication.UnicodeUTF8))
            aw.button_2.setEnabled(False)
            aw.button_2.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
            aw.button_1.setToolTip(QApplication.translate("Tooltip", "Stop recording", None, QApplication.UnicodeUTF8))
            aw.button_1.setEnabled(True) # ensure that the OFF button is enabled
            #disable RESET button:
            aw.button_7.setEnabled(False)
            aw.button_7.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
            aw.button_18.setEnabled(True)
            aw.button_18.setStyleSheet(aw.pushbuttonstyles["HUD_OFF"])
            self.updateLCDtime()
            aw.lowerbuttondialog.setVisible(True)
            aw.applyStandardButtonVisibility()
            if aw.qmc.phasesLCDflag:
                aw.phasesLCDs.show()
            aw.update_minieventline_visibility()
            aw.qmc.ax.set_xlabel("")
            aw.qmc.ax.set_ylabel("")
            aw.qmc.ax.set_title("")
            if aw.qmc.delta_ax:
                aw.qmc.delta_ax.set_ylabel("")
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " OffMonitor() %1").arg(str(ex)),exc_tb.tb_lineno)

    def OffRecorder(self):
        try:
            aw.enableSaveActions()
            self.flagstart = False
            aw.button_2.setStyleSheet(aw.pushbuttonstyles["STOP"])
            aw.button_2.setEnabled(True)   
            #enable RESET button:
            aw.button_7.setStyleSheet(aw.pushbuttonstyles["RESET"]) 
            aw.button_7.setEnabled(True)
            aw.button_18.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
            aw.button_18.setEnabled(False)
            self.updateLCDtime()
            self.redraw(smooth=True)
            #prevents accidentally deleting a modified profile.
            if len(self.timex) > 2:
                self.safesaveflag = True
            aw.sendmessage(QApplication.translate("Message","Scope recording stopped", None, QApplication.UnicodeUTF8))
            aw.button_2.setText(QApplication.translate("Button", "START",None, QApplication.UnicodeUTF8))
            aw.lowerbuttondialog.setVisible(False)
            aw.phasesLCDs.hide()
            aw.hideEventsMinieditor()
            if aw.qmc.autosaveflag and aw.qmc.autosavepath:
                aw.automaticsave()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " OffMonitor() %1").arg(str(ex)),exc_tb.tb_lineno)

    #Turns START/STOP flag self.flagon to read and plot. Called from push button_2.
    def ToggleRecorder(self):
        #turn START
        if not self.flagstart:
            aw.soundpop()
            if self.flagon and len(self.timex) == 1:
                # we are already in monitoring mode, we just clear this first measurement and go
                aw.qmc.clearMeasurements(andLCDs=False)
            elif self.timex != []: # there is a profile loaded, we have to reset
                aw.qmc.reset(True,False)
            self.OnRecorder()
        #turn STOP
        else:
            aw.soundpop()
            self.OffRecorder()

    #Records charge (put beans in) marker. called from push button 'Charge'
    def markCharge(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                try:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    if self.device == 18: #manual mode
                        tx,et,bt = aw.ser.NONE()
                        if bt != 1 and et != -1:  #cancel
                            self.drawmanual(et,bt,tx)
                            self.timeindex[0] = len(self.timex)-1
                        else:
                            return
                    else:
                        if self.autoChargeIdx:
                            self.timeindex[0] = self.autoChargeIdx
                        else:
                            if len(self.timex) > 0:
                                self.timeindex[0] = len(self.timex)-1
                            else:
                                message = QApplication.translate("Message","Not enough variables collected yet. Try again in a few seconds", None, QApplication.UnicodeUTF8)
                        if self.device == 19 and aw.arduino.pidOnCHARGE and not aw.arduino.pidActive: # Arduino/TC4
                            aw.arduino.pidOn()
                    self.xaxistosm() # need to fix uneven x-axis labels like -0:13
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation", "CHARGE 00:00", None, QApplication.UnicodeUTF8))
                    t2 = self.temp2[self.timeindex[0]]
                    tx = self.timex[self.timeindex[0]]
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,t2,t2,d)
                    self.annotate(t2,st1,tx,t2,self.ystep_up,self.ystep_down)
                    # mark active slider values that are not zero                   
                    for slidernr in range(4):
                        if aw.eventslidervisibilities[slidernr]:
                            if slidernr == 0:
                                slidervalue = aw.slider1.value()
                            elif slidernr == 1:
                                slidervalue = aw.slider2.value()
                            elif slidernr == 2:
                                slidervalue = aw.slider3.value()
                            elif slidernr == 3:
                                slidervalue = aw.slider4.value()
                            if slidervalue != 0:
                                value = aw.float2float((slidervalue + 10.0) / 10.0)
                                aw.qmc.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value)
                except:
                    pass
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markCharge() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            try:
                a = aw.qmc.buttonactions[0]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[0])
            except:
                pass
            aw.button_8.setDisabled(True)
            aw.button_8.setFlat(True)
            try:
                if aw.qmc.LCDdecimalplaces:
                    fmt = "%.1f"
                else:
                    fmt = "%.0f"
                bt = fmt%self.temp2[self.timeindex[0]] + aw.qmc.mode
                message = QApplication.translate("Message","Roast time starts now 00:00 BT = %1",None, QApplication.UnicodeUTF8).arg(bt)
                aw.sendmessage(message) 
            except:
                pass

    # called from sample() and marks the autodetected TP visually on the graph
    def markTP(self):
        try:
            self.samplingsemaphore.acquire(1)
            if self.flagstart and self.markTPflag:
                if aw.qmc.TPalarmtimeindex and self.timeindex[0] != -1 and len(self.timex) > aw.qmc.TPalarmtimeindex:
                    st = self.stringfromseconds(self.timex[aw.qmc.TPalarmtimeindex]-self.timex[self.timeindex[0]])
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","TP %1", None, QApplication.UnicodeUTF8).arg(st))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[aw.qmc.TPalarmtimeindex],d)
                    self.annotate(self.temp2[aw.qmc.TPalarmtimeindex],st1,self.timex[aw.qmc.TPalarmtimeindex],self.temp2[aw.qmc.TPalarmtimeindex],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
                    st2 = "%.1f "%self.temp2[aw.qmc.TPalarmtimeindex] + self.mode
                    message = QApplication.translate("Message","[TP] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st).arg(st2)
                    #set message at bottom
                    aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markTP() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    def markDryEnd(self):
        try:
            self.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    if self.device != 18:
                        self.timeindex[1] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[1] = len(self.timex)-1
                        else:
                            return
                    if aw.qmc.phasesbuttonflag:
                        self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
                    #calculate time elapsed since charge time
                    st = self.stringfromseconds(self.timex[self.timeindex[1]]-self.timex[self.timeindex[0]])
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DE %1", None, QApplication.UnicodeUTF8).arg(st))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[1]],d)
                    self.annotate(self.temp2[self.timeindex[1]],st1,self.timex[self.timeindex[1]],self.temp2[self.timeindex[1]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need

            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markDryEnd() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:                
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.button_19.setDisabled(True) # deactivate DRY button
            aw.button_19.setFlat(True)
            aw.button_8.setDisabled(True) # also deactivate CHARGE button
            aw.button_8.setFlat(True)
            try:
                a = aw.qmc.buttonactions[1]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[1])
            except:
                pass
            st = self.stringfromseconds(self.timex[self.timeindex[1]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[1]] + self.mode
            message = QApplication.translate("Message","[DRY END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st).arg(st2)
            #set message at bottom
            aw.sendmessage(message)

    #record 1C start markers of BT. called from push button_3 of application window
    def mark1Cstart(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    # record 1Cs only if Charge mark has been done
                    if self.device != 18:                
                        self.timeindex[2] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[2] = len(self.timex)-1
                        else:
                            return
                    if aw.qmc.phasesbuttonflag:
                        self.phases[2] = int(round(self.temp2[self.timeindex[2]]))
                    #calculate time elapsed since charge time
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCs %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[2]]-self.timex[self.timeindex[0]])))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    if self.timeindex[1]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[2]],d)
                    else:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[2]],d)
                    self.annotate(self.temp2[self.timeindex[2]],st1,self.timex[self.timeindex[2]],self.temp2[self.timeindex[2]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark1Cstart() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.flagalignFCs:
                aw.qmc.timealign(redraw=True,recompute=False,FCs=True) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.button_3.setDisabled(True) # deactivate FCs button
            aw.button_3.setFlat(True)
            aw.button_8.setDisabled(True) # also deactivate CHARGE button
            aw.button_8.setFlat(True)
            aw.button_19.setDisabled(True) # also deactivate DRY button
            aw.button_19.setFlat(True)
            try:
                a = aw.qmc.buttonactions[2]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[2])
            except:
                pass
            st1 = self.stringfromseconds(self.timex[self.timeindex[2]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[2]] + self.mode
            message = QApplication.translate("Message","[FC START] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
            aw.sendmessage(message)            
            

    #record 1C end markers of BT. called from button_4 of application window
    def mark1Cend(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    if self.device != 18:
                        self.timeindex[3] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[3] = len(self.timex)-1
                        else:
                            return
                    #calculate time elapsed since charge time
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCe %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[3]]-self.timex[self.timeindex[0]])))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[3]],d)
                    self.annotate(self.temp2[self.timeindex[3]],st1,self.timex[self.timeindex[3]],self.temp2[self.timeindex[3]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark1Cend() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.button_4.setDisabled(True) # deactivate FCe button
            aw.button_4.setFlat(True)
            aw.button_8.setDisabled(True) # also deactivate CHARGE button
            aw.button_8.setFlat(True)
            aw.button_19.setDisabled(True) # also deactivate DRY button
            aw.button_19.setFlat(True)
            aw.button_3.setDisabled(True) # also deactivate FCs button
            aw.button_3.setFlat(True)
            try:
                a = aw.qmc.buttonactions[3]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[3])
            except:
                pass
            st1 = self.stringfromseconds(self.timex[self.timeindex[3]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[3]] + self.mode
            message = QApplication.translate("Message","[FC END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
            aw.sendmessage(message)

    #record 2C start markers of BT. Called from button_5 of application window
    def mark2Cstart(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile. 
                    self.safesaveflag = True
                    if self.device != 18:
                        self.timeindex[4] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[4] = len(self.timex)-1
                        else:
                            return
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCs %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[4]]-self.timex[self.timeindex[0]])))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    if self.timeindex[3]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[4]],d)
                    else:
                        self.ystep_down,self.ystep_up = self.findtextgap(0,0,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[4]],d)
                    self.annotate(self.temp2[self.timeindex[4]],st1,self.timex[self.timeindex[4]],self.temp2[self.timeindex[4]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark2Cstart() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.button_5.setDisabled(True) # deactivate SCs button
            aw.button_5.setFlat(True)
            aw.button_8.setDisabled(True) # also deactivate CHARGE button
            aw.button_8.setFlat(True)
            aw.button_19.setDisabled(True) # also deactivate DRY button
            aw.button_19.setFlat(True)
            aw.button_3.setDisabled(True) # also deactivate FCs button
            aw.button_3.setFlat(True)
            aw.button_4.setDisabled(True) # also deactivate FCe button
            aw.button_4.setFlat(True)
            try:
                a = aw.qmc.buttonactions[4]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[4])
            except:
                pass
            st1 = self.stringfromseconds(self.timex[self.timeindex[4]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[4]] + self.mode
            message = QApplication.translate("Message","[SC START] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
            aw.sendmessage(message)

    #record 2C end markers of BT. Called from button_6  of application window
    def mark2Cend(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    if self.device != 18:
                        self.timeindex[5] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[5] = len(self.timex)-1
                        else:
                            return
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCe %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[5]]-self.timex[self.timeindex[0]])))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[5]],d)
                    self.annotate(self.temp2[self.timeindex[5]],st1,self.timex[self.timeindex[5]],self.temp2[self.timeindex[5]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark2Cend() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)  
        if self.flagstart:                      
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.button_6.setDisabled(True) # deactivate SCe button
            aw.button_6.setFlat(True)
            aw.button_8.setDisabled(True) # also deactivate CHARGE button
            aw.button_8.setFlat(True)
            aw.button_19.setDisabled(True) # also deactivate DRY button
            aw.button_19.setFlat(True)
            aw.button_3.setDisabled(True) # also deactivate FCs button
            aw.button_3.setFlat(True)
            aw.button_4.setDisabled(True) # also deactivate FCe button
            aw.button_4.setFlat(True)
            aw.button_5.setDisabled(True) # also deactivate SCs button
            aw.button_5.setFlat(True)
            try:
                a = aw.qmc.buttonactions[5]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[5])
            except:
                pass
            st1 = self.stringfromseconds(self.timex[self.timeindex[5]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[5]] + self.mode
            message = QApplication.translate("Message","[SC END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
            aw.sendmessage(message)

    #record end of roast (drop of beans). Called from push button 'Drop'
    def markDrop(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    if self.device != 18:
                        if self.autoDropIdx:
                            self.timeindex[6] = self.autoDropIdx
                        else:
                            self.timeindex[6] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[6] = len(self.timex)-1
                        else:
                            return
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DROP %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]])))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    if self.timeindex[5]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[5]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[4]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[3]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[2]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[1]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[6]],d)
                    self.annotate(self.temp2[self.timeindex[6]],st1,self.timex[self.timeindex[6]],self.temp2[self.timeindex[6]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
                    try:
                        # update ambient temperature if a ambient temperature source is configured and no value yet established
                        if aw.qmc.ambientTemp == 0.0:
                            aw.qmc.updateAmbientTemp()
                    except:
                        pass
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markDrop() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            try:
                aw.button_9.setDisabled(True) # deactivate DROP button
                aw.button_9.setFlat(True)
                aw.button_8.setDisabled(True) # also deactivate CHARGE button
                aw.button_8.setFlat(True)
                aw.button_19.setDisabled(True) # also deactivate DRY button
                aw.button_19.setFlat(True)
                aw.button_3.setDisabled(True) # also deactivate FCs button
                aw.button_3.setFlat(True)
                aw.button_4.setDisabled(True) # also deactivate FCe button
                aw.button_4.setFlat(True)
                aw.button_5.setDisabled(True) # also deactivate SCs button
                aw.button_5.setFlat(True)
                aw.button_6.setDisabled(True) # also deactivate SCe button
                aw.button_6.setFlat(True)
            except:
                pass
            try:
                a = aw.qmc.buttonactions[6]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[6])
            except:
                pass
            st1 = self.stringfromseconds(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[6]] + self.mode
            message = QApplication.translate("Message","Roast ended at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
            aw.sendmessage(message)

    def markCoolEnd(self):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    if self.device != 18:
                        self.timeindex[7] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[7] = len(self.timex)-1
                        else:
                            return
                    #calculate time elapsed since charge time
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","CE %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[7]] - self.timex[self.timeindex[0]])))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[6]],self.temp2[self.timeindex[7]],d)
                    self.annotate(self.temp2[self.timeindex[7]],st1,self.timex[self.timeindex[7]],self.temp2[self.timeindex[7]],self.ystep_up,self.ystep_down)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markCoolEnd() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.button_20.setDisabled(True) # deactivate COOL button
            aw.button_20.setFlat(True)
            aw.button_8.setDisabled(True) # also deactivate CHARGE button
            aw.button_8.setFlat(True)
            aw.button_19.setDisabled(True) # also deactivate DRY button
            aw.button_19.setFlat(True)
            aw.button_3.setDisabled(True) # also deactivate FCs button
            aw.button_3.setFlat(True)
            aw.button_4.setDisabled(True) # also deactivate FCe button
            aw.button_4.setFlat(True)
            aw.button_5.setDisabled(True) # also deactivate SCs button
            aw.button_5.setFlat(True)
            aw.button_6.setDisabled(True) # also deactivate SCe button
            aw.button_6.setFlat(True)
            aw.button_9.setDisabled(True) # also deactivate DROP button
            aw.button_9.setFlat(True)
            try:
                a = aw.qmc.buttonactions[7]
                aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[7])
            except:
                pass
            st1 = self.stringfromseconds(self.timex[self.timeindex[7]]-self.timex[self.timeindex[0]])
            st2 = "%.1f "%self.temp2[self.timeindex[7]] + self.mode
            message = QApplication.translate("Message","[COOL END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
            #set message at bottom
            aw.sendmessage(message)

    def EventRecord(self,extraevent=None):
        try:
            if extraevent!=None:
                self.EventRecordAction(
                    extraevent=extraevent,
                    eventtype=aw.extraeventstypes[extraevent],
                    eventvalue=aw.extraeventsvalues[extraevent],
                    eventdescription=aw.extraeventsdescriptions[extraevent])
            else:
                self.EventRecordAction(extraevent=extraevent)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " EventRecord() %1").arg(str(e)),exc_tb.tb_lineno)

    #Marks location in graph of special events. For example change a fan setting.
    #Uses the position of the time index (variable self.timex) as location in time
    # extraevent is given when called from aw.recordextraevent() from an extra Event Button
    def EventRecordAction(self,extraevent=None,eventtype=None,eventvalue=None,eventdescription=""):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0 or self.device == 18:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True                    
                    Nevents = len(self.specialevents)
                    #if in manual mode record first the last point in self.timex[]
                    if self.device == 18:
                        tx,et,bt = aw.ser.NONE()
                        if bt != -1 or et != -1:
                            self.drawmanual(et,bt,tx)
                        else:
                            return
                    #i = index number of the event (current length of the time list)
                    i = len(self.timex)-1
                    # if Desciption, Type and Value of the new event equals the last recorded one, we do not record this again!
                    if not(self.specialeventstype) or not(self.specialeventsvalue) or not(self.specialeventsStrings) or not(self.specialeventstype[-1] == eventtype and self.specialeventsvalue[-1] == eventvalue and self.specialeventsStrings[-1] == eventdescription):
                        self.specialevents.append(i)
                        self.specialeventstype.append(4)
                        self.specialeventsStrings.append(str(Nevents+1))
                        self.specialeventsvalue.append(0)
                        #if event was initiated by an Extra Event Button then change the type,value,and string 
                        if extraevent != None:
                            self.specialeventstype[-1] = eventtype
                            self.specialeventsvalue[-1] = eventvalue
                            self.specialeventsStrings[-1] = eventdescription
                        etype = self.specialeventstype[-1]
                        if etype == 0:
                            self.E1timex.append(self.timex[self.specialevents[-1]])
                            self.E1values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        elif etype == 1:
                            self.E2timex.append(self.timex[self.specialevents[-1]])
                            self.E2values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        elif etype == 2:
                            self.E3timex.append(self.timex[self.specialevents[-1]])
                            self.E3values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        elif etype == 3:
                            self.E4timex.append(self.timex[self.specialevents[-1]])
                            self.E4values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        #if Event show flag
                        if self.eventsshowflag:
                            index = self.specialevents[-1]
                            if etype < 4:
                                firstletter = self.etypesf(self.specialeventstype[-1])[0]
                            else:
                                firstletter = "E"
                            secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                            if self.eventsGraphflag == 0:
                                if self.mode == "F":
                                    height = 50
                                else:
                                    height = 20
                                #some times ET is not drawn (ET = 0) when using device NONE
                                if self.temp1[index] > self.temp2[index]:
                                    temp = self.temp1[index]
                                else:
                                    temp = self.temp2[index]
                                self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                            #if Event Type-Bars flag
                            elif self.eventsGraphflag == 1 and etype < 4:
                                char1 = self.etypesf(0)[0]
                                char2 = self.etypesf(1)[0]
                                char3 = self.etypesf(2)[0]
                                char4 = self.etypesf(3)[0]
                                if self.mode == "F":
                                    row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                                else:
                                    row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}
                                #some times ET is not drawn (ET = 0) when using device NONE
                                if self.temp1[index] >= self.temp2[index]:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                                     color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                                else:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                            elif self.eventsGraphflag == 2 and etype < 4:
                                # update lines data using the lists with new data
                                if etype == 0:
                                    self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                                elif etype == 1:
                                    self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                                elif etype == 2:
                                    self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                                elif etype == 3:
                                    self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
                        temp = "%.1f "%self.temp2[i]            
                        if aw.qmc.timeindex[0] != -1:
                            start = aw.qmc.timex[aw.qmc.timeindex[0]]
                        else:
                            start = 0
                        timed = self.stringfromseconds(self.timex[i] - start)
                        message = QApplication.translate("Message","Event # %1 recorded at BT = %2 Time = %3", None, QApplication.UnicodeUTF8).arg(str(Nevents+1)).arg(temp).arg(timed)
                        aw.sendmessage(message)
                        #write label in mini recorder if flag checked
                        if aw.minieventsflag:
                            aw.eventlabel.setText(QApplication.translate("Label", "Event #<b>%1 </b>",None, QApplication.UnicodeUTF8).arg(Nevents+1))
                            aw.eNumberSpinBox.blockSignals(True)
                            aw.eNumberSpinBox.setValue(Nevents+1)
                            aw.eNumberSpinBox.blockSignals(False)
                            if aw.qmc.timeindex[0] > -1:
                                timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[Nevents]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
                                aw.etimeline.setText(timez)
                            aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents])
                            aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents]))
                            aw.lineEvent.setText(self.specialeventsStrings[Nevents])
            else:
                aw.sendmessage(QApplication.translate("Message","Timer is OFF", None, QApplication.UnicodeUTF8))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " EventRecordAction() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    #called from controlling devices when roasting to record steps (commands) and produce a profile later
    def DeviceEventRecord(self,command):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                #prevents accidentally deleting a modified profile.
                self.safesaveflag = True
                #number of events
                Nevents = len(self.specialevents)
                #index number            
                i = len(self.timex)-1
                if i > 0:
                    self.specialevents.append(i)                                     # store absolute time index
                    self.specialeventstype.append(0)                                 # set type (to the first index 0)
                    self.specialeventsStrings.append(command)                        # store the command in the string section of events (not a binary string)
                    self.specialeventsvalue.append(0)                                # empty
                    temp = str(self.temp2[i])
                    if self.timeindex[0] != -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    timed = self.stringfromseconds(self.timex[i]-start)
                    message = QApplication.translate("Message","Computer Event # %1 recorded at BT = %2 Time = %3", None, QApplication.UnicodeUTF8).arg(str(Nevents+1)).arg(temp).arg(timed)
                    aw.sendmessage(message)
                    #write label in mini recorder if flag checked
                    if aw.minieventsflag:
                        aw.eNumberSpinBox.setValue(Nevents+1)
                        aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                        aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                        aw.lineEvent.setText(self.specialeventsStrings[Nevents])
                #if Event show flag
                if self.eventsshowflag:
                    index = self.specialevents[-1]
                    if self.specialeventstype[-1] < 4:
                        firstletter = self.etypesf(self.specialeventstype[-1])[0]
                        secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                        if self.eventsGraphflag == 0:
                            if self.mode == "F":
                                height = 50
                            else:
                                height = 20
                            #some times ET is not drawn (ET = 0) when using device NONE
                            if self.temp1[index] > self.temp2[index]:
                                temp = self.temp1[index]
                            else:
                                temp = self.temp2[index]
                            self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                        #if Event Type-Bars flag
                        if self.eventsGraphflag == 1:
                            char1 = self.etypesf(0)[0]
                            char2 = self.etypesf(1)[0]
                            char3 = self.etypesf(2)[0]
                            char4 = self.etypesf(3)[0]
                            if self.mode == "F":
                                row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                            else:
                                row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}
                            #some times ET is not drawn (ET = 0) when using device NONE
                            if self.temp1[index] >= self.temp2[index]:
                                self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                            else:
                                self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize="x-small",fontproperties=aw.mpl_fontproperties,backgroundcolor='yellow')
                        if self.eventsGraphflag == 2:
                            # update lines data using the lists with new data
                            etype = self.specialeventstype[-1]
                            if etype == 0:
                                self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                            elif etype == 1:
                                self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                            elif etype == 2:
                                self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                            elif etype == 3:
                                self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " DeviceEventRecord() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    def writecharacteristics(self,TP_index=None,LP=None):
        try:
            if self.statisticsflags[3] and self.timeindex[0]>-1 and self.temp1 and self.temp2 and self.temp1[self.timeindex[0]:self.timeindex[6]+1] and self.temp2[self.timeindex[0]:self.timeindex[6]+1]:
                statsprop = aw.mpl_fontproperties.copy()
                statsprop.set_size("small")
                if aw.qmc.statisticsmode == 0:
                    if TP_index == None:
                        TP_index = aw.findTP()
                    if LP == None:
                        #find Lowest Point in BT
                        LP = 1000 
                        if TP_index >= 0:
                            LP = self.temp2[TP_index]
                    # compute max ET between TP and DROP
                    if TP_index != None:
                        temp1_values = self.temp1[TP_index:self.timeindex[6]]
                        if self.LCDdecimalplaces:
                            lcdformat = "%.1f"
                        else:
                            lcdformat = "%.0f"
                        ETmax = lcdformat%max(temp1_values) + aw.qmc.mode
                    else:
                        ETmax = "--"
                
#                    dTime = self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]
#                    timez = self.stringfromseconds(dTime)
                    ror = "%.1f"%(((self.temp2[self.timeindex[6]]-LP)/(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]))*60.)
                    ts,tse,tsb = aw.ts()
                    
                    #curveSimilarity
                    det,dbt = aw.curveSimilarity(aw.qmc.phases[1]) # we analyze from DRY-END as specified in the phases dialog to DROP
                
                    #end temperature
                    if locale == "ar":
                        strline = QString("[%4-%5]%3=" + aw.arabicReshape(QApplication.translate("Label", "ETBTa", None,QApplication.UnicodeUTF8)) \
                                    + " " + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min", None,QApplication.UnicodeUTF8)) \
                                    + "%2=" + aw.arabicReshape(QApplication.translate("Label", "RoR", None,QApplication.UnicodeUTF8)) \
                                    + " %1=" + aw.arabicReshape(QApplication.translate("Label", "MET", None,QApplication.UnicodeUTF8))) \
                                    .arg(u(ETmax)) \
                                    .arg(u(ror)) \
                                    .arg(u("%d"%ts)) \
                                    .arg(u(int(tse))) \
                                    .arg(u(int(tsb)))
                        if det != None:
                            strline = QString(("%.1f/%.1f" % (det,dbt)) + self.mode + "=" + QApplication.translate("Label", "CM", None,QApplication.UnicodeUTF8) + " ") + strline
                    else:
                        strline = QString(QApplication.translate("Label", "MET", None,QApplication.UnicodeUTF8) + "=%1   " \
                                    + QApplication.translate("Label", "RoR", None,QApplication.UnicodeUTF8) + "=%2" \
                                    + aw.qmc.mode + QApplication.translate("Label", "/min", None,QApplication.UnicodeUTF8) + "   " \
                                    + QApplication.translate("Label", "ETBTa", None,QApplication.UnicodeUTF8) + "=%3[%4-%5]") \
                                    .arg(u(ETmax)) \
                                    .arg(u(ror)) \
                                    .arg(u("%d"%ts)) \
                                    .arg(u(int(tse))) \
                                    .arg(u(int(tsb)))
                        if det != None:
                            strline = strline + "   " + QString(QApplication.translate("Label", "CM", None,QApplication.UnicodeUTF8) + ("=%.1f/%.1f" % (det,dbt)) + self.mode)
                    self.ax.set_xlabel(strline,color = aw.qmc.palette["text"],fontproperties=statsprop)
                else:
                    sep = u"   "
                    msg = aw.qmc.roastdate.toString(Qt.SystemLocaleShortDate)
                    if aw.qmc.beans and aw.qmc.beans != "":
                        msg += sep + aw.qmc.abbrevString(u(aw.qmc.beans),25)
                    if aw.qmc.weight[0]:
                        msg += sep + str(int(round(aw.qmc.weight[0]))) + aw.qmc.weight[2]
                        if aw.qmc.weight[1]:
                            msg += sep + str(-aw.float2float(aw.weight_loss(aw.qmc.weight[0],aw.qmc.weight[1]),1)) + "%"
                    if aw.qmc.volume[0] and aw.qmc.volume[1]:
                            msg += sep + str(aw.float2float(aw.weight_loss(aw.qmc.volume[1],aw.qmc.volume[0]),1)) + "%"
                    if aw.qmc.whole_color and aw.qmc.ground_color:
                        msg += sep + u"#" + str(aw.qmc.whole_color) + u"/" +  str(aw.qmc.ground_color)
                    elif aw.qmc.ground_color:
                        msg += sep + u"#" + str(aw.qmc.ground_color)
                    self.ax.set_xlabel(msg,color = aw.qmc.palette["text"],fontproperties=statsprop)
            else:
                self.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8)),size=16,color = self.palette["xlabel"],fontproperties=aw.mpl_fontproperties)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " writecharacteristics() %1").arg(str(ex)),exc_tb.tb_lineno)
    

    # Writes information about the finished profile in the graph
    # TP_index is the TP index calculated by findTP and might be -1 if no TP could be detected
    def writestatistics(self,TP_index):
        try:
            if self.timeindex[1] and self.phasesbuttonflag:
                #manual dryend available
                dryEndIndex = self.timeindex[1]
            else:
                #find when dry phase ends 
                dryEndIndex = aw.findDryEnd(TP_index)
            dryEndTime = self.timex[dryEndIndex]

            #if DROP
            if self.timeindex[6] and self.timeindex[2]:
                totaltime = int(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]])
                if totaltime == 0:
                    aw.sendmessage(QApplication.translate("Message","Statistics cancelled: need complete profile [CHARGE] + [DROP]", None, QApplication.UnicodeUTF8))
                    return

                self.statisticstimes[0] = totaltime
                dryphasetime = int(dryEndTime - self.timex[self.timeindex[0]])
                midphasetime = int(self.timex[self.timeindex[2]] - dryEndTime)
                finishphasetime = int(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])

                if self.timeindex[7]:
                    coolphasetime = int(self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]])
                else:
                    coolphasetime = 0

                self.statisticstimes[1] = dryphasetime
                self.statisticstimes[2] = midphasetime
                self.statisticstimes[3] = finishphasetime
                self.statisticstimes[4] = coolphasetime

                #dry time string
                st1 = self.stringfromseconds(dryphasetime,False)

                #mid time string
                st2 = self.stringfromseconds(midphasetime,False)

                #finish time string
                st3 = self.stringfromseconds(finishphasetime,False)
                
                if coolphasetime:
                    st4 = self.stringfromseconds(coolphasetime,False)
                else:
                    st4 = ""

                #calculate the positions for the statistics elements
                ydist = self.ylimit - self.ylimit_min
                statisticsbarheight = ydist/70

                if aw.qmc.legendloc in [1,2,9]:
                    # legend on top
                    statisticsheight = self.ylimit - (0.13 * ydist) # standard positioning
                else:
                    # legend not on top
                    statisticsheight = self.ylimit - (0.08 * ydist)

                statisticsupper = statisticsheight + statisticsbarheight + 4
                statisticslower = statisticsheight - 3.5*statisticsbarheight

                if self.statisticsflags[1]:

                    #Draw cool phase rectangle
                    if self.timeindex[7]:
                        rect = patches.Rectangle((self.timex[self.timeindex[6]], statisticsheight), width = coolphasetime, height = statisticsbarheight,
                                                color = self.palette["rect4"],alpha=0.5)
                        self.ax.add_patch(rect)

                    if self.timeindex[2]: # only if FCs exists
                        #Draw finish phase rectangle
                        #check to see if end of 1C exists. If so, use half between start of 1C and end of 1C. Otherwise use only the start of 1C
                        rect = patches.Rectangle((self.timex[self.timeindex[2]], statisticsheight), width = finishphasetime, height = statisticsbarheight,
                                                color = self.palette["rect3"],alpha=0.5)
                        self.ax.add_patch(rect)

                        # Draw mid phase rectangle
                        rect = patches.Rectangle((self.timex[self.timeindex[0]]+dryphasetime, statisticsheight), width = midphasetime, height = statisticsbarheight,
                                              color = self.palette["rect2"],alpha=0.5)
                        self.ax.add_patch(rect)

                    # Draw dry phase rectangle
                    rect = patches.Rectangle((self.timex[self.timeindex[0]], statisticsheight), width = dryphasetime, height = statisticsbarheight,
                                              color = self.palette["rect1"],alpha=0.5)
                    self.ax.add_patch(rect)

                dryphaseP = int(round(dryphasetime*100/totaltime))
                midphaseP = int(round(midphasetime*100/totaltime))
                finishphaseP = int(round(finishphasetime*100/totaltime))
                            
                #find Lowest Point in BT
                LP = 1000 
                if TP_index >= 0:
                    LP = self.temp2[TP_index]

                if self.statisticsflags[0]:
                    statsprop = aw.mpl_fontproperties.copy()
                    statsprop.set_size(13)
                    self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime/2.,statisticsupper,st1 + "  "+ str(dryphaseP)+"%",color=self.palette["text"],ha="center",fontproperties=statsprop)
                    if self.timeindex[2]: # only if FCs exists
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime/2.,statisticsupper,st2+ "  " + str(midphaseP)+"%",color=self.palette["text"],ha="center",fontproperties=statsprop)
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime+finishphasetime/2.,statisticsupper,st3 + "  " + str(finishphaseP)+ "%",color=self.palette["text"],ha="center",fontproperties=statsprop)
                    if self.timeindex[7]: # only if COOL exists
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime+finishphasetime+coolphasetime/2.,statisticsupper,st4,color=self.palette["text"],ha="center",fontproperties=statsprop)

                if self.statisticsflags[2]:
                    (st1,st2,st3,st4) = aw.defect_estimation()
                    st1 = aw.arabicReshape(st1)
                    st2 = aw.arabicReshape(st2)
                    st3 = aw.arabicReshape(st3)
                    st4 = aw.arabicReshape(st4)
                else:
                    st1 = st2 = st3 = st4 = ""

                if self.statisticsflags[4] or self.statisticsflags[5]:
                    rates_of_changes = aw.RoR(TP_index,dryEndIndex)
                    if self.statisticsflags[2]:
                        st1 = st1 + u(" (")
                        st2 = st2 + u(" (")
                        st3 = st3 + u(" (")
                    if self.statisticsflags[4]:
                        st1 = st1 + "%.1f"%rates_of_changes[0] + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min",None, QApplication.UnicodeUTF8))
                        st2 = st2 + "%.1f"%rates_of_changes[1] + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min",None, QApplication.UnicodeUTF8))
                        st3 = st3 + "%.1f"%rates_of_changes[2] + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min",None, QApplication.UnicodeUTF8))
                    if self.statisticsflags[5]:
                        if self.statisticsflags[4]:
                            st1 += u("  ")
                            st2 += u("  ")
                            st3 += u("  ")
                        ts1,ts1e,ts1b = aw.ts(self.timeindex[0],dryEndIndex)
                        ts2,ts2e,ts2b = aw.ts(dryEndIndex,self.timeindex[2])
                        ts3,ts3e,ts3b = aw.ts(self.timeindex[2],self.timeindex[6])
                        st1 += u(ts1) + u(self.mode) + u("m")
                        st2 += u(ts2) + u(self.mode) + u("m")
                        st3 += u(ts3) + u(self.mode) + u("m")
                        if not self.statisticsflags[4]:
                            st1 += u(" [" + str(ts1e) + "-" + str(ts1b) + "]")
                            st2 += u(" [" + str(ts2e) + "-" + str(ts2b) + "]")
                            st3 += u(" [" + str(ts3e) + "-" + str(ts3b) + "]")
                    if self.statisticsflags[2]:
                        st1 = st1 + u(")")
                        st2 = st2 + u(")")
                        st3 = st3 + u(")")

                if self.statisticsflags[2] or self.statisticsflags[4] or self.statisticsflags[5]:
                    #Write flavor estimation
                    statsprop = aw.mpl_fontproperties.copy()
                    statsprop.set_size(13)
                    self.ax.text(self.timex[self.timeindex[0]] + dryphasetime/2.,statisticslower,st1,color=self.palette["text"],ha="center",fontproperties=statsprop)
                    if self.timeindex[2]: # only if FCs exists
                        self.ax.text(self.timex[self.timeindex[0]] + dryphasetime+midphasetime/2.,statisticslower,st2,color=self.palette["text"],ha="center",fontproperties=statsprop)
                        self.ax.text(self.timex[self.timeindex[0]] + dryphasetime+midphasetime+finishphasetime/2.,statisticslower,st3,color=self.palette["text"],ha="center",fontproperties=statsprop)
                    if self.timeindex[7]: # only if COOL exists
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime+finishphasetime+max(coolphasetime/2.,coolphasetime/3.),statisticslower,st4,color=self.palette["text"],ha="center",fontproperties=statsprop)
                self.writecharacteristics(TP_index,LP)
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " writestatistics() %1").arg(str(ex)),exc_tb.tb_lineno)

    #used in EventRecord()
    def restorebutton_11(self):
        aw.button_11.setDisabled(False)
        aw.button_11.setFlat(False)

    #called from markdryen(), markcharge(), mark1Cstart(), etc when using device 18 (manual mode)
    def drawmanual(self,et,bt,tx):
        self.timex.append(tx)
        self.temp1.append(et)
        self.l_temp1.set_data(self.timex, self.temp1)
        self.temp2.append(bt)
        self.l_temp2.set_data(self.timex, self.temp2)

    def movebackground(self,direction,step):
        lt = len(self.timeB)
        le = len(self.temp1B)
        lb = len(self.temp2B)
        #all background curves must have same dimension in order to plot. Check just in case.
        if lt > 1 and lt == le and lb == le:
            if  direction == "up":
                for i in range(lt):
                    self.temp1B[i] += step
                    self.temp2B[i] += step

            elif direction == "left":
                for i in range(lt):
                    self.timeB[i] -= step
                                   
            elif direction == "right":
                for i in range(lt):
                    self.timeB[i] += step

            elif direction == "down":
                for i in range(lt):
                    self.temp1B[i] -= step
                    self.temp2B[i] -= step
        else:
            aw.sendmessage(QApplication.translate("Message","Unable to move background", None, QApplication.UnicodeUTF8))
            return

    #points are used to draw interpolation
    def findpoints(self):
        #if profile found
        if self.timeindex[0] != -1:
            Xpoints = []                        #make temporary lists to hold the values to return
            Ypoints = []

            #start point from begining of time
            Xpoints.append(self.timex[0])
            Ypoints.append(self.temp2[0])
            #input beans (CHARGE)
            Xpoints.append(self.timex[self.timeindex[0]])
            Ypoints.append(self.temp2[self.timeindex[0]])

            #find indexes of lowest point and dryend
            LPind = aw.findTP()
            DE = aw.findDryEnd()

            if LPind < DE:
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
            else:
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                
            if self.temp2[self.timeindex[1]] > self.timex[DE] and self.temp2[self.timeindex[1]] > self.timex[LPind]:
                Xpoints.append(self.timex[self.timeindex[1]])
                Ypoints.append(self.temp2[self.timeindex[1]])
            if self.timeindex[2]:
                Xpoints.append(self.timex[self.timeindex[2]])
                Ypoints.append(self.temp2[self.timeindex[2]])
            if self.timeindex[3]:
                Xpoints.append(self.timex[self.timeindex[3]])
                Ypoints.append(self.temp2[self.timeindex[3]])
            if self.timeindex[4]:
                Xpoints.append(self.timex[self.timeindex[4]])
                Ypoints.append(self.temp2[self.timeindex[4]])
            if self.timeindex[5]:
                Xpoints.append(self.timex[self.timeindex[5]])
                Ypoints.append(self.temp2[self.timeindex[5]])
            if self.timeindex[6]:
                Xpoints.append(self.timex[self.timeindex[6]])
                Ypoints.append(self.temp2[self.timeindex[6]])

            #end point
            if self.timex[self.timeindex[6]] != self.timex[-1]:
                Xpoints.append(self.timex[-1])
                Ypoints.append(self.temp2[-1])

            return Xpoints,Ypoints

        else:
            aw.sendmessage(QApplication.translate("Message","No finished profile found", None, QApplication.UnicodeUTF8))
            return [],[]

    #collects info about the univariate interpolation
    def univariateinfo(self):
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            Xpoints,Ypoints = self.findpoints()  #from lowest point to avoid many coeficients
            equ = UnivariateSpline(Xpoints, Ypoints)
            coeffs = equ.get_coeffs().tolist()
            knots = equ.get_knots().tolist()
            resid = equ.get_residual()
            roots = equ.roots().tolist()

            #interpretation of coefficients: http://www.sagenb.org/home/pub/1708/
            #spline=[ans[0,i]+(x-xi)*(ans[1,i]+(x-xi)*(ans[2,i]+(x-xi)*ans[3,i]/3)/2) for i,xi in enumerate(a[:-1])]
            
            string = "<b>" + u(QApplication.translate("Message","Polynomial coefficients (Horner form):",
                                                    None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(coeffs) + "<br><br>"
            string += "<b>" + u(QApplication.translate("Message","Knots:",
                                                     None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(knots) + "<br><br>"
            string += "<b>" + u(QApplication.translate("Message","Residual:",
                                                     None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(resid) + "<br><br>"      
            string += "<b>" + u(QApplication.translate("Message","Roots:",
                                                     None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(roots)

            QMessageBox.information(self,QApplication.translate("Message","Profile information",None, QApplication.UnicodeUTF8),string)

        except ValueError as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " univariateinfo() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " univariateinfo() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    def polyfit(self,xarray,yarray,deg,startindex,endindex,deltacurvep):
        xa = xarray[startindex:endindex]
        ya = yarray[startindex:endindex]
        if len(xa) > 0 and len(xa) == len(ya):
            try:
                z = numpy.polyfit(xa,ya,deg)
                p = numpy.poly1d(z)
                x = p(xarray[startindex:endindex])
                pad = max(0,len(self.timex) - startindex - len(x))
                xx = numpy.append(numpy.append([None]*max(0,startindex), x), [None]*pad)
                if deltacurvep:
                    self.delta_ax.plot(self.timex, xx, linestyle = '--', linewidth=3)
                else:
                    self.ax.plot(self.timex, xx, linestyle = '--', linewidth=3)
                self.fig.canvas.draw()
                return z
            except:
                return None
        else:
            return None

    #interpolation type
    def univariate(self):
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            Xpoints,Ypoints = self.findpoints()

            func = UnivariateSpline(Xpoints, Ypoints)

            xa = numpy.array(self.timex)
            newX = func(xa).tolist()

            self.ax.plot(self.timex, newX, color="black", linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, "ro")

            self.fig.canvas.draw()

        except ValueError:
            aw.qmc.adderror(QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " univariate()")
            return

        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " univariate() " + str(e),exc_tb.tb_lineno)
            return

    def drawinterp(self,mode):
        try:
            #pylint: disable=E1101
            from scipy import interpolate as inter
            Xpoints,Ypoints = self.findpoints() #from 0 origin
            func = inter.interp1d(Xpoints, Ypoints, kind=mode)
            newY = func(self.timex)
            self.ax.plot(self.timex, newY, color="black", linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, "ro")

            self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " drawinterp() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " drawinterp() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    def timearray2index(self,timearray,seconds):
        #find where given seconds crosses timearray
        if len(timearray):                           #check that timearray is not empty just in case
            #if input seconds longer than available time return last index
            if  seconds > timearray[-1]:
                return len(timearray)-1
            #if given input seconds smaller than first time return first index
            if seconds < timearray[0]:
                return 0
            i = numpy.searchsorted(timearray,seconds,side='left')
            if i < len(self.timex) - 1:
                #look around (check if the value of the next index is closer
                choice1 = abs(self.timex[i] - seconds)
                choice2 = abs(self.timex[i-1] - seconds)
                #return closest (smallest) index
                if choice2 < choice1:
                    i = i - 1
            return i
        else:
            return -1

    #selects closest time INDEX in self.timex from a given input float seconds
    def time2index(self,seconds):
        #find where given seconds crosses aw.qmc.timex
        return self.timearray2index(self.timex,seconds)

    #selects closest time INDEX in self.timeB from a given input float seconds
    def backgroundtime2index(self,seconds):
        #find where given seconds crosses aw.qmc.timex
        return self.timearray2index(self.timeB,seconds)

    #updates list self.timeindex when found an _OLD_ profile without self.timeindex (new version)
    def timeindexupdate(self,times):
##        #          START            DRYEND          FCs             FCe         SCs         SCe         DROP
##        times = [self.startend[0],self.dryend[0],self.varC[0],self.varC[2],self.varC[4],self.varC[6],self.startend[2]]
        for i in range(len(times)):               
            if times[i]:
                self.timeindex[i] = self.time2index(times[i])
            else:
                self.timeindex[i] = 0

    #updates list self.timeindexB when found an _OLD_ profile without self.timeindexB 
    def timebackgroundindexupdate(self,times):
##        #          STARTB            DRYENDB          FCsB       FCeB         SCsB         SCeB               DROPB
##        times = [self.startendB[0],self.dryendB[0],self.varCB[0],self.varCB[2],self.varCB[4],self.varCB[6],self.startendB[2]]
        for i in range(len(times)):               
            if times[i]:
                self.timeindexB[i] = self.backgroundtime2index(times[i])
            else:
                self.timeindexB[i] = 0

    #adds errors
    def adderror(self,error,line=None):
        try:
            #### lock shared resources #####
            aw.qmc.errorsemaphore.acquire(1)
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            #keep a max of 500 errors
            if len(self.errorlog) > 499:
                self.errorlog = self.errorlog[1:]
            if line:
                error = error + "@line " + str(line)
            self.errorlog.append(timez + " " + error)
            aw.sendmessage(error)
        except:
            pass
        finally:
            if aw.qmc.errorsemaphore.available() < 1:
                aw.qmc.errorsemaphore.release(1)

    ####################  PROFILE DESIGNER   ###################################################################################
    #launches designer
    def designer(self):
        #disconnect mouse cross if ON
        if self.crossmarker:
            self.togglecrosslines()

        if len(self.timex):
            reply = QMessageBox.question(self,QApplication.translate("Message","Designer Start",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("Message","Importing a profile in to Designer will decimate all data except the main [points].\nContinue?",None, QApplication.UnicodeUTF8),
                                         QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Yes:
                self.initfromprofile()
                self.connect_designer()
                self.redraw(True)
            elif reply == QMessageBox.Cancel:
                aw.designerAction.setChecked(False)
        else:
            #if no profile found
            self.reset(redraw=False,soundOn=False)
            self.connect_designer()
            self.designerinit()

    #used to start designer from scratch (not from a loaded profile)
    def designerinit(self):
        #init start vars        #CH, DE,      Fcs,      Fce,       Scs,         Sce,         Drop,      COOL
        self.designertimeinit = [50,(5*60+50),(8*60+50),(10*60+50),(10.5*60+50),(11.5*60+50),(12*60+50),(16*60+50)]
        if self.mode == "C":
            self.designertemp1init = [290.,290.,290.,290.,290.,290.,290.,290.]   #CHARGE,DE,FCs,FCe,SCs,SCe,Drop
            self.designertemp2init = [230.,150.,190.,210.,220.,225.,230.,230.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP
        elif self.mode == "F":
            self.designertemp1init = [500.,500.,500.,500.,500.,500.,500.,500.]
            self.designertemp2init = [440.,300.,385.,410.,430.,445.,460.,460.]
            
        #check x limits
        if self.endofx < 960:
            self.endofx = 960
            self.redraw()

        self.timex,self.temp1,self.temp2 = [],[],[]
        for i in range(len(self.timeindex)):
            self.timex.append(self.designertimeinit[i])
            self.temp1.append(self.designertemp1init[i])
            self.temp2.append(self.designertemp2init[i])
            self.timeindex[i] = i

        self.xaxistosm()
        self.redrawdesigner()

    #loads main points from a profile so that they can be edited
    def initfromprofile(self):
        if self.timeindex[0] == -1 or self.timeindex[6] == 0:
            QMessageBox.information(self,QApplication.translate("Message","Designer Init",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("Message","Unable to start designer.\nProfile missing [CHARGE] or [DROP]",None, QApplication.UnicodeUTF8))
            self.disconnect_designer()
            return()

        #save events. They will be deleted on qmc.reset()
        self.specialeventsStringscopy = self.specialeventsStrings[:]
        self.specialeventsvaluecopy = self.specialeventsvalue[:]
        self.specialeventstypecopy = self.specialeventstype[:]
        self.eventtimecopy = []
        for i in range(len(self.specialevents)):
            #save relative time of events
            self.eventtimecopy.append(self.timex[self.specialevents[i]]-self.timex[self.timeindex[0]])

        #find lowest point from profile to be converted
        lpindex = aw.findTP()
        if lpindex != -1 and not lpindex in self.timeindex:
            lptime = self.timex[lpindex]
            lptemp2 = self.temp2[lpindex]
        else:
            lpindex = -1

        timeindexhold = [self.timex[self.timeindex[0]],0,0,0,0,0,0,0]
        timez,t1,t2 = [self.timex[self.timeindex[0]]],[self.temp1[self.timeindex[0]]],[self.temp2[self.timeindex[0]]]    #first CHARGE point
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:                           # fill up empty lists with main points (FCs, etc). match from timeindex
                timez.append(self.timex[self.timeindex[i]])  #add time
                t1.append(self.temp1[self.timeindex[i]])    #add temp1
                t2.append(self.temp2[self.timeindex[i]])    #add temp2
                timeindexhold[i] =  self.timex[self.timeindex[i]]

        self.reset()                                            #erase screen

        self.timex,self.temp1,self.temp2 = timez[:],t1[:],t2[:]  #copy lists back after reset() with the main points

        self.timeindexupdate(timeindexhold) #create new timeindex[]

        #add lowest point as extra point
        if lpindex != -1:
            self.currentx = lptime
            self.currenty = lptemp2
            self.addpoint()

        self.xaxistosm()
        self.redrawdesigner()                                   #redraw the designer screen

    #redraws designer
    def redrawdesigner(self):
        if aw.qmc.designerflag:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            #reset (clear) plot
            if self.DeltaBTflag or self.DeltaETflag:
                self.delta_ax.lines = []
            if self.background:
                self.ax.lines = self.ax.lines[0:4]
            else:
                self.ax.lines = []

            #create statistics bar
            #calculate the positions for the statistics elements
            ydist = self.ylimit - self.ylimit_min
            statisticsheight = self.ylimit - (0.13 * ydist)

            #add statistics bar
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[1]]],[statisticsheight,statisticsheight],color = self.palette["rect1"],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[2]]],[statisticsheight,statisticsheight],color = self.palette["rect2"],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[6]]],[statisticsheight,statisticsheight],color = self.palette["rect3"],alpha=.5,linewidth=5)

            #add phase division lines
            ylist = [self.ylimit,0]
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[0]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[1]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[2]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[6]],self.timex[self.timeindex[6]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")

            if self.timex[-1] > self.endofx:
                self.endofx = self.timex[-1] + 120
                self.xaxistosm()

            if self.BTsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.BTsplinedegree = len(self.timex)-1

            if self.ETsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.ETsplinedegree = len(self.timex)-1

            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()
            func = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            btvals = func(timez).tolist()
            func2 = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)
            etvals = func2(timez).tolist()
            #convert all time values to temperature

            #add markers (big circles) '0'
            if self.ETcurve:
                self.ax.plot(self.timex,self.temp1,color = self.palette["et"],marker = "o",picker=10,linestyle='',markersize=8)
            if self.BTcurve:
                self.ax.plot(self.timex,self.temp2,color = self.palette["bt"],marker = "o",picker=10,linestyle='',markersize=8)     #picker = 10 means 10 points tolerance

            rcParams['path.sketch'] = (0,0,0)
            #add curves
            if self.ETcurve:
                self.ax.plot(timez, etvals,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,
                    linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],
                        label=u(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
            if self.BTcurve:
                self.ax.plot(timez, btvals, markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,
                    linestyle=self.BTlinestyle,drawstyle=self.BTlinestyle,color=self.palette["bt"],
                        label=u(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))
                        
                        
            if self.DeltaBTflag:
                funcDelta = func.derivative()
                deltabtvals = [x*60 for x in funcDelta(timez).tolist()]
                self.delta_ax.plot(timez,deltabtvals,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],
                    label=aw.arabicReshape(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))
                    
            if self.DeltaETflag:
                funcDelta2 = func2.derivative()
                deltaetvals = [x*60 for x in funcDelta2(timez).tolist()]
                self.delta_ax.plot(timez,deltaetvals,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+aw.qmc.patheffects,foreground="w")],
                    linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],
                    label=aw.arabicReshape(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))                          
        
            #plot
            self.fig.canvas.draw()

    #CONTEXT MENU  = Right click
    def on_press(self,event):
        if event.inaxes != self.ax: return
        if event.button != 3: return   #select right click only

        self.releaseMouse()
        self.mousepress = False
        self.setCursor(Qt.OpenHandCursor)

        self.currentx = event.xdata
        if self.delta_ax:
#            self.currenty = self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,event.ydata))[1]))[1]
            self.currenty = event.ydata
        else:
            self.currenty = event.ydata

        designermenu = QMenu(self)

        createAction = QAction(QApplication.translate("Contextual Menu", "Create",None, QApplication.UnicodeUTF8),self)
        self.connect(createAction,SIGNAL("triggered()"),self.convert_designer)
        designermenu.addAction(createAction)

        configAction = QAction(QApplication.translate("Contextual Menu", "Config...",None, QApplication.UnicodeUTF8),self)
        self.connect(configAction,SIGNAL("triggered()"),self.desconfig)
        designermenu.addAction(configAction)

        backgroundAction = QAction(UIconst.ROAST_MENU_BACKGROUND,self)
        self.connect(backgroundAction,SIGNAL("triggered()"),aw.background)
        designermenu.addAction(backgroundAction)

        designermenu.addSeparator()

        addpointAction = QAction(QApplication.translate("Contextual Menu", "Add point",None, QApplication.UnicodeUTF8),self)
        self.connect(addpointAction,SIGNAL("triggered()"),self.addpoint)
        designermenu.addAction(addpointAction)

        removepointAction = QAction(QApplication.translate("Contextual Menu", "Remove point",None, QApplication.UnicodeUTF8),self)
        self.connect(removepointAction,SIGNAL("triggered()"),self.removepoint)
        designermenu.addAction(removepointAction)

        designermenu.addSeparator()

        resetAction = QAction(QApplication.translate("Contextual Menu", "Reset Designer",None, QApplication.UnicodeUTF8),self)
        self.connect(resetAction,SIGNAL("triggered()"),self.reset_designer)
        designermenu.addAction(resetAction)

        exitAction = QAction(QApplication.translate("Contextual Menu", "Exit Designer",None, QApplication.UnicodeUTF8),self)
        self.connect(exitAction,SIGNAL("triggered()"),aw.stopdesigner)
        designermenu.addAction(exitAction)

        designermenu.exec_(QCursor.pos())

    def on_pick(self,event):
        self.setCursor(Qt.ClosedHandCursor)

        self.indexpoint = event.ind
        self.mousepress = True

        line = event.artist
        #identify which line is being edited
        ydata = line.get_ydata()
        if ydata[1] == self.temp1[1]:
            self.workingline = 1
        else:
            self.workingline = 2

    #handles when releasing mouse
    def on_release(self,event):
        self.mousepress = False
        self.setCursor(Qt.OpenHandCursor)

    #handler for moving point
    def on_motion(self,event):
        if not event.inaxes: return

#        if self.delta_ax:
#            ydata = self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,event.ydata))[1]))[1]
#        else:
#            ydata = event.ydata
        
        ydata = event.ydata
        
        try:
            if self.mousepress:                                 #if mouse clicked
                self.timex[self.indexpoint] = event.xdata
                if self.workingline == 1:
                    self.temp1[self.indexpoint] = ydata
                else:
                    self.temp2[self.indexpoint] = ydata

                #check point going over point
                #check to the left    
                if self.indexpoint > 0:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint - 1]) < 10.:
                        self.unrarefy_designer()
                        return
                #check to the right
                if self.indexpoint <= len(self.timex)-2:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint + 1]) < 10.:
                        self.unrarefy_designer()
                        return

                #check for possible CHARGE time moving
                if self.indexpoint == self.timeindex[0]:
                    self.xaxistosm()

                #redraw
                self.redrawdesigner()
                return

            if type(event.xdata):                       #outside graph type is None
                for i in range(len(self.timex)):
                    if abs(event.xdata - self.timex[i]) < 7.:
                        if i in self.timeindex:
                            if abs(self.temp2[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = "orange",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = "orange",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            index = self.timeindex.index(i)
                            if index == 0:
                                timez = self.stringfromseconds(0)
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: #f07800\">" + u(QApplication.translate("Message", "[ CHARGE ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 1:
                                timez = self.stringfromseconds(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ DRY END ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 2:
                                timez = self.stringfromseconds(self.timex[self.timeindex[2]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ FC START ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 3:
                                timez = self.stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[0]])                                
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ FC END ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 4:
                                timez = self.stringfromseconds(self.timex[self.timeindex[4]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ SC START ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 5:
                                timez = self.stringfromseconds(self.timex[self.timeindex[5]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ SC END ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 6:
                                timez = self.stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: #f07800\">" + u(QApplication.translate("Message", "[ DROP ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            break
                        else:
                            if abs(self.temp2[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = "blue",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = "blue",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            timez = self.stringfromseconds(self.timex[i] - self.timex[self.timeindex[0]])
                            aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: lightblue\">%s</font> "%timez)
                            break
                    else:
                        totaltime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]]
                        dryphasetime = self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]]
                        midphasetime = self.timex[self.timeindex[2]] - self.timex[self.timeindex[1]]
                        finishphasetime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]]

                        if totaltime:
                            dryphaseP = int(round(dryphasetime*100./totaltime))
                            midphaseP = int(round(midphasetime*100./totaltime))
                            finishphaseP = int(round(finishphasetime*100./totaltime))
                        else:
                            return

                        dryramp = self.temp2[self.timeindex[1]] - self.temp2[self.timeindex[0]]
                        midramp = self.temp2[self.timeindex[2]] - self.temp2[self.timeindex[1]]
                        finishramp = self.temp2[self.timeindex[6]] - self.temp2[self.timeindex[2]]

                        ts1,_,_ = aw.ts(self.timeindex[0],self.timeindex[1])
                        ts2,_,_ = aw.ts(self.timeindex[1],self.timeindex[2])
                        ts3,_,_ = aw.ts(self.timeindex[2],self.timeindex[6])
                        etbt1 = "%i"%(ts1)
                        etbt2 = "%i"%(ts2)
                        etbt3 = "%i"%(ts3)

                        if dryphasetime:
                            dryroc = (" %.1f " + aw.qmc.mode + "/min")%((dryramp/dryphasetime)*60.)
                        else:
                            dryroc = " 0 " + aw.qmc.mode + "/min"

                        if midphasetime:
                            midroc = (" %.1f " + aw.qmc.mode + "/min")%((midramp/midphasetime)*60.)
                        else:
                            midroc = " 0 " + aw.qmc.mode + "/min"

                        if finishphasetime:
                            finishroc = (" %.1f " + aw.qmc.mode + "/min")%((finishramp/finishphasetime)*60.)
                        else:
                            finishroc = 0

                        margin = "&nbsp;&nbsp;&nbsp;"
                        string1 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect1"],
                                  margin,self.stringfromseconds(dryphasetime),margin, dryphaseP, margin,dryroc,margin,etbt1,margin)
                        string2 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect2"],
                                  margin,self.stringfromseconds(midphasetime),margin,midphaseP,margin,midroc,margin,etbt2,margin)
                        string3 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect3"],
                                  margin,self.stringfromseconds(finishphasetime),margin,finishphaseP,margin,finishroc,margin,etbt3,margin)
                        aw.messagelabel.setText(string1+string2+string3)

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " on_motion() %1").arg(str(e)),exc_tb.tb_lineno)
            self.unrarefy_designer()
            return

    #this is used in on_motion() to try to prevent points crossing over points
    def unrarefy_designer(self):
        for i in range(len(self.timex)-1):
            if abs(self.timex[i]-self.timex[i+1]) < 20:
                self.timex[i+1] = self.timex[i] + 20
            self.disconnect_designer()
            self.connect_designer()

    def addpoint(self):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()

            if self.currentx > self.timex[-1]:       #if point is beyond max timex (all the way to the right)
                #find closest line
                d1 = abs(self.temp1[-1] - self.currenty)
                d2 = abs(self.temp2[-1] - self.currenty)
                if d2 < d1:
                    self.temp2.append(self.currenty)
                    self.temp1.append(self.temp1[-1])
                else:
                    self.temp2.append(self.temp2[-1])
                    self.temp1.append(self.currenty)
                    
                self.timex.append(self.currentx)
                #no need to update time index

                self.redrawdesigner()
                return 0

            elif self.currentx < self.timex[0]:         #if point is bellow min timex (all the way to the left)
                #find closest line
                d1 = abs(self.temp1[0] - self.currenty)
                d2 = abs(self.temp2[0] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(0,self.currenty)
                    self.temp1.insert(0,self.temp1[0])
                else:
                    self.temp2.insert(0,self.temp2[0])
                    self.temp1.insert(0,self.currenty)

                self.timex.insert(0,self.currentx)

                #update timeindex
                if self.timeindex[0] != -1:   #we update timeindex[0] different
                    self.timeindex[0] += 1
                for u in range(1,len(self.timeindex)):
                    if self.timeindex[u]:
                        self.timeindex[u] += 1

                self.redrawdesigner()
                return len(self.timex)-1   #return index received from Designer Dialog Config to asign index to timeindex)

            else:                                           #mid range
                #find index
                for i in range(len(self.timex)):
                    if self.timex[i] > self.currentx:
                        break
                #find closest line
                d1 = abs(self.temp1[i] - self.currenty)
                d2 = abs(self.temp2[i] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(i,self.currenty)
                    self.temp1.insert(i,self.temp1[i])
                else:
                    self.temp2.insert(i,self.temp2[i])
                    self.temp1.insert(i,self.currenty)

                self.timex.insert(i,self.currentx)

                #update timeindex
                for x in range(len(self.timeindex)):
                    if self.timeindex[x] >= i:
                        self.timeindex[x] += 1

                self.redrawdesigner()
                return i

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " addpoint() %1").arg(str(e)),exc_tb.tb_lineno)
            return 

    #removes point
    def removepoint(self):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            #find index
            for i in range(len(self.timex)):
                if self.timex[i] > self.currentx:
                    break
            #find closest point
            if abs(self.timex[i]- self.currentx) < abs(self.timex[i-1] - self.currentx):
                index = i
            else:
                index = i-1

            #check if if it is a landmark point
            if index in self.timeindex:
                whichone = self.timeindex.index(index)
                if whichone == 0 or whichone == 6:  #if charge or drop
                    return
                self.timeindex[whichone] = 0

            self.timex.pop(index)
            self.temp1.pop(index)
            self.temp2.pop(index)

            for x in range(len(self.timeindex)):
                if self.timeindex[x] > index: #decrease time index by one when above the index taken out
                    self.timeindex[x] -= 1

            self.redrawdesigner()

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " removepoint() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    #finds a proper index location for a time that does not exists yet.
    def designerfindindex(self,time):
        if time < aw.qmc.timex[0]:
            return 0
        elif time > aw.qmc.timex[-1]:
            return len(aw.qmc.timex)-1
        else:
            for i in range(len(aw.qmc.timex)):
                if time == aw.qmc.timex[i]:
                    return i
                if aw.qmc.timex[i] > time:
                    return i-1

    #converts from a designer profile to a normal profile
    def convert_designer(self): 
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            #prevents accidentally deleting a modified profile.
            self.safesaveflag = True
            #create functions
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            funcET = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)

            #create longer list of time values
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()

            #convert all time values to temperature
            btvals = funcBT(timez).tolist()
            etvals = funcET(timez).tolist()

            #find new indexes for events
            for i in range(len(self.specialevents)):
                for p in range(len(timez)):
                    if timez[p] > self.timex[self.specialevents[i]]:
                        self.specialevents[i] = p
                        break

            #save landmarks
            maintimes = []
            for i in range(len(self.timeindex)):
                maintimes.append(self.timex[self.timeindex[i]])

            self.timex = timez[:]
            self.temp1 = etvals[:]
            self.temp2 = btvals[:]

            self.timeindexupdate(maintimes)

            #check and restore carried over events
            if len(self.eventtimecopy):
                for i in range(len(self.eventtimecopy)):
                    self.specialevents.append(self.time2index(self.eventtimecopy[i] + self.timex[self.timeindex[0]]))
                self.specialeventsStrings = self.specialeventsStringscopy[:]
                self.specialeventsvalue = self.specialeventsvaluecopy[:]
                self.specialeventstype = self.specialeventstypecopy[:]

            #check for extra devices
            num = len(self.timex)
            for i in range(len(self.extradevices)):
                self.extratemp1[i] = [-1.]*num
                self.extratemp2[i] = [-1.]*num
                self.extratimex[i] = self.timex[:]

            self.disconnect_designer()

            #create playback events
            if self.reproducedesigner:
                functioncall = [0,
                                self.designer_create_BT_rateofchange,
                                self.designer_create_ET_rateofchange,
                                self.designer_create_sv_command,
                                self.designer_create_ramp_command]

                functioncall[self.reproducedesigner]()

            self.redraw()
            aw.sendmessage(QApplication.translate("Message", "New profile created",None, QApplication.UnicodeUTF8))

        except ValueError:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " createFromDesigner()",exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " createFromDesigner() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    #activates mouse events
    def connect_designer(self):
        if not self.designerflag:
            self.designerflag = True
            aw.designerAction.setChecked(True)
            self.setCursor(Qt.OpenHandCursor)
            self.mousepress = None
            #create mouse events. Note: keeping the ids inside a list helps protect against extrange python behaviour.
            self.designerconnections = [0,0,0,0]
            self.designerconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.on_pick) 
            self.designerconnections[1] = self.fig.canvas.mpl_connect('button_release_event', self.on_release)
            self.designerconnections[2] = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
            self.designerconnections[3] = self.fig.canvas.mpl_connect('button_press_event', self.on_press) #right click
            #this is needed to prevent complaints from UnivariateSpline() -used in redraw()- in extreme cases of difficulty
            warnings.simplefilter('ignore', UserWarning)

    #deactivates mouse events
    def disconnect_designer(self):
        for i in range(len(self.designerconnections)):
            if self.designerconnections[i]:
                self.fig.canvas.mpl_disconnect(self.designerconnections[i])
        self.setCursor(Qt.ArrowCursor)
        self.designerflag = False
        aw.designerAction.setChecked(False)
        warnings.simplefilter('default', UserWarning)

    #launches designer config Window
    def desconfig(self):
        dialog = designerconfigDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())

    def reset_designer(self):
        self.reset()
        self.disconnect_designer()
        self.connect_designer()
        self.designerinit()

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_BT_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp2[self.timeindex[i]] - self.temp2[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = u(QApplication.translate("Label", "BT %1 %2/min for %3",None, QApplication.UnicodeUTF8).arg("%.1f"%(difftemp/difftime)).arg(aw.qmc.mode).arg(self.stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_ET_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp1[self.timeindex[i]] - self.temp1[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = u(QApplication.translate("Label", "ET %1 %2/min for %3",None, QApplication.UnicodeUTF8).arg("%.1f"%(difftemp/difftime)).arg(aw.qmc.mode).arg(self.stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    def deleteEvents(self):
        self.specialevents = []
        self.specialeventstype = []
        self.specialeventsStrings = []
        self.specialeventsvalue = []

    #this is used to create a string in pid language to reproduce the profile from Designer
    #NOTE: pid runs ET (temp1)    
    def designer_create_ramp_command(self):
        tempinits = []
        minutes_segments = []

        #ramp times in minutes
        minsDryPhase = str(int(abs(self.timex[self.timeindex[0]] - self.timex[self.timeindex[1]])/60))
        minsMidPhase = str(int(abs(self.timex[self.timeindex[1]] - self.timex[self.timeindex[2]])/60)) 
        minsFinishPhase = str(int(abs(self.timex[self.timeindex[2]] - self.timex[self.timeindex[6]])/60))

        #target temps for ET
        tempinits.append("%.1f"%self.temp1[self.timeindex[1]])
        tempinits.append("%.1f"%self.temp1[self.timeindex[2]])
        tempinits.append("%.1f"%self.temp1[self.timeindex[6]])

        minutes_segments.append(minsDryPhase)
        minutes_segments.append(minsMidPhase)
        minutes_segments.append(minsFinishPhase)

        command = ""
        for i in range(3):
            command += "SETRS::" + tempinits[i] + "::" + minutes_segments[i] + "::0::"
        command += "SETRS::" + tempinits[-1] + "::0::0"

        self.clean_old_pid_commands()

        #do only one event but with all segments
        self.specialevents.append(0)
        self.specialeventstype.append(0)
        self.specialeventsStrings.append(command)
        self.specialeventsvalue.append(0)

    #this is used to create a string in ET temp language to reproduce the profile from Designer
    def designer_create_sv_command(self):
        self.clean_old_pid_commands()
        for i in range(len(self.timeindex)-1):
            command = "SETSV::%.1f"%self.temp1[self.timeindex[i+1]]
            if i > 0 and self.timeindex[i]:
                self.specialevents.append(self.timeindex[i])
                self.specialeventstype.append(0)
                self.specialeventsStrings.append(command)
                self.specialeventsvalue.append(0)

    #verifies there are no previos machine commands on events
    def clean_old_pid_commands(self):
        #check for possible preloaded machine commands
        target = 0
        if len(self.specialevents):
            for i in range(len(self.specialevents)):
                if "::" in self.specialeventsStrings[i]:
                    self.specialevents.pop(i)
                    self.specialeventstype.pop(i)
                    self.specialeventsStrings.pop(i)
                    self.specialeventsvalue.pop(i)
                    target = 1
                    break     #break or the index i can become larger than the new shorted length of specialevents
        if target:
            self.clean_old_pid_commands()

    ###################################      WHEEL GRAPH  ####################################################

    def findCenterWheelTextAngle(self,t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if t == 360. or t == 0.:
            return 270.
        #check cuadrants
        elif t < 90. and t > 0. or t > 360.:        #quadrant 1
            return 270.+t
        elif t <= 180. and t >= 90.:                #quadrant 2
            return t-90.
        elif t < 270. and t > 180.:                 #quadrant 3
            return t+90.
        else:                                       #quadrant 4
            return t-270.

    def findRadialWheelTextAngle(self,t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)  
        if t <= 90. and t > 0. or t > 270.:
            return t
        else:
            return 180.+t

    def loadselectorwheel(self,path):
        string = "Wheels" + "\\" + path
        direct = QDir()
        pathDir = direct.toNativeSeparators(QString(string))
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Open Wheel Graph",None, QApplication.UnicodeUTF8),path=pathDir,ext="*.wg")
        if filename:
            self.connectWheel()
            aw.loadWheel(filename)
            self.drawWheel()

    def addTocuppingnotes(self):
        descriptor =  u(self.wheelnames[self.wheelx][self.wheelz]) 
        self.cuppingnotes += "\n" + descriptor 
        string = u(QApplication.translate("Message", " added to cupping notes",None, QApplication.UnicodeUTF8))
        aw.sendmessage(descriptor + string)

    def addToroastingnotes(self):
        descriptor =  u(self.wheelnames[self.wheelx][self.wheelz]) + " "
        self.roastingnotes +=  "\n" + descriptor + " "
        string = u(QApplication.translate("Message", " added to roasting notes",None, QApplication.UnicodeUTF8))
        aw.sendmessage(descriptor + string)

    def wheel_pick(self,event):
        rect =  event.artist
        loc = rect.get_url().split("-")
        x = int(loc[0])
        z = int(loc[1])
        self.wheelx = x
        self.wheelz = z
        aw.sendmessage(self.wheelnames[x][z])
        self.segmentsalpha[x][z] += .3
        self.drawWheel()

    def wheel_release(self,event):
        newlocz = event.xdata
        if newlocz:
            if newlocz != self.wheellocationz:
                diff = math.degrees(self.wheellocationx - newlocz)
                for i in range(len(self.startangle)):
                    self.startangle[i] -= diff
                self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection 
                self.drawWheel()

    def wheel_menu(self,event):
        if str(event.inaxes) != str(self.ax2): return
        if event.button == 1:                    #if left click
            self.wheellocationx = event.xdata
            self.wheellocationz = event.ydata

        elif event.button == 3:                  #if right click
            designermenu = QMenu(self)
            cuppingAction = QAction(QApplication.translate("Contextual Menu", "Add to Cupping Notes",None, QApplication.UnicodeUTF8),self)
            self.connect(cuppingAction,SIGNAL("triggered()"),self.addTocuppingnotes)
            designermenu.addAction(cuppingAction)

            roastingAction = QAction(QApplication.translate("Contextual Menu", "Add to Roasting Notes",None, QApplication.UnicodeUTF8),self)
            self.connect(roastingAction,SIGNAL("triggered()"),self.addToroastingnotes)
            designermenu.addAction(roastingAction)

            cancelwheelAction = QAction(QApplication.translate("Contextual Menu", "Cancel selection",None, QApplication.UnicodeUTF8),self)
            self.connect(cancelwheelAction,SIGNAL("triggered()"),self.cancelwheelselection)
            designermenu.addAction(cancelwheelAction)

            editAction = QAction(QApplication.translate("Contextual Menu", "Edit Mode",None, QApplication.UnicodeUTF8),self)
            self.connect(editAction,SIGNAL("triggered()"),self.editmode)
            designermenu.addAction(editAction)

            exitAction = QAction(QApplication.translate("Contextual Menu", "Exit",None, QApplication.UnicodeUTF8),self)
            self.connect(exitAction,SIGNAL("triggered()"),self.exitviewmode)
            designermenu.addAction(exitAction)

            designermenu.exec_(QCursor.pos())

    def cancelwheelselection(self):
        self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection
        self.drawWheel()

    def editmode(self):
        self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection
        self.disconnectWheel(buttomvisibility=False)
        aw.graphwheel()

    def exitviewmode(self):
        self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection 
        self.disconnectWheel()
        self.redraw(recomputeAllDeltas=False)

    def connectWheel(self):
        self.wheelflag = True
        self.setCursor(Qt.PointingHandCursor)
        self.wheelconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.wheel_pick)
        self.wheelconnections[1] = self.fig.canvas.mpl_connect('button_press_event', self.wheel_menu)           #right click menu context
        self.wheelconnections[2] = self.fig.canvas.mpl_connect('button_release_event', self.wheel_release)

    def disconnectWheel(self,buttomvisibility=True):
        self.wheelflag = False
        self.setCursor(Qt.ArrowCursor)
        self.fig.canvas.mpl_disconnect(self.wheelconnections[0])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[1])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[2])

    def drawWheel(self):
        try:
            ### var constants  #####
            pi = numpy.pi
            threesixty = 2.*pi
            div = threesixty/100.
            rad = 360./threesixty
            ########################
            # same as redraw but using different axes
            self.fig.clf()
            #create a new name ax1 instead of ax
            self.ax2 = self.fig.add_subplot(111, projection='polar', axisbg=self.backcolor)
            self.ax2.set_rmax(1.)
            self.ax2.set_aspect(self.wheelaspect)
            self.ax2.set_autoscale_on(True)
            self.ax2.grid(False)

            #delete degrees ticks to anotate flavor characteristics 
            for tick in self.ax2.xaxis.get_major_ticks():
                tick.label1On = False
            #delete yaxis 
            locs = self.ax2.get_yticks()
            labels = [""]*len(locs)
            self.ax2.set_yticklabels(labels)

            names = self.wheelnames[:]
            Wradii = self.wradii[:]
            startangle = self.startangle[:]
            projection = self.projection[:]

            #calculate text orientation
            wheels = len(names)

            if not wheels:
                self.fig.canvas.draw()
                return

            n,textangles,textloc = [],[],[]
            for i in range(wheels):
                l,tloc = [],[]
                count = self.startangle[i]
                #calculate text orientation
                for p in range(len(names[i])):
                    if projection[i] == 0:
                        l.append(0)
                    elif projection[i] == 1:
                        l.append(self.findCenterWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    elif projection[i] == 2:
                        l.append(self.findRadialWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    tloc.append((3.6*self.segmentlengths[i][p]/2. + count)/rad)
                    count += self.segmentlengths[i][p]*3.6

                textloc.append(tloc)
                textangles.append(l)
                Wradii[i] = float(Wradii[i])/100.                   #convert radii to float between 0-1 range
                startangle[i] = startangle[i]/rad                   #convert angles to radians
                n.append(len(names[i]))                             #store the number of names for each wheel


            #store the absolute len-radius origin of each circle
            lbottom = [0.]
            count = 0.
            for i in range(wheels-1):
                count += Wradii[i]
                lbottom.append(count)

            Wradiitext = [Wradii[0]/2.]
            for i in range(wheels-1):
                Wradiitext.append(lbottom[i+1] + Wradii[i+1]/2.)     #store absolute len-radius for text in each circle
                Wradii[i] += self.wheeledge                          #create extra color edge between wheels by overlaping wheels
            #Generate Wheel graph
            bar = []                                                 #holds bar-graphs (wheels)
            for z in range(len(n)):
                #create wheel
                theta,segmentwidth,radii = [],[],[]
                count = startangle[z]
                for i in range(n[z]):
                    #negative number affect eventpicker
                    if count > threesixty:
                        count %= threesixty
                    elif count < 0.:
                        count += threesixty
                    theta.append(count)
                    count += div*self.segmentlengths[z][i]
                    segmentwidth.append(div*self.segmentlengths[z][i])
                    radii.append(Wradii[z])
                bar.append(self.ax2.bar(theta, radii, width=segmentwidth, bottom=lbottom[z],edgecolor=self.wheellinecolor,
                                        linewidth=self.wheellinewidth,picker=1))
                count = 0
                #set color, alpha, and text
                for _,bar[z] in zip(radii, bar[z]):
                    bar[z].set_facecolor(self.wheelcolor[z][count])
                    bar[z].set_alpha(min(self.segmentsalpha[z][count],1))
                    bar[z].set_url(str(z) + "-" + str(count))
                    self.ax2.annotate(names[z][count],xy=(textloc[z][count],Wradiitext[z]),xytext=(textloc[z][count],Wradiitext[z]),
                        rotation=textangles[z][count],horizontalalignment="center",verticalalignment="center",fontsize=self.wheeltextsize[z],fontproperties=aw.mpl_fontproperties)
                    count += 1
            self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " drawWheel() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " drawWheel() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    def makewheelcolorpattern(self):
        for x in range(len(self.wheelcolor)):
            wlen = len(self.wheelcolor[x])
            for i in range(wlen):
                color = QColor()
                color.setHsv((360/wlen)*i*self.wheelcolorpattern,255,255,255)
                self.wheelcolor[x][i] = str(color.name())

    # sets parent and corrects segment lengths so that child fits inside parent (multiple children can be set to same parent)
    # input: z = index of parent in previus wheel    # x = wheel number    # i = index of element in wheel x
    def setwheelchild(self,z,x,i):
        #set same start angle
        self.startangle[x] = self.startangle[x-1]
        self.wheellabelparent[x][i] = z

        #adjust lengths
        for x in range(1,len(self.segmentlengths)):
            nsegments = len(self.segmentlengths[x])
            parentanglecount = 0
            for i in range(nsegments):
                if  self.wheellabelparent[x][i]:                                                  #if parent selected (otherwise 0) 
                    parentindex = self.wheellabelparent[x][i]                                     #parent index
                    if self.wheellabelparent[x][i] == parentindex:                                #if match
                        parentangle = self.segmentlengths[x-1][self.wheellabelparent[x][i]-1]     #find parent angle (in %)
                        #find number of labels with same parent
                        count = self.wheellabelparent[x].count(parentindex)                       #count number of labels with same parent
                        self.segmentlengths[x][i] = parentangle/count                             #divide parent angle between children

                        #calculate last total angle
                        if i < nsegments-1:
                            parentanglecount += self.segmentlengths[x][i]

                        #adjust rest of angles to get 100 % coverage
                        for a in range(i+1,nsegments):
                            self.segmentlengths[x][a] = (100-parentanglecount)/(nsegments-(i+1))

    #adjusts size of all segements of the graph based on child parent relation
    #expects all segments to have a parent except in the first wheel
    def setWheelHierarchy(self):
        #check for not stablished relashionships (will cause graph plotting problems) and give warning
        for x in range(1,len(self.wheellabelparent)):
            for i in range(len(self.wheellabelparent[x])):
                if self.wheellabelparent[x][i] == 0:
                    QMessageBox.information(self,"Wheel Hierarchy Problem",
                    "Please assign a  a parent to wheel #%i element#%i: \n\n%s"%(x+1,i+1,self.wheelnames[x][i]))
                    return

        #adjust top wheel and make all segments equal
        for i in range(len(self.segmentlengths[-1])):
            self.segmentlengths[-1][i] = 100./len(self.segmentlengths[-1])

        #adjust lower wheels based on previous wheels
        for p in range(len(self.wheellabelparent)-1,0,-1):
            nsegments = len(self.wheellabelparent[p])
            nparentsegments = len(self.wheellabelparent[p-1])
            angles = [0]*nparentsegments
            for x in range(nparentsegments):
                for i in range(nsegments):
                    if self.wheellabelparent[p][i]-1 == x:
                        angles[x] += self.segmentlengths[p][i]

            #adjust angle length of parents proportionaly
            for i in range(nparentsegments):
                self.segmentlengths[p-1][i] = angles[i]

        self.drawWheel()

#############################     MOUSE CROSS     #############################

    def togglecrosslines(self):
        if self.crossmarker == False and not self.designerflag and not self.flagstart:  #if not projection flag
            #turn ON
            self.l_horizontalcrossline = None
            self.l_verticalcrossline = None
            self.updateBackground() # update bitlblit backgrounds
            self.crossmarker = True
            message = QApplication.translate("Message", "Mouse Cross ON: move mouse around",None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
            self.crossmouseid = self.fig.canvas.mpl_connect('motion_notify_event', self.drawcross)
        else:
            #turn OFF
            self.crossmarker = False
            if (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag))) and not self.designerflag:
                self.resetdeltalines()
            else:
                self.resetlines()
            self.fig.canvas.draw()
            self.updateBackground() # update bitlblit backgrounds
            message = QApplication.translate("Message", "Mouse cross OFF",None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
            self.fig.canvas.mpl_disconnect(self.crossmouseid)
            self.l_horizontalcrossline = None
            self.l_verticalcrossline = None

    def drawcross(self,event):
        if event.inaxes == self.ax:
            x = event.xdata 
            y = event.ydata
            if x and y:
                if self.l_horizontalcrossline == None:
                    self.l_horizontalcrossline, = self.ax.plot([self.startofx,self.endofx*2], [y,y],color = self.palette["text"], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                else:
                    self.l_horizontalcrossline.set_data([self.startofx,self.endofx*2], [y,y])
                if self.l_verticalcrossline == None:
                    self.l_verticalcrossline, = self.ax.plot([x,x], [self.ylimit_min,self.ylimit],color = self.palette["text"], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                else:
                    self.l_verticalcrossline.set_data([x,x], [self.ylimit_min,self.ylimit])
                if self.ax_background:
                    self.fig.canvas.restore_region(self.ax_background)
                    aw.qmc.ax.draw_artist(self.l_horizontalcrossline)
                    aw.qmc.ax.draw_artist(self.l_verticalcrossline)
                    self.fig.canvas.blit(aw.qmc.ax.bbox)
                else:
                    self.fig.canvas.draw()
        elif event.inaxes == self.delta_ax:
            x = event.xdata 
            y = event.ydata
            if x and y:
                if self.l_horizontalcrossline == None:
                    self.l_horizontalcrossline, = self.delta_ax.plot([self.startofx,self.endofx*2], [y,y], color = self.palette["text"], linestyle = '-', linewidth = .5, alpha = 1.0,sketch_params=None,path_effects=[])
                else:
                    self.l_horizontalcrossline.set_data([self.startofx,self.endofx*2], [y,y])
                if self.l_verticalcrossline == None:
                    self.l_verticalcrossline, = self.delta_ax.plot([x,x], [self.zlimit_min,self.zlimit], color = self.palette["text"], linestyle = '-', linewidth = .5, alpha = 1.0,sketch_params=None,path_effects=[])
                else:
                    self.l_verticalcrossline.set_data([x,x], [self.zlimit_min,self.zlimit])
                if self.ax_background:
                    self.fig.canvas.restore_region(self.ax_background)
                    aw.qmc.delta_ax.draw_artist(self.l_horizontalcrossline)
                    aw.qmc.delta_ax.draw_artist(self.l_verticalcrossline)
                    self.fig.canvas.blit(aw.qmc.delta_ax.bbox)
                else:
                    self.fig.canvas.draw()


#######################################################################################
#####   temporary hack for windows till better solution found about toolbar icon problem with py2exe and svg
#######################################################################################

# changed "NavigationToolbar" for "VMToolbar" in ApplicationWindow

class VMToolbar(NavigationToolbar):
    def __init__(self, plotCanvas, parent):
        self.toolitems = (
            ('Home', 'Reset original view', 'home', 'home'),
            ('Back', 'Back to  previous view', 'back', 'back'),
            ('Forward', 'Forward to next view', 'forward', 'forward'),
            (None, None, None, None),
            ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'),
            ('Zoom', 'Zoom to rectangle', 'zoom_to_rect', 'zoom'),
        )

        NavigationToolbar.__init__(self, plotCanvas, parent)

        self.update_view_org = self._update_view
        self._update_view = self.update_view_new
        self.draw_org = self.draw
        self.draw = self.draw_new

    # monkey patch matplotlib navigationbar zoom and pan to update background cache
    def draw_new(self):
        self.draw_org()
        aw.qmc.updateBackground()

    # monkey patch matplotlib navigationbar zoom and pan to update background cache
    def update_view_new(self):
        self.update_view_org()
        aw.qmc.updateBackground()

    def _icon(self, name):
        #dirty hack to prefer .svg over .png Toolbar icons
        if platf == 'Windows':
            p = os.path.join(self.basedir, name.replace('.svg','.png'))
        else:
            p = os.path.join(self.basedir, name.replace('.png','.svg'))
        if os.path.exists(p):
            return QIcon(p)
        else:
            return QIcon(os.path.join(self.basedir, name))

    def edit_parameters(self):
        allaxes = self.canvas.figure.get_axes()
        if len(allaxes) == 1:
            axes = allaxes[0]
        else:
            titles = []
            two_ax_mode = (aw.qmc.DeltaETflag or aw.qmc.DeltaBTflag or (aw.qmc.background and (aw.qmc.DeltaETBflag or aw.qmc.DeltaBTBflag))) and not aw.qmc.designerflag
            if aw.qmc.flagstart:
                # temporary set the axis to get proper menu items (same code as in redraw)
                aw.qmc.ax.set_ylabel(aw.qmc.mode)
                aw.qmc.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "Time",None, QApplication.UnicodeUTF8)))
                if two_ax_mode:
                    aw.qmc.delta_ax.set_ylabel(aw.qmc.mode + aw.arabicReshape(QApplication.translate("Label", "/min", None, QApplication.UnicodeUTF8)))
            for axes in allaxes:
                title = axes.get_title()
                ylabel = axes.get_ylabel()
                if title:
                    fmt = u(QApplication.translate("Label","Curves",None, QApplication.UnicodeUTF8))
                    if ylabel:
                        fmt += " (%(ylabel)s)"
                elif ylabel:
                    fmt = u(QApplication.translate("Label","Delta Curves",None, QApplication.UnicodeUTF8)) + u(" (%(ylabel)s)")
                else:
                    fmt = "%(axes_repr)s"
                titles.append(fmt % dict(title = title,
                                     ylabel = ylabel,
                                     axes_repr = repr(axes)))
            if aw.qmc.flagstart:
                aw.qmc.ax.set_ylabel("")
                aw.qmc.ax.set_xlabel("")
                aw.qmc.ax.set_title("")
                if aw.qmc.delta_ax:
                    aw.qmc.delta_ax.set_ylabel("")
            item, ok = QInputDialog.getItem(self, 'Customize',
                                                  'Select axes:', titles,
                                                  0, False)
            if ok:
                axes = allaxes[titles.index(u(item))]
            else:
                return
        figureoptions.figure_edit(axes, self)
        aw.fetchCurveStyles()
        # the redraw is mostly necessary to force a redraw of the legend to reflect the changed colors/styles/labels
        aw.qmc.redraw(recomputeAllDeltas=False)


########################################################################################
###     Sample thread
########################################################################################

class SampleThread(QThread):
    def __init__(self,parent = None):
        super(SampleThread,self).__init__(parent)
        self.afterTP = False

    # input filter
    # if temp (the actual reading) is outside of the interval [tmin,tmax] or
    # a spike is detected, the previous value is repeated or if that happend already before, -1 is returned
    # note that here we assume that the actual measured temperature time/temp was not already added to the list of previous measurements timex/tempx
    def inputFilter(self,timex,tempx,time,temp,BT=False):
        try:
            #########################
            # a) detect overflows
            wrong_reading = 0
            if aw.qmc.minmaxLimits and (temp < aw.qmc.filterDropOut_tmin or temp > aw.qmc.filterDropOut_tmax):
                wrong_reading = 1
            #########################
            # b) detect spikes (on BT only after CHARGE if autoChargeFlag=True not to have a conflict here)
            n = aw.qmc.filterDropOut_spikeRoR_period
            dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit # the limit of additional RoR in temp/sec (4C for C / 7F for F) compared to previous readings
            if aw.qmc.dropSpikes and ((not aw.qmc.autoChargeFlag) or (not BT) or (aw.qmc.timeindex[0] != -1 and (aw.qmc.timeindex[0] + n) < len(timex))) and not wrong_reading and len(tempx) >= n:
                # no min/max overflow detected
                # check if RoR caused by actual measurement is way higher then the previous one
                # calc previous RoR (pRoR) taking the last n samples into account
                pdtemp = tempx[-1] - tempx[-n]
                pdtime = timex[-1] - timex[-n]
                if pdtime > 0:
                    pRoR = abs(pdtemp/pdtime)
                    dtemp = tempx[-1] - temp
                    dtime = timex[-1] - time
                    if dtime > 0:
                        RoR = abs(dtemp/dtime)
                        if RoR > (pRoR + dRoR_limit):
                            wrong_reading = 2
#            #########################
#            # c) handle outliers if it could be detected
            if wrong_reading:
#                if wrong_reading == 1:
#                    aw.sendmessage(QApplication.translate("Message","Overflow detected",None, QApplication.UnicodeUTF8))
#                    pass
#                elif wrong_reading == 2:
#                    aw.sendmessage(QApplication.translate("Message","Spike detected",None, QApplication.UnicodeUTF8))
#                # simple repeat strategy (should alternate between repeat-previous and keep-RoR strategy
                #m = aw.qmc.filterDropOut_replaceRoR_period
                if len(tempx) > 0 and tempx[-1] != -1:
                    # repeate last correct reading if not done before in the last two fixes (min/max violation are always filtered)
                    if len(tempx) == 1 or (len(tempx) > 3 and (tempx[-1] != tempx[-2] or tempx[-2] != tempx[-3])):
                        return tempx[-1]
                    else:
                        if wrong_reading == 1:
                            return -1
                        else:
                            # no way to correct this
                            return temp
                else:
                    if wrong_reading == 1:
                        return -1
                    else:
                        # no way to correct this
                        return temp
            else:
                # try to improve a previously corrected reading timex/temp[-1] based on the current reading time/temp (just in this case the actual reading is not a drop)
                if len(tempx) > 2 and tempx[-1] == tempx[-2] and tempx[-1] != temp: # previous reading was a drop and replaced by reading[-2]
                    tempx[-1] = (tempx[-2] + temp) / 2.0
                return temp                
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " filterDropOuts() %1").arg(str(e)),exc_tb.tb_lineno)            
            return temp

    def sample_main_device(self):
        #read time, ET (t1) and BT (t2) TEMPERATURE
        try:
            if aw.qmc.swapETBT:
                tx,t2,t1 = aw.ser.devicefunctionlist[aw.qmc.device]()  #use a list of functions (a different one for each device) with index aw.qmc.device
                return tx,t1,t2
            else:
                return aw.ser.devicefunctionlist[aw.qmc.device]()  #use a list of functions (a different one for each device) with index aw.qmc.device
        except:
            tx = aw.qmc.timeclock.elapsed()/1000.
            return tx,-1,-1
    
    def sample_extra_device(self,i):
        try:
            return aw.extraser[i].devicefunctionlist[aw.qmc.extradevices[i]]()
        except:
            tx = aw.qmc.timeclock.elapsed()/1000.
            return tx,-1,-1

    def compute_delta(self, times, temps, n):
        """Compute a tempurature delta using numpy's polyfit with degree 1.

        The latest n values from times and temps are used.  This returns a
        least-squares linear fit of the series. The result's units are degrees
        per minute.
        """
        n = min(n, len(times), len(temps))
        if n <= 0: return 0
        xs = times[-n:]
        ys = temps[-n:]

        # Remove NaNs from input
        if sys.version < '3':
            r = xrange(n - 1, -1, -1)
        else:
            r = range(n - 1, -1, -1)
        for i in r:
            if math.isnan(ys[i]):
                ys[i:i+1] = []
                xs[i:i+1] = []
        if not ys:  # All NaNs
            return 0

        fit = numpy.polyfit(xs, ys, 1)
        return fit[0] * 60

    # sample devices at interval self.delay miliseconds.
    # we can assume within the processing of sample() that flagon=True
    def sample(self):
        try:
            ##### lock resources  #########
            #aw.qmc.samplingsemaphore.acquire(1)
            gotlock = aw.qmc.samplingsemaphore.tryAcquire(1,200) # we try to catch a lock for 200ms, if we fail we just skip this sampling round (prevents stacking of waiting calls)
            if gotlock:
                
                # duplicate system state flag flagstart locally and only refer to this copies within this function to make it behaving uniquely (either append or overwrite mode)
                local_flagstart = aw.qmc.flagstart
                
                # if we are not yet recording, but sampling we keep on reseting the timer (only if not already a profile was recorded)
                if not local_flagstart and len(aw.qmc.timex) < 2:
                    aw.qmc.timeclock.start()
                    
                # send sampling action if any                
                try:
                    a = aw.qmc.extrabuttonactions[2]
                    aw.eventaction((a if (a < 3) else a + 1),aw.qmc.extrabuttonactionstrings[2])
                except:
                    pass
                    
                #if using a meter (thermocouple device)
                if aw.qmc.device != 18: # not NONE device
                
                    #### first retrieve readings from the main device
                    timeBeforeETBT = libtime.time() # the time before sending the request to the main device
                    #read time, ET (t1) and BT (t2) TEMPERATURE
                    tx,t1,t2 = self.sample_main_device()
                    timeAfterETBT = libtime.time() # the time the data of the main device was received
                    ##############  if using Extra devices
                    nxdevices = len(aw.qmc.extradevices)
                    if nxdevices:
                        les,led,let =  len(aw.extraser),len(aw.qmc.extradevices),len(aw.qmc.extratemp1)
                        if les == led == let:
                            xtra_dev_lines1 = 0
                            xtra_dev_lines2 = 0
                            for i in range(nxdevices):
                                extratx,extrat2,extrat1 = self.sample_extra_device(i)
                                if aw.qmc.extramathexpression1[i] != None and len(aw.qmc.extramathexpression1[i]):
                                    extrat1 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression1[i],extrat1,extratx)
                                if aw.qmc.extramathexpression2[i] != None and len(aw.qmc.extramathexpression2[i]):
                                    extrat2 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression2[i],extrat2,extratx)
                                # if modbus device do the C/F conversion if needed (done after mathexpression, not to mess up with x/10 formulas)
                                # modbus channel 1+2, respect input temperature scale setting
                                if aw.qmc.extradevices[i] == 29:
                                    if aw.modbus.input1mode == "C" and aw.qmc.mode == "F":
                                        extrat1 = aw.qmc.fromCtoF(extrat1)
                                    elif aw.modbus.input1mode == "F" and aw.qmc.mode == "C":
                                        extrat1 = aw.qmc.fromFtoC(extrat1)
                                    if aw.modbus.input2mode == "C" and aw.qmc.mode == "F":
                                        extrat2 = aw.qmc.fromCtoF(extrat2)
                                    elif aw.modbus.input2mode == "F" and aw.qmc.mode == "C":
                                        extrat2 = aw.qmc.fromFtoC(extrat2) 
                                # modbus channel 3+4, respect input temperature scale setting
                                if aw.qmc.extradevices[i] == 33:
                                    if aw.modbus.input3mode == "C" and aw.qmc.mode == "F":
                                        extrat1 = aw.qmc.fromCtoF(extrat1)
                                    elif aw.modbus.input3mode == "F" and aw.qmc.mode == "C":
                                        extrat1 = aw.qmc.fromFtoC(extrat1)
                                    if aw.modbus.input4mode == "C" and aw.qmc.mode == "F":
                                        extrat2 = aw.qmc.fromCtoF(extrat2)
                                    elif aw.modbus.input4mode == "F" and aw.qmc.mode == "C":
                                        extrat2 = aw.qmc.fromFtoC(extrat2)                                
                                if aw.qmc.extradevices[i] != 25: # don't apply input filters to virtual devices
                                    extrat1 = self.inputFilter(aw.qmc.extratimex[i],aw.qmc.extratemp1[i],extratx,extrat1)
                                    extrat2 = self.inputFilter(aw.qmc.extratimex[i],aw.qmc.extratemp2[i],extratx,extrat2)                                    
                                if local_flagstart:
                                    aw.qmc.extratemp1[i].append(float(extrat1))
                                    aw.qmc.extratemp2[i].append(float(extrat2))
                                    aw.qmc.extratimex[i].append(extratx)
                                    # update extra lines
                                    if aw.extraCurveVisibility1[i] and len(aw.qmc.extratemp1lines) > xtra_dev_lines1:
                                        aw.qmc.extratemp1lines[xtra_dev_lines1].set_data(aw.qmc.extratimex[i], aw.qmc.extratemp1[i])
                                        xtra_dev_lines1 = xtra_dev_lines1 + 1
                                    if aw.extraCurveVisibility2[i] and len(aw.qmc.extratemp2lines) > xtra_dev_lines2:
                                        aw.qmc.extratemp2lines[xtra_dev_lines2].set_data(aw.qmc.extratimex[i], aw.qmc.extratemp2[i])
                                        xtra_dev_lines2 = xtra_dev_lines2 + 1
                                else:
                                    # we do not record, so we just replace the old last value
                                    if len(aw.qmc.extratemp1[i]) > 0:
                                        aw.qmc.extratemp1[i][-1] = float(extrat1)
                                    else:
                                        aw.qmc.extratemp1[i].append(float(extrat1))
                                    if len(aw.qmc.extratemp2[i]) > 0:
                                        aw.qmc.extratemp2[i][-1] = float(extrat2)
                                    else:
                                        aw.qmc.extratemp2[i].append(float(extrat2))
                                    if len(aw.qmc.extratimex[i]) <= 0:
                                        aw.qmc.extratimex[i].append(extratx)
                        #ERROR FOUND
                        else:
                            lengths = [les,led,let]
                            location = ["Extra-Serial","Extra-Devices","Extra-Temp"]
                            #find error
                            if (nxdevices-1) in lengths:
                                indexerror =  lengths.index(nxdevices-1)
                            elif (nxdevices+1) in lengths:
                                indexerror =  lengths.index(nxdevices+1)
                            else:
                                indexerror = 1000
                            if indexerror != 1000:
                                errormessage = "ERROR: length of %s (=%i) does not have the necessary length (=%i)"%(location[indexerror],lengths[indexerror],nxdevices)
                                errormessage += "\nPlease Reset: Extra devices"
                            else:
                                string = location[0] + "= " + str(lengths[0]) + " " + location[1] + "= " + str(lengths[1]) + " "
                                string += location[2] + "= " + str(lengths[2])
                                errormessage = "ERROR: extra devices lengths don't match: %s"%string
                                errormessage += "\nPlease Reset: Extra devices"
                            raise Exception(errormessage)
                    timeAfterExtra = libtime.time() # the time the data of all extra devices was received
                    if aw.qmc.oversampling and aw.qmc.delay >= aw.qmc.oversampling_min_delay:
                        # send another sampling action if any
                        try:
                            a = aw.qmc.extrabuttonactions[2]
                            aw.eventaction((a if (a < 3) else a + 1),aw.qmc.extrabuttonactionstrings[2])
                        except:
                            pass
                        # let's do the oversampling thing and take a second reading from the main device
                        sampling_interval = aw.qmc.delay/1000.
#                        remaining_time = sampling_interval - (timeAfterExtra - timeBeforeETBT)
                        etbt_time = timeAfterETBT - timeBeforeETBT
                        gone = timeAfterExtra - timeBeforeETBT
                        # only do it if there is enough time to do the ET/BT sampling (which takes etbt_time) 
                        # and only half of the sampling interval is gone
                        if (sampling_interval - gone) > etbt_time and gone < (sampling_interval / 2.0):
                            # place the second ET/BT sampling in the middle of the sampling interval
                            libtime.sleep((sampling_interval / 2.0) - gone)
                            tx_2,t1_2,t2_2 = self.sample_main_device()
                            tx = tx + (tx_2 - tx) / 2.0
                            t2 = (t2 + t2_2) / 2.0
                            t1 = (t1 + t1_2) / 2.0
                    ####### all values retrieved
                    if aw.qmc.ETfunction != None and len(aw.qmc.ETfunction):
                        t1 = aw.qmc.eval_math_expression(aw.qmc.ETfunction,t1,tx)
                    if aw.qmc.BTfunction != None and len(aw.qmc.BTfunction):
                        t2 = aw.qmc.eval_math_expression(aw.qmc.BTfunction,t2,tx)
                    # if modbus device do the C/F conversion if needed (done after mathexpression, not to mess up with x/10 formulas)
                    # modbus channel 1+2, respect input temperature scale setting
                    if aw.qmc.device == 29:
                        if aw.modbus.input1mode == "C" and aw.qmc.mode == "F":
                            t1 = aw.qmc.fromCtoF(t1)
                        elif aw.modbus.input1mode == "F" and aw.qmc.mode == "C":
                            t1 = aw.qmc.fromFtoC(t1)
                        if aw.modbus.input2mode == "C" and aw.qmc.mode == "F":
                            t2 = aw.qmc.fromCtoF(t2)
                        elif aw.modbus.input2mode == "F" and aw.qmc.mode == "C":
                            t2 = aw.qmc.fromFtoC(t2)
                    t1 = self.inputFilter(aw.qmc.timex,aw.qmc.temp1,tx,t1)
                    t2 = self.inputFilter(aw.qmc.timex,aw.qmc.temp2,tx,t2,True)
                    length_of_qmc_timex = len(aw.qmc.timex)
                    t1_final = t1
                    t2_final = t2
                    if local_flagstart:
                        aw.qmc.temp2.append(t2_final)
                        aw.qmc.temp1.append(t1_final)
                        aw.qmc.timex.append(tx)
                        length_of_qmc_timex += 1
                    else:
                        if len(aw.qmc.temp2) > 0:
                            aw.qmc.temp2[-1] = t2_final
                        else:
                            aw.qmc.temp2.append(t2_final)
                        if len(aw.qmc.temp1) > 0:
                            aw.qmc.temp1[-1] = t1_final
                        else:
                            aw.qmc.temp1.append(t1_final)
                        if length_of_qmc_timex <= 0:
                            aw.qmc.timex.append(tx)
                            length_of_qmc_timex += 1
                        else:
                            aw.qmc.timex[-1] = tx
                    # update lines data using the lists with new data
                    if local_flagstart:
                        if aw.qmc.ETcurve:
                            aw.qmc.l_temp1.set_data(aw.qmc.timex, aw.qmc.temp1)
                        if aw.qmc.BTcurve:
                            aw.qmc.l_temp2.set_data(aw.qmc.timex, aw.qmc.temp2)
                    #we need a minimum of two readings to calculate rate of change
                    if local_flagstart and length_of_qmc_timex > 1:
#                        timed = aw.qmc.timex[-1] - aw.qmc.timex[-2]   #time difference between last two readings
#    #                    #calculate Delta T = (changeTemp/ChangeTime)*60. =  degress per minute;
#    #                    aw.qmc.rateofchange1 = ((aw.qmc.temp1[-1] - aw.qmc.temp1[-2])/timed)*60.  #delta ET (degress/minute)
#    #                    aw.qmc.rateofchange2 = ((aw.qmc.temp2[-1] - aw.qmc.temp2[-2])/timed)*60.  #delta  BT (degress/minute)
#                        # smooth BT and ET a bit for delta computations (replacing the above code without smoothing)
#                        # this might be not overly precise as time intervals between samples are not constant
#                        ETm1 = aw.qmc.temp1[-1]
#                        ETm2 = (aw.qmc.temp1[-3] + aw.qmc.temp1[-2] + aw.qmc.temp1[-1]) / 3.
#                        BTm1 = aw.qmc.temp2[-1]
#                        BTm2 = (aw.qmc.temp2[-3] + aw.qmc.temp2[-2] + aw.qmc.temp2[-1]) / 3.
#                        #calculate Delta T = (changeTemp/ChangeTime)*60. =  degress per minute;
#                        aw.qmc.rateofchange1 = ((ETm1 - ETm2)/timed)*60.  #delta ET (degress/minute)
#                        aw.qmc.rateofchange2 = ((BTm1 - BTm2)/timed)*60.  #delta  BT (degress/minute)
                        
                        # replaced above by taking the last and the butbutlast measurements to ensure a higher temperature resolution, reducing fluctuation
                        if aw.qmc.altsmoothing:
                            # Use numpy to compute a linear approximation for deltas:
                            aw.qmc.rateofchange1 = self.compute_delta(aw.qmc.timex, aw.qmc.temp1, aw.qmc.smoothingwindowsize)
                            aw.qmc.rateofchange2 = self.compute_delta(aw.qmc.timex, aw.qmc.temp2, aw.qmc.smoothingwindowsize)
                        else:
                            # Compute delta using the last two data points with:
                            left_index = max(2,(aw.qmc.deltasamples + 1))
                            timed = aw.qmc.timex[-1] - aw.qmc.timex[-left_index]   #time difference between last aw.qmc.deltasamples readings
                            #   Delta T = (changeTemp/ChangeTime)*60. =  degress per minute;
                            aw.qmc.rateofchange1 = ((aw.qmc.temp1[-1] - aw.qmc.temp1[-left_index])/timed)*60.  #delta ET (degress/minute)
                            aw.qmc.rateofchange2 = ((aw.qmc.temp2[-1] - aw.qmc.temp2[-left_index])/timed)*60.  #delta BT (degress/minute)



                        aw.qmc.unfiltereddelta1.append(aw.qmc.rateofchange1)
                        aw.qmc.unfiltereddelta2.append(aw.qmc.rateofchange2)

                        #######   filter deltaBT deltaET
                        # decay smoothing
                        if aw.qmc.deltafilter and not aw.qmc.altsmoothing:
                            user_filter = int(round(aw.qmc.deltafilter/2))                            
                            if user_filter and length_of_qmc_timex > user_filter and (len(aw.qmc.unfiltereddelta1) > user_filter) and (len(aw.qmc.unfiltereddelta2) > user_filter):
                                if self.decay_weights == None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = numpy.arange(1,user_filter+1)
                                aw.qmc.rateofchange1 = numpy.average(aw.qmc.unfiltereddelta1[-user_filter:],weights=self.decay_weights)
                                aw.qmc.rateofchange2 = numpy.average(aw.qmc.unfiltereddelta2[-user_filter:],weights=self.decay_weights)

    #                    # (deactivated due to the huge time lag and replaced by the above)
    #                    if aw.qmc.deltafilter:
    #                        if length_of_qmc_timex > aw.qmc.deltafilter:   #deltafilter is an int = number of pads
    #                            if (len(aw.qmc.unfiltereddelta1) > aw.qmc.deltafilter) and (len(aw.qmc.unfiltereddelta2) > aw.qmc.deltafilter):
    #                                a1,a2 = 0.,0.
    #                                for k in range(aw.qmc.deltafilter):
    #                                    a1 += aw.qmc.unfiltereddelta1[-(k+1)]
    #                                    a2 += aw.qmc.unfiltereddelta2[-(k+1)]
    #                                aw.qmc.rateofchange1 = a1/float(aw.qmc.deltafilter)
    #                                aw.qmc.rateofchange2 = a2/float(aw.qmc.deltafilter)
    #
# DEACTIVATED RoR min/max filter
#                        #if within limits append to RoR delta1 array, otherwise append None
#                        if aw.qmc.mode == "C":
#                            rorlimit = aw.qmc.RoRlimitC
#                        else:
#                            rorlimit = aw.qmc.RoRlimitF
#                        if -rorlimit < aw.qmc.rateofchange1 < rorlimit:
#                            rateofchange1plot = aw.qmc.rateofchange1
#                        else:
#                            rateofchange1plot = None
#                        if -rorlimit < aw.qmc.rateofchange2 < rorlimit:
#                            rateofchange2plot = aw.qmc.rateofchange2
#                        else:
#                            rateofchange2plot = None
# Instead we draw RoR only after the RoR filter fully applies
#                        if aw.qmc.deltafilter:
#                            user_filter = int(round(aw.qmc.deltafilter/2))
#                        else:
#                            user_filter = 0
                        if aw.qmc.timeindex[6]:
                            rateofchange1plot = None
                            rateofchange2plot = None
                        else:
                            rateofchange1plot = aw.qmc.rateofchange1
                            rateofchange2plot = aw.qmc.rateofchange2
                    else:
                        if local_flagstart:
                            aw.qmc.unfiltereddelta1.append(0.)
                            aw.qmc.unfiltereddelta2.append(0.)
                        else:
                            if len(aw.qmc.unfiltereddelta1) > 0:
                                aw.qmc.unfiltereddelta1[-1] = 0.
                            else:
                                aw.qmc.unfiltereddelta1.append(0.)
                            if len(aw.qmc.unfiltereddelta2) > 0:
                                aw.qmc.unfiltereddelta2[-1] = 0.
                            else:
                                aw.qmc.unfiltereddelta2.append(0.)
                        aw.qmc.rateofchange1,aw.qmc.rateofchange2,rateofchange1plot,rateofchange2plot = 0.,0.,0.,0.
                    # append new data to the rateofchange
                    if local_flagstart:
                        aw.qmc.delta1.append(rateofchange1plot)
                        aw.qmc.delta2.append(rateofchange2plot)
                    else:
                        if len(aw.qmc.delta1) > 0:
                            aw.qmc.delta1[-1] = rateofchange1plot
                        else:
                            aw.qmc.delta1.append(rateofchange1plot)
                        if len(aw.qmc.delta2) > 0:
                            aw.qmc.delta2[-1] = rateofchange2plot
                        else:
                            aw.qmc.delta2.append(rateofchange2plot)
                    if local_flagstart:
                        if aw.qmc.DeltaETflag:
                            aw.qmc.l_delta1.set_data(aw.qmc.timex, aw.qmc.delta1)
                        if aw.qmc.DeltaBTflag:
                            aw.qmc.l_delta2.set_data(aw.qmc.timex, aw.qmc.delta2)
                        #readjust xlimit of plot if needed
                        if  not aw.qmc.fixmaxtime and aw.qmc.timex[-1] > (aw.qmc.endofx - 45):            # if difference is smaller than 30 seconds
                            aw.qmc.endofx = int(aw.qmc.timex[-1] + 180.)         # increase x limit by 3 minutes
                            aw.qmc.xaxistosm(redraw=False) # don't redraw within the sampling process!!
                        if aw.qmc.projectFlag:
                            aw.qmc.updateProjection()
                        if aw.qmc.background and aw.qmc.backgroundReproduce:
                            aw.qmc.playbackevent()
                        # autodetect CHARGE event
                        # only if BT > 203F/95C
                        if not aw.qmc.autoChargeIdx and aw.qmc.autoChargeFlag and aw.qmc.timeindex[0] < 0 and length_of_qmc_timex >= 5 and \
                            ((aw.qmc.mode == "C" and aw.qmc.temp2[-1] > 95) or (aw.qmc.mode == "F" and aw.qmc.temp2[-1] > 203)):
                            if aw.BTbreak(length_of_qmc_timex - 1):
                                # we found a BT break at the current index minus 2
                                aw.qmc.autoChargeIdx = length_of_qmc_timex - 3
                        # check for TP event if already CHARGEed and not yet recognized (earliest in the next call to sample())
                        elif not aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[1] and aw.qmc.timeindex[0]+8 < len(aw.qmc.temp2) and self.checkTPalarmtime():
                            aw.qmc.autoTPIdx = 1
                            aw.qmc.TPalarmtimeindex = aw.findTP()
                        # autodetect DROP event
                        # only if 9min into roast and BT>180C/356F
                        if not aw.qmc.autoDropIdx and aw.qmc.autoDropFlag and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6] and \
                            length_of_qmc_timex >= 5 and ((aw.qmc.mode == "C" and aw.qmc.temp2[-1] > 170) or (aw.qmc.mode == "F" and aw.qmc.temp2[-1] > 338)) and\
                            ((aw.qmc.timex[-1] - aw.qmc.timex[aw.qmc.timeindex[0]]) > 480):
                            if aw.BTbreak(length_of_qmc_timex - 1):
                                # we found a BT break at the current index minus 2
                                aw.qmc.autoDropIdx = length_of_qmc_timex - 3
                        #check for autoDRY: # only after CHARGE and TP and before FCs if not yet set
                        if aw.qmc.autoDRYflag and aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[1] and not aw.qmc.timeindex[2]:
                            # if DRY event not yet set check for BT exceeding Dry-max as specified in the phases dialog
                            if aw.qmc.temp2[-1] >= aw.qmc.phases[1]:
                                aw.qmc.autoDryIdx = 1
                        #check for autoFCs: # only after CHARGE and TP and before FCe if not yet set
                        if aw.qmc.autoFCsFlag and aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[2] and not aw.qmc.timeindex[3]:
                            # after DRY (if FCs event not yet set) check for BT exceeding FC-min as specified in the phases dialog
                            if aw.qmc.temp2[-1] >= aw.qmc.phases[2]:
                                aw.qmc.autoFCsIdx = 1

                    #process active quantifiers
                    try:
                        for i in range(4):
                            if aw.eventquantifieractive[i]:
                                temp,_ = aw.quantifier2tempandtime(i)
                                if temp: # corresponding curve is available
                                    linespace = aw.eventquantifierlinspaces[i]
                                    if aw.eventquantifiercoarse[i]:
                                        linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdcoarse
                                    else:
                                        linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdfine                        
                                    t = temp[-1]
                                    d = aw.digitize(t,linespace,aw.eventquantifiercoarse[i])
                                    ld = aw.lastdigitizedvalue[i]
                                    lt = aw.lastdigitizedtemp[i]
                                    if d != None and (ld == None or ld != d):
                                        # and only if significantly different than previous to avoid fluktuation
                                        if ld == None or linespacethreshold < abs(t - lt):
                                            # establish this one
                                            aw.lastdigitizedvalue[i] = d
                                            aw.lastdigitizedtemp[i] = t
                                            # now move corresponding slider and add event
                                            v = d * 10.
                                            aw.qmc.quantifiedEvent.append([i,v])
                    except Exception:
                        pass
                        
                    #update SV on Arduino/TC4 if in Ramp/Soak or Background Follow mode and PID is active
                    if aw.qmc.device == 19 and aw.arduino.pidActive and aw.arduino.svMode in [1,2]:
                        # calculate actual SV
                        sv = aw.arduino.calcSV(tx)
                        # update SV (if needed)
                        if sv != None and sv != aw.arduino.sv:
                            aw.arduino.setSV(sv)

                    #check for each alarm that was not yet triggered
                    for i in range(len(aw.qmc.alarmflag)):
                        #if alarm on, and not triggered, and time is after set time:
                        # menu: 0:ON, 1:START, 2:CHARGE, 3:TP, 4:DRY, 5:FCs, 6:FCe, 7:SCs, 8:SCe, 9:DROP, 10:COOL
                        # qmc.alarmtime = -1 (None == START)
                        # qmc.alarmtime = 0 (CHARGE)
                        # qmc.alarmtime = 1 (DRY)
                        # qmc.alarmtime = 2 (FCs)
                        # qmc.alarmtime = 3 (FCe)
                        # qmc.alarmtime = 4 (SCs)
                        # qmc.alarmtime = 5 (SCe)
                        # qmc.alarmtime = 6 (DROP)
                        # qmc.alarmtime = 7 (COOL)
                        # qmc.alarmtime = 8 (TP)
                        # qmc.alarmtime = 9 (ON)
                        # Cases: (only between CHARGE and DRY we check for TP if alarmtime[i]=8)
                        # 1) the alarm is START
                        # 2) the alarm was not triggered yet
                        # 3) the alarm From is ON
                        # 4) the alarm From is CHARGE
                        # 5) the alarm From is any other event but TP
                        # 6) the alarm From is TP, it is CHARGED and the TP pattern is recognized
                        if aw.qmc.alarmflag[i] \
                          and not aw.qmc.alarmstate[i] \
                          and (aw.qmc.alarmguard[i] < 0 or (0 <= aw.qmc.alarmguard[i] < len(aw.qmc.alarmflag) and aw.qmc.alarmstate[aw.qmc.alarmguard[i]])) \
                          and (aw.qmc.alarmnegguard[i] < 0 or (0 <= aw.qmc.alarmnegguard[i] < len(aw.qmc.alarmnflag) and not aw.qmc.alarmstate[aw.qmc.alarmnegguard[i]])) \
                          and ((aw.qmc.alarmtime[i] == 9) or (aw.qmc.alarmtime[i] < 0 and local_flagstart) \
                          or (aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1) \
                          or (aw.qmc.alarmtime[i] > 0 and aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0) \
                          or (aw.qmc.alarmtime[i]==8 and aw.qmc.timeindex[0] > -1 \
                                and aw.qmc.TPalarmtimeindex)):
                            #########
                            # check alarmoffset (time after From event):
                            if aw.qmc.alarmoffset[i] > 0:
                                alarm_time = aw.qmc.timeclock.elapsed()/1000.
                                if aw.qmc.alarmtime[i] < 0: # time after START
                                    pass # the alarm_time is the clock time
                                elif aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1: # time after CHARGE
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.timeindex[0]]
                                elif aw.qmc.alarmtime[i] == 8 and aw.qmc.TPalarmtimeindex: # time after TP
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.TPalarmtimeindex]
                                elif aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0: # time after any other event
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.timeindex[aw.qmc.alarmtime[i]]]
                                if alarm_time >= aw.qmc.alarmoffset[i]:
                                    aw.qmc.temporaryalarmflag = i
                            #########
                            # check alarmtemp:
                            alarm_temp = None
                            if aw.qmc.alarmsource[i] == -2 and aw.qmc.delta1[-1]:  #check DeltaET (might be None)
                                alarm_temp = aw.qmc.delta1[-1]
                            elif aw.qmc.alarmsource[i] == -1 and aw.qmc.delta2[-1]: #check DeltaBT (might be None
                                alarm_temp = aw.qmc.delta2[-1]
                            elif aw.qmc.alarmsource[i] == 0:                      #check ET
                                alarm_temp = aw.qmc.temp1[-1]
                            elif aw.qmc.alarmsource[i] == 1:                      #check BT
                                alarm_temp = aw.qmc.temp2[-1]
                            elif aw.qmc.alarmsource[i] > 1 and ((aw.qmc.alarmsource[i] - 2) < (2*len(aw.qmc.extradevices))):
                                if (aw.qmc.alarmsource[i])%2==0:
                                    alarm_temp = aw.qmc.extratemp1[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                else:
                                    alarm_temp = aw.qmc.extratemp2[(aw.qmc.alarmsource[i] - 2)//2][-1]
                            alarm_limit = aw.qmc.alarmtemperature[i]
                            if alarm_temp != None and ((aw.qmc.alarmcond[i] == 1 and alarm_temp > alarm_limit) or (aw.qmc.alarmcond[i] == 0 and alarm_temp < alarm_limit)):
                                aw.qmc.temporaryalarmflag = i
                #############    if using DEVICE 18 (no device). Manual mode
                # temperatures are entered when pressing push buttons like for example at aw.qmc.markDryEnd()
                else:
                    tx = int(aw.qmc.timeclock.elapsed()/1000.)
                    #readjust xlimit of plot if needed
                    if  not aw.qmc.fixmaxtime and tx > (aw.qmc.endofx - 45):            # if difference is smaller than 45 seconds
                        aw.qmc.endofx = tx + 180              # increase x limit by 3 minutes (180)
                        aw.qmc.ax.set_xlim(aw.qmc.startofx,aw.qmc.endofx)
                        aw.qmc.xaxistosm(redraw=False) # don't redraw within the sampling process!!
                    #aw.qmc.resetlines()
                    #add to plot a vertical time line
                    aw.qmc.l_timeline, = aw.qmc.ax.plot([tx,tx], [aw.qmc.ylimit_min,aw.qmc.ylimit],color = aw.qmc.palette["Cline"],linestyle = '-', linewidth= 1, alpha = .7,sketch_params=None,path_effects=[])
                    # also in the manual case we check for TP
                    if local_flagstart:
                        # check for TP event if already CHARGEed and not yet recognized
                        if not aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[0]+5 < len(aw.qmc.temp2) and self.checkTPalarmtime():
                            aw.qmc.autoTPIdx = 1
                            aw.qmc.TPalarmtimeindex = aw.findTP()
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " sample() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
            #update screen in main GUI thread
            self.emit(SIGNAL("updategraphics"))

    # returns true after BT passed the TP
    def checkTPalarmtime(self):
        # if v[-1] is the current temperature then check if
        #   len(BT) > 4
        # BT[-5] <= BT[-4] abd BT[-5] <= BT[-3] and BT[-5] <= BT[-2] and BT[-5] <= BT[-1] and BT[-5] < BT[-1]
        if not self.afterTP and len(aw.qmc.temp2) > 3 and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-4]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-3]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-2]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-1]) and (aw.qmc.temp2[-5] < aw.qmc.temp2[-1]):
            self.afterTP = True
        return self.afterTP

    def run(self):
        aw.qmc.flagsamplingthreadrunning = True
        if sys.platform.startswith("darwin"):
            pool = Foundation.NSAutoreleasePool.alloc().init()
        self.afterTP = False
        if not aw.qmc.flagon:
            return
        try:
            # initialize digitizer
            aw.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
            aw.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier
            while True:
                if aw.qmc.flagon:
                    start = libtime.time()
                    #tx = aw.qmc.timeclock.elapsed()
                    
                    #collect information
                    aw.qmc.flagsampling = True # we signal that we are sampling
                    self.sample()
                    aw.qmc.flagsampling = False # we signal that we are done with sampling
                    
                    # calculate the time still to sleep based on the time the sampling took and the requested sampling interval (qmc.delay)
                    dt = max(0.05,aw.qmc.delay/1000. - libtime.time() + start) # min of 1sec to allow for refresh the display
                    #dt = aw.qmc.delay/1000. # use this for fixed intervals
                    #apply sampling interval here
                    if aw.qmc.flagon:
                        libtime.sleep(dt)
                else:
                    aw.qmc.flagsampling = False # we signal that we are done with sampling
                    try:
                        if aw.ser.SP.isOpen():
                            aw.ser.closeport()
                        QApplication.processEvents()
                    except:
                        pass
                    self.quit()
                    break  #thread ends
        except:
            aw.qmc.flagsampling = False # we signal that we are done with sampling
        finally:
            aw.qmc.flagsamplingthreadrunning = False
            if sys.platform.startswith("darwin"):
                del pool

#########################################################################################################
###     Artisan thread Server
#########################################################################################################

class Athreadserver(QWidget):
    def __init__(self,parent = None):
        super(Athreadserver,self).__init__(parent)

    def createSampleThread(self):
        sthread = SampleThread(self)
        sthread.decay_weights = None
        #QApplication.processEvents()

        #delete when finished to save memory 
        self.connect(sthread,SIGNAL("finished"),sthread,SLOT("deleteLater()"))
        #connect graphics to GUI thread
        self.connect(sthread, SIGNAL("updategraphics"),aw.qmc.updategraphics)
        sthread.start()
        sthread.wait(300)    #needed in some Win OS


########################################################################################
#################### MAIN APPLICATION WINDOW ###########################################
########################################################################################

class ApplicationWindow(QMainWindow):
    def __init__(self, parent = None):

        self.defaultAppearance = None
        # matplotlib font properties:
        self.mpl_fontproperties = mpl.font_manager.FontProperties()
        self.full_screen_mode_active = False
        
        self.quickEventShortCut = None 
        # this is None if inactive, or holds a tuple (n,s) with n a number {1,..,4} indicating the custom event number
        # and s a string of length 0 (no digit yet), length 1 (if first digit is typed) or 2 (both digits are typed) indicating the value (00-99)
        
        #############################  Define variables that need to exist before calling settingsload()
        self.curFile = None
        self.MaxRecentFiles = 20
        self.recentFileActs = []
        self.applicationDirectory =  QDir().current().absolutePath()
        super(ApplicationWindow, self).__init__(parent)
        
        # large LCDs
        self.largeLCDs_dialog = None
        self.LargeLCDs = False
        self.WebLCDs = False
        self.WebLCDsPort = 8080
        self.WebLCDsAlerts = False


        #flag to reset Qsettings
        self.resetqsettings = 0

        # self.profilepath is obteined at dirstruct() and points to profiles/year/month file-open/save will point to profilepath
        self.profilepath = ""
        if platf == 'Darwin' or platf == 'Linux':
            self.profilepath = QDir().homePath().append(QString("/Documents/"))
        else:
            self.profilepath = QDir().homePath()
            
        # on the Mac preferences should be stored outside of applications in the users ~/Library/Preferences path
        if platf == 'Darwin':
            preference_path = QDir().homePath().append(QString("/Library/Preferences//"))
            preference_dir = QDir()
            preference_dir.setPath(preference_path)
            if not preference_dir.exists():
                QDir().mkpath(preference_path)
            QDir().setCurrent(preference_path)

        #checks executable directory. dirstruct() checks or creates: /profile/year/month directory to store profiles
        #self.dirstruct()


        #defaults the users profile path to the standard profilepath (incl. month/year subdirectories)
        self.userprofilepath = self.profilepath

        self.printer = QPrinter()
#        self.printer.setPageSize(QPrinter.Letter)
        self.printer.setCreator("Artisan")

        self.main_widget = QWidget(self)
        #set a minimum size (main window can be bigger but never smaller)
        self.main_widget.setMinimumWidth(811)
        #self.main_widget.setMinimumHeight(670)

        ####      create Matplotlib canvas widget
        #resolution
        self.defaultdpi = 100
        self.dpi = self.defaultdpi
        self.qmc = tgraphcanvas(self.main_widget)
        #self.qmc.setAttribute(Qt.WA_NoSystemBackground)

        ####    HUD
        self.HUD = QLabel()  #main canvas for hud widget
        self.HUD.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)

        #This is a list of different HUD functions.
        self.showHUD = [self.showHUDmetrics, self.showHUDthermal]
        #this holds the index of the HUD functions above
        self.HUDfunction = 0

#        self.sound = soundcrack(QWidget)
        self.stack = QStackedWidget()
        self.stack.addWidget(self.qmc)
        self.stack.addWidget(self.HUD)
#        self.stack.addWidget(self.sound)
        self.stack.setCurrentIndex(0)
        self.stack.setContentsMargins(0,0,0,0)
        self.qmc.setContentsMargins(0,0,0,0)
        self.HUD.setContentsMargins(0,0,0,0)
#        self.sound.setContentsMargins(0,0,0,0)
        #events config
        self.eventsbuttonflag = 1
        self.minieventsflag = 0   #minieditor flag

        #create a serial port object (main ET BT device)
        self.ser = serialport()
        #create a modbus port object (main modbus device)
        self.modbus = modbusport()
        #create scale port object
        self.scale = scaleport()
        #create color port object
        self.color = colorport()
        #list with extra serial ports (extra devices)
        self.extraser = []
        #extra comm port settings 
        self.extracomport,self.extrabaudrate,self.extrabytesize,self.extraparity,self.extrastopbits,self.extratimeout = [],[],[],[],[],[]

        # create a ET control objects
        self.fujipid = FujiPID()
        self.dtapid = DtaPID()
        self.arduino = ArduinoTC4()

        self.soundflag = 0

        #lcd1 = time, lcd2 = met, lcd3 = bt, lcd4 = roc et, lcd5 = roc bt, lcd6 = sv (extra devices lcd same as sv seetings)
        self.lcdpaletteB = {"timer":'black',"et":'black',"bt":'black',"deltaet":'black',"deltabt":'black',"sv":'black'}
        self.lcdpaletteF = {"timer":'white',"et":'white',"bt":'white',"deltaet":'white',"deltabt":'white',"sv":'yellow'}

        #user defined event buttons
        self.extraeventsbuttonsflag = 1  #shows/hides rows of buttons  0/1
        self.extraeventslabels,self.extraeventsdescriptions, self.extraeventstypes,self.extraeventsvalues = [],[],[],[]  #hold string,string,index,index
        self.extraeventbuttoncolor,self.extraeventbuttontextcolor = [],[]
        self.extraeventsactionstrings,self.extraeventsactions,self.extraeventsvisibility = [],[],[] #hold string,index,index

        #event sliders
        self.eventslidervalues = [0,0,0,0]
        self.eventslidervisibilities = [0,0,0,0]
        self.eventslideractions = [0,0,0,0] # 0: None, 1: Serial Command, 2: Modbus Command, 3: DTA Command
        self.eventslidercommands = ["","","",""]
        self.eventslideroffsets = [0,0,0,0]
        self.eventsliderfactors = [1.0,1.0,1.0,1.0]
        
        #event quantifiers        
        self.eventquantifieractive = [0,0,0,0]
        self.eventquantifiersource = [0,0,0,0]
        self.eventquantifiermin = [0,0,0,0]
        self.eventquantifiermax = [100,100,100,100]
        self.eventquantifiercoarse = [0,0,0,0]
        self.eventquantifierlinspaces = [self.computeLinespace(0),self.computeLinespace(1),self.computeLinespace(2),self.computeLinespace(3)]
        self.eventquantifiersteps = 10
        self.eventquantifierthresholdfine = 1.5
        self.eventquantifierthresholdcoarse = .5
        self.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
        self.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier

        # set window title
        self.windowTitle = "Artisan %s"%str(__version__)
        self.setWindowTitle(self.windowTitle)
        for i in range(self.MaxRecentFiles):
            self.recentFileActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentFile))

        #records serial comm (Help menu)
        self.seriallogflag = False
        self.seriallog = []

        #temp variable for text searches in Help menu artisan seetings
        self.searchtextartisansettings = ""

        #######################    MENUS SECTION ##################################################
        ###############  create Top MENUS

        self.fileMenu = self.menuBar().addMenu(UIconst.FILE_MENU)
        self.editMenu = self.menuBar().addMenu(UIconst.EDIT_MENU)
        self.GraphMenu = self.menuBar().addMenu(UIconst.ROAST_MENU)
        self.ConfMenu = self.menuBar().addMenu(UIconst.CONF_MENU)
        self.ToolkitMenu = self.menuBar().addMenu(UIconst.TOOLKIT_MENU)
        self.helpMenu = self.menuBar().addMenu(UIconst.HELP_MENU)

        #FILE menu
        newRoastAction = QAction(UIconst.FILE_MENU_NEW,self)

        newRoastAction.setShortcut(QKeySequence.New)
        self.connect(newRoastAction,SIGNAL("triggered()"),self.newRoast)
        self.fileMenu.addAction(newRoastAction)

        self.fileLoadAction = QAction(UIconst.FILE_MENU_OPEN,self)
        self.fileLoadAction.setShortcut(QKeySequence.Open)
        self.connect(self.fileLoadAction,SIGNAL("triggered()"),self.fileLoad)
        self.fileMenu.addAction(self.fileLoadAction)

        self.openRecentMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_OPENRECENT)
        for i in range(self.MaxRecentFiles):
            self.openRecentMenu.addAction(self.recentFileActs[i])
        self.updateRecentFileActions()

        self.importMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_IMPORT)

        fileImportCSVAction = QAction(QApplication.translate("Menu", "CSV...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileImportCSVAction,SIGNAL("triggered()"),self.fileImportCSV)
        self.importMenu.addAction(fileImportCSVAction)

        fileImportJSONAction = QAction(QApplication.translate("Menu", "JSON...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileImportJSONAction,SIGNAL("triggered()"),self.fileImportJSON)
        self.importMenu.addAction(fileImportJSONAction)

        fileImportRoastLoggerAction = QAction(QApplication.translate("Menu", "RoastLogger...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileImportRoastLoggerAction,SIGNAL("triggered()"),self.fileImportRoastLogger)
        self.importMenu.addAction(fileImportRoastLoggerAction)

        importHH506RAAction = QAction(QApplication.translate("Menu", "HH506RA...",None, QApplication.UnicodeUTF8),self)
        self.connect(importHH506RAAction,SIGNAL("triggered()"),self.importHH506RA)
        self.importMenu.addAction(importHH506RAAction)

        importK202Action = QAction(QApplication.translate("Menu", "K202...",None, QApplication.UnicodeUTF8),self)
        self.connect(importK202Action,SIGNAL("triggered()"),self.importK202)
        self.importMenu.addAction(importK202Action)

        importK204Action = QAction(QApplication.translate("Menu", "K204...",None, QApplication.UnicodeUTF8),self)
        self.connect(importK204Action,SIGNAL("triggered()"),self.importK204)
        self.importMenu.addAction(importK204Action)

        self.fileMenu.addSeparator()

        self.fileSaveAction = QAction(UIconst.FILE_MENU_SAVE,self)
        self.fileSaveAction.setShortcut(QKeySequence.Save)
        self.connect(self.fileSaveAction,SIGNAL("triggered()"),lambda b=0:self.fileSave(self.curFile))
        self.fileMenu.addAction(self.fileSaveAction)

        self.fileSaveAsAction = QAction(UIconst.FILE_MENU_SAVEAS,self)
        self.connect(self.fileSaveAsAction,SIGNAL("triggered()"),lambda b=0:self.fileSave(None))
        self.fileMenu.addAction(self.fileSaveAsAction)

        self.fileMenu.addSeparator()

        self.exportMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_EXPORT)

        fileExportCSVAction = QAction(QApplication.translate("Menu", "CSV...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileExportCSVAction,SIGNAL("triggered()"),self.fileExportCSV)
        self.exportMenu.addAction(fileExportCSVAction)

        fileExportJSONAction = QAction(QApplication.translate("Menu", "JSON...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileExportJSONAction,SIGNAL("triggered()"),self.fileExportJSON)
        self.exportMenu.addAction(fileExportJSONAction)

        fileExportRoastLoggerAction = QAction(QApplication.translate("Menu", "RoastLogger...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileExportRoastLoggerAction,SIGNAL("triggered()"),self.fileExportRoastLogger)
        self.exportMenu.addAction(fileExportRoastLoggerAction)

        self.fileMenu.addSeparator()

        self.saveGraphMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_SAVEGRAPH)

        fullsizeAction = QAction(UIconst.FILE_MENU_SAVEGRAPH_FULL_SIZE,self)
        self.connect(fullsizeAction,SIGNAL("triggered()"),lambda x=0,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(fullsizeAction)

        HukyForumAction = QAction("HukyForum.com (1200x?)...",self)
        self.connect(HukyForumAction,SIGNAL("triggered()"),lambda x=1200,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(HukyForumAction)

        KaffeeNetzAction = QAction("Kaffee-Netz.de (800x?)...",self)
        self.connect(KaffeeNetzAction,SIGNAL("triggered()"),lambda x=800,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(KaffeeNetzAction)

        HomeBaristaAction = QAction("Home-Barista.com (700x?)...",self)
        self.connect(HomeBaristaAction,SIGNAL("triggered()"),lambda x=700,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(HomeBaristaAction)

        RiktigtKaffeAction = QAction("RiktigtKaffe.se (620x?)...",self)
        self.connect(RiktigtKaffeAction,SIGNAL("triggered()"),lambda x=620,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(RiktigtKaffeAction)

        PlanetCafeAction = QAction("PlanetCafe.fr (600x?)...",self)
        self.connect(PlanetCafeAction,SIGNAL("triggered()"),lambda x=600,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(PlanetCafeAction)

        CoffeeGeekAction = QAction("CoffeeGeek.com (500x?)...",self)
        self.connect(CoffeeGeekAction,SIGNAL("triggered()"),lambda x=500,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(CoffeeGeekAction)
        
        SVGAction = QAction("SVG...",self)
        self.connect(SVGAction,SIGNAL("triggered()"),lambda _=None : self.saveVectorGraph(".svg"))
        self.saveGraphMenu.addAction(SVGAction)

        if platf != 'Darwin' or not mpl.__version__.startswith("1.2"):
            PDFAction = QAction("PDF...",self)
            self.connect(PDFAction,SIGNAL("triggered()"),lambda _=None : self.saveVectorGraph(".pdf"))
            self.saveGraphMenu.addAction(PDFAction)

        self.htmlAction = QAction(UIconst.FILE_MENU_HTMLREPORT,self)
        self.connect(self.htmlAction,SIGNAL("triggered()"),self.htmlReport)
        self.htmlAction.setShortcut("Ctrl+R")
        self.fileMenu.addAction(self.htmlAction)

        self.fileMenu.addSeparator()

        self.printAction = QAction(UIconst.FILE_MENU_PRINT,self)
        self.printAction.setShortcut(QKeySequence.Print)
        self.connect(self.printAction,SIGNAL("triggered()"),self.filePrint)
        self.fileMenu.addAction(self.printAction)
        
        self.quitAction = QAction(UIconst.FILE_MENU_QUIT,self)
        self.quitAction.setMenuRole(QAction.QuitRole)
        self.quitAction.setShortcut(QKeySequence.Quit)
        self.connect(self.quitAction,SIGNAL("triggered()"),self.fileQuit)
        self.fileMenu.addAction(self.quitAction)

        # EDIT menu
        self.cutAction = QAction(UIconst.EDIT_MENU_CUT,self)
        self.cutAction.setShortcut(QKeySequence.Cut)
        self.editMenu.addAction(self.cutAction)
        self.connect(self.cutAction,SIGNAL("triggered()"),self.on_actionCut_triggered)
        self.copyAction = QAction(UIconst.EDIT_MENU_COPY,self)
        self.copyAction.setShortcut(QKeySequence.Copy)
        self.editMenu.addAction(self.copyAction)
        self.connect(self.copyAction,SIGNAL("triggered()"),self.on_actionCopy_triggered)
        self.pasteAction = QAction(UIconst.EDIT_MENU_PASTE,self)
        self.pasteAction.setShortcut(QKeySequence.Paste)
        self.editMenu.addAction(self.pasteAction)
        self.connect(self.pasteAction,SIGNAL("triggered()"),self.on_actionPaste_triggered)

        # ROAST menu
        editGraphAction = QAction(UIconst.ROAST_MENU_PROPERTIES,self)
        self.connect(editGraphAction,SIGNAL("triggered()"),self.editgraph)
        self.GraphMenu.addAction(editGraphAction)

        backgroundAction = QAction(UIconst.ROAST_MENU_BACKGROUND,self)
        self.connect(backgroundAction,SIGNAL("triggered()"),self.background)
        self.GraphMenu.addAction(backgroundAction)

        self.flavorAction = QAction(UIconst.ROAST_MENU_CUPPROFILE,self)
        self.connect(self.flavorAction ,SIGNAL("triggered()"),self.flavorchart)
        self.GraphMenu.addAction(self.flavorAction)

        self.GraphMenu.addSeparator()

        self.temperatureMenu = self.GraphMenu.addMenu(UIconst.ROAST_MENU_TEMPERATURE)

        self.ConvertToFahrenheitAction = QAction(UIconst.ROAST_MENU_CONVERT_TO_FAHRENHEIT,self)
        self.connect(self.ConvertToFahrenheitAction,SIGNAL("triggered()"),lambda t="F":self.qmc.convertTemperature(t))
        self.temperatureMenu.addAction(self.ConvertToFahrenheitAction)

        self.ConvertToCelsiusAction = QAction(UIconst.ROAST_MENU_CONVERT_TO_CELSIUS,self)
        self.connect(self.ConvertToCelsiusAction,SIGNAL("triggered()"),lambda t="C":self.qmc.convertTemperature(t))
        self.temperatureMenu.addAction(self.ConvertToCelsiusAction)

        self.FahrenheitAction = QAction(UIconst.ROAST_MENU_FAHRENHEIT_MODE,self)
        self.connect(self.FahrenheitAction,SIGNAL("triggered()"),self.qmc.fahrenheitModeRedraw)
        self.temperatureMenu.addAction(self.FahrenheitAction)

        self.CelsiusAction = QAction(UIconst.ROAST_MENU_CELSIUS_MODE,self)
        self.connect(self.CelsiusAction,SIGNAL("triggered()"),self.qmc.celsiusModeRedraw)
        self.temperatureMenu.addAction(self.CelsiusAction)

        if self.qmc.mode == "F":
            self.FahrenheitAction.setDisabled(True)
            self.ConvertToFahrenheitAction.setDisabled(True)
        else:
            self.CelsiusAction.setDisabled(True)
            self.ConvertToCelsiusAction.setDisabled(True)

        self.GraphMenu.addSeparator()

        self.switchAction = QAction(UIconst.ROAST_MENU_SWITCH,self)
        self.switchAction.setShortcut(QKeySequence.Close)
        self.connect(self.switchAction,SIGNAL("triggered()"),self.switch)
        self.GraphMenu.addAction(self.switchAction)  

        # CONFIGURATION menu
        deviceAction = QAction(UIconst.CONF_MENU_DEVICE, self)
        self.connect(deviceAction,SIGNAL("triggered()"),self.deviceassigment)
        self.ConfMenu.addAction(deviceAction)

        commportAction = QAction(UIconst.CONF_MENU_SERIALPORT,self)
        self.connect(commportAction,SIGNAL("triggered()"),self.setcommport)
        self.ConfMenu.addAction(commportAction)

        calibrateDelayAction = QAction(UIconst.CONF_MENU_SAMPLING,self)
        self.connect(calibrateDelayAction,SIGNAL("triggered()"),self.calibratedelay)
        self.ConfMenu.addAction(calibrateDelayAction)

        self.oversamplingAction = QAction(UIconst.CONF_MENU_OVERSAMPLING,self)
        self.connect(self.oversamplingAction,SIGNAL("triggered()"),self.oversampling)
        self.oversamplingAction.setCheckable(True)
        self.oversamplingAction.setChecked(self.qmc.oversampling)
        self.ConfMenu.addAction(self.oversamplingAction)

        self.ConfMenu.addSeparator()

        eventsAction = QAction(UIconst.CONF_MENU_EVENTS,self)
        self.connect(eventsAction,SIGNAL("triggered()"),self.eventsconf)
        self.ConfMenu.addAction(eventsAction)

        alarmAction = QAction(UIconst.CONF_MENU_ALARMS,self)
        self.connect(alarmAction,SIGNAL("triggered()"),self.alarmconfig)
        self.ConfMenu.addAction(alarmAction) 

        self.ConfMenu.addSeparator()

        phasesGraphAction = QAction(UIconst.CONF_MENU_PHASES,self)
        self.connect(phasesGraphAction,SIGNAL("triggered()"),self.editphases)
        self.ConfMenu.addAction(phasesGraphAction)

        StatisticsAction = QAction(UIconst.CONF_MENU_STATISTICS,self)
        self.connect(StatisticsAction,SIGNAL("triggered()"),self.showstatistics)
        self.ConfMenu.addAction(StatisticsAction)

        WindowconfigAction = QAction(UIconst.CONF_MENU_AXES,self)
        self.connect(WindowconfigAction,SIGNAL("triggered()"),self.Windowconfig)
        self.ConfMenu.addAction(WindowconfigAction)

        self.ConfMenu.addSeparator()

        colorsAction = QAction(UIconst.CONF_MENU_COLORS,self)
        self.connect(colorsAction,SIGNAL("triggered()"),lambda x=3:self.qmc.changeGColor(x))
        self.ConfMenu.addAction(colorsAction)

        autosaveAction = QAction(UIconst.CONF_MENU_AUTOSAVE,self)
        self.connect(autosaveAction,SIGNAL("triggered()"),self.autosaveconf)
        self.ConfMenu.addAction(autosaveAction)

        self.ConfMenu.addSeparator()

        self.languageMenu = self.ConfMenu.addMenu(UIconst.CONF_MENU_LANGUAGE)

        self.EnglishLanguage = QAction(UIconst.CONF_MENU_ENGLISH,self)
        self.EnglishLanguage.setCheckable(True)
        self.connect(self.EnglishLanguage,SIGNAL("triggered()"),lambda lang="en":self.changelocale(lang))
        self.languageMenu.addAction(self.EnglishLanguage)
        if locale == "en" or locale == "en_US":
            self.EnglishLanguage.setChecked(True)

        self.GermanLanguage = QAction(UIconst.CONF_MENU_GERMAN,self)
        self.GermanLanguage.setCheckable(True)
        self.connect(self.GermanLanguage,SIGNAL("triggered()"),lambda lang="de":self.changelocale(lang))
        self.languageMenu.addAction(self.GermanLanguage)
        if locale == "de":
            self.GermanLanguage.setChecked(True)

        self.FrenchLanguage = QAction(UIconst.CONF_MENU_FRENCH,self)
        self.FrenchLanguage.setCheckable(True)
        self.connect(self.FrenchLanguage,SIGNAL("triggered()"),lambda lang="fr":self.changelocale(lang))
        self.languageMenu.addAction(self.FrenchLanguage)
        if locale == "fr":
            self.FrenchLanguage.setChecked(True)

        self.SpanishLanguage = QAction(UIconst.CONF_MENU_SPANISH,self)
        self.SpanishLanguage.setCheckable(True)
        self.connect(self.SpanishLanguage,SIGNAL("triggered()"),lambda lang="es":self.changelocale(lang))
        self.languageMenu.addAction(self.SpanishLanguage) 
        if locale == "es":
            self.SpanishLanguage.setChecked(True)

        self.SwedishLanguage = QAction(UIconst.CONF_MENU_SWEDISH,self)
        self.SwedishLanguage.setCheckable(True)
        self.connect(self.SwedishLanguage,SIGNAL("triggered()"),lambda lang="sv":self.changelocale(lang))
        self.languageMenu.addAction(self.SwedishLanguage) 
        if locale == "sv":
            self.SwedishLanguage.setChecked(True)

        self.ItalianLanguage = QAction(UIconst.CONF_MENU_ITALIAN,self)
        self.ItalianLanguage.setCheckable(True)
        self.connect(self.ItalianLanguage,SIGNAL("triggered()"),lambda lang="it":self.changelocale(lang))
        self.languageMenu.addAction(self.ItalianLanguage) 
        if locale == "it":
            self.ItalianLanguage.setChecked(True)

        self.ChineseChinaLanguage = QAction(UIconst.CONF_MENU_CHINESE_CN,self)
        self.ChineseChinaLanguage.setCheckable(True)
        self.connect(self.ChineseChinaLanguage,SIGNAL("triggered()"),lambda lang="zh_CN":self.changelocale(lang))
        self.languageMenu.addAction(self.ChineseChinaLanguage) 
        if locale == "zh_CN":
            self.ChineseChinaLanguage.setChecked(True)

        self.ChineseTaiwanLanguage = QAction(UIconst.CONF_MENU_CHINESE_TW,self)
        self.ChineseTaiwanLanguage.setCheckable(True)
        self.connect(self.ChineseTaiwanLanguage,SIGNAL("triggered()"),lambda lang="zh_TW":self.changelocale(lang))
        self.languageMenu.addAction(self.ChineseTaiwanLanguage) 
        if locale == "zh_TW":
            self.ChineseTaiwanLanguage.setChecked(True)

        self.GreekLanguage = QAction(UIconst.CONF_MENU_GREEK,self)
        self.GreekLanguage.setCheckable(True)
        self.connect(self.GreekLanguage,SIGNAL("triggered()"),lambda lang="el":self.changelocale(lang))
        self.languageMenu.addAction(self.GreekLanguage)
        if locale == "el":
            self.GreekLanguage.setChecked(True)

        self.NorwegianLanguage = QAction(UIconst.CONF_MENU_NORWEGIAN,self)
        self.NorwegianLanguage.setCheckable(True)
        self.connect(self.NorwegianLanguage,SIGNAL("triggered()"),lambda lang="no":self.changelocale(lang))
        self.languageMenu.addAction(self.NorwegianLanguage)
        if locale == "no":
            self.NorwegianLanguage.setChecked(True)

        self.DutchLanguage = QAction(UIconst.CONF_MENU_DUTCH,self)
        self.DutchLanguage.setCheckable(True)
        self.connect(self.DutchLanguage,SIGNAL("triggered()"),lambda lang="nl":self.changelocale(lang))
        self.languageMenu.addAction(self.DutchLanguage)
        if locale == "nl":
            self.DutchLanguage.setChecked(True)

        self.KoreanLanguage = QAction(UIconst.CONF_MENU_KOREAN,self)
        self.KoreanLanguage.setCheckable(True)
        self.connect(self.KoreanLanguage,SIGNAL("triggered()"),lambda lang="ko":self.changelocale(lang))
        self.languageMenu.addAction(self.KoreanLanguage)
        if locale == "ko":
            self.KoreanLanguage.setChecked(True)

        self.PortugueseLanguage = QAction(UIconst.CONF_MENU_PORTUGUESE,self)
        self.PortugueseLanguage.setCheckable(True)
        self.connect(self.PortugueseLanguage,SIGNAL("triggered()"),lambda lang="pt":self.changelocale(lang))
        self.languageMenu.addAction(self.PortugueseLanguage)
        if locale == "pt":
            self.PortugueseLanguage.setChecked(True)

        self.RussianLanguage = QAction(UIconst.CONF_MENU_RUSSIAN,self)
        self.RussianLanguage.setCheckable(True)
        self.connect(self.RussianLanguage,SIGNAL("triggered()"),lambda lang="ru":self.changelocale(lang))
        self.languageMenu.addAction(self.RussianLanguage)
        if locale == "ru":
            self.RussianLanguage.setChecked(True)

        self.ArabicLanguage = QAction(UIconst.CONF_MENU_ARABIC,self)
        self.ArabicLanguage.setCheckable(True)
        self.connect(self.ArabicLanguage,SIGNAL("triggered()"),lambda lang="ar":self.changelocale(lang))
        self.languageMenu.addAction(self.ArabicLanguage)
        if locale == "ar":
            self.ArabicLanguage.setChecked(True)

        self.FinishLanguage = QAction(UIconst.CONF_MENU_FINISH,self)
        self.FinishLanguage.setCheckable(True)
        self.connect(self.FinishLanguage,SIGNAL("triggered()"),lambda lang="fi":self.changelocale(lang))
        self.languageMenu.addAction(self.FinishLanguage)
        if locale == "fi":
            self.FinishLanguage.setChecked(True)

        self.TurkishLanguage = QAction(UIconst.CONF_MENU_TURKISH,self)
        self.TurkishLanguage.setCheckable(True)
        self.connect(self.TurkishLanguage,SIGNAL("triggered()"),lambda lang="tr":self.changelocale(lang))
        self.languageMenu.addAction(self.TurkishLanguage)
        if locale == "tr":
            self.TurkishLanguage.setChecked(True)

        self.JapaneseLanguage = QAction(UIconst.CONF_MENU_JAPANESE,self)
        self.JapaneseLanguage.setCheckable(True)
        self.connect(self.JapaneseLanguage,SIGNAL("triggered()"),lambda lang="ja":self.changelocale(lang))
        self.languageMenu.addAction(self.JapaneseLanguage)
        if locale == "ja":
            self.JapaneseLanguage.setChecked(True)

        self.HungarianLanguage = QAction(UIconst.CONF_MENU_HUNGARIAN,self)
        self.HungarianLanguage.setCheckable(True)
        self.connect(self.HungarianLanguage,SIGNAL("triggered()"),lambda lang="hu":self.changelocale(lang))
        self.languageMenu.addAction(self.HungarianLanguage)
        if locale == "hu":
            self.HungarianLanguage.setChecked(True)

        self.HebrewLanguage = QAction(UIconst.CONF_MENU_HEBREW,self)
        self.HebrewLanguage.setCheckable(True)
        self.connect(self.HebrewLanguage,SIGNAL("triggered()"),lambda lang="he":self.changelocale(lang))
        self.languageMenu.addAction(self.HebrewLanguage)
        if locale == "he":
            self.HebrewLanguage.setChecked(True)

        self.PolishLanguage = QAction(UIconst.CONF_MENU_POLISH,self)
        self.PolishLanguage.setCheckable(True)
        self.connect(self.PolishLanguage,SIGNAL("triggered()"),lambda lang="pl":self.changelocale(lang))
        self.languageMenu.addAction(self.PolishLanguage)
        if locale == "pl":
            self.PolishLanguage.setChecked(True)

        # TOOLKIT menu
        self.designerAction = QAction(UIconst.TOOLKIT_MENU_DESIGNER,self)
        self.connect(self.designerAction ,SIGNAL("triggered()"),self.designerTriggered)
        self.designerAction.setCheckable(True)
        self.designerAction.setChecked(self.qmc.designerflag)
        self.ToolkitMenu.addAction(self.designerAction)

        calculatorAction = QAction(UIconst.TOOLKIT_MENU_CALCULATOR,self)
        self.connect(calculatorAction,SIGNAL("triggered()"),self.calculator)
        self.ToolkitMenu.addAction(calculatorAction)

        self.wheeleditorAction = QAction(UIconst.TOOLKIT_MENU_WHEELGRAPH,self)
        self.connect(self.wheeleditorAction,SIGNAL("triggered()"),self.graphwheel)
        self.ToolkitMenu.addAction(self.wheeleditorAction)

        self.lcdsAction = QAction(UIconst.TOOLKIT_MENU_LCDS,self)
        self.connect(self.lcdsAction,SIGNAL("triggered()"),self.largeLCDs)
        self.ToolkitMenu.addAction(self.lcdsAction)

        self.ToolkitMenu.addSeparator()

        hudAction = QAction(UIconst.TOOLKIT_MENU_EXTRAS,self)
        self.connect(hudAction,SIGNAL("triggered()"),self.hudset)
        self.ToolkitMenu.addAction(hudAction)

        # HELP menu
        helpAboutAction = QAction(UIconst.HELP_MENU_ABOUT,self)
        helpAboutAction.setMenuRole(QAction.AboutRole)
        self.connect(helpAboutAction,SIGNAL("triggered()"),self.helpAbout)
        self.helpMenu.addAction(helpAboutAction)
        
        aboutQtAction = QAction(UIconst.HELP_MENU_ABOUTQT,self)
        aboutQtAction.setMenuRole(QAction.AboutRole)
        self.connect(aboutQtAction,SIGNAL("triggered()"),self.showAboutQt)
        self.helpMenu.addAction(aboutQtAction)

        helpDocumentationAction = QAction(UIconst.HELP_MENU_DOCUMENTATION,self)
        self.connect(helpDocumentationAction,SIGNAL("triggered()"),self.helpHelp)
        self.helpMenu.addAction(helpDocumentationAction)

        KshortCAction = QAction(UIconst.HELP_MENU_KEYBOARDSHORTCUTS,self)
        self.connect(KshortCAction,SIGNAL("triggered()"),self.viewKshortcuts)
        self.helpMenu.addAction(KshortCAction)

        self.helpMenu.addSeparator()

        errorAction = QAction(UIconst.HELP_MENU_ERRORS,self)
        self.connect(errorAction,SIGNAL("triggered()"),self.viewErrorLog)
        self.helpMenu.addAction(errorAction)

        messageAction = QAction(UIconst.HELP_MENU_MESSAGES,self)
        self.connect(messageAction,SIGNAL("triggered()"),self.viewMessageLog)
        self.helpMenu.addAction(messageAction)

        serialAction = QAction(UIconst.HELP_MENU_SERIAL,self)
        self.connect(serialAction,SIGNAL("triggered()"),self.viewSerialLog)
        self.helpMenu.addAction(serialAction)

        settingsAction = QAction(UIconst.HELP_MENU_SETTINGS,self)
        self.connect(settingsAction,SIGNAL("triggered()"),self.viewartisansettings)
        self.helpMenu.addAction(settingsAction)

        platformAction = QAction(UIconst.HELP_MENU_PLATFORM,self)
        self.connect(platformAction,SIGNAL("triggered()"),self.viewplatform)
        self.helpMenu.addAction(platformAction)

        self.helpMenu.addSeparator()

        self.resetAction = QAction(UIconst.HELP_MENU_RESET,self)
        self.connect(self.resetAction,SIGNAL("triggered()"),self.resetApplication)
        self.helpMenu.addAction(self.resetAction)

        ############################## WIDGETS SECTION ########################################

        #create a Label object to display program status information
        self.messagelabel = QLabel()
        self.messagelabel.setIndent(2)

        if locale == "es":
            self.pushbuttonstyles = {"DISABLED":"QPushButton {font-size: 12pt; font-weight: normal; color: darkgrey; background-color: lightgrey}",
                                     "STOP":"QPushButton {font-size: 12pt; font-weight: bold; color: lightgrey; background-color: #43d300}",
                                     "START":"QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: red}",
                                     "OFF":"QPushButton {font-size: 12pt; font-weight: bold; color: lightgrey; background-color: #43d300}",
                                     "ON":"QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: red }",
                                     "COOL END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                     "DRY END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                     "CHARGE":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #f07800 }",
                                     "FC START":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                     "FC END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                     "SC START":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                     "SC END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                     "RESET":"QPushButton {font-size: 12pt; font-weight: bold; color: black; background-color: white }",
                                     "HUD_OFF":"QPushButton {font-size: 12pt; font-weight: bold; color: white; background-color: #b5baff  }",
                                     "HUD_ON":"QPushButton {font-size: 12pt; font-weight: bold; color: white; background-color: #60ffed   }",
                                     "EVENT":"QPushButton {font-size: 10pt; font-weight: bold; color: black; background-color: yellow }",
                                     "DROP":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #f07800 }",
                                     "PID":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #92C3FF }",
                                     "PIDactive":"QPushButton {font-size: 10pt; font-weight: bold; color: yellow; background-color: #6D4824 }",
                                     "SV +":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #ffaaff }",
                                     "SV -":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: lightblue }",
                                     "SELECTED":"QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: #6D4824 }"  #keyboard moves
                                     }
        else:
            self.pushbuttonstyles = {"DISABLED":"QPushButton {font-size: 14pt; font-weight: normal; color: darkgrey; background-color: lightgrey}",
                                     "STOP":"QPushButton {font-size: 14pt; font-weight: bold; color: lightgrey; background-color: #43d300}",
                                     "START":"QPushButton {font-size: 14pt; font-weight: bold; color: yellow; background-color: red}",
                                     "OFF":"QPushButton {font-size: 14pt; font-weight: bold; color: lightgrey; background-color: #43d300}",
                                     "ON":"QPushButton {font-size: 14pt; font-weight: bold; color: yellow; background-color: red }",
                                     "COOL END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                     "DRY END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                     "CHARGE":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #f07800 }",
                                     "FC START":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                     "FC END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                     "SC START":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                     "SC END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                     "RESET":"QPushButton {font-size: 14pt; font-weight: bold; color: black; background-color: white }",
                                     "HUD_OFF":"QPushButton {font-size: 14pt; font-weight: bold; color: white; background-color: #b5baff  }",
                                     "HUD_ON":"QPushButton {font-size: 14pt; font-weight: bold; color: white; background-color: #60ffed   }",
                                     "EVENT":"QPushButton {font-size: 10pt; font-weight: bold; color: black; background-color: yellow }",
                                     "DROP":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #f07800 }",
                                     "PID":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #92C3FF }",
                                     "PIDactive":"QPushButton {font-size: 10pt; font-weight: bold; color: yellow; background-color: #6D4824 }",
                                     "SV +":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #ffaaff }",
                                     "SV -":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: lightblue }",
                                     "SELECTED":"QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: #6D4824 }"  #keyboard moves
                                     }

        #create ON/OFF buttons
        self.button_1 = QPushButton(QApplication.translate("Button", "ON", None, QApplication.UnicodeUTF8))
        self.button_1.setFocusPolicy(Qt.NoFocus)
        self.button_1.setToolTip(QApplication.translate("Tooltip", "Start monitoring", None, QApplication.UnicodeUTF8))
        self.button_1.setStyleSheet(self.pushbuttonstyles["OFF"])
        if locale in ["el", "no"]:
            self.button_1.setMinimumWidth(120)
            self.button_1.setMaximumSize(120, 45)
        else:
            self.button_1.setMinimumWidth(100)
            self.button_1.setMaximumSize(100, 45)
        self.connect(self.button_1, SIGNAL("clicked()"), self.qmc.ToggleMonitor)

        #create START/STOP buttons
        self.button_2 = QPushButton(QApplication.translate("Button", "START", None, QApplication.UnicodeUTF8))
        self.button_2.setFocusPolicy(Qt.NoFocus)
        self.button_2.setToolTip(QApplication.translate("Tooltip", "Start recording", None, QApplication.UnicodeUTF8))
        self.button_2.setStyleSheet(self.pushbuttonstyles["STOP"])
        if locale in ["el", "no"]:
            self.button_2.setMinimumWidth(120)
            self.button_2.setMaximumSize(120, 45)
        else:
            self.button_2.setMinimumWidth(100)
            self.button_2.setMaximumSize(100, 45)
        self.connect(self.button_2, SIGNAL("clicked()"), self.qmc.ToggleRecorder)

        #create 1C START, 1C END, 2C START and 2C END buttons
        self.button_3 = QPushButton(QApplication.translate("Button", "FC\nSTART", None, QApplication.UnicodeUTF8))
        self.button_3.setFocusPolicy(Qt.NoFocus)
        self.button_3.setStyleSheet(self.pushbuttonstyles["FC START"])
        self.button_3.setMinimumHeight(50)
        self.button_3.setToolTip(QApplication.translate("Tooltip", "Marks the begining of First Crack (FCs)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_3, SIGNAL("clicked()"), self.qmc.mark1Cstart)

        self.button_4 = QPushButton(QApplication.translate("Button", "FC\nEND", None, QApplication.UnicodeUTF8))
        self.button_4.setFocusPolicy(Qt.NoFocus)
        self.button_4.setStyleSheet(self.pushbuttonstyles["FC END"])
        self.button_4.setMinimumHeight(50)
        self.button_4.setToolTip(QApplication.translate("Tooltip", "Marks the end of First Crack (FCs)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_4, SIGNAL("clicked()"), self.qmc.mark1Cend)

        self.button_5 = QPushButton(QApplication.translate("Button", "SC\nSTART", None, QApplication.UnicodeUTF8))
        self.button_5.setFocusPolicy(Qt.NoFocus)
        self.button_5.setStyleSheet(self.pushbuttonstyles["SC START"])
        self.button_5.setMinimumHeight(50)
        self.button_5.setToolTip(QApplication.translate("Tooltip", "Marks the begining of Second Crack (SCs)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_5, SIGNAL("clicked()"), self.qmc.mark2Cstart)

        self.button_6 = QPushButton(QApplication.translate("Button", "SC\nEND", None, QApplication.UnicodeUTF8))
        self.button_6.setFocusPolicy(Qt.NoFocus)
        self.button_6.setStyleSheet(self.pushbuttonstyles["SC END"])
        self.button_6.setMinimumHeight(50)
        self.button_6.setToolTip(QApplication.translate("Tooltip", "Marks the end of Second Crack (SCe)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_6, SIGNAL("clicked()"), self.qmc.mark2Cend)

        #create RESET button
        self.button_7 = QPushButton(QApplication.translate("Button", "RESET", None, QApplication.UnicodeUTF8))
        self.button_7.setFocusPolicy(Qt.NoFocus)
        self.button_7.setStyleSheet(self.pushbuttonstyles["RESET"])
        if locale in ["el", "no"]:
            self.button_7.setMinimumWidth(120)
            self.button_7.setMaximumSize(120, 45)
        else:
            self.button_7.setMinimumWidth(100)
            self.button_7.setMaximumSize(100, 45)
        self.button_7.setToolTip(QApplication.translate("Tooltip", "Reset", None, QApplication.UnicodeUTF8))
        self.connect(self.button_7, SIGNAL("clicked()"), self.qmc.reset)

        #create CHARGE button
        self.button_8 = QPushButton(QApplication.translate("Button", "CHARGE", None, QApplication.UnicodeUTF8))
        self.button_8.setFocusPolicy(Qt.NoFocus)
        self.button_8.setStyleSheet(self.pushbuttonstyles["CHARGE"])
        self.button_8.setMinimumHeight(50)
        self.button_8.setToolTip(QApplication.translate("Tooltip", "Marks the begining of the roast (beans in)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_8, SIGNAL("clicked()"), self.qmc.markCharge)

        #create DROP button
        self.button_9 = QPushButton(QApplication.translate("Button", "DROP", None, QApplication.UnicodeUTF8))
        self.button_9.setFocusPolicy(Qt.NoFocus)
        self.button_9.setStyleSheet(self.pushbuttonstyles["DROP"])
        self.button_9.setMinimumHeight(50)
        self.button_9.setToolTip(QApplication.translate("Tooltip", "Marks the end of the roast (drop beans)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_9, SIGNAL("clicked()"), self.qmc.markDrop)

        #create PID control button
        self.button_10 = QPushButton(QApplication.translate("Button", "Control", None, QApplication.UnicodeUTF8))
        self.button_10.setFocusPolicy(Qt.NoFocus)
        self.button_10.setStyleSheet(self.pushbuttonstyles["PID"])
        self.button_10.setMaximumSize(90, 45)
        self.connect(self.button_10, SIGNAL("clicked()"), self.PIDcontrol)

        #create EVENT record button
        self.button_11 = QPushButton(QApplication.translate("Button", "EVENT", None, QApplication.UnicodeUTF8))
        self.button_11.setFocusPolicy(Qt.NoFocus)
        self.button_11.setStyleSheet(self.pushbuttonstyles["EVENT"])
        self.button_11.setMinimumHeight(50)
        self.button_11.setToolTip(QApplication.translate("Tooltip", "Marks an Event", None, QApplication.UnicodeUTF8))
        self.connect(self.button_11, SIGNAL("clicked()"), self.qmc.EventRecord)

        #create PID+5 button
        self.button_12 = QPushButton(QApplication.translate("Button", "SV +5", None, QApplication.UnicodeUTF8))
        self.button_12.setFocusPolicy(Qt.NoFocus)
        self.button_12.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_12.setMaximumSize(90, 50)
        self.button_12.setMinimumHeight(50)
        self.button_12.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 5", None, QApplication.UnicodeUTF8))

        #create PID+10 button
        self.button_13 = QPushButton(QApplication.translate("Button", "SV +10", None, QApplication.UnicodeUTF8))
        self.button_13.setFocusPolicy(Qt.NoFocus)
        self.button_13.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_13.setMaximumSize(90, 50)
        self.button_13.setMinimumHeight(50)
        self.button_13.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 10", None, QApplication.UnicodeUTF8))

        #create PID+20 button
        self.button_14 = QPushButton(QApplication.translate("Button", "SV +20", None, QApplication.UnicodeUTF8))
        self.button_14.setFocusPolicy(Qt.NoFocus)
        self.button_14.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_14.setMaximumSize(90, 50)
        self.button_14.setMinimumHeight(50)
        self.button_14.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 20", None, QApplication.UnicodeUTF8))

        #create PID-20 button
        self.button_15 = QPushButton(QApplication.translate("Button", "SV -20", None, QApplication.UnicodeUTF8))
        self.button_15.setFocusPolicy(Qt.NoFocus)
        self.button_15.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_15.setMaximumSize(90, 50)
        self.button_15.setMinimumHeight(50)
        self.button_15.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 20", None, QApplication.UnicodeUTF8))

        #create PID-10 button
        self.button_16 = QPushButton(QApplication.translate("Button", "SV -10", None, QApplication.UnicodeUTF8))
        self.button_16.setFocusPolicy(Qt.NoFocus)
        self.button_16.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_16.setMaximumSize(90, 50)
        self.button_16.setMinimumHeight(50)
        self.button_16.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 10", None, QApplication.UnicodeUTF8))

        #create PID-5 button
        self.button_17 = QPushButton(QApplication.translate("Button", "SV -5", None, QApplication.UnicodeUTF8))
        self.button_17.setFocusPolicy(Qt.NoFocus)
        self.button_17.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_17.setMaximumSize(90, 50)
        self.button_17.setMinimumHeight(50)
        self.button_17.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 5", None, QApplication.UnicodeUTF8))

        #create HUD button
        self.button_18 = QPushButton(QApplication.translate("Button", "HUD", None, QApplication.UnicodeUTF8))
        self.button_18.setFocusPolicy(Qt.NoFocus)
        self.button_18.setStyleSheet(self.pushbuttonstyles["DISABLED"])
        if locale in ["el", "no"]:
            self.button_18.setMinimumWidth(100)
            self.button_18.setMaximumSize(100, 45)
        else:
            self.button_18.setMinimumWidth(80)
            self.button_18.setMaximumSize(80, 45)
        self.button_18.setContentsMargins(0,0,0,0)
        self.connect(self.button_18, SIGNAL("clicked()"), self.qmc.toggleHUD)
        self.button_18.setToolTip(QApplication.translate("Tooltip", "Turns ON/OFF the HUD", None, QApplication.UnicodeUTF8))
        self.button_18.setEnabled(False)

        #create DRY button
        self.button_19 = QPushButton(QApplication.translate("Button", "DRY\nEND", None, QApplication.UnicodeUTF8))
        self.button_19.setFocusPolicy(Qt.NoFocus)
        self.button_19.setStyleSheet(self.pushbuttonstyles["DRY END"])
        #self.button_19.setMaximumSize(90, 50)
        self.button_19.setMinimumHeight(50)
        self.button_19.setToolTip(QApplication.translate("Tooltip", "Marks the end of the Drying phase (DRYEND)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_19, SIGNAL("clicked()"), self.qmc.markDryEnd)

        #create COOLe button
        self.button_20 = QPushButton(QApplication.translate("Button", "COOL\nEND", None, QApplication.UnicodeUTF8))
        self.button_20.setFocusPolicy(Qt.NoFocus)
        self.button_20.setStyleSheet(self.pushbuttonstyles["COOL END"])
        self.button_20.setMinimumHeight(50)
        self.button_20.setToolTip(QApplication.translate("Tooltip", "Marks the end of the Cooling phase (COOLEND)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_20, SIGNAL("clicked()"), self.qmc.markCoolEnd)

        #connect PID sv easy buttons
        self.connect(self.button_12, SIGNAL("clicked()"),lambda x=5: self.adjustPIDsv(x))
        self.connect(self.button_13, SIGNAL("clicked()"),lambda x=10: self.adjustPIDsv(x))
        self.connect(self.button_14, SIGNAL("clicked()"),lambda x=20: self.adjustPIDsv(x))
        self.connect(self.button_15, SIGNAL("clicked()"),lambda x=-20: self.adjustPIDsv(x))
        self.connect(self.button_16, SIGNAL("clicked()"),lambda x=-10: self.adjustPIDsv(x))
        self.connect(self.button_17, SIGNAL("clicked()"),lambda x=-5: self.adjustPIDsv(x))

        # NavigationToolbar VMToolbar
        self.ntb = VMToolbar(self.qmc, self.main_widget)
        #self.ntb.setMinimumHeight(45)

        #create LCD displays
        #RIGHT COLUMN
        self.lcd1 = QLCDNumber() # time
        self.lcd1.setSegmentStyle(2)
        self.lcd1.setMinimumHeight(40)
        self.lcd1.setMinimumWidth(100)
        self.lcd1.setFrameStyle(QFrame.Plain)

        self.lcd2 = self.ArtisanLCD() # Temperature MET
        self.lcd3 = self.ArtisanLCD() # Temperature BT
        self.lcd4 = self.ArtisanLCD() # rate of change MET
        self.lcd5 = self.ArtisanLCD() # rate of change BT
        self.lcd6 = self.ArtisanLCD() # pid sv
        self.lcd7 = self.ArtisanLCD() # pid power % duty cycle

        self.lcd1.display("00:00")
        if self.qmc.LCDdecimalplaces:
            zz = "0.0"
        else:
            zz = "0"
        self.lcd2.display(zz)
        self.lcd3.display(zz)
        self.lcd4.display(zz)
        self.lcd5.display(zz)
        self.lcd6.display(zz)
        self.lcd7.display(zz)

        self.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["timer"],self.lcdpaletteB["timer"]))
        self.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["et"],self.lcdpaletteB["et"]))
        self.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["bt"],self.lcdpaletteB["bt"]))
        self.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltaet"],self.lcdpaletteB["deltaet"]))
        self.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltabt"],self.lcdpaletteB["deltabt"]))
        self.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
        self.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))

        self.lcd1.setToolTip(QApplication.translate("Tooltip", "Timer",None, QApplication.UnicodeUTF8))
        self.lcd2.setToolTip(QApplication.translate("Tooltip", "ET Temperature",None, QApplication.UnicodeUTF8))
        self.lcd3.setToolTip(QApplication.translate("Tooltip", "BT Temperature",None, QApplication.UnicodeUTF8))
        self.lcd4.setToolTip(QApplication.translate("Tooltip", "ET/time (degrees/min)",None, QApplication.UnicodeUTF8))
        self.lcd5.setToolTip(QApplication.translate("Tooltip", "BT/time (degrees/min)",None, QApplication.UnicodeUTF8))
        self.lcd6.setToolTip(QApplication.translate("Tooltip", "Value of SV in PID",None, QApplication.UnicodeUTF8))
        self.lcd7.setToolTip(QApplication.translate("Tooltip", "PID power %",None, QApplication.UnicodeUTF8))

        #MET
        self.label2 = QLabel()
        self.label2.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label2.setText("<big><b>" + u(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8)) + "</b></big>")
        #BT
        self.label3 = QLabel()
        self.label3.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label3.setText("<big><b>" + u(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8)) + "</b></big>")
        #DELTA MET
        self.label4 = QLabel()
        self.label4.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label4.setText("<big><b>&Delta;" + u(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8)) + "</b></big>")
        # DELTA BT
        self.label5 = QLabel()
        self.label5.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label5.setText("<big><b>&Delta;" + u(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8)) + "</b></big>")
        # pid sv
        self.label6 = QLabel()
        self.label6.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label6.setText("<big><b>" + u(QApplication.translate("Label", "PID SV",None, QApplication.UnicodeUTF8)) + "</b></big>")
        # pid power % duty cycle
        self.label7 = QLabel()
        self.label7.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label7.setText("<big><b>" + u(QApplication.translate("Label", "PID %",None, QApplication.UnicodeUTF8)) + "</b></big>")

        #extra LCDs
        self.nLCDS = 10 # maximum number of LCDs and extra devices
        self.extraLCD1,self.extraLCD2 = [],[]
        self.extraLCDlabel1,self.extraLCDlabel2 = [],[]
        self.extraLCDframe1,self.extraLCDframe2 = [],[]
        self.extraLCDvisibility1,self.extraLCDvisibility2 = [False]*self.nLCDS,[False]*self.nLCDS
        self.extraCurveVisibility1,self.extraCurveVisibility2 = [True]*self.nLCDS,[True]*self.nLCDS
        for i in range(self.nLCDS):
            #configure LCDs
            self.extraLCDframe1.append(QFrame())
            self.extraLCD1.append(self.ArtisanLCD())
            self.extraLCDlabel1.append(QLabel())
            self.extraLCDframe2.append(QFrame())
            self.extraLCD2.append(self.ArtisanLCD())
            self.extraLCDlabel2.append(QLabel())
            self.extraLCDframe1[i].setVisible(False)
            if self.qmc.LCDdecimalplaces:
                self.extraLCD1[i].display("0.0")
                self.extraLCD2[i].display("0.0")
            else:
                self.extraLCD1[i].display("0")
                self.extraLCD2[i].display("0")
            self.extraLCDframe2[i].setVisible(False)
            self.extraLCD1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.extraLCD2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
#            string1 = u(QApplication.translate("Tooltip", "Extra: %iA"%(i+1),None, QApplication.UnicodeUTF8))
#            string2 = u(QApplication.translate("Tooltip", "Extra: %iB"%(i+1),None, QApplication.UnicodeUTF8))
            #configure Labels
            self.extraLCDlabel1[i].setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
            self.extraLCDlabel2[i].setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
#            self.extraLCDlabel1[i].setText("<big><b>" + string1 + "</b></big>")
            self.extraLCDlabel1[i].setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
#            self.extraLCDlabel2[i].setText("<big><b>" + string2 + "</b></big>")
            self.extraLCDlabel2[i].setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))


        # Stores messages up to 500
        self.messagehist = []

        #only leave operational the control button if the device is Fuji PID
        #the SV buttons are activated from the PID control panel 
        self.button_10.setVisible(False)

        self.button_12.setVisible(False)
        self.button_13.setVisible(False)
        self.button_14.setVisible(False)
        self.button_15.setVisible(False)
        self.button_16.setVisible(False)
        self.button_17.setVisible(False)

        #### EVENT MINI EDITOR: View&Edits events without opening roast properties Dlg.
        self.eventlabel = QLabel(QApplication.translate("Label","Event #<b>0 </b>", None, QApplication.UnicodeUTF8))
        self.eventlabel.setIndent(5)
        self.eNumberSpinBox = QSpinBox()

#        self.eNumberSpinBox.setFocusPolicy(Qt.NoFocus)
        self.eNumberSpinBox.setAlignment(Qt.AlignCenter)
        self.eNumberSpinBox.setToolTip(QApplication.translate("Tooltip", "Number of events found", None, QApplication.UnicodeUTF8))
        self.eNumberSpinBox.setRange(0,20)
        self.connect(self.eNumberSpinBox, SIGNAL("valueChanged(int)"),self.changeEventNumber)
        self.eNumberSpinBox.setMaximumWidth(40)
        self.lineEvent = QLineEdit()
#        self.lineEvent.setFocusPolicy(Qt.ClickFocus)
        self.lineEvent.setMinimumWidth(200)

        self.eventlabel.setStyleSheet("background-color:'yellow';")

        self.etypeComboBox = QComboBox()
        self.etypeComboBox.setToolTip(QApplication.translate("Tooltip", "Type of event", None, QApplication.UnicodeUTF8))
#        self.etypeComboBox.setFocusPolicy(Qt.NoFocus)
        self.etypeComboBox.addItems(self.qmc.etypes)

        regexvalue = QRegExp(r"^100|\d?\d?$")
        self.valueEdit = QLineEdit()
        self.valueEdit.setValidator(QRegExpValidator(regexvalue,self))
        self.valueEdit.setToolTip(QApplication.translate("Tooltip", "Value of event", None, QApplication.UnicodeUTF8))
#        self.valueEdit.setFocusPolicy(Qt.ClickFocus)
        self.valueEdit.setMaximumWidth(50)

        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.etimeline = QLineEdit()
        self.etimeline.setValidator(QRegExpValidator(regextime,self))
#        self.etimeline.setFocusPolicy(Qt.ClickFocus)
        self.etimeline.setMaximumWidth(50)

        #create EVENT mini button
        self.buttonminiEvent = QPushButton(QApplication.translate("Button", "Update", None, QApplication.UnicodeUTF8))
        self.buttonminiEvent.setFocusPolicy(Qt.StrongFocus)
        self.connect(self.buttonminiEvent, SIGNAL("clicked()"), self.miniEventRecord)
        self.buttonminiEvent.setToolTip(QApplication.translate("Tooltip", "Updates the event", None, QApplication.UnicodeUTF8))

        #### CUSTOM events buttons
        self.buttonlist = []
        self.lastbuttonpressed = -1
        self.buttonlistmaxlen = 11
        #10 palettes of buttons
        self.buttonpalette = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
        self.buttonpalettemaxlen = [10]*10  #keeps max len of each palette

        #Create LOWER BUTTONS Widget layout QDialogButtonBox to stack all lower buttons
        self.lowerbuttondialog = QDialogButtonBox(Qt.Horizontal)
        self.lowerbuttondialog.setContentsMargins(0,0,0,10)
        self.lowerbuttondialog.setVisible(False)
        self.lowerbuttondialog.setCenterButtons(True)
        #initiate configuration
        self.lowerbuttondialog.addButton(self.button_8,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_19,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_3,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_4,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_5,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_6,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_9,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_20,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_11,QDialogButtonBox.ActionRole)

        self.e1buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e1buttondialog.setCenterButtons(True)
        self.e2buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e2buttondialog.setCenterButtons(True)
        self.e3buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e3buttondialog.setCenterButtons(True)
        self.e4buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e4buttondialog.setCenterButtons(True)

        # set the focus on the main widget
        self.main_widget.setFocus()

        # set the central widget of MainWindow to main_widget
        self.setCentralWidget(self.main_widget)

        #list of functions to chose from (using left-right keyboard arrow)
        self.keyboardmove = [self.qmc.reset,self.qmc.toggleHUD,self.qmc.ToggleMonitor,self.qmc.markCharge,self.qmc.markDryEnd,self.qmc.mark1Cstart,self.qmc.mark1Cend,
                             self.qmc.mark2Cstart,self.qmc.mark2Cend,self.qmc.markDrop,self.qmc.markCoolEnd,self.qmc.EventRecord]
        # list of buttons that can be controlled via the keyboard
        # RESET -> HUD -> ON/OFF -> .. -> EVENT (RESET at index 0 is never used)
        self.keyboardButtonList = [self.button_7, self.button_18,self.button_1,self.button_8,self.button_19,self.button_3,self.button_4,self.button_5,self.button_6,self.button_9,self.button_20,self.button_11]
        self.keyboardButtonStyles = ["RESET","HUD_ON","ON","CHARGE","DRY END","FC START","FC END","SC START","SC END","DROP","COOL END","EVENT"]

        #current function above
        self.keyboardmoveindex = 0
        #state flag for above. It is initialized by pressing SPACE or left-right arrows
        self.keyboardmoveflag = 0
        #time stamp of last keyboard event SPACE to prevent multiple recognitions
        self.lastkeyboardcmd = 0


        ####################   APPLICATION WINDOW (AW) LAYOUT  ##############################################

        level1layout = QHBoxLayout()   # matplotlib toolbox + HUD button + reset button + LCD Timer

        level3layout = QHBoxLayout()   # PID buttons, graph, temperature LCDs

        pidbuttonLayout = QVBoxLayout()

        EventsLayout = QHBoxLayout()
        EventsLayout.setMargin(1)
        EventsLayout.setSpacing(0)

        #EVENT MINIEDITOR layout
        EventsLayout.addWidget(self.eventlabel)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etimeline)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.lineEvent)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etypeComboBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.valueEdit)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.eNumberSpinBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.buttonminiEvent)
        self.EventsGroupLayout = QGroupBox()
        self.EventsGroupLayout.setLayout(EventsLayout)
        self.EventsGroupLayout.setVisible(False)

        LCDlayout = QVBoxLayout() 
        LCDlayout.setSpacing(0)
        LCDlayout.setContentsMargins(0,0,5,0)

        #place control buttons + LCDs inside vertical button layout manager
        self.LCD2frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label2,self.lcd2,self.LCD2frame))

        self.LCD3frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label3,self.lcd3,self.LCD3frame))

        self.LCD6frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label6,self.lcd6,self.LCD6frame))
        self.LCD6frame.setVisible(False)

        self.LCD7frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label7,self.lcd7,self.LCD7frame))
        self.LCD7frame.setVisible(False)

        self.LCD4frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label4,self.lcd4,self.LCD4frame))

        self.LCD5frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label5,self.lcd5,self.LCD5frame))

        #add extra LCDs
        for i in range(self.nLCDS):
            LCDlayout.addWidget(self.makeLCDbox(self.extraLCDlabel1[i],self.extraLCD1[i],self.extraLCDframe1[i]))
            LCDlayout.addWidget(self.makeLCDbox(self.extraLCDlabel2[i],self.extraLCD2[i],self.extraLCDframe2[i]))
        LCDlayout.addStretch()

        #PID Buttons
        pidbuttonLayout.addWidget(self.button_14)
        pidbuttonLayout.addWidget(self.button_13)
        pidbuttonLayout.addWidget(self.button_12)
        pidbuttonLayout.addWidget(self.button_17)
        pidbuttonLayout.addWidget(self.button_16)
        pidbuttonLayout.addWidget(self.button_15)

        # phases LCDs
        
        # TP
        self.TPlabel = QLabel()
        self.TPlabel.setText("<small><b>" + u(QApplication.translate("Label", "TP",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")
        self.TPlcd = QLCDNumber()        
        self.TPlcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.connect( self.TPlcd, SIGNAL("customContextMenuRequested(QPoint)"), self.PhaseslcdClicked)
        self.TPlcd.display("--:--")
        self.TPlcdFrame = self.makePhasesLCDbox(self.TPlabel,self.TPlcd)

        # TP2DRY
        self.TP2DRYlabel = QLabel("")
        TP2DRYlayout = QHBoxLayout()
        TP2DRYlayout.addWidget(self.TP2DRYlabel)
        TP2DRYlayout.setContentsMargins(3,0,3,0)
        TP2DRYframe = QFrame()
        TP2DRYframe.setLayout(TP2DRYlayout)

        # DRY
        self.DRYlabel = QLabel()
        self.DRYlabel.setText("<small><b>&raquo;" + u(QApplication.translate("Label", "DRY",None, QApplication.UnicodeUTF8)) + "</b></small>")
        self.DRYlcd = QLCDNumber()
        self.DRYlcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.connect( self.DRYlcd, SIGNAL("customContextMenuRequested(QPoint)"), self.PhaseslcdClicked)
        self.DRYlcd.display("--:--")
        self.DRYlcdFrame = self.makePhasesLCDbox(self.DRYlabel,self.DRYlcd)

        # DRY2FCs
        self.DRY2FCslabel = QLabel("")
        DRY2FCslayout = QHBoxLayout()
        DRY2FCslayout.addWidget(self.DRY2FCslabel)
        DRY2FCslayout.setContentsMargins(3,0,3,0)
        DRY2FCsframe = QFrame()
        DRY2FCsframe.setLayout(DRY2FCslayout)

        # FCs
        self.FCslabel = QLabel()
        self.FCslabel.setText("<small><b>&raquo;" + u(QApplication.translate("Label", "FCs",None, QApplication.UnicodeUTF8)) + "</b></small>")
        self.FCslcd = QLCDNumber()
        self.FCslcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.connect( self.FCslcd, SIGNAL("customContextMenuRequested(QPoint)"), self.PhaseslcdClicked)
        self.FCslcd.display("--:--")
        self.FCslcdFrame = self.makePhasesLCDbox(self.FCslabel,self.FCslcd)

        self.phasesLCDs = QFrame()
        self.phasesLCDs.setContentsMargins(0, 0, 0, 0)
        phasesLCDlayout = QHBoxLayout()
        phasesLCDlayout.addWidget(self.TPlcdFrame)
        phasesLCDlayout.addWidget(TP2DRYframe)
        phasesLCDlayout.addWidget(self.DRYlcdFrame)
        phasesLCDlayout.addWidget(DRY2FCsframe)
        phasesLCDlayout.addWidget(self.FCslcdFrame)
        phasesLCDlayout.setContentsMargins(0, 0, 0, 0)
        phasesLCDlayout.setSpacing(0)
        self.phasesLCDs.setLayout(phasesLCDlayout)
        self.phasesLCDs.hide()

        #level 1
        level1layout.addWidget(self.ntb)
        level1layout.addStretch()
        level1layout.addWidget(self.phasesLCDs)
        level1layout.addSpacing(15)
#        level1layout.addStretch()
        level1layout.addWidget(self.button_7)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_1)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_2)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_10)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_18)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.lcd1)
        level1layout.setMargin(0)
        level1layout.setSpacing(0)
        level1layout.setContentsMargins(5,5,5,0)

        #level 3
        level3layout.addLayout(pidbuttonLayout,0)
        level3layout.addWidget(self.stack,1)
        level3layout.setSpacing(0)
        level3layout.setMargin(0)
        level3layout.setContentsMargins(0,0,0,0)

        extrabuttonsLayout = QVBoxLayout()
        extrabuttonsLayout.setMargin(0)
#        extrabuttonsLayout.setSpacing(0)
        extrabuttonsLayout.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e1buttondialog)
#        self.e1buttondialog.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e2buttondialog)
#        self.e2buttondialog.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e3buttondialog)
#        self.e3buttondialog.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e4buttondialog)
#        self.e4buttondialog.setContentsMargins(0,0,0,0)
        self.extrabuttondialogs = QFrame()
        self.extrabuttondialogs.setLayout(extrabuttonsLayout)
        self.extrabuttondialogs.setVisible(False)
#        self.extrabuttondialogs.setContentsMargins(0,0,0,0)

        midleftlayout = QVBoxLayout()
        midleftlayout.setSpacing(0)
        midleftlayout.setContentsMargins(0,0,0,0)
        midleftlayout.setMargin(0)
        midleftlayout.addWidget(self.messagelabel)
        midleftlayout.addLayout(level3layout)
        midleftlayout.addWidget(self.lowerbuttondialog)
        midleftlayout.addWidget(self.extrabuttondialogs) 
        midleftlayout.addWidget(self.EventsGroupLayout)

        self.slider1 = self.slider()
        self.sliderLCD1 = self.sliderLCD()
        self.sliderLCD1.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[0])
        self.sliderLCD1.display(self.slider1.value())
        sliderGrp1 = QVBoxLayout()
        sliderGrp1.addWidget(self.sliderLCD1)
        sliderGrp1.addWidget(self.slider1)
        sliderGrp1.setAlignment(Qt.AlignCenter)
        sliderGrp1.setMargin(2)
        self.sliderGrpBox1 = QGroupBox()
        self.sliderGrpBox1.setLayout(sliderGrp1)
        self.sliderGrpBox1.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox1.setMinimumWidth(55) 
        self.sliderGrpBox1.setMaximumWidth(55)
        self.sliderGrpBox1.setVisible(False)
        self.slider1.setTracking(False)
        self.connect(self.slider1, SIGNAL("sliderMoved(int)"), lambda v=0:self.updateSliderLCD(0,v))
        self.connect(self.slider1, SIGNAL("valueChanged(int)"), lambda v=0:self.sliderReleased(0) or self.updateSliderLCD(0,v))
        self.slider1.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider2 = self.slider()
        self.sliderLCD2 = self.sliderLCD() 
        self.sliderLCD2.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[1])
        self.sliderLCD2.display(self.slider2.value())
        sliderGrp2 = QVBoxLayout()
        sliderGrp2.addWidget(self.sliderLCD2)
        sliderGrp2.addWidget(self.slider2)
        sliderGrp2.setAlignment(Qt.AlignCenter)
        sliderGrp2.setMargin(2)
        self.sliderGrpBox2 = QGroupBox()
        self.sliderGrpBox2.setLayout(sliderGrp2)
        self.sliderGrpBox2.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox2.setMinimumWidth(55) 
        self.sliderGrpBox2.setMaximumWidth(55) 
        self.sliderGrpBox2.setVisible(False)
        self.slider2.setTracking(False)
        self.connect(self.slider2, SIGNAL("sliderMoved(int)"), lambda v=0:self.updateSliderLCD(1,v))
        self.connect(self.slider2, SIGNAL("valueChanged(int)"), lambda v=0:self.sliderReleased(1) or self.updateSliderLCD(1,v))
        self.slider2.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider3 = self.slider()
        self.sliderLCD3 = self.sliderLCD()
        self.sliderLCD3.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[2])
        self.sliderLCD3.display(self.slider3.value())
        sliderGrp3 = QVBoxLayout()
        sliderGrp3.addWidget(self.sliderLCD3)
        sliderGrp3.addWidget(self.slider3)
        sliderGrp3.setAlignment(Qt.AlignCenter)
        sliderGrp3.setMargin(2)
        self.sliderGrpBox3 = QGroupBox()
        self.sliderGrpBox3.setLayout(sliderGrp3)
        self.sliderGrpBox3.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox3.setMinimumWidth(55) 
        self.sliderGrpBox3.setMaximumWidth(55) 
        self.sliderGrpBox3.setVisible(False)
        self.slider3.setTracking(False)
        self.connect(self.slider3, SIGNAL("sliderMoved(int)"), lambda v=0:self.updateSliderLCD(2,v))
        self.connect(self.slider3, SIGNAL("valueChanged(int)"), lambda v=0:self.sliderReleased(2) or self.updateSliderLCD(2,v))
        self.slider3.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider4 = self.slider()
        self.sliderLCD4 = self.sliderLCD()
        self.sliderLCD4.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[3])
        self.sliderLCD4.display(self.slider4.value())
        sliderGrp4 = QVBoxLayout()
        sliderGrp4.addWidget(self.sliderLCD4)
        sliderGrp4.addWidget(self.slider4)
        sliderGrp4.setAlignment(Qt.AlignCenter)
        sliderGrp4.setMargin(2)
        self.sliderGrpBox4 = QGroupBox()
        self.sliderGrpBox4.setLayout(sliderGrp4)
        self.sliderGrpBox4.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox4.setMinimumWidth(55) 
        self.sliderGrpBox4.setMaximumWidth(55) 
        self.sliderGrpBox4.setVisible(False)
        self.slider4.setTracking(False)
        self.connect(self.slider4, SIGNAL("sliderMoved(int)"), lambda v=0:self.updateSliderLCD(3,v))
        self.connect(self.slider4, SIGNAL("valueChanged(int)"), lambda v=0:self.sliderReleased(3) or self.updateSliderLCD(3,v))
        self.slider4.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.sliderSV = self.slider()
        self.sliderLCDSV = self.sliderLCD()
        self.sliderLCDSV.setNumDigits(3)
        self.sliderLCDSV.setStyleSheet("font-weight: bold;")
        self.sliderLCDSV.display(self.arduino.svValue)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.addWidget(self.sliderLCDSV)
        sliderGrpSV.addWidget(self.sliderSV)
        sliderGrpSV.setAlignment(Qt.AlignCenter)
        sliderGrpSV.setMargin(2)
        self.sliderGrpBoxSV = QGroupBox()
        self.sliderGrpBoxSV.setLayout(sliderGrpSV)
        self.sliderGrpBoxSV.setAlignment(Qt.AlignCenter)
        self.sliderGrpBoxSV.setMinimumWidth(55) 
        self.sliderGrpBoxSV.setMaximumWidth(55) 
        self.sliderGrpBoxSV.setVisible(False)
        self.sliderGrpBoxSV.setTitle("SV")
        self.sliderSV.setTracking(False)
        self.connect(self.sliderSV, SIGNAL("sliderMoved(int)"), lambda v=0:self.updateSVSliderLCD(v))
        self.connect(self.sliderSV, SIGNAL("valueChanged(int)"), lambda v=0:self.sliderSVreleased() or self.updateSVSliderLCD(v))
        self.sliderSV.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        sliderGrp12 = QVBoxLayout()
        sliderGrp12.setSpacing(0)
        sliderGrp12.setContentsMargins(0,0,0,0)
        sliderGrp12.addWidget(self.sliderGrpBox1)
        sliderGrp12.addWidget(self.sliderGrpBox2)
        sliderGrp34 = QVBoxLayout()
        sliderGrp34.setSpacing(0)
        sliderGrp34.setContentsMargins(0,0,0,0)
        sliderGrp34.addWidget(self.sliderGrpBox3)
        sliderGrp34.addWidget(self.sliderGrpBox4)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.setSpacing(0)
        sliderGrpSV.setContentsMargins(0,0,0,0)
        sliderGrpSV.addWidget(self.sliderGrpBoxSV)

        self.leftlayout = QHBoxLayout()
        self.leftlayout.setSpacing(0)
        self.leftlayout.setMargin(0)
        self.leftlayout.setContentsMargins(0,0,0,0)
        self.leftlayout.addLayout(sliderGrp12)
        self.leftlayout.addLayout(sliderGrp34)
        self.leftlayout.addLayout(sliderGrpSV)

        self.sliderFrame = QFrame()
        self.sliderFrame.setLayout(self.leftlayout)
        self.sliderFrame.setVisible(False)
        self.sliderFrame.setContentsMargins(0,0,0,0)

        self.lcdFrame = QFrame()
        self.lcdFrame.setLayout(LCDlayout)
        self.lcdFrame.setVisible(False)
        self.lcdFrame.setContentsMargins(0,0,0,0)
        self.lcdFrame.setSizePolicy(QSizePolicy.Maximum,QSizePolicy.Expanding) # prevent horizontal expansion (graph might not maximize otherwise)

        self.midlayout = QHBoxLayout()
        self.midlayout.addWidget(self.sliderFrame)
        self.midlayout.addLayout(midleftlayout)
        self.midlayout.addWidget(self.lcdFrame)
        self.midlayout.setSpacing(0)
        self.midlayout.setContentsMargins(0,0,0,0)

        mainlayout = QVBoxLayout(self.main_widget)
        mainlayout.addLayout(level1layout)
        mainlayout.addLayout(self.midlayout) 
        mainlayout.setContentsMargins(0,0,0,0)
        mainlayout.setSpacing(0)


###################################   APPLICATION WINDOW (AW) FUNCTIONS  ####################################
    def PhaseslcdClicked(self,x):
        aw.qmc.phasesLCDmode = (aw.qmc.phasesLCDmode + 1)%3
        aw.updatePhasesLCDs()

    def colordialog(self,c,noButtons=False,parent=None): # c a QColor
        if platform.system() == 'Darwin':
            if noButtons:
                if parent == None:
                    parent = self
                cd = QColorDialog(parent)
                cd.setOption(QColorDialog.NoButtons,True)
                cd.setCurrentColor(c)
                cd.exec_()
                cr = cd.currentColor()
                return cr
            else:
                return QColorDialog.getColor(c)
            #return QColorDialog.getColor(c,self,"Color",QColorDialog.DontUseNativeDialog) # works, but does not show native dialog
        else:
            return QColorDialog.getColor(c) # blocks on Mac OS X in the build

    def adjustPIDsv(self,x):
        if self.qmc.device == 0: # Fuji PID
            self.fujipid.adjustsv(x)
        elif self.qmc.device == 19: # Arduino TC4
            self.arduino.adjustsv(x)

    # compute the 12 or 102 event quantifier linespace for type n in [0,3]
    def computeLinespace(self,n):
        if self.eventquantifiercoarse[n]:
            num = 12
        else:
            num = 102
        return numpy.linspace(self.eventquantifiermin[n], self.eventquantifiermax[n], num=num)
        
    # update all 4 event quantifier linespaces
    def computeLinespaces(self):
        for n in range(4):
            self.eventquantifierlinspaces[n] = self.computeLinespace(n)
        
    # returns temp and time arrays corresponding to the quantifier source
    # temp might be None if there is no corresponding curve
    def quantifier2tempandtime(self,i):
        temp = None
        timex = aw.qmc.timex
        if aw.eventquantifiersource[i] == 0:
            temp = aw.qmc.temp1
        elif aw.eventquantifiersource[i] == 1:
            temp = aw.qmc.temp2
        else:
            x = (aw.eventquantifiersource[i]-2)
            timex = aw.qmc.extratimex[x / 2]
            if x % 2 == 0:
                # even
                if len(aw.qmc.extratemp1) > (x/2):
                    temp = aw.qmc.extratemp1[x / 2]
            else:
                # odd
                if len(aw.qmc.extratemp2) > (x/2):
                    temp = aw.qmc.extratemp2[x / 2]
        return temp,timex
        
    # returns min/max 0/10 for values outside of the given linespace ls defining the interval
    # otherwise the bin number from [0-self.eventquantifiersteps]
    def digitize(self,v,ls,coarse):
        if coarse:
            r = numpy.digitize([v],ls)[0] - 1
        else:
            r = (numpy.digitize([v],ls)[0] - 1) / 10.
        return max(0,min(10,r))
        
    
    # computes the similarity between BT and backgroundBT as well as ET and backgroundET
    # iterates over all BT/ET values backward from DROP to the specified BT temperature
    # returns None in case no similarity can be computed
    def curveSimilarity(self,BTlimit=None):
        try:
            # if background profile is loaded and both profiles have a DROP even set
            if aw.qmc.background and aw.qmc.timeindex[6] and aw.qmc.timeindexB[6]:
                # calculate time delta between background and foreground DROP event
                dropTimeDelta = aw.qmc.timex[aw.qmc.timeindex[6]] - aw.qmc.timeB[aw.qmc.timeindexB[6]]
                totalQuadraticDeltaET = 0
                totalQuadraticDeltaBT = 0
                count = 0
                for i in range(aw.qmc.timeindex[6],0,-1):
                    # iterate backward from DROP to BTlimit
                    if aw.qmc.stemp1 and len(aw.qmc.stemp1) > i:
                        # take smoothed data if available
                        et = aw.qmc.stemp1[i]
                    else:
                        et = aw.qmc.temp1[i]
                    if aw.qmc.stemp2 and len(aw.qmc.stemp2) > i:
                        # take smoothed data if available
                        bt = aw.qmc.stemp2[i]
                    else:
                        bt = aw.qmc.temp2[i]
                    if BTlimit and bt > BTlimit:
                        # still above the limit
                        # retrieve corresponding values from the background (is always smoothed)
                        # first compute closest index at that time point in the background data
                        j = aw.qmc.backgroundtime2index((aw.qmc.timex[i] - dropTimeDelta))
                        etb = aw.qmc.temp1B[j]
                        btb = aw.qmc.temp2B[j]
                        det = (et - etb)
                        totalQuadraticDeltaET += det * det
                        dbt = (bt - btb)
                        totalQuadraticDeltaBT += dbt * dbt
                        count += 1
                    else:
                        break
                return math.sqrt(totalQuadraticDeltaET/float(count)), math.sqrt(totalQuadraticDeltaBT/float(count))
            else:
                # no DROP event registered
                return None, None
        except:
            #import traceback
            #traceback.print_exc(file=sys.stdout)        
            return None, None
            
    def setLCDsDigitCount(self,n):
        self.lcd2.setDigitCount(n)
        self.lcd2.setMinimumWidth(n*16)
        self.lcd2.setMaximumWidth(n*16)
        self.lcd3.setDigitCount(n)
        self.lcd3.setMinimumWidth(n*16)
        self.lcd3.setMaximumWidth(n*16)
        self.lcd4.setDigitCount(n)
        self.lcd4.setMinimumWidth(n*16)
        self.lcd4.setMaximumWidth(n*16)
        self.lcd5.setDigitCount(n)
        self.lcd5.setMinimumWidth(n*16)
        self.lcd5.setMaximumWidth(n*16)
        self.lcd6.setDigitCount(n)
        self.lcd6.setMinimumWidth(n*16)
        self.lcd6.setMaximumWidth(n*16)
        self.lcd7.setDigitCount(n)
        self.lcd7.setMinimumWidth(n*16)
        self.lcd7.setMaximumWidth(n*16)
        for i in range(self.nLCDS):
            self.extraLCD1[i].setDigitCount(n)
            self.extraLCD1[i].setMinimumWidth(n*16)
            self.extraLCD1[i].setMaximumWidth(n*16)
            self.extraLCD2[i].setDigitCount(n)
            self.extraLCD2[i].setMinimumWidth(n*16)
            self.extraLCD2[i].setMaximumWidth(n*16)
        if aw.largeLCDs_dialog:
            aw.largeLCDs_dialog.lcd2.setDigitCount(n+1)
            aw.largeLCDs_dialog.lcd3.setDigitCount(n+1)
            if aw.qmc.LCDdecimalplaces:
                aw.largeLCDs_dialog.lcd2.display("-.-")
                aw.largeLCDs_dialog.lcd3.display("-.-")
            else:
                aw.largeLCDs_dialog.lcd2.display("--")
                aw.largeLCDs_dialog.lcd3.display("--")
            
    def ArtisanLCD(self):
        lcd = QLCDNumber()
        lcd.setSegmentStyle(2)
        lcd.setFrameStyle(QFrame.Plain)
        lcd.setMinimumHeight(35)
#        lcd.setSmallDecimalPoint(True)
        x = 16
        if self.qmc.LCDdecimalplaces:
            lcd.setDigitCount(5) # default is 5
            lcd.setMinimumWidth(5*x)
            lcd.setMaximumWidth(5*x)
        else:
            lcd.setDigitCount(3) # default is 5
            lcd.setMinimumWidth(3*x)
            lcd.setMaximumWidth(3*x)
        return lcd

    # set slider focus to Qt.StrongFocus to allow keyboard control and
    # Qt.NoFocus to deactivate it
    def setSliderFocusPolicy(self,focus):
        self.slider1.setFocusPolicy(focus)
        self.slider1.clearFocus()
        self.slider2.setFocusPolicy(focus)
        self.slider2.clearFocus()
        self.slider3.setFocusPolicy(focus)
        self.slider3.clearFocus()
        self.slider4.setFocusPolicy(focus)
        self.slider4.clearFocus()

    def appFrozen(self):
        ib = False
        try:
            if platf == "Darwin":
                # the sys.frozen is set by py2app and is unset otherwise
                if str(sys.frozen) == "macosx_app":
                    ib = True
            elif platf == "Windows":
                ib = (hasattr(sys, "frozen") or # new py2exe
                    hasattr(sys, "importers") # old py2exe
                    or imp.is_frozen("__main__")) # tools/freeze
            elif platf == "Linux":
                if getattr(sys, 'frozen', False):
                    # The application is frozen
                    ib = True
        except:
            pass
        return ib

    def getAppPath(self):
        res = ""
        if platf in ['Darwin','Linux']:
            if self.appFrozen():
                res = QApplication.applicationDirPath() + "/../../../"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "/../"
        elif platf == "Windows":
            if self.appFrozen():
                res = os.path.dirname(sys.executable) + "\\"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "\\..\\"
        else:
            res = QApplication.applicationDirPath() + "/"
        return res

    def getResourcePath(self):
        res = ""
        if platf in ['Darwin','Linux']:
            if self.appFrozen():
                res = QApplication.applicationDirPath() + "/../Resources/"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "/../includes/"
        elif platf == "Windows":
            if self.appFrozen():
                res = os.path.dirname(sys.executable) + "\\"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "\\..\\includes\\"
        else:
            res = QApplication.applicationDirPath() + "/"
        return res

    def setFonts(self):
        # try to select the right font for matplotlib according to the given locale and plattform
        if self.qmc.graphfont == 0:     
            try:                    
                rcParams['font.size'] = 12.0
                mpl.rcParams['font.family'] = ["Microsoft Sans Serif", "Arial"] # works for Greek and Arabic
                self.mpl_fontproperties = mpl.font_manager.FontProperties()
                if platf == "Darwin":
                    mpl.rcParams['font.family'] = "Arial Unicode MS"
                    self.mpl_fontproperties = mpl.font_manager.FontProperties()
                elif platf == "Linux":
                    if locale:
                        if locale == "ar":
                            mpl.rcParams['font.family'] = ["DejaVu Sans","DejaVu Sans Mono","Times New Roman"]
                        elif locale == "ja":
                            mpl.rcParams['font.family'] = ["TakaoPGothic"]
                        elif locale == "el":
                            mpl.rcParams['font.family'] = ["DejaVu Sans","DejaVu Sans Mono"]
                        elif locale == "zh_CN":
                            mpl.rcParams['font.family'] = ["NanumGothic","DejaVu Sans Mono"]
                        elif locale == "zh_TW":
                            mpl.rcParams['font.family'] = ["NanumGothic","DejaVu Sans Mono"]
                        self.mpl_fontproperties = mpl.font_manager.FontProperties()
                else: # Windows:
                    # for asian languages on Windows we have to set the parameters directly to *.ttc fonts (mpl supports only *.ttf)
                    if locale == "ja":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\MSGOTHIC.ttc")
                    elif locale == "zh_CN":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\simsun.ttc")
                    elif locale == "zh_TW":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\mingliu.ttc")
                    elif locale == "ko":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\batang.ttc")
#                    elif locale == "ar":
#                        mpl.rcParams['font.family'] = "TraditionalArabic"
#                        self.mpl_fontproperties = mpl.font_manager.FontProperties()
            except:
                pass
        # no Comic on Linux!
        elif self.qmc.graphfont == 1 or platf == "Linux":
            # font Humor selected
            rcParams['font.size'] = 16.0
            if platf == 'Linux':
                rcParams['font.family'] = ['Humor Sans']
            else:
                rcParams['font.family'] = ['Humor Sans', 'Comic Sans MS']
            aw.set_mpl_fontproperties(u(self.getResourcePath() + "Humor-Sans.ttf"))
        elif self.qmc.graphfont == 2 and not platf == "Linux":
            # font Comic selected
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Comic Sans MS','Humor Sans']
            self.mpl_fontproperties = mpl.font_manager.FontProperties()
        self.qmc.redraw(recomputeAllDeltas=False)

    def set_mpl_fontproperties(self,fontpath):
        if os.path.exists(fontpath):
            self.mpl_fontproperties = mpl.font_manager.FontProperties(fname=fontpath)

    # trims arabic strings to be rendered correctly with unicode fonts if arabic locale is active
    # if s is a QString with one %1 placeholder and a is an argument, the argument is reversed, and then the wohle string result is reversed
    # if it contains any arabic characters
    def arabicReshape(self,s,a=None):
        if locale and locale == "ar":
            st = u(s)
            if artisanlib.arabic_reshaper.has_arabic_letters(st):
                if a: 
                    return u(artisanlib.arabic_reshaper.reshape(u(s.arg(a[::-1])))[::-1])
                else:
                    return u(artisanlib.arabic_reshaper.reshape(st)[::-1])
            else:
                if a:
                    return u(s.arg(a))
                else:
                    return u(s)
        elif locale and locale == "he":
            if a:
                return u(s[::-1].arg(a[::-1]))
            else:
                return u(s[::-1])
        else:
            if a:
                return u(s.arg(a))
            else:
                return u(s)

#    def makePhasesLCDbox(self,label,lcd):
#        label.setAlignment(Qt.Alignment(Qt.AlignRight | Qt.AlignVCenter))
#        lcd.setMinimumHeight(40)
#        lcd.setMinimumWidth(50)
#        lcd.setSegmentStyle(2)
#        lcd.setFrameStyle(QFrame.Plain)
#        lcd.setNumDigits(5)
#        frame = QFrame()
#        LCDHbox = QHBoxLayout()
#        LCDHbox.addWidget(label)
#        LCDHbox.addWidget(lcd)
#        LCDHbox.setSpacing(0)
#        LCDHbox.setContentsMargins(0, 0, 0, 0)
#        frame.setStyleSheet("background-color: rgb(230,230,230);")
#        frame.setFrameShadow(QFrame.Sunken)
#        frame.setLineWidth(1)
#        frame.setFrameShape(QFrame.Panel)
#        frame.setLayout(LCDHbox)
#        return frame

    def makePhasesLCDbox(self,label,lcd):
        label.setAlignment(Qt.Alignment(Qt.AlignRight | Qt.AlignVCenter))
        lcd.setMinimumHeight(30)
        lcd.setMinimumWidth(60)
        lcd.setSegmentStyle(2)
        lcd.setFrameStyle(QFrame.Plain)
        lcd.setNumDigits(5)
        lcd.setLineWidth(0)
        lcd.setContentsMargins(0, 0, 0, 0)
        frame = QFrame()
        LCDHbox = QVBoxLayout()
        LCDHbox.addWidget(label)
        LCDHbox.addWidget(lcd)
        LCDHbox.setSpacing(0)
        LCDHbox.setContentsMargins(0, 0, 0, 0)
        frame.setStyleSheet("background-color: rgb(230,230,230);")
        frame.setFrameShadow(QFrame.Sunken)
        frame.setLineWidth(1)
        frame.setFrameShape(QFrame.Panel)
        frame.setLayout(LCDHbox)
        return frame

    def updatePhasesLCDs(self):
        try:
            if self.qmc.timex: # requires at least some recordings
                window_width = aw.width()
                if aw.qmc.LCDdecimalplaces:
                    fmtstr = "%.1f"
                else:
                    fmtstr = "%.0f" 
                tx = self.qmc.timex[-1]
                if self.qmc.timeindex[0]:
                    chrg = self.qmc.timex[self.qmc.timeindex[0]]
                else:
                    chrg = 0
                if self.qmc.timeindex[6]: # after drop
                    totaltime = self.qmc.timex[self.qmc.timeindex[6]] - chrg
                else: # before drop
                    totaltime = tx - chrg

                # TP phase LCD
                if aw.qmc.phasesLCDmode == 0: # time mode
                    if self.qmc.TPalarmtimeindex:
                        # after TP
                        self.TPlabel.setText("<small><b>" + u(QApplication.translate("Label", "TP",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")                    
                        if self.qmc.timeindex[6]:
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.TPalarmtimeindex]
                        else:
                            ts = tx - self.qmc.timex[self.qmc.TPalarmtimeindex]
                        tss = QString(self.qmc.stringfromseconds(int(ts)))
                        self.TPlcd.display(tss)
                    else:
                        # before TP
                        self.TPlcd.display(QString("--:--"))
                elif aw.qmc.phasesLCDmode == 1: # percentage mode
                    self.TPlabel.setText("<small><b>" + u(QApplication.translate("Label", "DRY%",None, QApplication.UnicodeUTF8)) + "</b></small>")
                    if self.qmc.timeindex[1]: # after DRY
                        ts = self.qmc.timex[self.qmc.timeindex[1]] - chrg
                        dryphaseP = fmtstr%(ts*100/totaltime)
                        if not aw.qmc.LCDdecimalplaces:
                            dryphaseP += " "
                        self.TPlcd.display(QString(dryphaseP))
                    else:
                        self.TPlcd.display(QString(" --- "))
                elif aw.qmc.phasesLCDmode == 2: # temp mode
                    if self.qmc.TPalarmtimeindex:
                        if self.qmc.timeindex[6]: # after drop
                            dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                        else:
                            dBT = self.qmc.temp2[-1]
                        dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.TPalarmtimeindex])
                        self.TPlabel.setText("<small><b>" + u(QApplication.translate("Label", "TP",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")
                        self.TPlcd.display(QString(dBT + self.qmc.mode))                       
                    else:
                        # before TP
                        self.TPlcd.display(QString(" --- "))
                # DRY phase LCD
                if self.qmc.timeindex[1]:
                    # after DRY
                    if self.qmc.timeindex[6]:
                        ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[1]]
                    else:
                        ts = tx - self.qmc.timex[self.qmc.timeindex[1]]
                    if aw.qmc.phasesLCDmode == 0: # time mode
                        self.DRYlabel.setText("<small><b>" + u(QApplication.translate("Label", "DRY",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")
                        self.DRYlcd.display(QString(self.qmc.stringfromseconds(int(ts))))
                    elif aw.qmc.phasesLCDmode == 1: # percentage mode
                        if self.qmc.timeindex[2]:
                            ts = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                        midphaseP = fmtstr%(ts*100/totaltime)
                        if not aw.qmc.LCDdecimalplaces:
                            midphaseP += " "
                        self.DRYlabel.setText("<small><b>" + u(QApplication.translate("Label", "RAMP%",None, QApplication.UnicodeUTF8)) + "</b></small>")
                        self.DRYlcd.display(QString(midphaseP))
                    elif aw.qmc.phasesLCDmode == 2: # temp mode
                        if self.qmc.timeindex[6]: # after drop
                            dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                        else:
                            dBT = self.qmc.temp2[-1]
                        dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[1]])
                        self.DRYlabel.setText("<small><b>" + u(QApplication.translate("Label", "DRY",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")
                        self.DRYlcd.display(QString(dBT + self.qmc.mode))                       
                    # TP2DRY
                    if window_width > 950 and self.qmc.TPalarmtimeindex:
                        t = self.qmc.timex[self.qmc.timeindex[1]] - self.qmc.timex[self.qmc.TPalarmtimeindex]
                        self.TP2DRYlabel.setText(QString(self.qmc.stringfromseconds(int(t))))
                    else:
                        self.TP2DRYlabel.setText("")
                else:
                    # before DRY
                    self.DRYlabel.setText("<small><b>&raquo;" + u(QApplication.translate("Label", "DRY",None, QApplication.UnicodeUTF8)) + "</b></small>")
                    if self.qmc.timeindex[0] > -1 and self.qmc.TPalarmtimeindex and len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                        # display expected time to reach DRY as defined in the background profile or the phases dialog
                        if self.qmc.background and self.qmc.timeindexB[1]:
                            drytarget = self.qmc.temp2B[self.qmc.timeindexB[1]] # Background DRY BT temperature
                        else:
                            drytarget = self.qmc.phases[1] # Drying max phases definition
                        if drytarget > self.qmc.temp2[-1]:
                            dryexpectedtime = (drytarget - self.qmc.temp2[-1])/(self.qmc.delta2[-1]/60.)
                            tstring = QString(self.qmc.stringfromseconds(int(tx - self.qmc.timex[self.qmc.timeindex[0]] + dryexpectedtime)))
                            self.DRYlcd.display(tstring)
                        else:
                            self.DRYlcd.display(QString("--:--"))
                    else:
                        self.DRYlcd.display(QString("--:--"))
                    self.TP2DRYlabel.setText("")

                # FCs phase LCD  
                if self.qmc.timeindex[2]:
                    # after FCs
                    if self.qmc.timeindex[6]: # after drop
                        ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                    else: # before drop
                        ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                    if aw.qmc.phasesLCDmode == 0: # time mode
                        self.FCslabel.setText("<small><b>" + u(QApplication.translate("Label", "FCs",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")
                        self.FCslcd.display(QString(self.qmc.stringfromseconds(int(ts))[1:]))
                    elif aw.qmc.phasesLCDmode == 1: # percentage mode
                        finishphaseP = fmtstr%(ts*100/totaltime)
                        if not aw.qmc.LCDdecimalplaces:
                            finishphaseP += " "
                        self.FCslabel.setText("<small><b>" + u(QApplication.translate("Label", "DEV%",None, QApplication.UnicodeUTF8)) + "</b></small>")
                        self.FCslcd.display(QString(finishphaseP))
                    elif aw.qmc.phasesLCDmode == 2: # temp mode
                        if self.qmc.timeindex[6]: # after drop
                            dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                        else:
                            dBT = self.qmc.temp2[-1]
                        dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[2]])
                        self.FCslabel.setText("<small><b>" + u(QApplication.translate("Label", "FCs",None, QApplication.UnicodeUTF8)) + "&raquo;</b></small>")
                        self.FCslcd.display(QString(dBT + self.qmc.mode))                        
                    # DRY2FCs
                    if  window_width > 950 and self.qmc.timeindex[1]:
                        t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                        self.DRY2FCslabel.setText(QString(self.qmc.stringfromseconds(int(t))))
                    else:
                        self.DRY2FCslabel.setText("")
                else:
                    # before FCs
                    self.FCslabel.setText("<small><b>&raquo;" + u(QApplication.translate("Label", "FCs",None, QApplication.UnicodeUTF8)) + "</b></small>")
                    if self.qmc.timeindex[0] > -1 and self.qmc.timeindex[1] and len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                        ts = tx - self.qmc.timex[self.qmc.timeindex[1]]
                        self.FCslcd.display(QString(self.qmc.stringfromseconds(int(ts))[1:]))
                        # display expected time to reach FCs as defined in the background profile or the phases dialog
                        if self.qmc.background and self.qmc.timeindexB[2]:
                            fcstarget = self.qmc.temp2B[self.qmc.timeindexB[2]] # Background FCs BT temperature
                        else:
                            fcstarget = self.qmc.phases[2] # FCs min phases definition
                        if fcstarget > self.qmc.temp2[-1]:
                            fcsexpectedtime = (fcstarget - self.qmc.temp2[-1])/(self.qmc.delta2[-1]/60.)
                            tstring = QString(self.qmc.stringfromseconds(int(tx - self.qmc.timex[self.qmc.timeindex[0]] + fcsexpectedtime)))
                            self.FCslcd.display(tstring)
                        else:
                            self.FCslcd.display(QString("--:--"))
                    else:
                        self.FCslcd.display(QString("--:--"))
                    self.DRY2FCslabel.setText("")
        except Exception as e:            
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " updatePhasesLCDs() %1").arg(str(e)),exc_tb.tb_lineno)

    def makeLCDbox(self,label,lcd,lcdframe):
        LCDbox = QVBoxLayout()
        LCDbox.setSpacing(0)
        LCDbox.addWidget(label)
        LCDhBox = QHBoxLayout()
        LCDhBox.addStretch()
        LCDhBox.addWidget(lcd)
        LCDbox.addLayout(LCDhBox)
        LCDhBox.setContentsMargins(0, 0, 0, 0)
        LCDbox.setContentsMargins(0, 0, 0, 0)
        lcdframe.setContentsMargins(0, 10, 0, 3)
        lcdframe.setLayout(LCDbox)
        return lcdframe

    def updateSliderLCD(self,n,v):
        if v > 99:
            v = 99
        elif v < 0:
            v = 0
        if n == 0:
            self.sliderLCD1.display(v)
        elif n == 1:
            self.sliderLCD2.display(v)
        elif n == 2:
            self.sliderLCD3.display(v)
        elif n == 3:
            self.sliderLCD4.display(v)
            
    def updateSVSliderLCD(self,v):
        if v > aw.arduino.svSliderMax:
            v = aw.arduino.svSliderMax
        if v < aw.arduino.svSliderMin:
            v = aw.arduino.svSliderMin
        self.sliderLCDSV.display(v)

    def sliderSVreleased(self):
        if aw.qmc.LCDdecimalplaces:
            s = "%.1f"%self.sliderSV.value()
        else:
            s = "%.0f"%self.sliderSV.value()
        aw.sendmessage(QApplication.translate("Message","SV set to %s"%s, None, QApplication.UnicodeUTF8))
        aw.arduino.setSV(self.sliderSV.value(),False)

    def moveSVslider(self,v):
        if aw.arduino.svSlider:
            self.sliderSV.setValue(v)

    def sliderReleased(self,n):
        if n == 0:
            if self.slider1.value() != self.eventslidervalues[0]:
                self.eventslidervalues[0] = self.slider1.value()
                self.recordsliderevent(n)
        elif n == 1:
            if self.slider2.value() != self.eventslidervalues[1]:
                self.eventslidervalues[1] = self.slider2.value()
                self.recordsliderevent(n)
        elif n == 2:
            if self.slider3.value() != self.eventslidervalues[2]:
                self.eventslidervalues[2] = self.slider3.value()
                self.recordsliderevent(n)
        elif n == 3:
            if self.slider4.value() != self.eventslidervalues[3]:
                self.eventslidervalues[3] = self.slider4.value()
                self.recordsliderevent(n)
        return False

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    def fireslideraction(self,n):
        action = self.eventslideractions[n]
        if action:
            try:
                # action =0 (None), =1 (Serial), =2 (Modbus), =3 (DTA Command), =4 (Call Program [with argument])
                action = (action+2 if action > 1 else action)
                if action == 6:
                    action = 7 # skip the 6:IO Command
                value = int(round((self.eventsliderfactors[n] * self.eventslidervalues[n]) + self.eventslideroffsets[n]))
                cmd = self.eventslidercommands[n]
                cmd = cmd.format(value)
                self.eventaction(action,cmd)
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " fireslideraction() %1").arg(str(e)),exc_tb.tb_lineno)

    def recordsliderevent(self,n):
        if self.qmc.flagstart:
            value = aw.float2float((self.eventslidervalues[n] + 10.0) / 10.0)
            self.qmc.EventRecordAction(extraevent = 1,eventtype=n,eventvalue=value)
        self.fireslideraction(n)

    def sliderLCD(self):
        slcd = QLCDNumber()
        slcd.setSegmentStyle(2)
        slcd.setNumDigits(2)
        slcd.setMinimumHeight(35)
        slcd.setMinimumWidth(50)
        slcd.setMaximumWidth(50)
        slcd.setFrameStyle(QFrame.Panel | QFrame.Plain)
        slcd.setLineWidth(0)
        slcd.setContentsMargins(0,0,0,0)
        return slcd

    def slider(self):
        s = QSlider()
        s.setTickPosition(3)
        s.setTickInterval(10)
        s.setSingleStep(1)
        s.setPageStep(10)
        s.setMaximum(100)
        s.setMinimumWidth(50) 
        s.setMaximumWidth(50) 
        s.setContentsMargins(0,0,0,0)
        return s

    def setLabelColor(self,label,color):
        palette = QPalette(label.palette()) # make a copy of the palette
        palette.setColor(QPalette.Foreground, color)
        label.setPalette(palette) # assign new palette

    #adds errors
    def addserial(self,serialstring):
        try:
            #### lock shared resources #####
            aw.qmc.serialsemaphore.acquire(1)
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            #keep a max of 1000 comm strings
            if len(self.seriallog) > 999:
                self.seriallog = self.seriallog[1:]
            self.seriallog.append(timez + " " + serialstring)
        except:
            pass
        finally:
            if aw.qmc.serialsemaphore.available() < 1:
                aw.qmc.serialsemaphore.release(1)

    def resizeEvent(self, event):
        #if HUD is ON when resizing application. No drawing should be done inside this handler
        if self.qmc.HUDflag:
            self.qmc.hudresizeflag = True
        super(ApplicationWindow,self).resizeEvent(event)

    def setdpi(self,dpi,moveWindow=True):
        if aw:
            aw.dpi = dpi
            self.qmc.fig.set_dpi(dpi)
            #move widget to update display
            if moveWindow:
                self.showFullScreen()
                libtime.sleep(0.3)
                self.showNormal()

    def enableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(True)
            self.fileSaveAsAction.setEnabled(True) 

    def disableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(False)
            self.fileSaveAsAction.setEnabled(False) 

    #actions: 0 = None; 1= Serial Command; 2= Call program; 3= Multiple Event; 4= Modbus Command; 5=DTA Command; 6=IO Command (Phidgets IO), 7=Call Program with argument (slider action)
    def eventaction(self,action,cmd):
        if action:
            try:
                cmd_str = str(cmd)
                if action == 1:
                    cmd_str_bin = ""
                    #example a2b_uu("Hello") sends Hello in binary format instead of ASCII
                    if "a2b_uu" in cmd_str:
                        cmd_str = cmd_str[(len("a2b_uu")+1):][:1]  # removes function-name + char ( and )
                        cmd_str_bin = binascii.a2b_uu(cmd_str)
                    if cmd_str_bin:
                        self.ser.sendTXcommand(cmd_str_bin)
                    else:
                        self.ser.sendTXcommand(cmd_str)
                elif action == 2: # alarm and button call program action (without any argument)
                    try:
                        if cmd_str and len(cmd_str.split(" ")) > 1:
                            self.call_prog_with_args(cmd_str) # a command with argument
                        else:
# take care, the QDir().current() directory changes with loads and saves 
#                        QDesktopServices.openUrl(QUrl("file:///" + u(QDir().current().absolutePath()) + "/" + cmd_str, QUrl.TolerantMode))
                            if platf in ['Windows','Linux']:
                                QDesktopServices.openUrl(QUrl("file:///" + u(QApplication.applicationDirPath()) + "/" + cmd_str, QUrl.TolerantMode))
                            else: # on Darwin
                                QDesktopServices.openUrl(QUrl("file:///" + u(QApplication.applicationDirPath()) + "/../../../" + cmd_str, QUrl.TolerantMode))
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " eventaction() %1").arg(str(e)),exc_tb.tb_lineno)
                elif action == 3:
                    cmds = cmd_str.split(",")
                    for i in range(len(cmds)):
                        buttonnumber = int(cmds[i])-1
                        if self.extraeventsactions[buttonnumber] != 3:   #avoid calling other buttons with multiple actions to avoid possible infinite loops
                            self.recordextraevent(buttonnumber)
                elif action == 4:
                    # TODO: add "_" substitution and read command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = False #
                        for c in cmds:
                            cs = c.replace("_",str(aw.modbus.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if followupCmd:
                                libtime.sleep(0.80) # add time between commands to let the server compute the results
                            if cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "write(s,r,v)"
                                            libtime.sleep(0.30) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                            aw.modbus.writeRegister(*cmds)
                                            followupCmd = True
                                        else:
                                        # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cmd in cmds:
                                                libtime.sleep(0.30) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                                aw.modbus.writeRegister(*cmd)
                                            followupCmd = True
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        libtime.sleep(0.30) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                        aw.modbus.writeRegister(*cmds)
                                        followupCmd = True
                                except:
                                    pass
                            elif cs.startswith("wcoils"):
                                try:
                                    cmds = eval(cs[len('wcoils'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "wcoils(s,r,[<b>,..<b>])"
                                            libtime.sleep(0.30) # respect the MODBUS timing (a MODBUS command might have preceeded)  
                                            aw.modbus.writeCoils(*cmds)
                                            followupCmd = True
                                except:
                                    pass
                            elif cs.startswith("wcoil"):
                                try:
                                    cmds = eval(cs[len('wcoil'):])
                                    if isinstance(cmds,tuple) and len(cmds) == 3:
                                        # cmd has format "wcoil(s,r,<b>)"
                                        libtime.sleep(0.30) # respect the MODBUS timing (a MODBUS command might have preceeded)                       
                                        aw.modbus.writeCoil(*cmds)
                                        followupCmd = True
                                except:
                                    pass
                            elif cs.startswith("read"):
                                try:
                                    cmds = eval(cs[len('read'):])
                                    if isinstance(cmds,tuple) and len(cmds) == 2:
                                        # cmd has format "read(s,r)"
                                        libtime.sleep(0.30) # respect the MODBUS timing (a MODBUS command might have preceeded)                       
                                        aw.modbus.lastReadResult = aw.modbus.readSingleRegister(*cmds)
                                        followupCmd = True
                                except:
                                    pass
                elif action == 5:
                    try:
                        DTAvalue=cmd_str.split(':')[1]
                        DTAaddress=cmd_str.split(':')[0]
                        aw.dtapid.writeDTE(DTAvalue,DTAaddress)
                    except:
                        pass
                elif action == 6:
                    try:
                        if aw.ser.PhidgetIO and aw.ser.PhidgetIO.isAttached():
                            if cmd_str.startswith('set(') and len(cmd_str)>7:
                                c,v = cmd_str[4:-1].split(',')
                                aw.ser.PhidgetIO.setOutputState(int(c),bool(int(v)))
                            elif cmd-str.startswith('toggle(') and len(cmd_str)>8:
                                c = int(cmd_str[7:-1])
                                state = bool(aw.ser.PhidgetIO.getOutputState(c))
                                aw.ser.PhidgetIO.setOutputState(c,not(state))
                    except:
                        pass
                elif action == 7: # slider call-program action
                    try:
                        self.call_prog_with_args(cmd_str)
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " callProgram(): %1").arg(str(e)),exc_tb.tb_lineno)
            except:
                pass
                
    def call_prog_with_args(self,cmd_str):
        cmd_str_parts = cmd_str.split(" ")
        if len(cmd_str_parts) > 0:
            cmd = cmd_str_parts[0].strip()
            prg_file = u(aw.getAppPath()) + u(cmd)
            subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]])
            # alternative approach, that seems to fail on some Mac OS X versions:
            #QProcess.startDetached(prg_file)
                    
    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    # updates corresponding eventslidervalues
    def moveslider(self,n,v):
        if v >= 0 and v <= 100:
            self.eventslidervalues[n] = v
            if n == 0:
                self.slider1.setValue(v)
                self.updateSliderLCD(0,v)
            elif n == 1:
                self.slider2.setValue(v)
                self.updateSliderLCD(1,v)
            elif n == 2:
                self.slider3.setValue(v)
                self.updateSliderLCD(2,v)
            elif n == 3:
                self.slider4.setValue(v)
                self.updateSliderLCD(3,v)

    #call from user configured event buttons
    def recordextraevent(self,ee):
        eventtype = self.extraeventstypes[ee]
        try:
            # reset color of last pressed button
            if self.lastbuttonpressed != -1:
                normalstyle = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(self.extraeventbuttontextcolor[self.lastbuttonpressed],self.extraeventbuttoncolor[self.lastbuttonpressed])
                self.buttonlist[self.lastbuttonpressed].setStyleSheet(normalstyle)
            # set color of this button to "pressed"
            pressedstyle = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(self.extraeventbuttoncolor[ee],self.extraeventbuttontextcolor[ee])
            self.buttonlist[ee].setStyleSheet(pressedstyle)
            # reset lastbuttonpressed
            self.lastbuttonpressed = ee
        except:
            pass
        if eventtype < 4:  ## if eventtype == 4 we have an button event of type "--" that does not add an event
            if self.qmc.flagstart:
                self.qmc.EventRecord(extraevent = ee)
            value = (self.extraeventsvalues[ee] - 1) # TODO: why "-1" here??
            cmdvalue = int(round((self.eventsliderfactors[eventtype] * value) + self.eventslideroffsets[eventtype]))
            self.eventaction(self.extraeventsactions[ee],u(self.extraeventsactionstrings[ee]).format(cmdvalue))
            # move corresponding slider to new value:
            self.moveslider(eventtype,aw.qmc.eventsInternal2ExternalValue(self.extraeventsvalues[ee]))
        else:
            # just issue the eventaction (no cmd substitution here)
            self.eventaction(self.extraeventsactions[ee],u(self.extraeventsactionstrings[ee]))

    def resetApplication(self):
        string = QApplication.translate("Message","Do you want to reset all settings?", None, QApplication.UnicodeUTF8)
        reply = QMessageBox.warning(self,QApplication.translate("Message","Factory Reset", None, QApplication.UnicodeUTF8),string,
                            QMessageBox.Cancel | QMessageBox.Reset)
        if reply == QMessageBox.Reset :
            #raise flag. Next time app will open, the settings (bad settings) will not be loaded.
            self.resetqsettings = 1
            self.close()
        elif reply == QMessageBox.Cancel:
            return

    def on_actionCut_triggered(self,checked=None):
        try:
            app.activeWindow().focusWidget().cut()
        except:
            pass

    def on_actionCopy_triggered(self,checked=None):
        try:
            app.activeWindow().focusWidget().copy()
        except:
            pass

    def on_actionPaste_triggered(self,checked=None):
        try:
            app.activeWindow().focusWidget().paste()
        except:
            pass

    def sendmessage(self,message):
        try:
            #### lock shared resources #####
            aw.qmc.messagesemaphore.acquire(1)
            message = aw.arabicReshape(message)
            #keep a max of 100 messages
            if len(self.messagehist) > 99:
                self.messagehist = self.messagehist[1:]
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz ")))    #zzz = miliseconds
            self.messagehist.append(timez + message)
            self.messagelabel.setText(message)
        except:
            pass
        finally:
            if aw.qmc.messagesemaphore.available() < 1:
                aw.qmc.messagesemaphore.release(1)

    def hideDefaultButtons(self):
        self.lowerbuttondialog.setVisible(False)

    def showDefaultButtons(self):
        self.lowerbuttondialog.setVisible(True)

    def hideExtraButtons(self):
        self.extrabuttondialogs.setVisible(False)

    def showExtraButtons(self):
        self.extrabuttondialogs.setVisible(True)

    def updateSliders(self):
        # update visibility (based on the app state)
        if self.qmc.flagon:
            self.showSliders()
        else:
            self.hideSliders()

    def hideSliders(self):
        self.sliderFrame.setVisible(False)

    def showSliders(self):
        self.sliderFrame.setVisible(True)
        
    def toggleSlidersVisibility(self):
        if self.sliderFrame.isVisible():
            self.hideSliders()
        else:
            self.showSliders()

    def updateSlidersProperties(self):
        # update slider properties
        aw.sliderGrpBox1.setVisible(bool(aw.eventslidervisibilities[0]))
        aw.sliderGrpBox2.setVisible(bool(aw.eventslidervisibilities[1]))
        aw.sliderGrpBox3.setVisible(bool(aw.eventslidervisibilities[2]))
        aw.sliderGrpBox4.setVisible(bool(aw.eventslidervisibilities[3]))
        # update event type names
        aw.sliderGrpBox1.setTitle(aw.qmc.etypesf(0))
        aw.sliderGrpBox2.setTitle(aw.qmc.etypesf(1))
        aw.sliderGrpBox3.setTitle(aw.qmc.etypesf(2))
        aw.sliderGrpBox4.setTitle(aw.qmc.etypesf(3))

    def hideLCDs(self):
        self.lcdFrame.setVisible(False)

    def showLCDs(self):
        self.lcdFrame.setVisible(True)

    def hideEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(False)

    def showEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(True)

    def updateLCDproperties(self):
        # set LCDframe visibilities and labels
        ndev = len(aw.qmc.extradevices)
        for i in range(ndev):
            aw.extraLCDframe1[i].setVisible(bool(aw.extraLCDvisibility1[i]))
            if i < len(aw.qmc.extraname1):
                aw.extraLCDlabel1[i].setText("<big><b>" + aw.qmc.extraname1[i] + "</b></big>")
            aw.extraLCD1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            self.extraLCDframe2[i].setVisible(bool(aw.extraLCDvisibility2[i])) 
            if i < len(aw.qmc.extraname2):
                aw.extraLCDlabel2[i].setText("<big><b>" + aw.qmc.extraname2[i] + "</b></big>")
            aw.extraLCD2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        #hide the rest (just in case)
        for i in range(ndev,aw.nLCDS):
            aw.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)
        aw.LCD2frame.setVisible(aw.qmc.ETlcd)
        aw.LCD3frame.setVisible(aw.qmc.BTlcd)
        aw.LCD4frame.setVisible(aw.qmc.DeltaETlcdflag)
        aw.LCD5frame.setVisible(aw.qmc.DeltaBTlcdflag)
        if aw.largeLCDs_dialog:
            try:
                aw.largeLCDs_dialog.lcd2.setVisible(aw.qmc.ETlcd)
                aw.largeLCDs_dialog.lcd3.setVisible(aw.qmc.BTlcd)
            except:
                pass
        if aw.qmc.device == 0 or aw.qmc.device == 26:         #extra LCDs for Fuji or DTA pid
            aw.LCD6frame.setVisible(True)
            aw.LCD7frame.setVisible(True)
        else:
            aw.LCD6frame.setVisible(False) 
            aw.LCD7frame.setVisible(False)
        if self.qmc.LCDdecimalplaces:
            self.setLCDsDigitCount(5)
        else:
            self.setLCDsDigitCount(3)

    def enableEditMenus(self):
        self.fileLoadAction.setEnabled(True) # open
        self.openRecentMenu.setEnabled(True) # open recent
        self.importMenu.setEnabled(True) # import
        self.fileSaveAction.setEnabled(True)
        self.fileSaveAsAction.setEnabled(True)
        self.exportMenu.setEnabled(True)
        self.saveGraphMenu.setEnabled(True)
        self.htmlAction.setEnabled(True)
        self.printAction.setEnabled(True)
        self.flavorAction.setEnabled(True)
        self.temperatureMenu.setEnabled(True)
        self.languageMenu.setEnabled(True)
        self.designerAction.setEnabled(True)
        self.wheeleditorAction.setEnabled(True)
        self.resetAction.setEnabled(True)
        self.switchAction.setEnabled(True)

    def disableEditMenus(self):
        self.fileLoadAction.setEnabled(False) # open
        self.openRecentMenu.setEnabled(False) # open recent
        self.importMenu.setEnabled(False) # import
        self.fileSaveAction.setEnabled(False)
        self.fileSaveAsAction.setEnabled(False)
        self.exportMenu.setEnabled(False)
        self.saveGraphMenu.setEnabled(False)
        self.htmlAction.setEnabled(False)
        self.printAction.setEnabled(False)
        self.flavorAction.setEnabled(False)
        self.temperatureMenu.setEnabled(False)
        self.languageMenu.setEnabled(False)
        self.designerAction.setEnabled(False)
        self.wheeleditorAction.setEnabled(False)
        self.resetAction.setEnabled(False)
        self.switchAction.setEnabled(False)

    def update_minieventline_visibility(self):
        if self.minieventsflag:
            self.EventsGroupLayout.setVisible(True)
        else:
            self.EventsGroupLayout.setVisible(False)

    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        key = int(event.key())
        #uncomment next line to find the integer value of a key
        #key)
        
        if key == 70: # F SELECTS FULL SCREEN MODE
            if self.full_screen_mode_active or self.isFullScreen():
                self.full_screen_mode_active = False
                self.showNormal()
            else:
                self.full_screen_mode_active = True
                self.showFullScreen()
        elif key == 32:                       #SELECTS ACTIVE BUTTON
            self.moveKbutton("space")
        elif key == 16777220:                 #TURN ON/OFF KEYBOARD MOVES
            self.releaseminieditor()
            self.moveKbutton("enter")
        elif key == 16777216:                 #ESCAPE
            self.quickEventShortCut = None
            aw.sendmessage("")
            if self.full_screen_mode_active or self.isFullScreen():
                self.full_screen_mode_active = False
                self.showNormal()
            else:
                #if designer ON
                if self.qmc.designerflag:
                    string = QApplication.translate("Message","Exit Designer?", None, QApplication.UnicodeUTF8)
                    reply = QMessageBox.question(self,QApplication.translate("Message", "Designer Mode ON",None, QApplication.UnicodeUTF8),string,QMessageBox.Yes|QMessageBox.Cancel)
                    if reply == QMessageBox.Yes:
                        self.stopdesigner()
                    else:
                        return
                #if wheel graph ON
                elif self.qmc.wheelflag:
                    self.qmc.disconnectWheel()
                    self.qmc.redraw(recomputeAllDeltas=False)
                if self.minieventsflag:
                    self.releaseminieditor()
        elif key == 16777234:               #MOVES CURRENT BUTTON LEFT
            self.moveKbutton("left")
        elif key == 16777236:               #MOVES CURRENT BUTTON RIGHT
            self.moveKbutton("right")
        elif key == 65:                     #letter A (automatic save)
            self.automaticsave()
        elif key == 68:                     #letter D (toggle xy between temp and RoR scale)
            self.qmc.fmt_data_RoR = not (self.qmc.fmt_data_RoR)
        elif key == 83:                     #letter S (sliders)
            self.toggleSlidersVisibility()
        elif key == 84:                     #letter T (mouse cross)
            self.qmc.togglecrosslines()
        elif key == 81 and aw.qmc.flagstart:  #letter q (quick entry of custom event 1)
            self.quickEventShortCut = (0,"")
            aw.sendmessage("%s"%aw.qmc.etypes[0])
        elif key == 87 and aw.qmc.flagstart:  #letter w (quick entry of custom event 2)
            self.quickEventShortCut = (1,"")
            aw.sendmessage("%s"%aw.qmc.etypes[1])
        elif key == 69 and aw.qmc.flagstart:  #letter e (quick entry of custom event 3)
            self.quickEventShortCut = (2,"")
            aw.sendmessage("%s"%aw.qmc.etypes[2])
        elif key == 82 and aw.qmc.flagstart:  #letter r (quick entry of custom event 4)
            self.quickEventShortCut = (3,"")
            aw.sendmessage("%s"%aw.qmc.etypes[3])
        elif key == 66:  #letter b hides/shows extra rows of event buttons
            if aw.qmc.flagon:
                self.toggleextraeventrows()
                aw.update_extraeventbuttons_visibility()
            else:
                # allow to use 'b' key also if OFF
                if aw.extrabuttondialogs.isVisible():
                    aw.hideExtraButtons()
                    aw.extraeventsbuttonsflag = False
                else:
                    aw.update_extraeventbuttons_visibility()
                    aw.showExtraButtons()
                    aw.extraeventsbuttonsflag = True
        #Extra event buttons palette. Numerical keys [0,1,2,3,4,5,6,7,8,9]
        elif key > 47 and key < 58:
            button = [48,49,50,51,52,53,54,55,56,57] 
            if self.quickEventShortCut:
                # quick custom event entry
                eventNr = self.quickEventShortCut[0]
                eventValueStr = self.quickEventShortCut[1] + str(button.index(key))
                aw.sendmessage("%s %s"%(aw.qmc.etypes[eventNr],eventValueStr))
                if len(eventValueStr) == 2:
                    # both digits entered, create the event
                    self.quickEventShortCut = None
                    value = int(eventValueStr)
                    aw.moveslider(eventNr,value)
                    if aw.qmc.flagstart:
                        aw.qmc.EventRecordAction(extraevent = 1,eventtype=eventNr,eventvalue=(value + 10)/10.)
                    aw.fireslideraction(eventNr)
                else:
                    # keep on looking for digits
                    self.quickEventShortCut = (eventNr,eventValueStr)
            else:
    #            palette = button.index(key)
    # for now we deactivate this extra dialog step
    #            string = QApplication.translate("Message","Changing palettes will delete the present extra event buttons.\nRestore palette %i?"%palette,
    #                                            None, QApplication.UnicodeUTF8)
    #            reply = QMessageBox.question(self,QApplication.translate("Message", "Extra Event Button Palette",None, QApplication.UnicodeUTF8),
    #                                         string,QMessageBox.Yes|QMessageBox.Cancel)
    #            if reply == QMessageBox.Yes:
    #                self.setbuttonsfrom(button.index(key))
    #            else:
    #                return
                self.setbuttonsfrom(button.index(key))
        elif key == 58 and not aw.qmc.flagon: # screenshots only if not sampling!
            self.desktopscreenshot()
        elif key == 59 and not aw.qmc.flagon: # screenshots only if not sampling!
            self.applicationscreenshot() 
        elif key == 73:                     #letter I (get weight in from scale)
            self.retrieveWeightIn()
        elif key == 79:                     #letter O (get weight out from scale)
            self.retrieveWeightOut()
        else:
            QWidget.keyPressEvent(self, event)

    def releaseminieditor(self):
        if self.minieventsflag:
            self.eNumberSpinBox.releaseKeyboard()
            self.lineEvent.releaseKeyboard()
            self.etimeline.releaseKeyboard()
            self.etypeComboBox.releaseKeyboard()
            self.valueEdit.releaseKeyboard()
            self.eNumberSpinBox.releaseKeyboard()
            self.lineEvent.clearFocus()
            self.valueEdit.clearFocus()
            self.etimeline.clearFocus()
            self.eNumberSpinBox.clearFocus()

    # this function respects the button visibility via aw.qmc.buttonvisibility and if button.isDisabled()
    # ON/OFF (2,self.button_1) -> CHARGE (3,self.button_8) -> DRYEND (4,self.button_19) -> FCs (5,self.button_3)
    # -> FCe (6,self.button_4) -> SCs (7,self.button_5) -> SCe (8,self.button_6) -> DROP (9,self.button_9) 
    # -> COOLend (10,self.button_20) -> EVENT (11,self.button_11) -> HUD (1,self.button_18) -> ON/OFF
    # currentButtonIndex is from [1-11]
    # buttons that trigger events and can be triggered only once
    def nextActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 11 and aw.qmc.HUDbuttonflag: # current: EVENT
            # the current button index is the event button, we move to the HUD button
            return 1 # next: HUD
        elif currentButtonIndex == 1 or (currentButtonIndex == 11 and not aw.qmc.HUDbuttonflag): # current: HUD
            return 2 # next: ON/OFF
        elif currentButtonIndex == 10: # current: COOL
            # check if the EVENT button is active, else move to the HUD
            if aw.eventsbuttonflag:
                return 11 # next: EVENT
            else:
                return 1 # next: HUD
        else:
            # we check if the next button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
            # there is an offset of 3
            if aw.qmc.buttonvisibility[currentButtonIndex - 2] and self.keyboardButtonList[currentButtonIndex + 1].isEnabled():
                return currentButtonIndex + 1
            else:
                return self.nextActiveButton(currentButtonIndex + 1)

    def previousActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 2 and aw.qmc.HUDbuttonflag: # current: ON/OFF
            # the current button index is the ON/OFF button, we move to the HUD button (if visible)
            return 1
        elif currentButtonIndex == 1 or (currentButtonIndex == 2 and not aw.qmc.HUDbuttonflag): # current: HUD
            # check if the EVENT button is active, else move to the HUD
            if aw.eventsbuttonflag:
                return 11 # move to EVENT
            else:
                return self.previousActiveButton(10) # move to prev(EVENT)
        elif currentButtonIndex == 3: # current: CHARGE
            return 2 # next: ON/OFF
        else:
            # we check if the previous button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
            # there is an offset of 3
            if aw.qmc.buttonvisibility[currentButtonIndex - 4] and self.keyboardButtonList[currentButtonIndex - 1].isEnabled():
                return currentButtonIndex - 1
            else:
                return self.previousActiveButton(currentButtonIndex - 1)

    def resetKeyboardButtonMarks(self):
        if self.qmc.flagon:    
            self.button_1.setStyleSheet(self.pushbuttonstyles["ON"])
        else:
            self.button_1.setStyleSheet(self.pushbuttonstyles["OFF"])
        self.button_8.setStyleSheet(self.pushbuttonstyles["CHARGE"])
        self.button_19.setStyleSheet(self.pushbuttonstyles["DRY END"])
        self.button_20.setStyleSheet(self.pushbuttonstyles["COOL END"])
        self.button_3.setStyleSheet(self.pushbuttonstyles["FC START"])
        self.button_4.setStyleSheet(self.pushbuttonstyles["FC END"])
        self.button_5.setStyleSheet(self.pushbuttonstyles["SC START"])
        self.button_6.setStyleSheet(self.pushbuttonstyles["SC END"])
        self.button_9.setStyleSheet(self.pushbuttonstyles["DROP"])
        self.button_11.setStyleSheet(self.pushbuttonstyles["EVENT"])
        if self.qmc.flagstart:
            if self.qmc.HUDflag:
                self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_ON"])
            else:
                self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
        else:
            aw.button_18.setStyleSheet(aw.pushbuttonstyles["DISABLED"])

    def moveKbutton(self,kcommand):
        #"Enter" toggles ON/OFF keyboard    
        if kcommand =="enter" and self.qmc.flagstart:
            if self.keyboardmoveflag == 0:
                #turn on
                self.keyboardmoveflag = 1
                # deactivate slider keyboard control
                self.setSliderFocusPolicy(Qt.NoFocus)
                self.keyboardmoveindex = 2
                self.sendmessage(QApplication.translate("Message","Keyboard moves turned ON", None, QApplication.UnicodeUTF8))
                self.button_1.setStyleSheet(self.pushbuttonstyles["SELECTED"])
                
            elif self.keyboardmoveflag == 1:
                # turn off 
                self.keyboardmoveflag = 0
                # activate slider keyboard control
                self.setSliderFocusPolicy(Qt.StrongFocus)
                # clear all
                self.sendmessage(QApplication.translate("Message","Keyboard moves turned OFF", None, QApplication.UnicodeUTF8))
                self.resetKeyboardButtonMarks()
        #if moves on
        if self.keyboardmoveflag:
            if kcommand == "space":
                now = libtime.time()
                if self.lastkeyboardcmd == 0 or (now > self.lastkeyboardcmd + 2): # accept SPACE keyboard cmds only every 2sec.
                    self.keyboardmove[self.keyboardmoveindex]()   #apply button command
                    #behaviour rules after pressing a button
                    #if less than EVENT jump forward to the right once automatically
                    if self.keyboardmoveindex > 1 and self.keyboardmoveindex < 11:
                        self.moveKbutton("right")
                    self.lastkeyboardcmd = now
                    self.releaseminieditor()
                else: # we ignore this event
                    return
            else:
                if kcommand == "left":
                    nextcmd = self.previousActiveButton(self.keyboardmoveindex)
                else:
                    nextcmd = self.nextActiveButton(self.keyboardmoveindex)
                # activate the button at index nextcmd
                self.keyboardButtonList[nextcmd].setStyleSheet(self.pushbuttonstyles["SELECTED"])
                # deactivate the button at index self.keyboardmoveindex
                if self.keyboardmoveindex == 1: # we make an exception to respect the state of the HUD button
                    if self.qmc.HUDflag:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_ON"])
                    else:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
                else:
                    self.keyboardButtonList[self.keyboardmoveindex].setStyleSheet(self.pushbuttonstyles[self.keyboardButtonStyles[self.keyboardmoveindex]])
                # update self.keyboardmoveindex
                self.keyboardmoveindex = nextcmd
        # we enable keyboard event processing again

    #sound feedback when pressing a push button
    def soundpop(self):
        if self.soundflag:
            QApplication.beep()
# the following does not work on the Mac, nor under Python3
#            try:
#                import pyaudio
#            except ImportError:
#                return False
#
#            p = pyaudio.PyAudio()
#            stream = p.open(rate=44100, channels=1, format=pyaudio.paFloat32, output=True, input=False)
#            stream.write(array.array('b',(int(.25 * math.sin(i / 10.)) for i in range(44100))))
#            stream.close()
#            p.terminate()


    def removeDisallowedFilenameChars(self,filename):
        validFilenameChars = "-_.() %s%s" % (libstring.ascii_letters, libstring.digits)
        cleanedFilename = unicodedata.normalize('NFKD', filename).encode('ASCII', 'ignore')
        return ''.join(c for c in cleanedFilename if c in validFilenameChars)
    
    
    def generateFilename(self,prefix=""):
        title = None
        if  aw.qmc.title != "" and aw.qmc.title != QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8):
            title = aw.qmc.title
        if prefix == "" and title:
            filename = title
        else:
            filename = prefix
        if filename != "":                
            filename += "-" + str(QDateTime.currentDateTime().toString(QString("yy-MM-dd_hhmm")))
        else:
            filename += str(QDateTime.currentDateTime().toString(QString("yy-MM-dd_hhmm")))
        filename += ".alog"
        #clean name
        filename = self.removeDisallowedFilenameChars(u(filename))                    
        return filename
        
    #automatation of filename when saving a file through keyboard shortcut. Speeds things up for batch roasting.
    def automaticsave(self):
        try:
            title = None
            if  aw.qmc.title != "" and aw.qmc.title != QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8):
                title = aw.qmc.title
            if self.qmc.autosavepath and self.qmc.autosaveflag:
                filename = self.generateFilename(prefix=self.qmc.autosaveprefix)
                oldDir = u(QDir.current())
                QDir.setCurrent(self.qmc.autosavepath)
                #write
                self.serialize(QString(filename),self.getProfile())
                #restore dirs
                QDir.setCurrent(oldDir)
                self.sendmessage(QApplication.translate("Message","Profile %1 saved in: %2", None, QApplication.UnicodeUTF8).arg(filename).arg(self.qmc.autosavepath))
                self.setCurrentFile(filename)
                self.qmc.safesaveflag = False
                return filename
            else:
                self.sendmessage(QApplication.translate("Message","Empty path or box unchecked in Autosave", None, QApplication.UnicodeUTF8))
                self.autosaveconf()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Error:",None, QApplication.UnicodeUTF8) + " automaticsave() %1").arg(str(e)),exc_tb.tb_lineno)

    def viewKshortcuts(self):
        string = u(QApplication.translate("Message", "<b>[ENTER]</b> = Turns ON/OFF Keyboard Shortcuts",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[SPACE]</b> = Choses current button",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[LEFT]</b> = Move to the left",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[RIGHT]</b> = Move to the right",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[a]</b> = Autosave",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[CRTL N]</b> = Autosave + Reset + START",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[t]</b> = Mouse cross lines",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[d]</b> = Toggle xy scale (T/Delta)",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[b]</b> = Shows/Hides Extra Event Buttons",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[s]</b> = Shows/Hides Event Sliders",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[i]</b> = Retrieve Weight In from Scale",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[o]</b> = Retrieve Weight Out from Scale",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[0-9]</b> = Changes Event Button Palettes",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[;]</b> = Application ScreenShot",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[:]</b> = Desktop ScreenShot",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[q,w,e,r + <i>nn</i>]</b> = Quick Custom Event",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[f]</b> = Full Screen Mode",None, QApplication.UnicodeUTF8))

        QMessageBox.information(self,QApplication.translate("Message", "Keyboard Shotcuts",None, QApplication.UnicodeUTF8),string)

    #moves events in minieditor
    def changeEventNumber(self):
        if self.qmc.designerflag:
            return
        #check
        lenevents = len(self.qmc.specialevents)
        currentevent = self.eNumberSpinBox.value()
        self.eNumberSpinBox.setDisabled(True)
        try:
            self.eventlabel.setText(QApplication.translate("Label", "Event #<b>%1 </b>",None, QApplication.UnicodeUTF8).arg(currentevent))
            if currentevent == 0:
                self.lineEvent.setText("")
                self.valueEdit.setText("")
                self.etypeComboBox.setCurrentIndex(0)
                self.etimeline.setText("")
                self.qmc.resetlines()
                if not aw.qmc.flagstart:
                    self.qmc.fig.canvas.draw()
                return
            if currentevent > lenevents:
                self.eNumberSpinBox.setValue(lenevents)
                return
            else:
                self.lineEvent.setText(self.qmc.specialeventsStrings[currentevent-1])
                if aw.qmc.timeindex[0] > -1:
                    timez = self.qmc.stringfromseconds(int(self.qmc.timex[self.qmc.specialevents[currentevent-1]]-self.qmc.timex[self.qmc.timeindex[0]]))
                    self.etimeline.setText(timez)
                self.valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[currentevent-1]))
                self.etypeComboBox.setCurrentIndex(self.qmc.specialeventstype[currentevent-1])
                #plot little dot lines
                self.qmc.resetlines() #clear old
                etimeindex = self.qmc.specialevents[currentevent-1]
                if currentevent:
                    x = [self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex]]
                    y = [(self.qmc.ylimit_min-100),self.qmc.temp2[etimeindex],self.qmc.temp1[etimeindex],(self.qmc.ylimit+100)]
                    self.qmc.ax.plot(x,y,marker ="o",markersize=12,color ="yellow",linestyle="-",linewidth = 7,alpha=.4)
                    if not aw.qmc.flagstart:
                        self.qmc.fig.canvas.draw()
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " changeEventNumber() %1").arg(str(e)),exc_tb.tb_lineno)        
        finally:
            self.eNumberSpinBox.setDisabled(False)
            self.eNumberSpinBox.setFocus()


    #updates events from mini edtitor
    def miniEventRecord(self):
        lenevents = self.eNumberSpinBox.value()
        if lenevents:
            self.qmc.specialeventstype[lenevents-1] = self.etypeComboBox.currentIndex()
            self.qmc.specialeventsvalue[lenevents-1] = aw.qmc.str2eventsvalue(str(self.valueEdit.text()))
            self.qmc.specialeventsStrings[lenevents-1] = u(self.lineEvent.text())
            self.qmc.specialevents[lenevents-1] = self.qmc.time2index(self.qmc.timex[self.qmc.timeindex[0]]+ self.qmc.stringtoseconds(str(self.etimeline.text())))

            self.lineEvent.clearFocus()
            self.eNumberSpinBox.clearFocus()
            self.etimeline.clearFocus()

            self.qmc.redraw(recomputeAllDeltas=False)

            #plot highest ET or BT (sometimes only BT is plot (et is zero))
            etimeindex = self.qmc.specialevents[lenevents-1]
            if self.qmc.temp1[etimeindex] > self.qmc.temp2[etimeindex]:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp1[etimeindex], "o", color = self.qmc.palette["et"])
            else:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp2[etimeindex], "o", color = self.qmc.palette["bt"])
            
            if not aw.qmc.flagstart:
                self.qmc.fig.canvas.draw()

            string = ""
            if len(self.qmc.specialeventsStrings[lenevents-1]) > 5:
                string += self.qmc.specialeventsStrings[lenevents-1][0:5]
                string += "..."

            message = u(QApplication.translate("Message","Event #%1:  %2 has been updated", None, QApplication.UnicodeUTF8).arg(str(lenevents)).arg(string))
            self.sendmessage(message)

    def strippedName(self, fullFileName):
        return u(QFileInfo(fullFileName).fileName())

    def strippedDir(self, fullFileName):
        return u(QFileInfo(fullFileName).dir().dirName())

    def setCurrentFile(self, fileName):
        self.curFile = fileName
        if self.curFile:
            self.setWindowTitle(("%s - " + self.windowTitle) % self.strippedName(self.curFile))
            settings = QSettings()
            files = settings.value('recentFileList').toStringList()
            try:
                files.removeAll(fileName)
            except ValueError:
                pass
            files.insert(0, fileName)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentFileList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentFileActions()
        else:
            self.setWindowTitle(self.windowTitle)
 
    def updateRecentFileActions(self):
        settings = QSettings()
        files = settings.value('recentFileList').toStringList()
        strippedNames = list(map(self.strippedName,files))
        numRecentFiles = min(len(files), self.MaxRecentFiles)
 
        for i in range(numRecentFiles):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = "&%s (%s)" % (strippedName, self.strippedDir(files[i]))
            else:
                text = "&%s" % strippedName
            self.recentFileActs[i].setText(text)
            self.recentFileActs[i].setData(files[i])
            self.recentFileActs[i].setVisible(True)
 
        for j in range(numRecentFiles, self.MaxRecentFiles):
            self.recentFileActs[j].setVisible(False)
 
    def openRecentFile(self):
        action = self.sender()
        if action:
            self.loadFile(action.data().toString())

    def getDefaultPath(self):
#        userprofilepath_dir = QDir()
#        userprofilepath_dir.setPath(self.userprofilepath)
#        userprofilepath_elements = userprofilepath_dir.absolutePath().split("/") # directories as QStrings
#        profilepath_dir = QDir()
#        profilepath_dir.setPath(self.profilepath)
#        profilepath_elements = profilepath_dir.absolutePath().split("/")
        #compare profilepath with userprofilepath (modulo the last two segments which are month/year respectively)
        return self.userprofilepath
#        if len(userprofilepath_elements) == len(profilepath_elements) and len(userprofilepath_elements) > 1 and freduce(lambda x,y: x and y, [x[0] == x[1] for x in zip(userprofilepath_elements[:-2],profilepath_elements[:-2])]):
#            if platf == 'Darwin':
#                return self.userprofilepath
#            else:
#                return self.profilepath
#        else:
#            return self.userprofilepath

    def setDefaultPath(self,f):
        if f:
            filepath_dir = QDir()
            filepath_dir.setPath(f)
            filepath_elements = filepath_dir.absolutePath().split("/")[:-1] # directories as QStrings (without the filename)
            self.userprofilepath = u(freduce(lambda x,y: x + '/' + y, filepath_elements) + "/")

    #the central OpenFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanOpenFileDialog(self,msg="Open",ext="*",path=None):
        if path == None:   
            path = self.getDefaultPath()
        f = u(QFileDialog.getOpenFileName(self,msg,path,ext))
        self.setDefaultPath(f)
        return f
 
    #the central SaveFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanSaveFileDialog(self,msg=QApplication.translate("Message","Save",None, QApplication.UnicodeUTF8),ext="*.alog",path=None):
        if path == None:
            path = self.getDefaultPath() 
        f = u(QFileDialog.getSaveFileName(self,msg,path,ext))
        self.setDefaultPath(f)
        return f
 
    #the central ExistingDirectoryDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanExistingDirectoryDialog(self,msg=QApplication.translate("Message","Select Directory",None, QApplication.UnicodeUTF8),path=None):
        if path == None:
            path = self.getDefaultPath()
        f = u(QFileDialog.getExistingDirectory(self,msg,path))
        self.setDefaultPath(f)
        return f

    def newRoast(self):
        #####################################
        #IF there is an ongoing roast (if ON):
        #   (this block allows batch processing using the autosave feature)
        #   if no CHARGE found:
        #       return
        #   if no DROP found:
        #       use last data point as DROP (mark DROP)
        #   stop recording
        #   if there is an autosave path (from autosafe config) AND the autosave flag is ON:
        #       create filename using the autosavepath and date+time
        #   else:
        #       start autosave Dialog to set the name path
        #       return (nothing saved. Cancell New)
        #   reset  (delete everything)
        #   start new roast (START)
        #ELSE (if recording is stoped - OFF):
        #   if no profile present (no data present or profile loaded):
        #       start new roast (START)
        #   else:
        #       reset (reset offers three options: Save,Continue,Cancell)
        #       START
        #########################################
        if self.qmc.flagstart:
            if self.qmc.timeindex[0] == -1:
                self.sendmessage(QApplication.translate("Message","No profile found", None, QApplication.UnicodeUTF8))
                return
            #mark drop if not yet done
            if self.qmc.timeindex[6] == 0:
                self.qmc.markDrop()
            #invoke "OFF"
            self.qmc.OffMonitor()


            filename = self.automaticsave()
# the call to automaticsave() moved to OffRecorder() which is triggered by the above OffMonitor
#            #store, reset and redraw
#            if self.qmc.autosavepath and self.qmc.autosaveflag:
#                #if autosave mode active we just save automatic
#            else:
#                self.sendmessage(QApplication.translate("Message","Empty path or box unchecked in Autosave", None, QApplication.UnicodeUTF8))
#                self.autosaveconf()
#                return
            if self.qmc.reset():
                #start new roast
                self.qmc.ToggleRecorder()
                self.sendmessage(QApplication.translate("Message","%1 has been saved. New roast has started", None, QApplication.UnicodeUTF8).arg(filename))
        else:
            if not len(self.qmc.timex):
                self.qmc.ToggleRecorder()
            else:
                if self.qmc.reset():
                    self.qmc.ToggleRecorder()

    def fileLoad(self):
        try:
            fileName = self.ArtisanOpenFileDialog()
            if fileName:
                self.loadFile(fileName)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " fileLoad() %1").arg(str(ex)),exc_tb.tb_lineno)

    #loads stored profiles. Called from file menu
    def loadFile(self,filename):
        f = None
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            if self.qmc.reset(redraw=False): # operation not canceled by the user in the save dirty state dialog
                firstChar = stream.read(1)
                if firstChar == "{":
                    f.close()
                    res = self.setProfile(filename,self.deserialize(filename))
                else:
                    self.sendmessage(QApplication.translate("Message","Invalid artisan format", None, QApplication.UnicodeUTF8))
                    res = False
                if res:
                    self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                    #update etypes combo box
                    self.etypeComboBox.clear()
                    self.etypeComboBox.addItems(self.qmc.etypes)
                    #Plot everything
                    self.qmc.redraw()
                    message = u(QApplication.translate("Message","%1  loaded ", None, QApplication.UnicodeUTF8).arg(u(filename)))
                    self.sendmessage(message)
                    self.setCurrentFile(filename)
        except IOError as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " %1").arg(str(ex)))
            # remove file from the recent file list
            settings = QSettings()
            files = settings.value('recentFileList').toStringList()
            try:
                files.removeAll(filename)
            except ValueError:
                pass
            settings.setValue('recentFileList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentFileActions()
        except ValueError as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " fileload() %1").arg(str(ex)),exc_tb.tb_lineno)
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " loadFile() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if f:
                f.close()

    # Loads background profile
    def loadbackground(self,filename):
        try:        
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                profile = self.deserialize(filename)
                tb = profile["timex"]
                t1 = profile["temp1"]
                t2 = profile["temp2"]
                self.qmc.temp1B,self.qmc.temp2B,self.qmc.timeB = t1,t2,tb
                b1 = self.qmc.smooth_list(tb,t1,window_len=self.qmc.curvefilter)
                b2 = self.qmc.smooth_list(tb,t2,window_len=self.qmc.curvefilter)
                # NOTE: parallel assignment after time intensive smoothing is necessary to avoid redraw failure!
                self.qmc.stemp1B,self.qmc.stemp2B = b1,b2
                self.qmc.backgroundEvents = profile["specialevents"]
                self.qmc.backgroundEtypes = profile["specialeventstype"]
                self.qmc.backgroundEvalues = profile["specialeventsvalue"]
                self.qmc.backgroundEStrings = profile["specialeventsStrings"]
                self.qmc.backgroundFlavors = profile["flavors"]
                self.qmc.titleB = profile["title"]
# we don't load alarms from backgrounds as this would overload the one of the foreground profile that automatically loads this background
#                # alarms
#                if self.qmc.loadalarmsfromprofile:
#                    if "alarmflag" in profile:
#                        self.qmc.alarmflag = profile["alarmflag"]
#                    else:
#                        self.qmc.alarmflag = []
#                    if "alarmguard" in profile:
#                        self.qmc.alarmguard = profile["alarmguard"]
#                    else:
#                        self.qmc.alarmguard = [-1]*len(self.qmc.alarmflag)
#                    if "alarmnegguard" in profile:
#                        self.qmc.alarmnegguard = profile["alarmnegguard"]
#                    else:
#                        self.qmc.alarmnegguard = [-1]*len(self.qmc.alarmflag)
#                    if "alarmtime" in profile:
#                        self.qmc.alarmtime = profile["alarmtime"]
#                    else:
#                        self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
#                    if "alarmoffset" in profile:
#                        self.qmc.alarmoffset = profile["alarmoffset"]
#                    else:
#                        self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
#                    if "alarmcond" in profile:
#                        self.qmc.alarmcond = profile["alarmcond"]
#                    else:
#                        self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
#                    if "alarmsource" in profile:
#                        self.qmc.alarmsource = profile["alarmsource"]
#                    else:
#                        self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
#                    if "alarmtemperature" in profile:
#                        self.qmc.alarmtemperature = profile["alarmtemperature"]
#                    else:
#                        self.qmc.alarmtemperature = [500]*len(self.qmc.alarmflag)
#                    if "alarmaction" in profile:
#                        self.qmc.alarmaction = profile["alarmaction"]
#                    else:
#                        self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
#                    if "alarmbeep" in profile:
#                        self.qmc.alarmbeep = profile["alarmbeep"]
#                    else:
#                        self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
#                    if "alarmstrings" in profile:
#                        self.qmc.alarmstrings = [d(x) for x in profile["alarmstrings"]]
#                    else:
#                        self.qmc.alarmstrings = [""]*len(self.qmc.alarmflag)
#                    self.qmc.alarmstate = [0]*len(self.qmc.alarmflag)  #0 = not triggered; 1 = triggered
                #if old format < 0.5.0 version  (identified by numbers less than 1.). convert
                if self.qmc.backgroundFlavors[0] < 1. and self.qmc.backgroundFlavors[-1] < 1.:
                    l = len(self.qmc.backgroundFlavors)
                    for i in range(l):
                        self.qmc.backgroundFlavors[i] *= 10.
                    self.qmc.backgroundFlavors = self.qmc.backgroundFlavors[:(l-1)]
                if "etypes" in profile:
                    self.qmc.Betypes = profile["etypes"]
                if "timeindex" in profile:
                    self.qmc.timeindexB = profile["timeindex"]          #if new profile found with variable timeindex
                else:            
                    if "startend" in profile:
                        startendB = profile["startend"]
                        varCB = profile["cracks"]
                        if "dryend" in profile:
                            dryendB = profile["dryend"]
                        else:
                            dryendB = [0,0]
                        times = []
                        times.append(startendB[0])
                        times.append(dryendB[0])
                        times.append(varCB[0])
                        times.append(varCB[2])
                        times.append(varCB[4])
                        times.append(varCB[6])
                        times.append(startendB[2])
                        self.qmc.timebackgroundindexupdate(times[:])
                self.qmc.timeindexB = self.qmc.timeindexB + [0 for i in range(8-len(self.qmc.timeindexB))]
                backgroundDrop = self.qmc.timeindexB[6]
                if len(self.qmc.timeB) > backgroundDrop:
                    message =  u(QApplication.translate("Message", "Background %1 loaded successfully %2",None, QApplication.UnicodeUTF8).arg(u(filename)).arg(str(self.qmc.stringfromseconds(self.qmc.timeB[self.qmc.timeindexB[6]]))))
                else:
                    message =  u(QApplication.translate("Message", "Background %1 loaded successfully %2",None, QApplication.UnicodeUTF8).arg(u(filename)).arg(""))                    
                self.sendmessage(message)
                self.qmc.backgroundpath = u(filename)
            else:
                self.sendmessage(QApplication.translate("Message", "Invalid artisan format",None, QApplication.UnicodeUTF8))
        except IOError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " loadbackground() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " loadbackground() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " loadbackground() %1").arg(str(e)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()

    def eventtime2string(self,time):
        if time == 0.0:
            return ""
        else:
            return "%02d:%02d"% divmod(time,60)

    #read Artisan CSV
    def importCSV(self,filename):
        try:
            import csv
            import io
            if sys.version < '3':
                csvFile = io.open(filename, 'rb') # , encoding='utf-8'
            else:
                csvFile = io.open(filename, 'r', newline="") # , encoding='utf-8'
            data = csv.reader(csvFile,delimiter='\t')
            #read file header
            header = next(data)
            self.qmc.roastdate = QDate.fromString(header[0].split('Date:')[1],"dd'.'MM'.'yyyy")
            unit = header[1].split('Unit:')[1]
            #set temperature mode
            if unit == "F" and self.qmc.mode == "C":
                self.qmc.fahrenheitMode()
            if unit == "C" and self.qmc.mode == "F":
                self.qmc.celsiusMode()
            #read column headers
            fields = next(data) 
            extra_fields = fields[5:] # colums after 'Event'
            # add devices if needed
            for i in range(max(0,(len(extra_fields) / 2) - len(self.qmc.extradevices))):
                self.addDevice()
            # set extra device names # NOTE: eventuelly we want to set/change the names only for devices that were just added in the line above!?
            for i in range(len(extra_fields)):
                if i % 2 == 1:
                    # odd
                    self.qmc.extraname2[int(i/2)] = d(extra_fields[i])
                else:
                    # even
                    self.qmc.extraname1[int(i/2)] = d(extra_fields[i])
            #read data
            last_time = None
            
            i = 0
            for row in data:
                i = i + 1
                items = list(zip(fields, row))
                item = {}
                for (name, value) in items:
                    item[name] = value.strip()
                #add one measurement
                timez = float(self.qmc.stringtoseconds(item['Time1']))
                if not last_time or last_time < timez:
                    self.qmc.timex.append(timez)
                    self.qmc.temp1.append(float(item['ET']))
                    self.qmc.temp2.append(float(item['BT']))
                    for j in range(len(extra_fields)):
                        if j % 2 == 1:
                            # odd
                            self.qmc.extratemp2[int(j/2)].append(float(item[extra_fields[j]]))
                        else:
                            # even
                            self.qmc.extratimex[int(j/2)].append(timez)
                            self.qmc.extratemp1[int(j/2)].append(float(item[extra_fields[j]]))
                last_time = timez
            csvFile.close()
            #swap temperature curves if needed such that BT is the lower and ET the upper one
            sumTemp2 = freduce(lambda x,y:x + y, self.qmc.temp2)
            sumTemp1 = freduce(lambda x,y:x + y, self.qmc.temp1)
            if len(self.qmc.temp2) > 0 and len(self.qmc.temp1) > 0 and sumTemp2 > 0 and sumTemp1 > 0 and sumTemp2 > sumTemp1:
                tmp = self.qmc.temp1
                self.qmc.temp1 = self.qmc.temp2
                self.qmc.temp2 = tmp
            #set events
            CHARGE = self.qmc.stringtoseconds(header[2].split('CHARGE:')[1],False)
            if CHARGE > 0:
                self.qmc.timeindex[0] = self.time2index(CHARGE)
            DRYe = self.qmc.stringtoseconds(header[4].split('DRYe:')[1],False)
            if DRYe > 0:
                self.qmc.timeindex[1] = self.time2index(DRYe)
            FCs = self.qmc.stringtoseconds(header[5].split('FCs:')[1],False)
            if FCs > 0:
                self.qmc.timeindex[2] = self.time2index(FCs)
            FCe = self.qmc.stringtoseconds(header[6].split('FCe:')[1],False)
            if FCe > 0:
                self.qmc.timeindex[3] = self.time2index(FCe)
            SCs = self.qmc.stringtoseconds(header[7].split('SCs:')[1],False)
            if SCs > 0:
                self.qmc.timeindex[4] = self.time2index(SCs)
            SCe = self.qmc.stringtoseconds(header[8].split('SCe:')[1],False)
            if SCe> 0:
                self.qmc.timeindex[5] = self.time2index(SCe)
            DROP = self.qmc.stringtoseconds(header[9].split('DROP:')[1],False)
            if DROP > 0:
                self.qmc.timeindex[6] = self.time2index(DROP)
            COOL = self.qmc.stringtoseconds(header[10].split('COOL:')[1],False)
            if COOL > 0:
                self.qmc.timeindex[7] = self.time2index(COOL)
            self.qmc.endofx = self.qmc.timex[-1]
            self.sendmessage(QApplication.translate("Message","Artisan CSV file loaded successfully", None, QApplication.UnicodeUTF8))
            self.qmc.safesaveflag = True
            self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importCSV() %1").arg(str(ex)),exc_tb.tb_lineno)

    def addSerialPort(self):
        self.extraser.append(serialport()) 
        self.extracomport.append("COM1")
        self.extrabaudrate.append(9600)
        self.extrabytesize.append(8)
        self.extraparity.append("E")
        self.extrastopbits.append(1)
        self.extratimeout.append(1)

    def addDevice(self):
        try:
            self.qmc.extradevices.append(1)
            self.qmc.extradevicecolor1.append("black") #init color to black
            self.qmc.extradevicecolor2.append("black")
            self.qmc.extraname1.append(u"Extra 1")
            self.qmc.extraname2.append(u"Extra 2")
            self.qmc.extramathexpression1.append("")
            self.qmc.extramathexpression2.append("")
            
            # ensure that the curves and LCDs of the new device are visible:
            n = len(self.qmc.extradevices)
            self.extraLCDvisibility1[n-1] = True
            self.extraLCDvisibility2[n-1] = True
            self.extraCurveVisibility1[n-1] = True
            self.extraCurveVisibility2[n-1] = True

            #create new serial port (but don't open it yet). Store initial settings
            self.addSerialPort()

            #add new line variables
            self.qmc.extratimex.append([])
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2.append([])
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2.append([])

            #add new style variables
            self.qmc.extralinestyles1.append(self.qmc.linestyle_default)
            self.qmc.extralinestyles2.append(self.qmc.linestyle_default)
            self.qmc.extradrawstyles1.append(self.qmc.drawstyle_default)
            self.qmc.extradrawstyles2.append(self.qmc.drawstyle_default)
            self.qmc.extralinewidths1.append(self.qmc.linewidth_default)
            self.qmc.extralinewidths2.append(self.qmc.linewidth_default)
            self.qmc.extramarkers1.append(self.qmc.marker_default)
            self.qmc.extramarkers2.append(self.qmc.marker_default)
            self.qmc.extramarkersizes1.append(self.qmc.markersize_default)
            self.qmc.extramarkersizes2.append(self.qmc.markersize_default)

            #add two extra lines in figure for extra ET and extra BT
            l = len(self.qmc.extradevices)-1  #new line index
            self.qmc.extratemp1lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp1[l],color=self.qmc.extradevicecolor1[l],markersize=self.qmc.extramarkersizes1[l],marker=self.qmc.extramarkers1[l],linewidth=self.qmc.extralinewidths1[l],linestyle=self.qmc.extralinestyles1[l],drawstyle=self.qmc.extradrawstyles1[l],label=self.qmc.extraname1[l])[0])
            self.qmc.extratemp2lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp2[l],color=self.qmc.extradevicecolor2[l],markersize=self.qmc.extramarkersizes2[l],marker=self.qmc.extramarkers2[l],linewidth=self.qmc.extralinewidths2[l],linestyle=self.qmc.extralinestyles2[l],drawstyle=self.qmc.extradrawstyles2[l],label=self.qmc.extraname2[l])[0])

            self.updateExtraLCDvisibility()
        except Exception:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            pass

    #Write readings to Artisan JSON file
    def exportJSON(self,filename):
        try:
            outfile = open(filename, 'w')
            json.dump(self.getProfile(), outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
#            import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " exportJSON() %1").arg(str(ex)),exc_tb.tb_lineno)
            return False

    #Write readings to RoastLogger CSV file
    def exportRoastLogger(self,filename):
        outfile = open(filename, 'w')
        try:
            outfile.write("Log created at 09:00:00 "+ self.qmc.roastdate.toString("dd'/'MM'/'yyyy") + "\n")
            outfile.write("Use Options|Set template for new log to modify this template.\n")
            outfile.write("------------------------------------------------------\n")
            outfile.write("Bean/Blend name:\n")
            outfile.write("\n")
            outfile.write("Profile description:\n")
            outfile.write("\n")
            outfile.write("Roast notes:\n")
            outfile.write("\n")
            outfile.write("Cupping results:\n")
            outfile.write("\n")
            outfile.write("Roast Logger Copyright ? T. R. Coxon (GreenBean TMC).\n")
            outfile.write("Roast started at 09:00:00 " + self.qmc.roastdate.toString("dd'/'MM'/'yyyy") + "\n")
            if len(self.qmc.timex) > 0:
                CHARGE = aw.qmc.timex[aw.qmc.timeindex[0]] 
            else:
                CHARGE = 0
            import csv
            writer= csv.writer(outfile,delimiter=',')
            writer.writerow(["Elapsed time "," T1 "," T2 "," Event type"])
            for i in range(len(aw.qmc.timex)):
                if i == aw.qmc.timeindex[0]:
                    kind = "Beans loaded"
                elif i!=0 and i == aw.qmc.timeindex[2]:
                    kind = "First crack start"
                elif i!=0 and i == aw.qmc.timeindex[3]:
                    kind = "First crack end"
                elif i!=0 and i == aw.qmc.timeindex[4]:
                    kind = "Second crack start"
                elif i!=0 and i == aw.qmc.timeindex[6]:
                    kind = "Beans ejected"
                else:
                    kind = "timer"
                writer.writerow([aw.qmc.stringfromseconds(aw.qmc.timex[i]-CHARGE),"%.1f"%float(aw.qmc.temp2[i]),"%.1f"%float(aw.qmc.temp1[i]),kind])
            outfile.write("\n")
            outfile.write("@actionT1Table\n")
            outfile.write("120|null|30\n")
            outfile.write("178|65|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("\n")
            outfile.write("@actionSecsFCTable\n")
            outfile.write("60|50|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("\n")
            outfile.write("@actionResetTable\n")
            outfile.write("100|0\n")
            outfile.write("\n")
            outfile.write("@loadBeansTable\n")
            outfile.write("146\n")
            outfile.write("\n")
            outfile.close()
            return True
        except Exception as ex:
#           import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " exportRoastLogger() %1").arg(str(ex)),exc_tb.tb_lineno)
            return False
        finally:
            outfile.close()

    def importJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            obj = json.load(infile)
            res = self.setProfile(filename,obj)
            infile.close()
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #change Title
#                self.qmc.ax.set_title(aw.arabicReshape(self.qmc.title), size=18, color= self.qmc.palette["title"])
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importJSON() %1").arg(str(ex)),exc_tb.tb_lineno)

    def importRoastLogger(self,filename):
        self.resetExtraDevices()
        # the RoastLogger file might be in utf-8 or latin1 encoding, we cannot know so let's test both
        try:
            try:
                self.importRoastLoggerEnc(filename,'utf-8')
            except:
                self.importRoastLoggerEnc(filename,'latin1')
            aw.qmc.safesaveflag = True
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importRoastLogger() %1").arg(str(ex)),exc_tb.tb_lineno)
            
    def resetExtraDevices(self):
        try:
            #delete extra devices
            aw.qmc.extradevices = []
            #delete extra curves variables
            aw.qmc.extratimex = []
            aw.qmc.extradevicecolor1 = []
            aw.qmc.extradevicecolor2 = []
            aw.qmc.extratemp1,aw.qmc.extratemp2 = [],[]
            aw.qmc.extrastemp1,aw.qmc.extrastemp2 = [],[]
            aw.qmc.extratemp1lines,aw.qmc.extratemp2lines = [],[]
            aw.qmc.extralinestyles1,aw.qmc.extralinestyles2 = [],[]
            aw.qmc.extradrawstyles1,aw.qmc.extradrawstyles2 = [],[]
            aw.qmc.extralinewidths1,aw.qmc.extralinewidths2 = [],[]
            aw.qmc.extramarkers1,aw.qmc.extramarkers2 = [],[]
            aw.qmc.extramarkersizes1,aw.qmc.extramarkersizes2 = [],[]
            aw.qmc.extraname1,aw.qmc.extraname2 = [],[]
            aw.qmc.extramathexpression1,aw.qmc.extramathexpression2 = [],[]
            for i in range(len(aw.extraLCDlabel1)):
                aw.extraLCDframe1[i].setVisible(False)
                aw.extraLCDframe2[i].setVisible(False)
            #delete EXTRA COMM PORTS VARIABLES
            aw.extraser = []
            aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            aw.qmc.resetlinecountcaches()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " resetExtraDevices(): %1").arg(str(e)),exc_tb.tb_lineno)
            
    def importRoastLoggerEnc(self,filename,enc='utf-8'):
        roastlogger_action_section = ""
        # use io.open instead of open to have encoding support on Python 2
        import io
        infile = io.open(filename, 'r', encoding=enc)
        obj = {}
        obj["mode"] = "C"
        obj["title"] = u(QFileInfo(filename).fileName())
        import csv
        obj["roastdate"] = encodeLocal(QDate.currentDate().toString())
        # read roastdate from file
        while True:
            l = infile.readline()
            if l.startswith("Roast started at "):
                #extract roast date
                roastdate = QDate.fromString(l.split(" ")[-1][0:10],"dd'/'MM'/'yyyy")
                if not roastdate.isNull():
                    obj["roastdate"] = encodeLocal(roastdate.toString())
                break
            if l == '':
                break
        timeindex = [-1,0,0,0,0,0,0,0]
        timex = []
        temp1 = []
        temp2 = []
        data = csv.reader(infile,delimiter=',')
        #read file header
        next(data) # we do not use the labels
        #header = list(map(lambda s:s.strip(),next(data)))
        while True:
            fields = next(data)
            if len(fields) == 0:
                break
            else:
                timex.append(float(self.qmc.stringtoseconds(fields[0])))
                try:
                    t1 = float(fields[1])
                except:
                    t1 = -1
                temp1.append(t1)
                try:
                    t2 = float(fields[2])
                except:
                    t2 = -1
                temp2.append(t2)
                event = fields[3]
                if event == "Beans loaded":
                    timeindex[0] = len(timex) - 1
                elif event == "First crack start":
                    timeindex[2] = len(timex) - 1
                elif event == "First crack end":
                    timeindex[3] = len(timex) - 1
                elif event == "Second crack start":
                    timeindex[4] = len(timex) - 1
                elif event == "Beans ejected":
                    timeindex[6] = len(timex) - 1
        obj["timeindex"] = timeindex
        obj["timex"] = timex
        obj["temp1"] = temp2
        obj["temp2"] = temp1
        res = self.setProfile(filename,obj)
            
        try:
            error_msg = ""
            if aw.qmc.loadalarmsfromprofile:
                aw.qmc.alarmsfile = filename
                roastlogger_action_section = "No actions loaded"

                #Find sliders - exact names of the sliders must be defined
                slider_power = -1
                slider_fan = -1
                try:
                    slider_power=aw.qmc.etypes.index("Power")
                except:
                    pass
                try:
                    slider_fan=aw.qmc.etypes.index("Fan")
                except:
                    pass
                #load only "Power" and "Fan" events
                if slider_power != -1 and slider_fan != -1:
                    data_action = csv.reader(infile,delimiter='|')

                    aw.qmc.alarmflag = []
                    aw.qmc.alarmguard = []
                    aw.qmc.alarmnegguard = []
                    aw.qmc.alarmtime = []
                    aw.qmc.alarmoffset = []
                    aw.qmc.alarmcond = []
                    aw.qmc.alarmstate = []
                    aw.qmc.alarmsource = []
                    aw.qmc.alarmtemperature = []
                    aw.qmc.alarmaction = []
                    aw.qmc.alarmbeep = []
                    aw.qmc.alarmstrings = []

                    while True:
                        fields_action = next(data_action)
                        if len(fields_action) == 0:
                            pass
                        elif len(fields_action) == 1 and fields_action[0].startswith("@"):
                            roastlogger_action_section=fields_action[0]
                        else:
                            #process items in the section
                            if roastlogger_action_section.startswith("@actionT1Table"):
                                if len(fields_action) == 3 and fields_action[0] != "null":
                                    #add temp alarm - POWER
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(8)        #after TP
                                    aw.qmc.alarmoffset.append(0)
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(0)
                                    aw.qmc.alarmsource.append(1)    #BT
                                    aw.qmc.alarmtemperature.append(fields_action[0])
                                    aw.qmc.alarmaction.append(3+slider_power)    #SLIDER POWER
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[1],None, QApplication.UnicodeUTF8))

                                    #add temp alarm - FAN
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(8)        #after TP
                                    aw.qmc.alarmoffset.append(0)
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(0)
                                    aw.qmc.alarmsource.append(1)    #BT
                                    aw.qmc.alarmtemperature.append(fields_action[0])
                                    aw.qmc.alarmaction.append(3+slider_fan)    #SLIDER FAN
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[2],None, QApplication.UnicodeUTF8))

                            elif roastlogger_action_section.startswith("@actionSecsFCTable"):
                                if len(fields_action) == 3 and fields_action[0] != "null":

                                    #add time alarm - POWER
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(2)        #after FC
                                    aw.qmc.alarmoffset.append(int(fields_action[0]))
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(0)
                                    aw.qmc.alarmsource.append(-3)       #no source - this is time alarm
                                    aw.qmc.alarmtemperature.append(0)
                                    aw.qmc.alarmaction.append(3+slider_power)    #SLIDER POWER
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[1],None, QApplication.UnicodeUTF8))

                                    #add time alarm - FAN
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(2)        #after FC
                                    aw.qmc.alarmoffset.append(int(fields_action[0]))
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(0)
                                    aw.qmc.alarmsource.append(-3)       #no source - this is time alarm
                                    aw.qmc.alarmtemperature.append(0)
                                    aw.qmc.alarmaction.append(3+slider_fan)    #SLIDER FAN
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[2],None, QApplication.UnicodeUTF8))

                            elif roastlogger_action_section.startswith("@actionResetTable"):
                                if len(fields_action) == 2 and fields_action[0] != "null":

                                    #add temp alarm - POWER
                                    aw.qmc.alarmflag.insert(0,1)
                                    aw.qmc.alarmguard.insert(0,-1)
                                    aw.qmc.alarmnegguard.insert(0,-1)
                                    aw.qmc.alarmtime.insert(0,9)        #after ON
                                    aw.qmc.alarmoffset.insert(0,0)
                                    aw.qmc.alarmcond.insert(0,1)
                                    aw.qmc.alarmstate.insert(0,0)
                                    aw.qmc.alarmsource.insert(0,1)    #BT
                                    aw.qmc.alarmtemperature.insert(0,0)
                                    aw.qmc.alarmaction.insert(0,3+slider_power)    #SLIDER POWER
                                    aw.qmc.alarmbeep.insert(0,0)
                                    aw.qmc.alarmstrings.insert(0,QApplication.translate("Label",fields_action[0],None, QApplication.UnicodeUTF8))

                                    #add temp alarm - FAN
                                    aw.qmc.alarmflag.insert(0,1)
                                    aw.qmc.alarmguard.insert(0,-1)
                                    aw.qmc.alarmnegguard.insert(0,-1)
                                    aw.qmc.alarmtime.insert(0,9)        #after ON
                                    aw.qmc.alarmoffset.insert(0,0)
                                    aw.qmc.alarmcond.insert(0,1)
                                    aw.qmc.alarmstate.insert(0,0)
                                    aw.qmc.alarmsource.insert(0,1)    #BT
                                    aw.qmc.alarmtemperature.insert(0,0)
                                    aw.qmc.alarmaction.insert(0,3+slider_fan)    #SLIDER POWER
                                    aw.qmc.alarmbeep.insert(0,0)
                                    aw.qmc.alarmstrings.insert(0,QApplication.translate("Label",fields_action[1],None, QApplication.UnicodeUTF8))

                            elif roastlogger_action_section.startswith("@loadBeansTable"):
                                if len(fields_action) == 1 and fields_action[0] != "null":

                                    #add START TRIGGER - 10 DEG before charge temp
                                    aw.qmc.alarmflag.insert(2,1)
                                    aw.qmc.alarmguard.insert(2,-1)
                                    aw.qmc.alarmnegguard.insert(2,-1)
                                    aw.qmc.alarmtime.insert(0,9)        #after ON
                                    aw.qmc.alarmoffset.insert(2,0)
                                    aw.qmc.alarmcond.insert(2,1)
                                    aw.qmc.alarmstate.insert(2,0)
                                    aw.qmc.alarmsource.insert(2,1)    #BT
                                    aw.qmc.alarmtemperature.insert(2,str(int(fields_action[0])-10))
                                    aw.qmc.alarmaction.insert(2,7)    #inititate 7 (START)
                                    aw.qmc.alarmbeep.insert(2,0)
                                    aw.qmc.alarmstrings.insert(2,QApplication.translate("Label","Start recording",None, QApplication.UnicodeUTF8))

                                    #add CHARGE alarm
                                    aw.qmc.alarmflag.insert(3,1)
                                    aw.qmc.alarmguard.insert(3,-1)
                                    aw.qmc.alarmnegguard.insert(3,-1)
                                    aw.qmc.alarmtime.insert(3,-1)        #after START
                                    aw.qmc.alarmoffset.insert(3,0)
                                    aw.qmc.alarmcond.insert(3,1)
                                    aw.qmc.alarmstate.insert(3,0)
                                    aw.qmc.alarmsource.insert(3,1)    #BT
                                    aw.qmc.alarmtemperature.insert(3,fields_action[0])
                                    aw.qmc.alarmaction.insert(3,0)    #POPUP
                                    aw.qmc.alarmbeep.insert(3,1)      #do beep for charge
                                    aw.qmc.alarmstrings.insert(3,QApplication.translate("Label","Charge the beans",None, QApplication.UnicodeUTF8))
                                break;
                    else:
                        if slider_power == -1: error_msg += "Could not find slider named 'Power' "
                        if slider_fan == -1: error_msg += "Could not find slider named 'Fan' "
                        error_msg += "Please rename sliders in Config - Events menu"

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            if roastlogger_action_section == "No actions loaded":
                error_msg += "Roastlogger file does not contain actions.  Alarms will not be loaded."
            else:
                error_msg += "Roastlogger actions are not complete. Last loaded section is '" + roastlogger_action_section + "'"

        finally:
            infile.close()
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                self.qmc.redraw()

        if error_msg: 
            aw.qmc.adderror(QApplication.translate("Error Message","Roastlogger log file exception: " + error_msg,None, QApplication.UnicodeUTF8))

    #Write readings to Artisan csv file
    def exportCSV(self,filename):
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]] 
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    #manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                else:
                    #we use the dryEndIndex respecting the dry phase
                    if dryEndIndex < len(self.qmc.timex):
                        DRYe = self.qmc.timex[dryEndIndex]
                    else:
                        DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [     
                    [CHARGE,"Charge",False],
                    [TP,"TP",False],      
                    [DRYe,"Dry End",False], 
                    [FCs,"FCs",False],
                    [FCe,"FCe",False],
                    [SCs,"SCs",False],
                    [SCe,"SCe",False],
                    [DROP, "Drop",False],
                    [COOL, "COOL",False],
                    ]
                import csv
                if sys.version < '3':
                    outfile = open(filename, 'wb')
                else:
                    outfile = open(filename, 'w',newline="")
                writer= csv.writer(outfile,delimiter='\t')
                writer.writerow([
                    u("Date:" + self.qmc.roastdate.toString("dd'.'MM'.'yyyy")),
                    u("Unit:" + self.qmc.mode),
                    u("CHARGE:" + self.eventtime2string(CHARGE)),
                    u("TP:" + self.eventtime2string(TP)),
                    u("DRYe:" + self.eventtime2string(DRYe)),
                    u("FCs:" + self.eventtime2string(FCs)),
                    u("FCe:" + self.eventtime2string(FCe)),
                    u("SCs:" + self.eventtime2string(SCs)),
                    u("SCe:" + self.eventtime2string(SCe)),
                    u("DROP:" + self.eventtime2string(DROP)),
                    u("COOL:" + self.eventtime2string(COOL))])
                row = ([u('Time1'),u('Time2'),u('BT'),u('ET'),u('Event')] + freduce(lambda x,y: x + [u(y[0]),u(y[1])], list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],self.qmc.extraname2[0:len(self.qmc.extradevices)])),[]))
                row = [encodeLocal(e) for e in row]
                writer.writerow(row)
                last_time = None
                for i in range(len(self.qmc.timex)):
                    if CHARGE > 0. and self.qmc.timex[i] >= CHARGE:
                        time2 = "%02d:%02d"% divmod(self.qmc.timex[i] - CHARGE, 60)
                    else:
                        time2 = "" 
                    event = ""               
                    for e in range(len(events)):
                        if not events[e][2] and int(round(self.qmc.timex[i])) == int(round(events[e][0])):
                            event = events[e][1]
                            events[e][2] = True
                            break
                    time1 = "%02d:%02d"% divmod(self.qmc.timex[i],60)
                    if not last_time or last_time != time1:
                        extratemps = []
                        for j in range(len(self.qmc.extradevices)):
                            if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                extratemps.append(u(self.qmc.extratemp1[j][i]))
                            else:
                                extratemps.append(u("-1"))
                            if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                extratemps.append(u(self.qmc.extratemp2[j][i]))
                            else:
                                extratemps.append(u("-1"))
                        writer.writerow([u(time1),u(time2),u(self.qmc.temp2[i]),u(self.qmc.temp1[i]),u(event)] + extratemps)
                    last_time = time1
                outfile.close()
                return True
            else:
                return False
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " exportCSV() %1").arg(str(ex)),exc_tb.tb_lineno)
            return False

    #Write object to file
    def serialize(self,filename,obj):
        f = codecs.open(u(filename), 'w+', encoding='utf-8')
        f.write(repr(obj))
        f.close()

    #Read object from file 
    def deserialize(self,filename):
        try:
            obj = None
            if os.path.exists(u(filename)):
                f = codecs.open(u(filename), 'rb', encoding='utf-8')
                obj=ast.literal_eval(f.read())
                f.close()
            return obj
        except Exception:
            pass
#            import traceback
#            traceback.print_exc(file=sys.stdout)

    #called by fileLoad()
    def setProfile(self,filename,profile):
        try:
            #extra devices load and check
            if "extratimex" in profile and len(profile["extratimex"]) > 0:
                if "extradevices" in profile:
                    if (len(self.qmc.extradevices) < len(profile["extradevices"])) or self.qmc.extradevices[:len(profile["extradevices"])] != profile["extradevices"]:
                        string = u(QApplication.translate("Message","To load this profile the extra devices configuration needs to be changed.\nContinue?", None, QApplication.UnicodeUTF8))
                        reply = QMessageBox.question(self,QApplication.translate("Message", "Found a different number of curves",None, QApplication.UnicodeUTF8),string,QMessageBox.Yes|QMessageBox.Cancel)
                        if reply == QMessageBox.Yes:
                            aw.qmc.resetlinecountcaches()
                            self.qmc.extradevices = profile["extradevices"]
                        else:
                            return False
                # adjust extra serial device table
                # a) remove superfluous extra serial settings
                self.extraser = self.extraser[:len(self.qmc.extradevices)]
                self.extracomport = self.extracomport[:len(self.qmc.extradevices)]
                self.extrabaudrate = self.extrabaudrate[:len(self.qmc.extradevices)]
                self.extrabytesize = self.extrabytesize[:len(self.qmc.extradevices)]
                self.extraparity = self.extraparity[:len(self.qmc.extradevices)]
                self.extrastopbits = self.extrastopbits[:len(self.qmc.extradevices)]
                self.extratimeout = self.extratimeout[:len(self.qmc.extradevices)]
                # b) add missing extra serial settings
                for i in range(len(self.qmc.extradevices) - len(self.extraser)):
                    self.addSerialPort()
                # c) set extra temp curves and prepare empty extra smoothed temp curves
                if "extratimex" in profile:
                    self.qmc.extratimex = profile["extratimex"] + [profile["extratimex"][0]]*(len(self.qmc.extradevices) - len(profile["extratimex"]))
                if "extratemp1" in profile:
                    self.qmc.extratemp1 = profile["extratemp1"] + [[-1]*len(self.qmc.extratimex[0])]*(len(self.qmc.extradevices) - len(profile["extratimex"]))
                    self.qmc.extrastemp1 = [[]]*len(self.qmc.extratemp1)
                if "extratemp2" in profile:
                    self.qmc.extratemp2 = profile["extratemp2"] + [[-1]*len(self.qmc.extratimex[0])]*(len(self.qmc.extradevices) - len(profile["extratimex"]))
                    self.qmc.extrastemp2 = [[]]*len(self.qmc.extratemp2)
                # d) set other extra curve attribute lists
                if "extraname1" in profile:
                    self.qmc.extraname1 = [d(x) for x in profile["extraname1"] + self.qmc.extraname1[len(profile["extraname1"]):]]
                if "extraname2" in profile:
                    self.qmc.extraname2 = [d(x) for x in profile["extraname2"] + self.qmc.extraname2[len(profile["extraname2"]):]]
                if "extramathexpression1" in profile:
                    self.qmc.extramathexpression1 = profile["extramathexpression1"] + self.qmc.extramathexpression1[len(profile["extramathexpression1"]):]
                if "extramathexpression2" in profile:
                    self.qmc.extramathexpression2 = profile["extramathexpression2"] + self.qmc.extramathexpression2[len(profile["extramathexpression2"]):]
                if "extradevicecolor1" in profile:
                    self.qmc.extradevicecolor1 = [d(x) for x in profile["extradevicecolor1"]] + self.qmc.extradevicecolor1[len(profile["extradevicecolor1"]):]
                if "extradevicecolor2" in profile:
                    self.qmc.extradevicecolor2 = [d(x) for x in profile["extradevicecolor2"]] + self.qmc.extradevicecolor2[len(profile["extradevicecolor2"]):]
                if "extramarkersizes1" in profile:
                    self.qmc.extramarkersizes1 = profile["extramarkersizes1"] + self.qmc.extramarkersizes1[len(profile["extramarkersizes1"]):]
                else:
                    self.qmc.extramarkersizes1 = [self.qmc.markersize_default]*len(self.qmc.extratemp1)
                if "extramarkersizes2" in profile:
                    self.qmc.extramarkersizes2 = profile["extramarkersizes2"] + self.qmc.extramarkersizes2[len(profile["extramarkersizes2"]):]
                else:
                    self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*len(self.qmc.extratemp2)
                if "extramarkers1" in profile:
                    self.qmc.extramarkers1 = [d(x) for x in profile["extramarkers1"]] + self.qmc.extramarkers1[len(profile["extramarkers1"]):]
                else:
                    self.qmc.extramarkers1 = [self.qmc.marker_default]*len(self.qmc.extratemp1)
                if "extramarkers2" in profile:
                    self.qmc.extramarkers2 = [d(x) for x in profile["extramarkers2"]] + self.qmc.extramarkers2[len(profile["extramarkers2"]):]
                else:
                    self.qmc.extramarkers2 = [self.qmc.marker_default]*len(self.qmc.extratemp2)
                if "extralinewidths1" in profile:
                    self.qmc.extralinewidths1 = [int(w) for w in profile["extralinewidths1"]] + self.qmc.extralinewidths1[len(profile["extralinewidths1"]):]
                else:
                    self.qmc.extralinewidths1 = [self.qmc.linewidth_default]*len(self.qmc.extratemp1)
                if "extralinewidths2" in profile:
                    self.qmc.extralinewidths2 = [int(w) for w in profile["extralinewidths2"]] + self.qmc.extralinewidths2[len(profile["extralinewidths2"]):]
                else:
                    self.qmc.extralinewidths2 = [self.qmc.linewidth_default]*len(self.qmc.extratemp2)
                if "extralinestyles1" in profile:
                    self.qmc.extralinestyles1 = [d(x) for x in profile["extralinestyles1"]] + self.qmc.extralinestyles1[len(profile["extralinestyles1"]):]
                else:
                    self.qmc.extralinestyles1 = [self.qmc.linestyle_default]*len(self.qmc.extratemp1)
                if "extralinestyles2" in profile:
                    self.qmc.extralinestyles2 = [d(x) for x in profile["extralinestyles2"]] + self.qmc.extralinestyles2[len(profile["extralinestyles2"]):]
                else:
                    self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*len(self.qmc.extratemp2)
                if "extradrawstyles1" in profile:
                    self.qmc.extradrawstyles1 = [d(x) for x in profile["extradrawstyles1"]] + self.qmc.extradrawstyles1[len(profile["extradrawstyles1"]):]
                else:
                    self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp1)
                if "extradrawstyles2" in profile:
                    self.qmc.extradrawstyles2 = [d(x) for x in profile["extradrawstyles2"]] + self.qmc.extradrawstyles2[len(profile["extradrawstyles2"]):]
                else:
                    self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp2)
                self.updateExtraLCDvisibility()

            old_mode = self.qmc.mode
            if "mode" in profile:
                self.qmc.mode = str(profile["mode"])
            #convert modes only if needed comparing the new uploaded mode to the old one.
            #otherwise it would incorrectly convert the uploaded phases
            if "phases" in profile and aw.qmc.phasesbuttonflag:
                self.qmc.phases = profile["phases"]
            if self.qmc.mode == "F" and old_mode == "C":
                self.qmc.fahrenheitMode()
            if self.qmc.mode == "C" and old_mode == "F":
                self.qmc.celsiusMode()
            if "flavors" in profile:
                self.qmc.flavors = [float(fl) for fl in profile["flavors"]]
            #if old format < 0.5.0 version  (identified by numbers less than 1.). convert
            if self.qmc.flavors[0] < 1. and self.qmc.flavors[-1] < 1.:
                l = len(self.qmc.flavors)
                for i in range(l):
                    self.qmc.flavors[i] *= 10.
                self.qmc.flavors = self.qmc.flavors[:(l-1)]
            if "flavorlabels" in profile:
                self.qmc.flavorlabels = QStringList([d(x) for x in profile["flavorlabels"]])
            for i in range(len(self.qmc.flavorlabels)):
                self.qmc.flavorlabels[i] = self.qmc.flavorlabels[i]
            if "flavorstartangle" in profile:
                self.qmc.flavorstartangle = int(profile["flavorstartangle"])
            if "flavoraspect" in profile:
                self.qmc.flavoraspect = float(profile["flavoraspect"])
            else:
                self.qmc.flavoraspect = 1.
            if "title" in profile:
                self.qmc.title = d(profile["title"])
            else:            
                self.qmc.title = QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8)
            if "beans" in profile:
                self.qmc.beans = d(profile["beans"])
            else:
                self.qmc.beans = ""
            if "weight" in profile:
                self.qmc.weight = [profile["weight"][0],profile["weight"][1],d(profile["weight"][2])]
            else:
                self.qmc.weight = [0,0,"g"]
            if "volume" in profile:
                self.qmc.volume = profile["volume"]
            else:
                self.qmc.volume = [0,0,"l"]
            if "density" in profile:
                self.qmc.density = [profile["density"][0],d(profile["density"][1]),profile["density"][2],d(profile["density"][3])]
            else:
                self.qmc.density = [0,"g",0,"l"]
            if "roastertype" in profile:
                self.qmc.roastertype = d(profile["roastertype"])
            else:
                self.qmc.roastertype = ""
            if "operator" in profile:
                self.qmc.operator = d(profile["operator"])
            else:
                self.qmc.operator = ""
            if "beansize" in profile:
                self.qmc.beansize = float(profile["beansize"])
            else:
                self.qmc.beansize = 0.0
            if "heavyFC" in profile:
                self.qmc.heavyFC_flag = profile["heavyFC"]
            if "lowFC" in profile:
                self.qmc.lowFC_flag = profile["lowFC"]
            if "lightCut" in profile:
                self.qmc.lightCut_flag = profile["lightCut"]
            if "darkCut" in profile:
                self.qmc.darkCut_flag = profile["darkCut"]
            if "drops" in profile:
                self.qmc.drops_flag = profile["drops"]
            if "oily" in profile:
                self.qmc.oily_flag = profile["oily"]
            if "uneven" in profile:
                self.qmc.uneven_flag = profile["uneven"]
            if "tipping" in profile:
                self.qmc.tipping_flag = profile["tipping"]
            if "scorching" in profile:
                self.qmc.scorching_flag = profile["scorching"]
            if "divots" in profile:
                self.qmc.divots_flag = profile["divots"]
            # color
            if "whole_color" in profile:
                self.qmc.whole_color = profile["whole_color"]
            if "ground_color" in profile:
                self.qmc.ground_color = profile["ground_color"]
            if "color_system" in profile and profile["color_system"] in self.qmc.color_systems:
                self.qmc.color_system_idx = self.qmc.color_systems.index(profile["color_system"])
            if "volumeCalcWeightIn" in profile:
                self.qmc.volumeCalcWeightInStr = profile["volumeCalcWeightIn"]
            if "volumeCalcWeightOut" in profile:
                self.qmc.volumeCalcWeightOutStr = profile["volumeCalcWeightOut"]
            # for compatibility with older profiles:
            if "roastdate" in profile:
                try:
                    self.qmc.roastdate = QDate.fromString(d(profile["roastdate"]))
                except Exception:
                    pass
            # the new dates have the locale independent isodate format:
            if "roastisodate" in profile:
                try:
                    self.qmc.roastdate = QDate.fromString(d(profile["roastisodate"]),Qt.ISODate)
                except Exception:
                    pass
            if "specialevents" in profile:
                self.qmc.specialevents = profile["specialevents"]
            else:
                self.qmc.specialevents = []
            if "specialeventstype" in profile:
                self.qmc.specialeventstype = profile["specialeventstype"]
            else:  
                self.qmc.specialeventstype = []
            if "specialeventsvalue" in profile:
                self.qmc.specialeventsvalue = profile["specialeventsvalue"]
            else:
                self.qmc.specialeventsvalue = []
            if "specialeventsStrings" in profile:
                self.qmc.specialeventsStrings = [d(x) for x in profile["specialeventsStrings"]]
            else:
                self.qmc.specialeventsStrings = []
            if "etypes" in profile:
                self.qmc.etypes = [d(x) for x in profile["etypes"]]
                
            if "roastingnotes" in profile:
                self.qmc.roastingnotes = d(profile["roastingnotes"])
            else:
                self.qmc.roastingnotes = ""
            if "cuppingnotes" in profile:
                self.qmc.cuppingnotes = d(profile["cuppingnotes"])
            else:
                self.qmc.cuppingnotes = ""
            if "timex" in profile:
                self.qmc.timex = profile["timex"]
            if "temp1" in profile:
                self.qmc.temp1 = profile["temp1"]
            if "temp2" in profile:
                self.qmc.temp2 = profile["temp2"]
    # don't let the users y/z min/max axis limits be overwritten by loading a profile
    #        if "zmax" in profile:
    #            self.qmc.zlimit = min(int(profile["zmax"]),500)
    #        if "zmin" in profile:
    #            self.qmc.zlimit_min = max(min(int(profile["zmin"]),self.qmc.zlimit),-200)
    #        if "ymax" in profile:
    #            self.qmc.ylimit = min(int(profile["ymax"]),850)
    #        if "ymin" in profile:
    #            self.qmc.ylimit_min = max(min(int(profile["ymin"]),self.qmc.ylimit),-150)
            if "xmin" in profile:
                self.qmc.startofx = int(profile["xmin"])
            if  not self.qmc.locktimex:
                if "xmax" in profile:
                    self.qmc.endofx = int(profile["xmax"])
                else:
                    #Set the xlimits
                    if self.qmc.timex:
                        self.qmc.endofx = self.qmc.timex[-1] + 40
            if "ambientTemp" in profile:
                self.qmc.ambientTemp = profile["ambientTemp"]    
            if "ambient_humidity" in profile:
                self.qmc.ambient_humidity = profile["ambient_humidity"]
            if "moisture_greens" in profile:
                self.qmc.moisture_greens = profile["moisture_greens"]
            else:
                self.qmc.moisture_greens = 0.
            if "moisture_roasted" in profile:
                self.qmc.moisture_roasted = profile["moisture_roasted"]
            else:
                self.qmc.moisture_roasted = 0.
            if "externalprogram" in profile:
                self.ser.externalprogram = d(profile["externalprogram"])
            if "samplinginterval" in profile:
                # derive aw.qmc.deltasamples from aw.qmc.deltaspan and the sampling interval of the profile
                self.qmc.profile_sampling_interval = profile["samplinginterval"]
                self.qmc.updateDeltaSamples()
            # alarms
            if self.qmc.loadalarmsfromprofile:
                self.qmc.alarmsfile = filename
                if "alarmflag" in profile:
                    self.qmc.alarmflag = profile["alarmflag"]
                else:
                    self.qmc.alarmflag = []
                if "alarmguard" in profile:
                    self.qmc.alarmguard = profile["alarmguard"]
                else:
                    self.qmc.alarmguard = [0]*len(self.qmc.alarmflag)
                if "alarmnegguard" in profile:
                    self.qmc.alarmnegguard = profile["alarmnegguard"]
                else:
                    self.qmc.alarmnegguard = [0]*len(self.qmc.alarmflag)
                if "alarmtime" in profile:
                    self.qmc.alarmtime = profile["alarmtime"]
                else:
                    self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
                if "alarmoffset" in profile:
                    self.qmc.alarmoffset = profile["alarmoffset"]
                else:
                    self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
                if "alarmcond" in profile:
                    self.qmc.alarmcond = profile["alarmcond"]
                else:
                    self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
                if "alarmsource" in profile:
                    self.qmc.alarmsource = profile["alarmsource"]
                else:
                    self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
                if "alarmtemperature" in profile:
                    self.qmc.alarmtemperature = profile["alarmtemperature"]
                else:
                    self.qmc.alarmtemperature = [500]*len(self.qmc.alarmflag)
                if "alarmaction" in profile:
                    self.qmc.alarmaction = profile["alarmaction"]
                else:
                    self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
                if "alarmbeep" in profile:
                    self.qmc.alarmbeep = profile["alarmbeep"]
                else:
                    self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
                if "alarmstrings" in profile:
                    self.qmc.alarmstrings = [d(x) for x in profile["alarmstrings"]]
                else:
                    self.qmc.alarmstrings = [""]*len(self.qmc.alarmflag)
                self.qmc.alarmstate = [0]*len(self.qmc.alarmflag)  #0 = not triggered; 1 = triggered
            # Ramp/Soak Profiles
            if aw.arduino.loadRampSoakFromProfile:
                if "svValues" in profile:
                    aw.arduino.svValues = profile["svValues"]
                if "svRamps" in profile:
                    aw.arduino.svRamps = profile["svRamps"]
                if "svSoaks" in profile:
                    aw.arduino.svSoaks = profile["svSoaks"]
            if "timeindex" in profile:
                self.qmc.timeindex = profile["timeindex"]
                if self.qmc.locktimex:
                    if self.qmc.locktimex_start >= 0 and self.qmc.timeindex[0] != -1:
                        self.qmc.startofx = self.qmc.timex[aw.qmc.timeindex[0]] + self.qmc.locktimex_start
                    elif self.qmc.locktimex_start >= 0 and self.qmc.timeindex[0] == -1:
                        self.qmc.startofx = self.qmc.locktimex_start
                    elif self.qmc.locktimex_start < 0 and self.qmc.timeindex[0] != -1:
                        self.qmc.startofx = self.qmc.timex[self.qmc.timeindex[0]]-abs(self.qmc.locktimex_start)
                    else:
                        self.qmc.startofx = self.qmc.locktimex
            else:
                ###########      OLD PROFILE FORMAT
                if "startend" in profile:
                    startend = [float(fl) for fl in profile["startend"]]
                else:
                    startend = [0.,0.,0.,0.]
                if "dryend" in profile:
                    dryend = profile["dryend"]
                else:
                    dryend = [0.,0.]
                if "cracks" in profile:
                    varC = [float(fl) for fl in profile["cracks"]]
                else:
                    varC = [0.,0.,0.,0.,0.,0.,0.,0.]
                times = []
                times.append(startend[0])
                times.append(dryend[0])
                times.append(varC[0])
                times.append(varC[2])
                times.append(varC[4])
                times.append(varC[6])
                times.append(startend[2])
                #convert to new profile
                self.qmc.timeindexupdate(times)
            # update phases if phases are set to auto ajusted
            if aw.qmc.phasesbuttonflag:
                # adjust phases by DryEnd and FCs events
                if aw.qmc.timeindex[1]:
                    aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                if aw.qmc.timeindex[2]:
                    aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            # ensure that timeindex has the proper length
            self.qmc.timeindex = self.qmc.timeindex + [0 for i in range(8-len(self.qmc.timeindex))]
            # reset linecount caches
            aw.qmc.resetlinecountcaches()
            # try to reload background profile
            if "backgroundpath" in profile:
                self.qmc.backgroundpath = d(profile["backgroundpath"])
                if os.path.isfile(self.qmc.backgroundpath):
                    aw.loadbackground(u(self.qmc.backgroundpath))
                    aw.qmc.background = True
                    aw.qmc.timealign(redraw=False) # there will be a later redraw triggered that also recomputes the deltas
                else:
                    self.qmc.backgroundpath = ""
                    self.qmc.titleB = ""
            return True
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            # we don't report errors on settingsLoad
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setProfile()",str(ex) + "@line " + str(exc_tb.tb_lineno))

    # the int n specifies the number of digits
    def float2float(self,f,n=1):
        if n==0:
            if math.isnan(f):
                return 0
            else:
                return int(round(f))
        else:
            res = float(("%." + str(n) + "f")%f)
            if math.isnan(res):
                return 0.0
            else:
                return res

    # returns data that is computed by Artisan out of raw profile data using some formulas 
    # and displayed to users e.g. as part of the Report to users and stored along profiles to be used by external programs
    # in case a value cannot be computed the corresponding entry is missing in the resulting dict
    def computedProfileInformation(self):
        computedProfile = {}
        TP_time_idx = None
        DRY_time_idx = None
        try:
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
                computedProfile["CHARGE_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[0]])
                computedProfile["CHARGE_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[0]])
            else:
                start = 0
            ######### TP #########
            # calc TP_time_idx (index of TP; is None if unknown)
            TP_index = self.findTP() # could return -1
            if TP_index > 0 and len(self.qmc.timex) > 0:
                TP_time_idx = TP_index
            else:
                TP_time_idx = None
            if TP_time_idx:
                computedProfile["TP_time"] = self.float2float(self.qmc.timex[TP_time_idx] - start)
                computedProfile["TP_ET"] = self.float2float(self.qmc.temp1[TP_time_idx])
                computedProfile["TP_BT"] = self.float2float(self.qmc.temp2[TP_time_idx])
                if self.qmc.timeindex[6]:
                    computedProfile["MET"] = self.float2float(max(self.qmc.temp1[TP_time_idx:self.qmc.timeindex[6]]))
            ######### DRY #########
            # calc DRY_time_idx (index of DRY; is None if unknown)
            if self.qmc.timeindex[1] and aw.qmc.phasesbuttonflag:
                #manual dryend available
                DRY_time_idx = self.qmc.timeindex[1]
            else:
                dryEndIndex = self.findDryEnd(TP_index)  # use TP_index to avoid recomputation of TP if it failed before
                #we use the dryEndIndex respecting the dry phase
                if dryEndIndex > 0 and dryEndIndex < len(self.qmc.timex):
                    DRY_time_idx = dryEndIndex 
                else:
                    DRY_time_idx = None
            if DRY_time_idx:
                computedProfile["DRY_time"] = self.float2float(self.qmc.timex[DRY_time_idx] - start)
                computedProfile["DRY_ET"] = self.float2float(self.qmc.temp1[DRY_time_idx])
                computedProfile["DRY_BT"] = self.float2float(self.qmc.temp2[DRY_time_idx])
            ######### FC #########
            if self.qmc.timeindex[2]:
                computedProfile["FCs_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[2]] - start)
                computedProfile["FCs_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[2]])
                computedProfile["FCs_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[2]])
            if self.qmc.timeindex[3]:
                computedProfile["FCe_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[3]] - start)
                computedProfile["FCe_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[3]])
                computedProfile["FCe_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[3]])
            ######### SC #########
            if self.qmc.timeindex[4]:
                computedProfile["SCs_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[4]] - start)
                computedProfile["SCs_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[4]])
                computedProfile["SCs_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[4]])
            if self.qmc.timeindex[5]:
                computedProfile["SCe_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[5]] - start)
                computedProfile["SCe_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[5]])
                computedProfile["SCe_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[5]])
            ######### DROP #########
            if self.qmc.timeindex[6]:
                computedProfile["DROP_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[6]] - start)
                computedProfile["DROP_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[6]])
                computedProfile["DROP_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[6]])
            ######### COOL #########
            if self.qmc.timeindex[7]:
                computedProfile["COOL_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[7]] - start)
                computedProfile["COOL_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[7]])
                computedProfile["COOL_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[7]])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)        
        ######### Phases #########
        try:
            if self.qmc.statisticstimes[0]:
                computedProfile["totaltime"] = self.qmc.statisticstimes[0]
            if self.qmc.statisticstimes[1]:
                computedProfile["dryphasetime"] = self.qmc.statisticstimes[1]
            if self.qmc.statisticstimes[2]:
                computedProfile["midphasetime"] = self.qmc.statisticstimes[2]
            if self.qmc.statisticstimes[3]:
                computedProfile["finishphasetime"] = self.qmc.statisticstimes[3]
            if self.qmc.statisticstimes[4]:
                computedProfile["coolphasetime"] = self.qmc.statisticstimes[4]
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### Evaluations #########
        try:
            evaluations = self.defect_estimation()
            computedProfile["dryphaseeval"] = u(evaluations[0])
            computedProfile["midphaseeval"] = u(evaluations[1])
            computedProfile["finishphaseeval"] = u(evaluations[2])
            computedProfile["coolphaseeval"] = u(evaluations[3])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### RoR ######### 
        try:
            if TP_time_idx and DRY_time_idx:
                ror = self.RoR(TP_time_idx,DRY_time_idx)
                computedProfile["dry_phase_ror"] = self.float2float(ror[0])
                computedProfile["mid_phase_ror"] = self.float2float(ror[1])
                computedProfile["finish_phase_ror"] = self.float2float(ror[2])
                if "TP_BT" in computedProfile and "TP_time" in computedProfile and "DROP_BT" in computedProfile and "DROP_time" in computedProfile:
                    computedProfile["total_ror"] = self.float2float(((computedProfile["DROP_BT"]-computedProfile["TP_BT"])/(computedProfile["DROP_time"]-computedProfile["TP_time"]))*60.)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### ETBTarea #########
        try:
            ts,tse,tsb = aw.ts(self.qmc.timeindex[0],self.qmc.timeindex[6])
            computedProfile["total_ts"] = self.float2float(ts,0)
            computedProfile["total_ts_ET"] = self.float2float(tse,0)
            computedProfile["total_ts_BT"] = self.float2float(tsb,0)
        except:
            pass
        try:
            ts1,ts1e,ts1b = aw.ts(self.qmc.timeindex[0],DRY_time_idx)
            computedProfile["dry_phase_ts"] = self.float2float(ts1,0)
            computedProfile["dry_phase_ts_ET"] = self.float2float(ts1e,0)
            computedProfile["dry_phase_ts_BT"] = self.float2float(ts1b,0)
        except:
            pass
        try:
            ts2,ts2e,ts2b = aw.ts(DRY_time_idx,self.qmc.timeindex[2])
            computedProfile["mid_phase_ts"] = self.float2float(ts2,0)
            computedProfile["mid_phase_ts_ET"] = self.float2float(ts2e,0)
            computedProfile["mid_phase_ts_BT"] = self.float2float(ts2b,0)
        except:
            pass
        try:
            ts3,ts3e,ts3b = aw.ts(self.qmc.timeindex[2],self.qmc.timeindex[6])
            computedProfile["finish_phase_ts"] = self.float2float(ts3,0)
            computedProfile["finish_phase_ts_ET"] = self.float2float(ts3e,0)
            computedProfile["finish_phase_ts_BT"] = self.float2float(ts3b,0)
        except:
            pass
        ######### Weight, Volume, Loss, Gain, Density #########
        try:
            volumein = self.qmc.volume[0]
            volumeout = self.qmc.volume[1]
            weightin = self.qmc.weight[0]
            weightout = self.qmc.weight[1]
            weight_loss = self.weight_loss(weightin,weightout)
            volume_gain = self.weight_loss(volumeout,volumein)
            if weight_loss:
                computedProfile["weight_loss"] = self.float2float(weight_loss)
            if volume_gain:
                computedProfile["volume_gain"] = self.float2float(volume_gain)
            if self.qmc.moisture_greens and self.qmc.moisture_roasted:
                moisture_loss = self.qmc.moisture_greens - self.qmc.moisture_roasted
                computedProfile["moisture_loss"] = self.float2float(moisture_loss)
                if weight_loss:
                    computedProfile["organic_loss"] = self.float2float(weight_loss - moisture_loss)
            din = dout = 0
            # standardize unit of volume and weight to l and g
            if volumein != 0.0 and volumeout != 0.0:
                if self.qmc.volume[2] == "ml":
                    volumein = volumein / 1000.0
                    volumeout = volumeout / 1000.0
            # store volume in l
            computedProfile["volumein"] = volumein
            computedProfile["volumeout"] = volumeout
            if weightin != 0.0 and weightout != 0.0:
                if self.qmc.weight[2] != "g":
                    weightin = weightin * 1000.0
                    weightout = weightout * 1000.0
            # store weight in Kg
            computedProfile["weightin"] = weightin * 1000.
            computedProfile["weightout"] = weightout * 1000.
            if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
                din = (weightin / volumein) 
                dout = (weightout / volumeout)
            if din > 0.:
                computedProfile["green_density"] = self.float2float(din)
            if dout > 0.:
                computedProfile["roasted_density"] = self.float2float(dout)
                
            if (aw.qmc.density[0] != 0.0 and aw.qmc.density[2] != 0.0):
                setdensity = aw.qmc.density[0] /  aw.qmc.density[2]
                if aw.qmc.density[1] != "g":
                    setdensity = setdensity / 1000.0
                if aw.qmc.density[3] != "l":
                    setdensity = setdensity * 1000.0
                computedProfile["set_density"] = self.float2float(setdensity)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)                
        ######### Humidity #########
        try:
            if aw.qmc.moisture_greens != 0.0 and not math.isnan(aw.qmc.moisture_greens):
                computedProfile["moisture_greens"] = self.float2float(aw.qmc.moisture_greens)
            if aw.qmc.moisture_roasted != 0.0 and not math.isnan(aw.qmc.moisture_roasted):
                computedProfile["moisture_roasted"] = self.float2float(aw.qmc.moisture_roasted)
            if aw.qmc.ambient_humidity != 0.0 and not math.isnan(aw.qmc.ambient_humidity):
                computedProfile["ambient_humidity"] = self.float2float(aw.qmc.ambient_humidity)
            if aw.qmc.ambientTemp != 0.0 and not math.isnan(aw.qmc.ambientTemp):
                computedProfile["ambient_temperature"] = self.float2float(aw.qmc.ambientTemp)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### Similarity #########
        try:
            det,dbt = aw.curveSimilarity(aw.qmc.phases[1])
            if det != None:
                computedProfile["det"] = det
                computedProfile["dbt"] = dbt
        except:
            pass
        ######### RETURN #########
        return computedProfile

    #used by filesave()
    #wrap values in unicode(.) if and only if those are of type string
    def getProfile(self):
        try:
            profile = {}
            profile["version"] = str(__version__)
            profile["revision"] = str(__revision__)
            profile["mode"] = self.qmc.mode
            profile["timeindex"] = self.qmc.timeindex
            profile["flavors"] = self.qmc.flavors
            profile["flavorlabels"] = [encodeLocal(fl) for fl in self.qmc.flavorlabels]
            profile["flavorstartangle"] = self.qmc.flavorstartangle
            profile["flavoraspect"] = self.qmc.flavoraspect
            profile["title"] = encodeLocal(self.qmc.title)
            profile["beans"] = encodeLocal(self.qmc.beans)
            profile["weight"] = [self.qmc.weight[0],self.qmc.weight[1],encodeLocal(self.qmc.weight[2])]
            profile["volume"] = [self.qmc.volume[0],self.qmc.volume[1],encodeLocal(self.qmc.volume[2])]
            profile["density"] = [self.qmc.density[0],encodeLocal(self.qmc.density[1]),self.qmc.density[2],encodeLocal(self.qmc.density[3])]
            profile["roastertype"] = encodeLocal(self.qmc.roastertype)
            profile["operator"] = encodeLocal(self.qmc.operator)
            profile["heavyFC"] = self.qmc.heavyFC_flag
            profile["lowFC"] = self.qmc.lowFC_flag
            profile["lightCut"] = self.qmc.lightCut_flag
            profile["darkCut"] = self.qmc.darkCut_flag
            profile["drops"] = self.qmc.drops_flag
            profile["oily"] = self.qmc.oily_flag
            profile["uneven"] = self.qmc.uneven_flag
            profile["tipping"] = self.qmc.tipping_flag
            profile["scorching"] = self.qmc.scorching_flag
            profile["divots"] = self.qmc.divots_flag
            profile["whole_color"] = self.qmc.whole_color
            profile["ground_color"] = self.qmc.ground_color
            profile["color_system"] = self.qmc.color_systems[self.qmc.color_system_idx]
            profile["volumeCalcWeightIn"] = str(self.qmc.volumeCalcWeightInStr)
            profile["volumeCalcWeightOut"] = str(self.qmc.volumeCalcWeightOutStr)
            # write roastdate that respects locale and potential cannot be read in under a different locale (just for compatibility to older versions)
            try:
                profile["roastdate"] = encodeLocal(self.qmc.roastdate.toString())
            except:
                pass
            # write roast date
            try:
                profile["roastisodate"] = encodeLocal(self.qmc.roastdate.toString(Qt.ISODate))
            except:
                pass
            profile["beansize"] = str(self.qmc.beansize)
            profile["specialevents"] = self.qmc.specialevents
            profile["specialeventstype"] = self.qmc.specialeventstype
            profile["specialeventsvalue"] = self.qmc.specialeventsvalue
            profile["specialeventsStrings"] = [encodeLocal(ses) for ses in self.qmc.specialeventsStrings]
            profile["etypes"] = [encodeLocal(et) for et in self.qmc.etypes]
            profile["roastingnotes"] = encodeLocal(self.qmc.roastingnotes)
            profile["cuppingnotes"] = encodeLocal(self.qmc.cuppingnotes)
            profile["timex"] = [self.float2float(x,6) for x in self.qmc.timex]
            profile["temp1"] = [self.float2float(x,3) for x in self.qmc.temp1]
            profile["temp2"] = [self.float2float(x,3) for x in self.qmc.temp2]
            profile["phases"] = self.qmc.phases
            profile["zmax"] = self.qmc.zlimit
            profile["zmin"] = self.qmc.zlimit_min
            profile["ymax"] = self.qmc.ylimit
            profile["ymin"] = self.qmc.ylimit_min
            profile["xmin"] = self.qmc.startofx
            profile["xmax"] = self.qmc.endofx
            profile["ambientTemp"] = self.qmc.ambientTemp
            profile["ambient_humidity"] = self.qmc.ambient_humidity
            profile["moisture_greens"] = self.qmc.moisture_greens
            profile["moisture_roasted"] = self.qmc.moisture_roasted
            profile["extradevices"] = self.qmc.extradevices
            profile["extraname1"] = [encodeLocal(n) for n in self.qmc.extraname1]
            profile["extraname2"] = [encodeLocal(n) for n in self.qmc.extraname2]
            profile["extratimex"] = [[self.float2float(t,5) for t in x] for x in self.qmc.extratimex]
            profile["extratemp1"] = [[self.float2float(t,2) for t in x] for x in self.qmc.extratemp1]
            profile["extratemp2"] = [[self.float2float(t,2) for t in x] for x in self.qmc.extratemp2]
            profile["extramathexpression1"] = self.qmc.extramathexpression1
            profile["extramathexpression2"] = self.qmc.extramathexpression2  
            profile["extradevicecolor1"] = [encodeLocal(x) for x in self.qmc.extradevicecolor1]
            profile["extradevicecolor2"] = [encodeLocal(x) for x in self.qmc.extradevicecolor2]
            profile["extramarkersizes1"] = self.qmc.extramarkersizes1
            profile["extramarkersizes2"] = self.qmc.extramarkersizes2
            profile["extramarkers1"] = [encodeLocal(x) for x in self.qmc.extramarkers1]
            profile["extramarkers2"] = [encodeLocal(x) for x in self.qmc.extramarkers2]
            profile["extralinewidths1"] = self.qmc.extralinewidths1
            profile["extralinewidths2"] = self.qmc.extralinewidths2
            profile["extralinestyles1"] = [encodeLocal(x) for x in self.qmc.extralinestyles1]
            profile["extralinestyles2"] = [encodeLocal(x) for x in self.qmc.extralinestyles2]
            profile["extradrawstyles1"] = [encodeLocal(x) for x in self.qmc.extradrawstyles1]
            profile["extradrawstyles2"] = [encodeLocal(x) for x in self.qmc.extradrawstyles2]
            profile["externalprogram"] = encodeLocal(self.ser.externalprogram)
            #alarms
            profile["alarmflag"] = self.qmc.alarmflag
            profile["alarmguard"] = self.qmc.alarmguard
            profile["alarmnegguard"] = self.qmc.alarmnegguard
            profile["alarmtime"] = self.qmc.alarmtime
            profile["alarmoffset"] = self.qmc.alarmoffset
            profile["alarmcond"] = self.qmc.alarmcond
            profile["alarmsource"] = self.qmc.alarmsource
            profile["alarmtemperature"] = self.qmc.alarmtemperature
            profile["alarmaction"] = self.qmc.alarmaction
            profile["alarmbeep"] = self.qmc.alarmbeep
            profile["alarmstrings"] = [encodeLocal(x) for x in self.qmc.alarmstrings]
            # remember background profile path
            profile["backgroundpath"] = encodeLocal(self.qmc.backgroundpath)
            #write only:
            profile["samplinginterval"] = self.qmc.delay / 1000.
            profile["oversampling"] = self.qmc.oversampling
            profile["svValues"] = aw.arduino.svValues
            profile["svRamps"] = aw.arduino.svRamps
            profile["svSoaks"] = aw.arduino.svSoaks
            try:
                ds = list(self.qmc.extradevices)
                ds.insert(0,self.qmc.device)
                profile["devices"] = [self.qmc.devices[d-1] for d in ds]
            except Exception as ex:
                pass
            profile["computed"] = self.computedProfileInformation()
            return profile
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " getProfile(): %1").arg(str(ex)),exc_tb.tb_lineno)
            return None

    #saves recorded profile in hard drive. Called from file menu 
    def fileSave(self,fname):
        try:
            filename = fname
            if not filename:
                path = QDir()
                path.setPath(self.getDefaultPath())
                fname = path.absoluteFilePath(self.generateFilename())
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Profile",None, QApplication.UnicodeUTF8), path=fname)
            if filename:
                #write
                pf = self.getProfile()
                if pf:
                    self.serialize(filename,pf)
                    self.setCurrentFile(filename)
                    self.sendmessage(QApplication.translate("Message","Profile saved", None, QApplication.UnicodeUTF8))
                    self.qmc.safesaveflag = False
                else:
                    self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " filesave(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def fileExport(self,msg,ext,dumper):
        try:
            filename = self.ArtisanSaveFileDialog(msg=msg,ext=ext)
            if filename:
                res = dumper(filename)
                if res:
                    self.sendmessage(QApplication.translate("Message","Readings exported", None, QApplication.UnicodeUTF8))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
        except Exception as ex:
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " fileExport(): %1").arg(str(ex)))
            return

    def fileExportCSV(self):
        self.fileExport(QApplication.translate("Message", "Export CSV",None, QApplication.UnicodeUTF8),"*.csv",self.exportCSV)

    def fileExportJSON(self):
        self.fileExport(QApplication.translate("Message", "Export JSON",None, QApplication.UnicodeUTF8),"*.json",self.exportJSON)

    def fileExportRoastLogger(self):
        self.fileExport(QApplication.translate("Message", "Export RoastLogger",None, QApplication.UnicodeUTF8),"*.csv",self.exportRoastLogger)

    def fileImport(self,msg,loader,reset=False):
        try:
            filename = self.ArtisanOpenFileDialog(msg=msg)
            if filename:
                if reset:
                    aw.qmc.reset(True,False)
                loader(filename)
                self.sendmessage(QApplication.translate("Message","Readings imported", None, QApplication.UnicodeUTF8))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " fileImport(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def fileImportCSV(self):
        self.fileImport(QApplication.translate("Message", "Import CSV",None, QApplication.UnicodeUTF8),self.importCSV,True)

    def fileImportJSON(self):
        self.fileImport(QApplication.translate("Message", "Import JSON",None, QApplication.UnicodeUTF8),self.importJSON,True)

    def fileImportRoastLogger(self):
        self.fileImport(QApplication.translate("Message", "Import RoastLogger",None, QApplication.UnicodeUTF8),self.importRoastLogger,True)

    #loads the settings at the start of application. See the oppposite closeEvent()
    def settingsLoad(self):
        try: 
            settings = QSettings()
            if settings.contains("resetqsettings"):
                self.resetqsettings = settings.value("resetqsettings",self.resetqsettings).toInt()[0]
                if self.resetqsettings:
                    self.resetqsettings = 0
                    self.qmc.redraw()
                    return  #don't load any more settings. They could be bad (corrupted). Stop here.
            #restore geometry
            if settings.contains("Geometry"):
                self.restoreGeometry(settings.value("Geometry").toByteArray())
            #restore mode
            old_mode = self.qmc.mode
            self.qmc.mode = str(settings.value("Mode",self.qmc.mode).toString())
            #convert modes only if needed comparing the new uploaded mode to the old one.
            #otherwise it would incorrectly convert the uploaded phases
            if self.qmc.mode == "F" and old_mode == "C":
                self.qmc.fahrenheitMode()
            if self.qmc.mode == "C" and old_mode == "F":
                self.qmc.celsiusMode()
            #restore device
            settings.beginGroup("Device")
            self.qmc.device = settings.value("id",self.qmc.device).toInt()[0]
            # Phidget configurations
            if settings.contains("phidget1048_types"):
                self.qmc.phidget1048_types = [x.toInt()[0] for x in settings.value("phidget1048_types",self.qmc.phidget1048_types).toList()]
            if settings.contains("phidget1048_async"):
                self.qmc.phidget1048_async = [bool(x.toBool()) for x in settings.value("phidget1048_async",self.qmc.phidget1048_async).toList()]
                self.qmc.phidget1048_changeTriggers = [aw.float2float(x.toFloat()[0]) for x in settings.value("phidget1048_changeTriggers",self.qmc.phidget1048_changeTriggers).toList()]              
            if settings.contains("phidget1046_gain"):
                self.qmc.phidget1046_gain = [x.toInt()[0] for x in settings.value("phidget1046_gain",self.qmc.phidget1046_gain).toList()]
                self.qmc.phidget1046_formula = [x.toInt()[0] for x in settings.value("phidget1046_formula",self.qmc.phidget1046_formula).toList()]
                self.qmc.phidget1046_async = [bool(x.toBool()) for x in settings.value("phidget1046_async",self.qmc.phidget1046_async).toList()]
                self.qmc.phidget1046_dataRate = settings.value("phidget1046_dataRate",self.qmc.phidget1046_dataRate).toInt()[0]
            if settings.contains("phidget1045_async"):
                self.qmc.phidget1045_async = bool(settings.value("phidget1045_async",self.qmc.phidget1045_async).toBool())
                self.qmc.phidget1045_changeTrigger = aw.float2float(settings.value("phidget1045_changeTrigger",self.qmc.phidget1045_changeTrigger).toFloat()[0])
            if settings.contains("phidget1045_emissivity"):
                self.qmc.phidget1045_emissivity = settings.value("phidget1045_emissivity",self.qmc.phidget1045_emissivity).toDouble()[0]
            if settings.contains("phidgetRemoteFlag"):
                self.qmc.phidgetRemoteFlag = bool(settings.value("phidgetRemoteFlag",self.qmc.phidgetRemoteFlag).toBool())
                self.qmc.phidgetServerID = u(settings.value("phidgetServerID",self.qmc.phidgetServerID).toString())
                self.qmc.phidgetPassword = u(settings.value("phidgetPassword",self.qmc.phidgetPassword).toString())
            if settings.contains("phidget1018Ratiometric"):
                self.qmc.phidget1018Ratiometric = bool(settings.value("phidget1018Ratiometric",self.qmc.phidget1018Ratiometric).toBool())
                self.qmc.phidget1018_async = [bool(x.toBool()) for x in settings.value("phidget1018_async",self.qmc.phidget1018_async).toList()]
                self.qmc.phidget1018_raws = [bool(x.toBool()) for x in settings.value("phidget1018_raws",self.qmc.phidget1018_raws).toList()]
                self.qmc.phidget1018_dataRates = [x.toInt()[0] for x in settings.value("phidget1018_dataRates",self.qmc.phidget1018_dataRates).toList()]
                self.qmc.phidget1018_changeTriggers = [x.toInt()[0] for x in settings.value("phidget1018_changeTriggers",self.qmc.phidget1018_changeTriggers).toList()]              
            if settings.contains("PIDbuttonflag"):
                self.qmc.PIDbuttonflag = settings.value("PIDbuttonflag",self.qmc.PIDbuttonflag).toBool()
            # activate CONTROL BUTTON
            if self.qmc.device == 0: # Fuji
                self.button_10.setVisible(True) #CONTROL BUTTON
                self.LCD6frame.setVisible(True)
                self.LCD7frame.setVisible(True)
            elif self.qmc.device == 26:   #DEVICE 26 = DTA; 
                self.button_10.setVisible(True) #CONTROL BUTTON
            elif self.qmc.device == 19: #DEVICE 19 = ARDUINOTC4
                if aw.qmc.PIDbuttonflag:
                    self.button_10.setVisible(True) #CONTROL BUTTON
                else:
                    self.button_10.setVisible(False) #CONTROL BUTTON
            if settings.contains("controlETpid"):
                self.ser.controlETpid = [x.toInt()[0] for x in settings.value("controlETpid").toList()]
            if settings.contains("readBTpid"):
                self.ser.readBTpid = [x.toInt()[0] for x in settings.value("readBTpid").toList()]
            if settings.contains("arduinoETChannel"):
                self.ser.arduinoETChannel = str(settings.value("arduinoETChannel").toString())
            if settings.contains("arduinoBTChannel"):
                self.ser.arduinoBTChannel = str(settings.value("arduinoBTChannel").toString())
            if settings.contains("arduinoATChannel"):
                self.ser.arduinoATChannel = str(settings.value("arduinoATChannel").toString())
            if settings.contains("ArduinoFILT"):
                self.ser.ArduinoFILT = [x.toInt()[0] for x in settings.value("ArduinoFILT").toList()]
            if settings.contains("useModbusPort"):
                self.ser.useModbusPort = settings.value("useModbusPort").toBool()
            settings.endGroup()
            #restore phases
            if settings.contains("Phases"):
                self.qmc.phases = [x.toInt()[0] for x in settings.value("Phases").toList()]
            if settings.contains("PhasesFilter"):
                self.qmc.phases_mode = settings.value("PhasesMode",int(self.qmc.phases_mode)).toInt()[0]
                self.qmc.phases_filter = [x.toInt()[0] for x in settings.value("PhasesFilter").toList()]
                self.qmc.phases_espresso = [x.toInt()[0] for x in settings.value("PhasesEspresso").toList()]
            if settings.contains("phasesbuttonflag"):
                self.qmc.phasesbuttonflag = settings.value("phasesbuttonflag",self.qmc.phasesbuttonflag).toBool()
            if settings.contains("watermarks"):
                self.qmc.watermarksflag = settings.value("watermarks",self.qmc.watermarksflag).toBool()
            if settings.contains("phasesLCDs"):
                self.qmc.phasesLCDflag = settings.value("phasesLCDs",self.qmc.phasesLCDflag).toBool()
            if settings.contains("autoDry"):
                self.qmc.autoDRYflag = settings.value("autoDry",self.qmc.autoDRYflag).toBool()
            if settings.contains("autoFCs"):
                self.qmc.autoFCsFlag = settings.value("autoFCs",self.qmc.autoFCsFlag).toBool()
            #restore Events settings
            settings.beginGroup("events")
            self.eventsbuttonflag = settings.value("eventsbuttonflag",int(self.eventsbuttonflag)).toInt()[0]
            self.minieventsflag = settings.value("minieventsflag",int(self.minieventsflag)).toInt()[0]
            self.qmc.eventsGraphflag = settings.value("eventsGraphflag",int(self.qmc.eventsGraphflag)).toInt()[0]
            if settings.contains("etypes"):
                self.qmc.etypes = settings.value("etypes",self.qmc.etypes).toStringList()
                # update minieditor event type ComboBox
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(self.qmc.etypes)
            if settings.contains("eventsshowflag"):
                self.qmc.eventsshowflag = settings.value("eventsshowflag",int(self.qmc.eventsshowflag)).toInt()[0]
            if settings.contains("autoChargeDrop"):
                self.qmc.autoChargeFlag = settings.value("autoChargeDrop",False).toBool()
                self.qmc.autoDropFlag = self.qmc.autoChargeFlag
            if settings.contains("autoCharge"):
                self.qmc.autoChargeFlag = settings.value("autoCharge",self.qmc.autoChargeFlag).toBool()
            if settings.contains("autoDrop"):
                self.qmc.autoDropFlag = settings.value("autoDrop",self.qmc.autoDropFlag).toBool()
            if settings.contains("markTP"):
                self.qmc.markTPflag = settings.value("markTP",self.qmc.markTPflag).toBool()
            if settings.contains("EvalueColor"):
                self.qmc.EvalueColor = list(map(str,list(settings.value("EvalueColor",self.qmc.EvalueColor).toStringList())))
                self.qmc.EvalueMarker = list(map(str,list(settings.value("EvalueMarker",self.qmc.EvalueMarker).toStringList())))
            if settings.contains("Evaluelinethickness"):
                self.qmc.Evaluelinethickness = [x.toInt()[0] for x in settings.value("Evaluelinethickness").toList()]
                self.qmc.Evaluealpha = [x.toDouble()[0] for x in settings.value("Evaluealpha").toList()]
            if settings.contains("EvalueMarkerSize"):
                self.qmc.EvalueMarkerSize = [x.toInt()[0] for x in settings.value("EvalueMarkerSize").toList()]
            settings.endGroup()
            #restore statistics
            if settings.contains("Statistics"):
                self.qmc.statisticsflags = [x.toInt()[0] for x in settings.value("Statistics").toList()]
                # extend statisticsflag len to the full size (for backward compatibility)
                for i in range(6 - len(self.qmc.statisticsflags)):
                    self.qmc.statisticsflags.append(0)
            if settings.contains("StatisticsConds"):
                tmpconds = [x.toInt()[0] for x in settings.value("StatisticsConds").toList()]
                for i in range(len(tmpconds),len(self.qmc.statisticsconditions)):
                    tmpconds.append(self.qmc.statisticsconditions[i])
                self.qmc.statisticsconditions = tmpconds
            #restore ambient temperature source
            if settings.contains("AmbientTempSource"):
                aw.qmc.ambientTempSource = settings.value("AmbientTempSource",int()).toInt()[0]
            #restore delay
            if settings.contains("Delay"):
                self.qmc.delay = max(self.qmc.min_delay,settings.value("Delay",int(self.qmc.delay)).toInt()[0])
            else:
                self.qmc.delay = self.qmc.default_delay
            # restore oversampling
            if settings.contains("Oversampling"):
                self.qmc.oversampling = settings.value("Oversampling",self.qmc.oversampling).toBool()
                aw.oversamplingAction.setChecked(aw.qmc.oversampling)
            #restore colors
            for (k, v) in list(settings.value("Colors").toMap().items()):
                self.qmc.palette[str(k)] = str(v.toString())
            if self.qmc.palette["et"]:
                self.setLabelColor(aw.label2,QColor(self.qmc.palette["et"]))
            if self.qmc.palette["bt"]:    
                self.setLabelColor(aw.label3,QColor(self.qmc.palette["bt"]))
            if self.qmc.palette["deltaet"]:    
                self.setLabelColor(aw.label4,QColor(self.qmc.palette["deltaet"]))
            if self.qmc.palette["deltabt"]:    
                self.setLabelColor(aw.label5,QColor(self.qmc.palette["deltabt"]))
            if settings.contains("ETBColor"):
                self.qmc.backgroundmetcolor = str(settings.value("ETBColor",self.qmc.backgroundmetcolor).toString())
            if settings.contains("BTBColor"):
                self.qmc.backgroundbtcolor = str(settings.value("BTBColor",self.qmc.backgroundbtcolor).toString())
            if settings.contains("ETBdeltaColor"):
                self.qmc.backgrounddeltaetcolor = str(settings.value("ETBdeltaColor",self.qmc.backgrounddeltaetcolor).toString())
            if settings.contains("BTBdeltaColor"):
                self.qmc.backgrounddeltabtcolor = str(settings.value("BTBdeltaColor",self.qmc.backgrounddeltabtcolor).toString())
            if settings.contains("LCDColors"):
                for (k, v) in list(settings.value("LCDColors").toMap().items()):
                    self.lcdpaletteB[str(k)] = str(v.toString())
            if settings.contains("LEDColors"):
                for (k, v) in list(settings.value("LEDColors").toMap().items()):
                    self.lcdpaletteF[str(k)] = str(v.toString())
            #restore colors
            self.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["timer"],self.lcdpaletteB["timer"]))
            self.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["et"],self.lcdpaletteB["et"]))
            self.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["bt"],self.lcdpaletteB["bt"]))
            self.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltaet"],self.lcdpaletteB["deltaet"]))
            self.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltabt"],self.lcdpaletteB["deltabt"]))
            self.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            #restore flavors
            self.qmc.flavorlabels = settings.value("Flavors",self.qmc.flavorlabels).toStringList()
            self.qmc.flavors = [5.]*len(self.qmc.flavorlabels)
            if settings.contains("flavorstartangle"):
                self.qmc.flavorstartangle = settings.value("flavorstartangle",int(self.qmc.flavorstartangle)).toInt()[0]
            #restore roast color system
            if settings.contains("colorsystem"):
                self.qmc.color_system_idx = settings.value("colorsystem",int(self.qmc.color_system_idx)).toInt()[0]
            #restore units
            settings.beginGroup("Units")
            if settings.contains("weight"):
                self.qmc.weight[2] = str(settings.value("weight",self.qmc.weight[2]).toString())
                self.qmc.volume[2] = str(settings.value("volume",self.qmc.volume[2]).toString())
                self.qmc.density[1] = str(settings.value("densityweight",self.qmc.density[1]).toString())
                self.qmc.density[3] = str(settings.value("densityvolume",self.qmc.density[3]).toString())
            if settings.contains("volumeCalcUnit"):
                self.qmc.volumeCalcUnit = settings.value("volumeCalcUnit",int(self.qmc.volumeCalcUnit)).toInt()[0]
            settings.endGroup()
            settings.beginGroup("Tare")
            if settings.contains("names"):
                self.qmc.container_names = list(map(u,list(settings.value("names",self.qmc.container_names).toStringList())))
            if settings.contains("weights"):
                self.qmc.container_weights = [x.toInt()[0] for x in settings.value("weights").toList()]
            if settings.contains("idx"):
                self.qmc.container_idx = settings.value("idx",int(self.qmc.container_idx)).toInt()[0]
            settings.endGroup()
            #restore serial port
            settings.beginGroup("SerialPort")
            self.ser.comport = str(settings.value("comport",self.ser.comport).toString())
            self.ser.baudrate = settings.value("baudrate",int(self.ser.baudrate)).toInt()[0]
            self.ser.bytesize = settings.value("bytesize",self.ser.bytesize).toInt()[0]
            self.ser.stopbits = settings.value("stopbits",self.ser.stopbits).toInt()[0]
            self.ser.parity = str(settings.value("parity",self.ser.parity).toString())
            self.ser.timeout = settings.value("timeout",self.ser.timeout).toInt()[0]
            settings.endGroup()
            #restore modbus port
            settings.beginGroup("Modbus")
            self.modbus.comport = str(settings.value("comport",self.modbus.comport).toString())
            self.modbus.baudrate = settings.value("baudrate",int(self.modbus.baudrate)).toInt()[0]
            self.modbus.bytesize = settings.value("bytesize",self.modbus.bytesize).toInt()[0]
            self.modbus.stopbits = settings.value("stopbits",self.modbus.stopbits).toInt()[0]
            self.modbus.parity = str(settings.value("parity",self.modbus.parity).toString())
            self.modbus.timeout = settings.value("timeout",self.modbus.timeout).toInt()[0]
            self.modbus.input1slave = settings.value("input1slave",self.modbus.input1slave).toInt()[0]
            self.modbus.input1register = settings.value("input1register",self.modbus.input1register).toInt()[0]
            self.modbus.input2slave = settings.value("input2slave",self.modbus.input2slave).toInt()[0]
            self.modbus.input2register = settings.value("input2register",self.modbus.input2register).toInt()[0]
            self.modbus.input3slave = settings.value("input3slave",self.modbus.input3slave).toInt()[0]
            self.modbus.input3register = settings.value("input3register",self.modbus.input3register).toInt()[0]
            self.modbus.input4slave = settings.value("input4slave",self.modbus.input4slave).toInt()[0]
            self.modbus.input4register = settings.value("input4register",self.modbus.input4register).toInt()[0]
            if settings.contains("input1float"):
                self.modbus.input1float = settings.value("input1float",self.modbus.input1float).toBool()
                self.modbus.input1code = settings.value("input1code",self.modbus.input1code).toInt()[0]
                self.modbus.input2float = settings.value("input2float",self.modbus.input2float).toBool()
                self.modbus.input2code = settings.value("input2code",self.modbus.input2code).toInt()[0]
                self.modbus.input3float = settings.value("input3float",self.modbus.input3float).toBool()
                self.modbus.input3code = settings.value("input3code",self.modbus.input3code).toInt()[0]
                self.modbus.input4float = settings.value("input4float",self.modbus.input4float).toBool()
                self.modbus.input4code = settings.value("input4code",self.modbus.input4code).toInt()[0]
                self.modbus.littleEndianFloats = settings.value("littleEndianFloats",self.modbus.littleEndianFloats).toBool()
#                # switch to little-endian if needed (HACK!!)
#                if self.modbus.littleEndianFloats:
#                    try:
#                        minimalmodbus._bytestringToFloat = littleEndianBytestringToFloat
#                    except:
#                        pass
            if settings.contains("input1mode"):
                self.modbus.input1mode = str(settings.value("input1mode",self.modbus.input1mode).toString())
                self.modbus.input2mode = str(settings.value("input2mode",self.modbus.input2mode).toString())
                self.modbus.input3mode = str(settings.value("input3mode",self.modbus.input3mode).toString())
                self.modbus.input4mode = str(settings.value("input4mode",self.modbus.input4mode).toString())                
            #restore MODBUS TCP/UDP settings
            if settings.contains("host"):
                self.modbus.type = settings.value("type",self.modbus.type).toInt()[0]
                self.modbus.host = str(settings.value("host",self.modbus.host).toString())
                self.modbus.port = settings.value("port",self.modbus.port).toInt()[0]
            settings.endGroup()
            #restore scale port
            settings.beginGroup("Scale")
            self.scale.device = u(settings.value("device",self.scale.device).toString())
            self.scale.comport = str(settings.value("comport",self.scale.comport).toString())
            self.scale.baudrate = settings.value("baudrate",int(self.scale.baudrate)).toInt()[0]
            self.scale.bytesize = settings.value("bytesize",self.scale.bytesize).toInt()[0]
            self.scale.stopbits = settings.value("stopbits",self.scale.stopbits).toInt()[0]
            self.scale.parity = str(settings.value("parity",self.scale.parity).toString())
            self.scale.timeout = settings.value("timeout",self.scale.timeout).toInt()[0]
            settings.endGroup()
            #restore color port
            settings.beginGroup("Color")
            self.color.device = u(settings.value("device",self.color.device).toString())
            self.color.comport = str(settings.value("comport",self.color.comport).toString())
            self.color.baudrate = settings.value("baudrate",int(self.color.baudrate)).toInt()[0]
            self.color.bytesize = settings.value("bytesize",self.color.bytesize).toInt()[0]
            self.color.stopbits = settings.value("stopbits",self.color.stopbits).toInt()[0]
            self.color.parity = str(settings.value("parity",self.color.parity).toString())
            self.color.timeout = settings.value("timeout",self.color.timeout).toInt()[0]
            settings.endGroup()
            #restore alarms
            settings.beginGroup("Alarms")
            if settings.contains("alarmtime"):
                self.qmc.alarmflag = [x.toInt()[0] for x in settings.value("alarmflag").toList()]
                if settings.contains("alarmguard"):
                    self.qmc.alarmguard = [x.toInt()[0] for x in settings.value("alarmguard").toList()]
                else:
                    self.qmc.alarmguard = [-1]*len(self.qmc.alarmflag)
                if settings.contains("alarmnegguard"):
                    self.qmc.alarmnegguard = [x.toInt()[0] for x in settings.value("alarmnegguard").toList()]
                else:
                    self.qmc.alarmnegguard = [-1]*len(self.qmc.alarmflag)
                if settings.contains("alarmtime"):
                    self.qmc.alarmtime = [x.toInt()[0] for x in settings.value("alarmtime").toList()]
                else:
                    self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
                if settings.contains("alarmoffset"):
                    self.qmc.alarmoffset = [max(0,x.toInt()[0]) for x in settings.value("alarmoffset").toList()]
                else:
                    self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmcond"):
                    self.qmc.alarmcond = [x.toInt()[0] for x in settings.value("alarmcond").toList()]
                else:
                    self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
                if settings.contains("alarmsource"):
                    self.qmc.alarmsource = [x.toInt()[0] for x in settings.value("alarmsource").toList()]
                else:
                    self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
                if settings.contains("alarmtemperature"):
                    self.qmc.alarmtemperature = [x.toInt()[0] for x in settings.value("alarmtemperature").toList()]
                else:
                    self.qmc.alarmtemperature = [500]*len(self.qmc.alarmflag)
                if settings.contains("alarmaction"):
                    self.qmc.alarmaction = [x.toInt()[0] for x in settings.value("alarmaction").toList()]
                else:
                    self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmbeep"):
                    self.qmc.alarmbeep = [x.toInt()[0] for x in settings.value("alarmbeep").toList()]
                else:
                    self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmstrings"):
                    self.qmc.alarmstrings = list(settings.value("alarmstrings",self.qmc.alarmstrings).toStringList())
                else:
                    self.qmc.alarmstrings = [""]*len(self.qmc.alarmflag)
                self.qmc.alarmstate = [0]*len(self.qmc.alarmflag)
                if settings.contains("loadAlarmsFromProfile"):
                    self.qmc.loadalarmsfromprofile = settings.value("loadAlarmsFromProfile",self.qmc.loadalarmsfromprofile).toBool()
                if settings.contains("alarmsfile"):
                    self.qmc.alarmsfile = settings.value("alarmsfile",self.qmc.loadalarmsfromprofile).toString()
            settings.endGroup()
            #restore TC4/Arduino PID settings
            settings.beginGroup("ArduinoPID")
            if settings.contains("pidOnCHARGE"):
                aw.arduino.pidOnCHARGE = settings.value("pidOnCHARGE",aw.arduino.pidOnCHARGE).toBool()
                aw.arduino.loadRampSoakFromProfile = settings.value("loadRampSoakFromProfile",aw.arduino.loadRampSoakFromProfile).toBool()
                aw.arduino.svValues = [x.toInt()[0] for x in settings.value("svValues",aw.arduino.svValues).toList()]
                aw.arduino.svRamps = [x.toInt()[0] for x in settings.value("svRamps",aw.arduino.svRamps).toList()]
                aw.arduino.svSoaks = [x.toInt()[0] for x in settings.value("svSoaks",aw.arduino.svSoaks).toList()]
                aw.arduino.svSlider = settings.value("svSlider",aw.arduino.svSlider).toBool()
                aw.arduino.svButtons = settings.value("svButtons",aw.arduino.svButtons).toBool()
                aw.arduino.svMode = settings.value("svMode",aw.arduino.svMode).toInt()[0]
                aw.arduino.svLookahead = settings.value("svLookahead",aw.arduino.svLookahead).toInt()[0]
                aw.arduino.svSliderMin = settings.value("svSliderMin",aw.arduino.svSliderMin).toInt()[0]
                aw.arduino.svSliderMax = settings.value("svSliderMax",aw.arduino.svSliderMax).toInt()[0]
                aw.arduino.svValue = settings.value("svValue",aw.arduino.svValue).toInt()[0]
                aw.arduino.pidKp = settings.value("pidKp",aw.arduino.pidKp).toDouble()[0]
                aw.arduino.pidKi = settings.value("pidKi",aw.arduino.pidKi).toDouble()[0]
                aw.arduino.pidKd = settings.value("pidKd",aw.arduino.pidKd).toDouble()[0]
                aw.arduino.pidSource = settings.value("pidSource",aw.arduino.pidSource).toInt()[0]
                aw.arduino.pidCycle = settings.value("pidCycle",aw.arduino.pidCycle).toInt()[0]
            settings.endGroup()
            
            #restore pid settings
            settings.beginGroup("PXR")
            for key in list(self.fujipid.PXR.keys()):
                if type(self.fujipid.PXR[key][0]) == type(float()):
                    self.fujipid.PXR[key][0] = settings.value(key,self.fujipid.PXR[key]).toDouble()[0]
                elif type(self.fujipid.PXR[key][0]) == type(int()):
                    self.fujipid.PXR[key][0] = settings.value(key,self.fujipid.PXR[key]).toInt()[0]
            settings.endGroup()
            settings.beginGroup("PXG4")
            for key in list(self.fujipid.PXG4.keys()):
                if type(self.fujipid.PXG4[key][0]) == type(float()):
                    self.fujipid.PXG4[key][0] = settings.value(key,self.fujipid.PXG4[key][0]).toDouble()[0]
                elif type(self.fujipid.PXG4[key][0]) == type(int()):
                    self.fujipid.PXG4[key][0] = settings.value(key,self.fujipid.PXG4[key][0]).toInt()[0]
            settings.endGroup()
            if settings.contains("deltaDTA"):
                settings.beginGroup("deltaDTA")
                for key in list(self.dtapid.dtamem.keys()):
                    if type(self.dtapid.dtamem[key][0]) == type(float()):
                        self.dtapid.dtamem[key][0] = settings.value(key,self.dtapid.dtamem[key][0]).toDouble()[0]
                    elif type(self.dtapid.dtamem[key][0]) == type(int()):
                        self.dtapid.dtamem[key][0] = settings.value(key,self.dtapid.dtamem[key][0]).toInt()[0]
                settings.endGroup()
            if settings.contains("filterDropOuts"):
                self.qmc.filterDropOuts = settings.value("filterDropOuts",self.qmc.filterDropOuts).toBool()
            if settings.contains("dropSpikes"):
                self.qmc.dropSpikes = settings.value("dropSpikes",self.qmc.dropSpikes).toBool()
            if settings.contains("altSmoothing"):
                self.qmc.altsmoothing = settings.value("altSmoothing",self.qmc.altsmoothing).toBool()
            if settings.contains("swapETBT"):
                self.qmc.swapETBT = settings.value("swapETBT",self.qmc.swapETBT).toBool()
            if settings.contains("minmaxLimits"):
                self.qmc.minmaxLimits = settings.value("minmaxLimits",self.qmc.minmaxLimits).toBool()
                self.qmc.filterDropOut_tmin = settings.value("minLimit",self.qmc.filterDropOut_tmin).toInt()[0]
                self.qmc.filterDropOut_tmax = settings.value("maxLimit",self.qmc.filterDropOut_tmax).toInt()[0]
            settings.beginGroup("RoC")
            self.qmc.DeltaETflag = settings.value("DeltaET",self.qmc.DeltaETflag).toBool()
            self.qmc.DeltaBTflag = settings.value("DeltaBT",self.qmc.DeltaBTflag).toBool()
            self.qmc.deltafilter = settings.value("deltafilter",self.qmc.deltafilter).toInt()[0]
            if settings.contains("DeltaSpan"):
                self.qmc.deltaspan = settings.value("DeltaSpan",self.qmc.deltaspan).toInt()[0]
            self.qmc.LCDdecimalplaces = settings.value("LCDdecimalplaces",self.qmc.LCDdecimalplaces).toInt()[0]
            if settings.contains("DeltaETlcd"):
                self.qmc.DeltaETlcdflag = settings.value("DeltaETlcd",self.qmc.DeltaETlcdflag).toBool()
            if settings.contains("DeltaBTlcd"):
                self.qmc.DeltaBTlcdflag = settings.value("DeltaBTlcd",self.qmc.DeltaBTlcdflag).toBool()
            settings.endGroup()
            if settings.contains("curvefilter"):
                self.qmc.curvefilter = settings.value("curvefilter",self.qmc.curvefilter).toInt()[0]
            if settings.contains("smoothingwindowsize"):
                self.qmc.smoothingwindowsize = settings.value("smoothingwindowsize",self.qmc.smoothingwindowsize).toInt()[0]
            if settings.contains("ETcurve"):
                self.qmc.ETcurve = settings.value("ETcurve",self.qmc.ETcurve).toBool()
            if settings.contains("BTcurve"):
                self.qmc.BTcurve = settings.value("BTcurve",self.qmc.BTcurve).toBool()
            if settings.contains("ETlcd"):
                self.qmc.ETlcd = settings.value("ETlcd",self.qmc.ETlcd).toBool()
            if settings.contains("BTlcd"):
                self.qmc.BTlcd = settings.value("BTlcd",self.qmc.BTlcd).toBool()
            settings.beginGroup("DefaultButtons")
            if settings.contains("buttonvisibility"):
                self.qmc.buttonvisibility = [x.toBool() for x in settings.value("buttonvisibility").toList()]
            if settings.contains("buttonactions"):
                self.qmc.buttonactions = [x.toInt()[0] for x in settings.value("buttonactions").toList()]
            if settings.contains("buttonactionstrings"):
                self.qmc.buttonactionstrings = list(map(str,list(settings.value("buttonactionstrings",self.qmc.buttonactionstrings).toStringList())))
            if settings.contains("extrabuttonactions"):
                self.qmc.extrabuttonactions = [x.toInt()[0] for x in settings.value("extrabuttonactions").toList()]
            if settings.contains("extrabuttonactionstrings"):
                self.qmc.extrabuttonactionstrings = list(map(str,list(settings.value("extrabuttonactionstrings",self.qmc.extrabuttonactionstrings).toStringList())))
            settings.endGroup()
            settings.beginGroup("HUD")
            self.qmc.projectFlag = settings.value("Projection",self.qmc.projectFlag).toBool()
            self.qmc.projectionmode = settings.value("ProjectionMode",self.qmc.projectionmode).toInt()[0]
            self.qmc.ETtarget = settings.value("ETtarget",self.qmc.ETtarget).toInt()[0]
            self.qmc.BTtarget = settings.value("BTtarget",self.qmc.BTtarget).toInt()[0]
            if settings.contains("ET2target"):
                self.qmc.ET2target = settings.value("ET2target",self.qmc.ET2target).toInt()[0]
            if settings.contains("BT2target"):
                self.qmc.BT2target = settings.value("BT2target",self.qmc.BT2target).toInt()[0]
            self.HUDfunction = settings.value("Mode",self.HUDfunction).toInt()[0]
            if settings.contains("hudETpid"):
                self.qmc.hudETpid = [x.toInt()[0] for x in settings.value("hudETpid").toList()]
            if settings.contains("buttonFlag"):
                self.qmc.HUDbuttonflag = settings.value("buttonFlag",self.qmc.HUDbuttonflag).toBool()
                if not self.qmc.HUDbuttonflag:
                    aw.button_18.setVisible(False)
            settings.endGroup()
            settings.beginGroup("Style")
            if settings.contains("patheffects"):
                self.qmc.patheffects = settings.value("patheffects",self.qmc.patheffects).toInt()[0]
            if settings.contains("graphstyle"):
                self.qmc.graphstyle = settings.value("graphstyle",self.qmc.graphstyle).toInt()[0]
            if settings.contains("graphfont"):
                self.qmc.graphfont = settings.value("graphfont",self.qmc.graphfont).toInt()[0]
            settings.endGroup()
            settings.beginGroup("Sound")
            self.soundflag = settings.value("Beep",self.soundflag).toInt()[0]
            settings.endGroup()
            #saves max-min temp limits of graph
            settings.beginGroup("Axis")
            self.qmc.startofx = settings.value("xmin",self.qmc.startofx).toInt()[0]
            self.qmc.endofx = settings.value("xmax",self.qmc.endofx).toInt()[0]
            #fixes Windows OS sometimes saving endofx as 0 
            if self.qmc.endofx < 60 or self.qmc.endofx > 1800:
                self.qmc.endofx = 60
            self.qmc.ylimit = min(settings.value("ymax",self.qmc.ylimit).toInt()[0],850)
            self.qmc.ylimit_min = max(min(settings.value("ymin",self.qmc.ylimit_min).toInt()[0],self.qmc.ylimit),-150)
            self.qmc.zlimit = min(settings.value("zmax",self.qmc.zlimit).toInt()[0],500)
            self.qmc.zlimit_min = max(min(settings.value("zmin",self.qmc.zlimit_min).toInt()[0],self.qmc.zlimit),-200)
            if settings.contains("resetmaxtime"):
                self.qmc.resetmaxtime = settings.value("resetmaxtime",self.qmc.resetmaxtime).toInt()[0]
            if settings.contains("lockmax"):
                self.qmc.fixmaxtime = settings.value("lockmax",self.qmc.fixmaxtime).toBool()
            if settings.contains("locktimex"):
                self.qmc.locktimex = settings.value("locktimex",self.qmc.locktimex).toBool()
            if settings.contains("locktimex_start"):
                self.qmc.locktimex_start = settings.value("locktimex_start",self.qmc.locktimex_start).toInt()[0]
            self.qmc.legendloc = settings.value("legendloc",self.qmc.legendloc).toInt()[0]
            settings.endGroup()
            settings.beginGroup("RoastProperties")
            self.qmc.operator = u(settings.value("operator",self.qmc.operator).toString())
            self.qmc.roastertype = u(settings.value("roastertype",self.qmc.roastertype).toString())
            self.qmc.density[2] = settings.value("densitySampleVolume",self.qmc.density[2]).toInt()[0]
            self.qmc.density[3] = u(settings.value("densitySampleVolumeUnit",self.qmc.density[3]).toString())
            if settings.contains("beansize"):
                self.qmc.beansize = settings.value("beansize",self.qmc.beansize).toDouble()[0]
            settings.endGroup()
            self.userprofilepath = u(settings.value("profilepath",self.userprofilepath).toString())
            if settings.contains("autosavepath"):
                self.qmc.autosavepath = u(settings.value("autosavepath",self.qmc.autosavepath).toString())
            if settings.contains("externalprogram"):
                self.ser.externalprogram = u(settings.value("externalprogram",self.ser.externalprogram).toString())
            settings.beginGroup("ExtraDev")
            if settings.contains("extradevices"):
                self.qmc.extradevices = [x.toInt()[0] for x in settings.value("extradevices").toList()]
                self.qmc.extraname1 = list(map(u,list(settings.value("extraname1",self.qmc.extraname1).toStringList())))
                self.qmc.extraname2 = list(map(u,list(settings.value("extraname2",self.qmc.extraname2).toStringList())))
                self.qmc.extramathexpression1 = list(map(str,list(settings.value("extramathexpression1",self.qmc.extramathexpression1).toStringList())))
                self.qmc.extramathexpression2 = list(map(str,list(settings.value("extramathexpression2",self.qmc.extramathexpression2).toStringList())))
                self.qmc.extradevicecolor1 = list(map(str,list(settings.value("extradevicecolor1",self.qmc.extradevicecolor1).toStringList())))
                self.qmc.extradevicecolor2 = list(map(str,list(settings.value("extradevicecolor2",self.qmc.extradevicecolor2).toStringList())))
                if settings.contains("extraLCDvisibility1"):
                    self.extraLCDvisibility1 = [x.toBool() for x in settings.value("extraLCDvisibility1").toList()]
                if settings.contains("extraLCDvisibility2"):
                    self.extraLCDvisibility2 = [x.toBool() for x in settings.value("extraLCDvisibility2").toList()]
                if settings.contains("extraCurveVisibility1"):
                    self.extraCurveVisibility1 = [x.toBool() for x in settings.value("extraCurveVisibility1").toList()]
                if settings.contains("extraCurveVisibility2"):
                    self.extraCurveVisibility2 = [x.toBool() for x in settings.value("extraCurveVisibility2").toList()]
            #create empty containers
            settings.endGroup()
            #restore curve styles
            settings.beginGroup("CurveStyles")
            if settings.contains("BTlinestyle"):
                self.qmc.BTlinestyle = str(settings.value("BTlinestyle",self.qmc.BTlinestyle).toString())
                self.qmc.BTdrawstyle = str(settings.value("BTdrawstyle",self.qmc.BTdrawstyle).toString())
                self.qmc.BTlinewidth = settings.value("BTlinewidth",self.qmc.BTlinewidth).toInt()[0]
                self.qmc.BTmarker = str(settings.value("BTmarker",self.qmc.BTmarker).toString())
                self.qmc.BTmarkersize = settings.value("BTmarkersize",self.qmc.BTmarkersize).toInt()[0]
                self.qmc.ETlinestyle = str(settings.value("ETlinestyle",self.qmc.ETlinestyle).toString())
                self.qmc.ETdrawstyle = str(settings.value("ETdrawstyle",self.qmc.ETdrawstyle).toString())
                self.qmc.ETlinewidth = settings.value("ETlinewidth",self.qmc.ETlinewidth).toInt()[0]
                self.qmc.ETmarker = str(settings.value("ETmarker",self.qmc.ETmarker).toString())
                self.qmc.ETmarkersize = settings.value("ETmarkersize",self.qmc.ETmarkersize).toInt()[0]
                self.qmc.BTdeltalinestyle = str(settings.value("BTdeltalinestyle",self.qmc.BTdeltalinestyle).toString())
                self.qmc.BTdeltadrawstyle = str(settings.value("BTdeltadrawstyle",self.qmc.BTdeltadrawstyle).toString())
                self.qmc.BTdeltalinewidth = settings.value("BTdeltalinewidth",self.qmc.BTdeltalinewidth).toInt()[0]
                self.qmc.BTdeltamarker = str(settings.value("BTdeltamarker",self.qmc.BTdeltamarker).toString())
                self.qmc.BTdeltamarkersize = settings.value("BTdeltamarkersize",self.qmc.BTdeltamarkersize).toInt()[0]
                self.qmc.ETdeltalinestyle = str(settings.value("ETdeltalinestyle",self.qmc.ETdeltalinestyle).toString())
                self.qmc.ETdeltadrawstyle = str(settings.value("ETdeltadrawstyle",self.qmc.ETdeltadrawstyle).toString())
                self.qmc.ETdeltalinewidth = settings.value("ETdeltalinewidth",self.qmc.ETdeltalinewidth).toInt()[0]
                self.qmc.ETdeltamarker = str(settings.value("ETdeltamarker",self.qmc.ETdeltamarker).toString())
                self.qmc.ETdeltamarkersize = settings.value("ETdeltamarkersize",self.qmc.ETdeltamarkersize).toInt()[0]
                self.qmc.BTbacklinestyle = str(settings.value("BTbacklinestyle",self.qmc.BTbacklinestyle).toString())
                self.qmc.BTbackdrawstyle = str(settings.value("BTbackdrawstyle",self.qmc.BTbackdrawstyle).toString())
                self.qmc.BTbacklinewidth = settings.value("BTbacklinewidth",self.qmc.BTbacklinewidth).toInt()[0]
                self.qmc.BTbackmarker = str(settings.value("BTbackmarker",self.qmc.BTbackmarker).toString())
                self.qmc.BTbackmarkersize = settings.value("BTbackmarkersize",self.qmc.BTbackmarkersize).toInt()[0]
                self.qmc.ETbacklinestyle = str(settings.value("ETbacklinestyle",self.qmc.ETbacklinestyle).toString())
                self.qmc.ETbackdrawstyle = str(settings.value("ETbackdrawstyle",self.qmc.ETbackdrawstyle).toString())
                self.qmc.ETbacklinewidth = settings.value("ETbacklinewidth",self.qmc.ETbacklinewidth).toInt()[0]
                self.qmc.ETbackmarker = str(settings.value("ETbackmarker",self.qmc.ETbackmarker).toString())
                self.qmc.ETbackmarkersize = settings.value("ETbackmarkersize",self.qmc.ETbackmarkersize).toInt()[0]
                self.qmc.extralinestyles1 = list(map(str,list(settings.value("extralinestyles1",self.qmc.extralinestyles1).toStringList())))
                self.qmc.extralinestyles2 = list(map(str,list(settings.value("extralinestyles2",self.qmc.extralinestyles2).toStringList())))
                self.qmc.extradrawstyles1 = list(map(str,list(settings.value("extradrawstyles1",self.qmc.extradrawstyles1).toStringList())))
                self.qmc.extradrawstyles2 = list(map(str,list(settings.value("extradrawstyles2",self.qmc.extradrawstyles2).toStringList())))
                self.qmc.extralinewidths1 = [x.toInt()[0] for x in settings.value("extralinewidths1").toList()]
                self.qmc.extralinewidths2 = [x.toInt()[0] for x in settings.value("extralinewidths2").toList()]
                self.qmc.extramarkers1 = list(map(str,list(settings.value("extramarkers1",self.qmc.extramarkers1).toStringList())))
                self.qmc.extramarkers2 = list(map(str,list(settings.value("extramarkers2",self.qmc.extramarkers2).toStringList())))
                self.qmc.extramarkersizes1 = [x.toInt()[0] for x in settings.value("extramarkersizes1").toList()]
                self.qmc.extramarkersizes2 = [x.toInt()[0] for x in settings.value("extramarkersizes2").toList()]
                self.qmc.BTBdeltalinestyle = str(settings.value("BTBdeltalinestyle",self.qmc.BTBdeltalinestyle).toString())
                self.qmc.BTBdeltadrawstyle = str(settings.value("BTBdeltadrawstyle",self.qmc.BTBdeltadrawstyle).toString())
                self.qmc.BTBdeltalinewidth = settings.value("BTBdeltalinewidth",self.qmc.BTBdeltalinewidth).toInt()[0]
                self.qmc.BTBdeltamarker = str(settings.value("BTBdeltamarker",self.qmc.BTBdeltamarker).toString())
                self.qmc.BTBdeltamarkersize = settings.value("BTBdeltamarkersize",self.qmc.BTBdeltamarkersize).toInt()[0]
                self.qmc.ETBdeltalinestyle = str(settings.value("ETBdeltalinestyle",self.qmc.ETBdeltalinestyle).toString())
                self.qmc.ETBdeltadrawstyle = str(settings.value("ETBdeltadrawstyle",self.qmc.ETBdeltadrawstyle).toString())
                self.qmc.ETBdeltalinewidth = settings.value("ETBdeltalinewidth",self.qmc.ETBdeltalinewidth).toInt()[0]
                self.qmc.ETBdeltamarker = str(settings.value("ETBdeltamarker",self.qmc.ETBdeltamarker).toString())
                self.qmc.ETBdeltamarkersize = settings.value("ETBdeltamarkersize",self.qmc.ETBdeltamarkersize).toInt()[0]
            settings.endGroup()
            ndevices = len(self.qmc.extradevices)
            if ndevices != len(self.qmc.extralinestyles1) or \
               ndevices != len(self.qmc.extralinestyles2) or \
               ndevices != len(self.qmc.extradrawstyles1) or \
               ndevices != len(self.qmc.extradrawstyles2) or \
               ndevices != len(self.qmc.extralinewidths1) or \
               ndevices != len(self.qmc.extralinewidths2) or \
               ndevices != len(self.qmc.extramarkers1) or \
               ndevices != len(self.qmc.extramarkers2) or \
               ndevices != len(self.qmc.extramarkersizes1) or \
               ndevices != len(self.qmc.extramarkersizes2):
                self.qmc.extralinestyles1 = self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*ndevices
                self.qmc.extradrawstyles1 = self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*ndevices
                self.qmc.extralinewidths1 = self.qmc.extralinewidths2 = [self.qmc.linewidth_default]*ndevices
                self.qmc.extramarkers1 = self.qmc.extramarkers2 = [self.qmc.marker_default]*ndevices
                self.qmc.extramarkersizes1 = self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*ndevices
            for i in range(len(self.qmc.extradevices)):
                self.qmc.extratemp1.append([])
                self.qmc.extratemp2.append([])
                self.qmc.extratimex.append([])
                self.qmc.extrastemp1.append([])
                self.qmc.extrastemp2.append([])
            #extra LCDs
            self.updateLCDproperties()
            # set extraLCD colors
            for i in range(len(self.qmc.extradevices)):
                self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
                self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
            # Extra com ports
            settings.beginGroup("ExtraComm")
            if settings.contains("extracomport"):
                self.extracomport = list(map(str,list(settings.value("extracomport",self.extracomport).toStringList())))
                self.extrabaudrate = [x.toInt()[0] for x in settings.value("extrabaudrate").toList()]
                self.extrabytesize = [x.toInt()[0] for x in settings.value("extrabytesize").toList()]
                self.extraparity = list(map(str,list(settings.value("extraparity",self.extraparity).toStringList())))
                self.extrastopbits = [x.toInt()[0] for x in settings.value("extrastopbits").toList()]
                self.extratimeout = [x.toInt()[0] for x in settings.value("extratimeout").toList()]
                lenextraports = len(self.extracomport)
                self.extraser = [None]*lenextraports
                #populate aw.extraser
                for i in range(lenextraports):
                    self.extraser[i] = serialport()
                    self.extraser[i].comport = str(self.extracomport[i])
                    self.extraser[i].baudrate = self.extrabaudrate[i]
                    self.extraser[i].bytesize = self.extrabytesize[i]
                    self.extraser[i].parity = str(self.extraparity[i])
                    self.extraser[i].stopbits = self.extrastopbits[i]
                    self.extraser[i].timeout = self.extratimeout[i]
            settings.endGroup()
            if settings.contains("BTfunction"):
                self.qmc.BTfunction = str(settings.value("BTfunction",self.qmc.BTfunction).toString())
                self.qmc.ETfunction = str(settings.value("ETfunction",self.qmc.ETfunction).toString())
            if settings.contains("plotcurves"):
                self.qmc.plotcurves = list(settings.value("plotcurves",self.qmc.plotcurves).toStringList())
                self.qmc.plotcurvecolor = list(settings.value("plotcurvecolor",self.qmc.plotcurvecolor).toStringList())
                for i in range(len(self.qmc.plotcurves)):
                    self.qmc.plotcurves[i] = str(self.qmc.plotcurves[i])
                    self.qmc.plotcurvecolor[i] = str(self.qmc.plotcurvecolor[i])
            settings.beginGroup("grid")
            if settings.contains("xgrid"):
                self.qmc.xgrid = settings.value("xgrid",self.qmc.xgrid).toInt()[0]
                self.qmc.ygrid = settings.value("ygrid",self.qmc.ygrid).toInt()[0]
                self.qmc.zgrid = settings.value("zgrid",self.qmc.zgrid).toInt()[0]
                self.qmc.gridthickness = settings.value("gridthickness",self.qmc.gridthickness).toInt()[0]
                self.qmc.xrotation = settings.value("xrotation",self.qmc.xrotation).toInt()[0]
                self.qmc.gridlinestyle = settings.value("gridlinestyle",self.qmc.gridlinestyle).toInt()[0]
                self.qmc.gridalpha = settings.value("gridalpha",self.qmc.gridalpha).toDouble()[0]
            settings.endGroup()
            if settings.contains("roastpropertiesflag"):
                self.qmc.roastpropertiesflag = settings.value("roastpropertiesflag",self.qmc.roastpropertiesflag).toInt()[0]
            if settings.contains("customflavorlabels"):
                self.qmc.customflavorlabels = list(map(u,list(settings.value("customflavorlabels",self.qmc.customflavorlabels).toStringList())))
            #restore sliders
            settings.beginGroup("Sliders")
            if settings.contains("slidervisibilities"):
                self.eventslidervisibilities = [x.toInt()[0] for x in settings.value("slidervisibilities").toList()]
                self.eventslideractions = [x.toInt()[0] for x in settings.value("slideractions").toList()]
                self.eventslidercommands = list(map(str,list(settings.value("slidercommands",self.eventslidercommands).toStringList())))
                self.eventslideroffsets = [x.toInt()[0] for x in settings.value("slideroffsets").toList()]
                self.eventsliderfactors = [x.toDouble()[0] for x in settings.value("sliderfactors").toList()]
            settings.endGroup()
            #restore quantifier
            settings.beginGroup("Quantifiers")
            if settings.contains("quantifieractive"):
                self.eventquantifieractive = [x.toInt()[0] for x in settings.value("quantifieractive").toList()]
                self.eventquantifiersource = [x.toInt()[0] for x in settings.value("quantifiersource").toList()]
                self.eventquantifiermin = [x.toInt()[0] for x in settings.value("quantifiermin").toList()]
                self.eventquantifiermax = [x.toInt()[0] for x in settings.value("quantifiermax").toList()]
                if settings.contains("quantifiercoarse"):
                    self.eventquantifiercoarse = [x.toInt()[0] for x in settings.value("quantifiercoarse").toList()]
            settings.endGroup()
            self.computeLinespaces()
            self.updateSlidersProperties()
            #restore background profile settings
            settings.beginGroup("background")
            if settings.contains("backgrounddetails"):
                aw.qmc.backgroundDetails = settings.value("backgrounddetails",aw.qmc.backgroundDetails).toBool()
                aw.qmc.backgroundeventsflag = settings.value("backgroundevents",aw.qmc.backgroundeventsflag).toBool()
                aw.qmc.DeltaETBflag = settings.value("DeltaETB",aw.qmc.DeltaETBflag).toBool()
                aw.qmc.DeltaBTBflag = settings.value("DeltaBTB",aw.qmc.DeltaBTBflag).toBool()
                if settings.contains("alignFCs"):
                    aw.qmc.flagalignFCs = settings.value("alignFCs",aw.qmc.flagalignFCs).toBool()
            settings.endGroup()
            if settings.contains("autosaveflag"):
                self.qmc.autosaveflag = settings.value("autosaveflag",self.qmc.autosaveflag).toInt()[0]
            if settings.contains("autosaveprefix"):
                self.qmc.autosaveprefix = settings.value("autosaveprefix",self.qmc.autosaveprefix).toString()
            # WebLCDs            
            settings.beginGroup("WebLCDs")
            if settings.contains("active"):
                self.WebLCDs = settings.value("active",self.WebLCDs).toBool()
                self.WebLCDsPort = settings.value("port",self.WebLCDsPort).toInt()[0]
                self.WebLCDsAlerts = settings.value("alerts",self.WebLCDsAlerts).toBool()
            settings.endGroup()
            if settings.contains("LargeLCDs"):
                self.LargeLCDs = settings.value("LargeLCDs",self.LargeLCDs).toBool()
            if self.LargeLCDs:
                self.largeLCDs()
            # start server if needed
            if self.WebLCDs:
                self.startWebLCDs(force=True)
            #restore buttons
            settings.beginGroup("ExtraEventButtons")
            if settings.contains("extraeventsactions"):
                if settings.contains("buttonlistmaxlen"):
                    self.buttonlistmaxlen = settings.value("buttonlistmaxlen",self.buttonlistmaxlen).toInt()[0]
                if settings.contains("extraeventsbuttonsflag"):
                    self.extraeventsbuttonsflag = settings.value("extraeventsbuttonsflag",self.extraeventsbuttonsflag).toInt()[0]
                self.extraeventstypes = [x.toInt()[0] for x in settings.value("extraeventstypes").toList()]
                self.extraeventsvalues = [x.toFloat()[0] for x in settings.value("extraeventsvalues").toList()]
                self.extraeventsactions = [x.toInt()[0] for x in settings.value("extraeventsactions").toList()]
                self.extraeventsvisibility = [x.toInt()[0] for x in settings.value("extraeventsvisibility").toList()]
                self.extraeventsactionstrings = list(settings.value("extraeventsactionstrings",self.extraeventsactionstrings).toStringList())
                self.extraeventslabels = list(settings.value("extraeventslabels",self.extraeventslabels).toStringList())
                self.extraeventsdescriptions= list(settings.value("extraeventsdescriptions",self.extraeventsdescriptions).toStringList())
                if settings.contains("extraeventbuttoncolor"):
                    self.extraeventbuttoncolor = list(settings.value("extraeventbuttoncolor",self.extraeventbuttoncolor).toStringList())
                    self.extraeventbuttontextcolor = list(settings.value("extraeventbuttontextcolor",self.extraeventbuttontextcolor).toStringList())
                else:
                    self.extraeventbuttoncolor = ["yellow"]*len(self.extraeventstypes)
                    self.extraeventbuttontextcolor = ["black"]*len(self.extraeventstypes)
                if settings.contains("buttonpalette"):
                    self.buttonpalettemaxlen = [max(9,x.toInt()[0]) for x in settings.value("buttonpalettemaxlen").toList()]
                    mlist = [x.toList() for x in settings.value("buttonpalette").toList()]
                    for i in range(len(mlist)):
                        if len(mlist[i]) in [9,13,14]:
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][0].toList()])              #types
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][1].toList()])              #values
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][2].toList()])              #actions
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][3].toList()])              #visibility
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][4].toList()]))) #strings
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][5].toList()]))) #labels
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][6].toList()]))) #descriptions
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][7].toList()]))) #color
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][8].toList()]))) #textcolor
                            if len(mlist[i]) == 14:
                                self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][9].toList()])            #slider visibility
                                self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][10].toList()])            #slider actions
                                self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][11].toList()]))) #sider commands
                                self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][12].toList()])            #slider offsets
                                self.buttonpalette[i].append([x.toDouble()[0] for x in mlist[i][13].toList()])         #slider factors
                            else:
                                self.buttonpalette[i].extend([[],[],[],[],[]])
                        else:
                            self.buttonpalette[i].extend([[],[],[],[],[],[],[],[],[],[],[],[],[]])
                for i in range(len(self.extraeventsactionstrings)):
                    self.extraeventsactionstrings[i] = u(self.extraeventsactionstrings[i])
                    self.extraeventslabels[i] = u(self.extraeventslabels[i])
                    self.extraeventsdescriptions[i] = u(self.extraeventsdescriptions[i])
                    self.extraeventbuttoncolor[i] = str(self.extraeventbuttoncolor[i])
                    self.extraeventbuttontextcolor[i] = str(self.extraeventbuttontextcolor[i])
                #update individual visibility of each buttons
                self.realignbuttons()
                self.update_extraeventbuttons_visibility()
            settings.endGroup()

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None, QApplication.UnicodeUTF8),QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "  settingsLoad()  @line " + str(exc_tb.tb_lineno))

#--------------------------------
        try:
            #update visibility of main event button
            self.applyStandardButtonVisibility()
            
            #self.qmc.redraw()
            # set window appearances (style)
            if settings.contains("appearance"):
                try:
                    available = list(map(str, list(QStyleFactory.keys())))
                    i = list(map(lambda x:x.lower(),available)).index(str(settings.value("appearance").toString()))
                    app.setStyle(available[i])
                except:
                    pass
            # set dpi
            if settings.contains("dpi"):
                try:
                    aw.dpi = settings.value("dpi",aw.dpi).toInt()[0]
                    if aw.dpi != aw.defaultdpi:
                        aw.setdpi(aw.dpi,moveWindow=False)
                except:
                    pass
        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None, QApplication.UnicodeUTF8),QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " settingsLoad()  @line " + str(exc_tb.tb_lineno))

    def startWebLCDs(self,force=False):
        try:
            if not self.WebLCDs or force:
                res = startWeb(
                    self.WebLCDsPort,
                    u(self.getResourcePath()),
                    ("&nbsp;&nbsp;-.-" if aw.qmc.LCDdecimalplaces else "&nbsp;--"),
                    aw.lcdpaletteF["timer"],
                    aw.lcdpaletteB["timer"],
                    aw.lcdpaletteF["bt"],
                    aw.lcdpaletteB["bt"],
                    aw.lcdpaletteF["et"],
                    aw.lcdpaletteB["et"],
                    aw.qmc.ETlcd,
                    aw.qmc.BTlcd)
                if res:
                    self.WebLCDs = True
                    return True
                else:
                    self.stopWebLCDs()
                    return False
            else:
                return False
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " startWebLCDs() %1").arg(str(e)),exc_tb.tb_lineno)
            self.stopWebLCDs()
            return False
            
    def stopWebLCDs(self):
        try:
            stopWeb()
            self.WebLCDs = False
        except:
            pass

    def applyStandardButtonVisibility(self):
        if self.eventsbuttonflag:
            self.button_11.setVisible(True)
        else:
            self.button_11.setVisible(False)
        #set default button visibility
        aw.button_8.setVisible(bool(aw.qmc.buttonvisibility[0]))
        aw.button_19.setVisible(bool(aw.qmc.buttonvisibility[1]))
        aw.button_3.setVisible(bool(aw.qmc.buttonvisibility[2]))
        aw.button_4.setVisible(bool(aw.qmc.buttonvisibility[3]))
        aw.button_5.setVisible(bool(aw.qmc.buttonvisibility[4]))
        aw.button_6.setVisible(bool(aw.qmc.buttonvisibility[5]))
        aw.button_9.setVisible(bool(aw.qmc.buttonvisibility[6]))
        aw.button_20.setVisible(bool(aw.qmc.buttonvisibility[7]))

    def fetchCurveStyles(self):
        try:
# this conflicts in GreenFlag zoom mode!
#            # get and set axis y limits
#            yrange = aw.qmc.ax.get_ylim()
#            yl_min = int(yrange[0])
#            yl = int(yrange[1])
#            if yl > yl_min + 10:
#                aw.qmc.ylimit = yl
#                aw.qmc.ylimit_min = yl_min
#            delta_yrange = aw.qmc.delta_ax.get_ylim()
#            zl_min = int(delta_yrange[0])
#            zl = int(delta_yrange[1])
#            if zl > zl_min + 5:
#                aw.qmc.zlimit = zl
#                aw.qmc.zlimit_min = zl_min
            if aw.qmc.l_temp1:
                self.qmc.ETlinestyle = aw.qmc.l_temp1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                # otherwise the drawingstyle cannot be set back to default!
                if self.qmc.ETlinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdrawstyle = aw.qmc.l_temp1.get_drawstyle()
                else:
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = aw.qmc.l_temp1.get_linewidth()
                m = aw.qmc.l_temp1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETmarker = m
                self.qmc.palette["et"] = aw.qmc.l_temp1.get_color()
            if aw.qmc.l_temp2:
                self.qmc.BTlinestyle = aw.qmc.l_temp2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTlinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdrawstyle = aw.qmc.l_temp2.get_drawstyle()
                else:
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = aw.qmc.l_temp2.get_linewidth()
                m = aw.qmc.l_temp2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTmarker = m
                self.qmc.BTmarkersize = aw.qmc.l_temp2.get_markersize()
                self.qmc.palette["bt"] = aw.qmc.l_temp2.get_color()
            if aw.qmc.l_delta1:
                self.qmc.ETdeltalinestyle = aw.qmc.l_delta1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdeltadrawstyle = aw.qmc.l_delta1.get_drawstyle()
                else:
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = aw.qmc.l_delta1.get_linewidth()
                m = aw.qmc.l_delta1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETdeltamarker = m
                self.qmc.ETdeltamarkersize = aw.qmc.l_delta1.get_markersize()
                self.qmc.palette["deltaet"] = aw.qmc.l_delta1.get_color()
            if aw.qmc.l_delta2:
                self.qmc.BTdeltalinestyle = aw.qmc.l_delta2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdeltadrawstyle = aw.qmc.l_delta2.get_drawstyle()
                else:
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = aw.qmc.l_delta2.get_linewidth()
                m = aw.qmc.l_delta2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTdeltamarker = m
                self.qmc.BTdeltamarkersize = aw.qmc.l_delta2.get_markersize()  
                self.qmc.palette["deltabt"] = aw.qmc.l_delta2.get_color()
            if aw.qmc.l_back1:
                self.qmc.ETbacklinestyle = aw.qmc.l_back1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.ETbackdrawstyle = aw.qmc.l_back1.get_drawstyle()
                else:
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = aw.qmc.l_back1.get_linewidth()
                m = aw.qmc.l_back1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETbackmarker = m                
                self.qmc.ETbackmarkersize = aw.qmc.l_back1.get_markersize()
                self.qmc.backgroundmetcolor = aw.qmc.l_back1.get_color()
            if aw.qmc.l_back2:
                self.qmc.BTbacklinestyle = aw.qmc.l_back2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.BTbackdrawstyle = aw.qmc.l_back2.get_drawstyle()
                else:
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = aw.qmc.l_back2.get_linewidth()
                m = aw.qmc.l_back2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTbackmarker = m                                
                self.qmc.BTbackmarkersize = aw.qmc.l_back2.get_markersize()
                self.qmc.backgroundbtcolor = aw.qmc.l_back2.get_color()
            if aw.qmc.l_delta1B:
                self.qmc.ETBdeltalinestyle = aw.qmc.l_delta1B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETBdeltadrawstyle = aw.qmc.l_delta1B.get_drawstyle()
                else:
                    self.qmc.ETBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETBdeltalinewidth = aw.qmc.l_delta1B.get_linewidth()
                m = aw.qmc.l_delta1B.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETBdeltamarker = m                                
                self.qmc.ETBdeltamarkersize = aw.qmc.l_delta1B.get_markersize()
                self.qmc.backgrounddeltaetcolor = aw.qmc.l_delta1B.get_color()
            if aw.qmc.l_delta2B:
                self.qmc.BTBdeltalinestyle = aw.qmc.l_delta2B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTBdeltadrawstyle = aw.qmc.l_delta2B.get_drawstyle()
                else:
                    self.qmc.BTBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTBdeltalinewidth = aw.qmc.l_delta2B.get_linewidth()
                m = aw.qmc.l_delta2B.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTBdeltamarker = m
                self.qmc.BTBdeltamarkersize = aw.qmc.l_delta2B.get_markersize()
                self.qmc.backgrounddeltabtcolor = aw.qmc.l_delta2B.get_color()
            x1 = x2 = 0
            for i in range(len(aw.qmc.extradevices)):
                if aw.extraCurveVisibility1[i]:
                    l1 = aw.qmc.extratemp1lines[x1]
                    self.qmc.extralinestyles1[i] = l1.get_linestyle()
                    if self.qmc.extralinestyles1[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles1[i] = l1.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles1[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths1[i] = l1.get_linewidth()
                    m = l1.get_marker()
                    if not isinstance(m, (int)):
                        self.qmc.extramarkers1[i] = m
                    self.qmc.extramarkersizes1[i] = l1.get_markersize()
                    aw.qmc.extradevicecolor1[i] = l1.get_color()
                    aw.setLabelColor(aw.extraLCDlabel1[i],QColor(l1.get_color()))
                    aw.qmc.extraname1[i] = l1.get_label()
                    x1 = x1 + 1
                if aw.extraCurveVisibility2[i]:
                    l2 = aw.qmc.extratemp2lines[x2]
                    self.qmc.extralinestyles2[i] = l2.get_linestyle()
                    if self.qmc.extralinestyles2[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles2[i] = l2.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles2[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths2[i] = l2.get_linewidth()
                    m = l2.get_marker()
                    if not isinstance(m, (int)):
                        self.qmc.extramarkers2[i] = m
                    self.qmc.extramarkersizes2[i] = l2.get_markersize()
                    aw.qmc.extradevicecolor2[i] = l2.get_color()
                    aw.setLabelColor(aw.extraLCDlabel2[i],QColor(l2.get_color()))
                    aw.qmc.extraname2[i] = l2.get_label()
                    x2 = x2 + 1
            if self.qmc.eventsGraphflag == 2:
                m = self.qmc.l_eventtype1dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[0] = m
                m = self.qmc.l_eventtype2dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[1] = m
                m = self.qmc.l_eventtype3dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[2] = m
                m = self.qmc.l_eventtype4dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[3] = m
                self.qmc.EvalueMarkerSize[0] = self.qmc.l_eventtype1dots.get_markersize()
                self.qmc.EvalueMarkerSize[1] = self.qmc.l_eventtype2dots.get_markersize()
                self.qmc.EvalueMarkerSize[2] = self.qmc.l_eventtype3dots.get_markersize()
                self.qmc.EvalueMarkerSize[3] = self.qmc.l_eventtype4dots.get_markersize()
                self.qmc.EvalueColor[0] = self.qmc.l_eventtype1dots.get_color()
                self.qmc.EvalueColor[1] = self.qmc.l_eventtype2dots.get_color()
                self.qmc.EvalueColor[2] = self.qmc.l_eventtype3dots.get_color()
                self.qmc.EvalueColor[3] = self.qmc.l_eventtype4dots.get_color()
                self.qmc.Evaluelinethickness[0] = self.qmc.l_eventtype1dots.get_linewidth()
                self.qmc.Evaluelinethickness[1] = self.qmc.l_eventtype2dots.get_linewidth()
                self.qmc.Evaluelinethickness[2] = self.qmc.l_eventtype3dots.get_linewidth()
                self.qmc.Evaluelinethickness[3] = self.qmc.l_eventtype4dots.get_linewidth()
                self.qmc.etypes[0] = self.qmc.l_eventtype1dots.get_label()
                self.qmc.etypes[1] = self.qmc.l_eventtype2dots.get_label()
                self.qmc.etypes[2] = self.qmc.l_eventtype3dots.get_label()
                self.qmc.etypes[3] = self.qmc.l_eventtype4dots.get_label()
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " fetchCurveStyles() %1").arg(str(e)),exc_tb.tb_lineno)

    #Saves the settings when closing application. See the oppposite settingsLoad()
    def closeEvent(self,_):
        self.closeApp()
    
    def closeEventSettings(self,_):
        #save window geometry and position. See QSettings documentation.
        #This information is often stored in the system registry on Windows,
        #and in XML preferences files on Mac OS X. On Unix systems, in the absence of a standard,
        #many applications (including the KDE applications) use INI text files
        try:
            settings = QSettings()
            #save window geometry
            settings.setValue("Geometry",QVariant(self.saveGeometry()))
            #save mode
            previous_mode = str(settings.value("Mode",self.qmc.mode).toString())
            settings.setValue("Mode",self.qmc.mode)
            #save device
            settings.beginGroup("Device")
            settings.setValue("id",self.qmc.device)
            settings.setValue("phidget1048_types",self.qmc.phidget1048_types)
            settings.setValue("phidget1048_async",self.qmc.phidget1048_async)
            settings.setValue("phidget1048_changeTriggers",self.qmc.phidget1048_changeTriggers)
            settings.setValue("phidget1046_async",self.qmc.phidget1046_async)
            settings.setValue("phidget1046_gain",self.qmc.phidget1046_gain)
            settings.setValue("phidget1046_formula",self.qmc.phidget1046_formula)
            settings.setValue("phidget1046_dataRate",self.qmc.phidget1046_dataRate)
            settings.setValue("phidget1045_async",self.qmc.phidget1045_async)
            settings.setValue("phidget1045_changeTrigger",self.qmc.phidget1045_changeTrigger)
            settings.setValue("phidget1045_emissivity",self.qmc.phidget1045_emissivity)
            settings.setValue("phidgetRemoteFlag",self.qmc.phidgetRemoteFlag)
            settings.setValue("phidgetServerID",self.qmc.phidgetServerID)
            settings.setValue("phidgetPassword",self.qmc.phidgetPassword)
            settings.setValue("phidget1018Ratiometric",self.qmc.phidget1018Ratiometric)
            settings.setValue("phidget1018_async",self.qmc.phidget1018_async)
            settings.setValue("phidget1018_raws",self.qmc.phidget1018_raws)
            settings.setValue("phidget1018_dataRates",self.qmc.phidget1018_dataRates)
            settings.setValue("phidget1018_changeTriggers",self.qmc.phidget1018_changeTriggers)
            settings.setValue("controlETpid",self.ser.controlETpid)
            settings.setValue("readBTpid",self.ser.readBTpid)
            settings.setValue("arduinoETChannel",self.ser.arduinoETChannel)
            settings.setValue("arduinoBTChannel",self.ser.arduinoBTChannel)
            settings.setValue("arduinoATChannel",self.ser.arduinoATChannel)
            settings.setValue("ArduinoFILT",self.ser.ArduinoFILT)
            settings.setValue("useModbusPort",self.ser.useModbusPort)
            settings.setValue("PIDbuttonflag",self.qmc.PIDbuttonflag)
            settings.endGroup()
            settings.setValue("PhasesMode",self.qmc.phases_mode)
            settings.setValue("PhasesEspresso",self.qmc.phases_espresso)
            settings.setValue("PhasesFilter",self.qmc.phases_filter)
            #save of phases is done in the phases dialog
            #only if mode was changed (and therefore the phases values have been converted)
            #we update the defaults here
            if previous_mode != self.qmc.mode:
                #save phases
                settings.setValue("Phases",self.qmc.phases)
            #save phasesbuttonflag
            settings.setValue("phasesbuttonflag",self.qmc.phasesbuttonflag)
            #save phases watermarks flag
            settings.setValue("watermarks",self.qmc.watermarksflag)
            #save phases LCDs on recording flag
            settings.setValue("phasesLCDs",self.qmc.phasesLCDflag)
            #phase triggered DRY and FCs
            settings.setValue("autoDry",self.qmc.autoDRYflag)
            settings.setValue("autoFCs",self.qmc.autoFCsFlag)
            #save statistics
            settings.setValue("Statistics",self.qmc.statisticsflags)
            settings.setValue("StatisticsConds",self.qmc.statisticsconditions)
            #save Events settings
            settings.beginGroup("events")
            settings.setValue("eventsbuttonflag",self.eventsbuttonflag)
            settings.setValue("minieventsflag",self.minieventsflag)
            settings.setValue("eventsGraphflag",self.qmc.eventsGraphflag)
            settings.setValue("etypes",self.qmc.etypes)
            settings.setValue("eventsshowflag",self.qmc.eventsshowflag)
            settings.setValue("autoCharge",self.qmc.autoChargeFlag)
            settings.setValue("autoDrop",self.qmc.autoDropFlag)
            settings.setValue("markTP",self.qmc.markTPflag)
            settings.setValue("EvalueColor",self.qmc.EvalueColor)
            settings.setValue("EvalueMarker",self.qmc.EvalueMarker)
            settings.setValue("Evaluelinethickness",self.qmc.Evaluelinethickness)
            settings.setValue("EvalueMarkerSize",self.qmc.EvalueMarkerSize)
            settings.setValue("Evaluealpha",self.qmc.Evaluealpha)
            settings.endGroup()
            #save ambient temperature source
            settings.setValue("AmbientTempSource",aw.qmc.ambientTempSource)
            #save delay (sampling interval)
            settings.setValue("Delay",self.qmc.delay)
            # save oversampling
            settings.setValue("Oversampling",self.qmc.oversampling)
            #save colors
            settings.setValue("Colors",self.qmc.palette)
            settings.setValue("LCDColors",self.lcdpaletteB)
            settings.setValue("LEDColors",self.lcdpaletteF)
            settings.setValue("ETBColor",self.qmc.backgroundmetcolor)
            settings.setValue("BTBColor",self.qmc.backgroundbtcolor)
            settings.setValue("ETBdeltaColor",self.qmc.backgrounddeltaetcolor)
            settings.setValue("BTBdeltaColor",self.qmc.backgrounddeltabtcolor)
            #save flavors
            settings.setValue("Flavors",self.qmc.flavorlabels)
            settings.setValue("flavorstartangle",self.qmc.flavorstartangle)
            #save roast color system
            settings.setValue("colorsystem",self.qmc.color_system_idx)
            #soundflag
            settings.setValue("sound",self.soundflag)
            settings.beginGroup("Tare")
            settings.setValue("names",self.qmc.container_names)
            settings.setValue("weights",self.qmc.container_weights)
            settings.setValue("idx",self.qmc.container_idx)
            settings.endGroup()            
            #save serial port
            settings.beginGroup("SerialPort")
            settings.setValue("comport",self.ser.comport)
            settings.setValue("baudrate",self.ser.baudrate)
            settings.setValue("bytesize",self.ser.bytesize)
            settings.setValue("stopbits",self.ser.stopbits)
            settings.setValue("parity",self.ser.parity)
            settings.setValue("timeout",self.ser.timeout)
            settings.endGroup()
            #save modbus port
            settings.beginGroup("Modbus")
            settings.setValue("comport",self.modbus.comport)
            settings.setValue("baudrate",self.modbus.baudrate)
            settings.setValue("bytesize",self.modbus.bytesize)
            settings.setValue("stopbits",self.modbus.stopbits)
            settings.setValue("parity",self.modbus.parity)
            settings.setValue("timeout",self.modbus.timeout)
            settings.setValue("input1slave",self.modbus.input1slave)
            settings.setValue("input1register",self.modbus.input1register)
            settings.setValue("input1float",self.modbus.input1float)
            settings.setValue("input1code",self.modbus.input1code)
            settings.setValue("input1mode",self.modbus.input1mode)
            settings.setValue("input2slave",self.modbus.input2slave)
            settings.setValue("input2register",self.modbus.input2register)
            settings.setValue("input2float",self.modbus.input2float)
            settings.setValue("input2code",self.modbus.input2code)
            settings.setValue("input2mode",self.modbus.input2mode)
            settings.setValue("input3slave",self.modbus.input3slave)
            settings.setValue("input3register",self.modbus.input3register)
            settings.setValue("input3float",self.modbus.input3float)
            settings.setValue("input3code",self.modbus.input3code)
            settings.setValue("input3mode",self.modbus.input3mode)
            settings.setValue("input4slave",self.modbus.input4slave)
            settings.setValue("input4register",self.modbus.input4register)
            settings.setValue("input4float",self.modbus.input4float)
            settings.setValue("input4code",self.modbus.input4code)
            settings.setValue("input4mode",self.modbus.input4mode)
            settings.setValue("littleEndianFloats",self.modbus.littleEndianFloats)
            settings.setValue("type",self.modbus.type)
            settings.setValue("host",self.modbus.host)
            settings.setValue("port",self.modbus.port)
            settings.endGroup()
            #save scale port
            settings.beginGroup("Scale")
            settings.setValue("device",self.scale.device)
            settings.setValue("comport",self.scale.comport)
            settings.setValue("baudrate",self.scale.baudrate)
            settings.setValue("bytesize",self.scale.bytesize)
            settings.setValue("stopbits",self.scale.stopbits)
            settings.setValue("parity",self.scale.parity)
            settings.setValue("timeout",self.scale.timeout)
            settings.endGroup()
            #save color port
            settings.beginGroup("Color")
            settings.setValue("device",self.color.device)
            settings.setValue("comport",self.color.comport)
            settings.setValue("baudrate",self.color.baudrate)
            settings.setValue("bytesize",self.color.bytesize)
            settings.setValue("stopbits",self.color.stopbits)
            settings.setValue("parity",self.color.parity)
            settings.setValue("timeout",self.color.timeout)
            settings.endGroup()
            #save pid settings (only key and value[0])
            settings.beginGroup("ArduinoPID")
            settings.setValue("pidOnCHARGE",aw.arduino.pidOnCHARGE)
            settings.setValue("loadRampSoakFromProfile",aw.arduino.loadRampSoakFromProfile)
            settings.setValue("svValues",aw.arduino.svValues)
            settings.setValue("svRamps",aw.arduino.svRamps)
            settings.setValue("svSoaks",aw.arduino.svSoaks)
            settings.setValue("svSlider",aw.arduino.svSlider)
            settings.setValue("svButtons",aw.arduino.svButtons)
            settings.setValue("svMode",aw.arduino.svMode)
            settings.setValue("svLookahead",aw.arduino.svLookahead)
            settings.setValue("svSliderMin",aw.arduino.svSliderMin)
            settings.setValue("svSliderMax",aw.arduino.svSliderMax)
            settings.setValue("svValue",aw.arduino.svValue)
            settings.setValue("pidKp",aw.arduino.pidKp)
            settings.setValue("pidKi",aw.arduino.pidKi)
            settings.setValue("pidKd",aw.arduino.pidKd)
            settings.setValue("pidSource",aw.arduino.pidSource)
            settings.setValue("pidCycle",aw.arduino.pidCycle)
            settings.endGroup()
            settings.beginGroup("PXR")
            for key in list(self.fujipid.PXR.keys()):
                settings.setValue(key,self.fujipid.PXR[key][0])
            settings.endGroup()
            settings.beginGroup("PXG4")
            for key in list(self.fujipid.PXG4.keys()):
                settings.setValue(key,self.fujipid.PXG4[key][0])
            settings.endGroup()
            settings.beginGroup("deltaDTA")
            for key in list(self.dtapid.dtamem.keys()):
                settings.setValue(key,self.dtapid.dtamem[key][0])
            settings.endGroup()
            settings.setValue("filterDropOuts",self.qmc.filterDropOuts)
            settings.setValue("dropSpikes",self.qmc.dropSpikes)
            settings.setValue("altSmoothing",self.qmc.altsmoothing)
            settings.setValue("swapETBT",self.qmc.swapETBT)
            settings.setValue("minmaxLimits",self.qmc.minmaxLimits)
            settings.setValue("minLimit",self.qmc.filterDropOut_tmin)
            settings.setValue("maxLimit",self.qmc.filterDropOut_tmax)
            settings.beginGroup("RoC")
            settings.setValue("DeltaET",self.qmc.DeltaETflag)
            settings.setValue("DeltaBT",self.qmc.DeltaBTflag)
            settings.setValue("DeltaETlcd",self.qmc.DeltaETlcdflag)
            settings.setValue("DeltaBTlcd",self.qmc.DeltaBTlcdflag)
            settings.setValue("deltafilter",self.qmc.deltafilter)
            settings.setValue("DeltaSpan",self.qmc.deltaspan)
            settings.setValue("LCDdecimalplaces",self.qmc.LCDdecimalplaces)
            settings.endGroup()
            settings.setValue("curvefilter",self.qmc.curvefilter)
            settings.setValue("smoothingwindowsize",self.qmc.smoothingwindowsize)
            settings.setValue("ETcurve",self.qmc.ETcurve)
            settings.setValue("BTcurve",self.qmc.BTcurve)
            settings.setValue("ETlcd",self.qmc.ETlcd)
            settings.setValue("BTlcd",self.qmc.BTlcd)
            settings.beginGroup("DefaultButtons")
            settings.setValue("buttonvisibility",self.qmc.buttonvisibility)
            settings.setValue("buttonactions",self.qmc.buttonactions)
            settings.setValue("buttonactionstrings",self.qmc.buttonactionstrings)
            settings.setValue("extrabuttonactions",self.qmc.extrabuttonactions)
            settings.setValue("extrabuttonactionstrings",self.qmc.extrabuttonactionstrings)
            settings.endGroup()
            settings.beginGroup("HUD")
            settings.setValue("Projection",self.qmc.projectFlag)
            settings.setValue("ProjectionMode",self.qmc.projectionmode)
            settings.setValue("ETtarget",self.qmc.ETtarget)
            settings.setValue("BTtarget",self.qmc.BTtarget)
            settings.setValue("ET2target",self.qmc.ET2target)
            settings.setValue("BT2target",self.qmc.BT2target)
            settings.setValue("Mode",self.HUDfunction)
            settings.setValue("hudETpid",self.qmc.hudETpid)
            settings.setValue("buttonFlag",self.qmc.HUDbuttonflag)
            settings.endGroup()
            settings.beginGroup("Style")
            settings.setValue("patheffects",self.qmc.patheffects)
            settings.setValue("graphstyle",self.qmc.graphstyle)
            settings.setValue("graphfont",self.qmc.graphfont)
            settings.endGroup()
            settings.beginGroup("Sound")
            settings.setValue("Beep",self.soundflag)
            settings.endGroup()
            settings.beginGroup("Axis")
            settings.setValue("xmin",self.qmc.startofx)
            settings.setValue("xmax",self.qmc.endofx)
            settings.setValue("ymax",self.qmc.ylimit)
            settings.setValue("ymin",self.qmc.ylimit_min)
            settings.setValue("zmax",self.qmc.zlimit)
            settings.setValue("zmin",self.qmc.zlimit_min)
            settings.setValue("resetmaxtime",self.qmc.resetmaxtime)
            settings.setValue("lockmax",self.qmc.fixmaxtime)
            settings.setValue("locktimex",self.qmc.locktimex)
            settings.setValue("locktimex_start",self.qmc.locktimex_start)
            settings.setValue("legendloc",self.qmc.legendloc)
            settings.endGroup()
            settings.beginGroup("RoastProperties")
            settings.setValue("operator",self.qmc.operator)
            settings.setValue("roastertype",self.qmc.roastertype)
            settings.setValue("beansize",self.qmc.beansize)
            settings.setValue("densitySampleVolume",self.qmc.density[2])
            settings.setValue("densitySampleVolumeUnit",self.qmc.density[3])
            settings.endGroup()
            settings.beginGroup("Units")
            settings.setValue("weight",self.qmc.weight[2])
            settings.setValue("volume",self.qmc.volume[2])
            settings.setValue("densityweight",self.qmc.density[1])
            settings.setValue("densityvolume",self.qmc.density[3])
            settings.setValue("volumeCalcUnit",self.qmc.volumeCalcUnit)
            settings.endGroup()
            #save alarms
            settings.beginGroup("Alarms")
            settings.setValue("alarmflag",self.qmc.alarmflag)  
            settings.setValue("alarmguard",self.qmc.alarmguard)
            settings.setValue("alarmnegguard",self.qmc.alarmnegguard)
            settings.setValue("alarmtime",self.qmc.alarmtime)
            settings.setValue("alarmoffset",self.qmc.alarmoffset)
            settings.setValue("alarmcond",self.qmc.alarmcond)
            settings.setValue("alarmsource",self.qmc.alarmsource)
            settings.setValue("alarmtemperature",self.qmc.alarmtemperature)
            settings.setValue("alarmaction",self.qmc.alarmaction)
            settings.setValue("alarmbeep",self.qmc.alarmbeep)
            settings.setValue("alarmstrings",self.qmc.alarmstrings)
            settings.setValue("loadAlarmsFromProfile",self.qmc.loadalarmsfromprofile)
            settings.setValue("alarmsfile",self.qmc.alarmsfile)
            settings.endGroup()
            settings.setValue("profilepath",self.userprofilepath)
            settings.setValue("autosavepath",self.qmc.autosavepath)
            settings.setValue("externalprogram",self.ser.externalprogram)
            #save extra devices
            settings.beginGroup("ExtraDev")
            settings.setValue("extradevices",self.qmc.extradevices)
            settings.setValue("extradevicecolor1",self.qmc.extradevicecolor1)
            settings.setValue("extradevicecolor2",self.qmc.extradevicecolor2)
            settings.setValue("extraname1",self.qmc.extraname1)
            settings.setValue("extraname2",self.qmc.extraname2)
            settings.setValue("extramathexpression1",self.qmc.extramathexpression1)
            settings.setValue("extramathexpression2",self.qmc.extramathexpression2)
            settings.setValue("extraLCDvisibility1",self.extraLCDvisibility1)
            settings.setValue("extraLCDvisibility2",self.extraLCDvisibility2)
            settings.setValue("extraCurveVisibility1",self.extraCurveVisibility1)
            settings.setValue("extraCurveVisibility2",self.extraCurveVisibility2)
            settings.endGroup()
            #save extra serial comm ports settings
            settings.beginGroup("ExtraComm")
            settings.setValue("extracomport",self.extracomport)
            settings.setValue("extrabaudrate",self.extrabaudrate)
            settings.setValue("extrabytesize",self.extrabytesize)
            settings.setValue("extraparity",self.extraparity)
            settings.setValue("extrastopbits",self.extrastopbits)
            settings.setValue("extratimeout",self.extratimeout)
            settings.endGroup()
            settings.setValue("BTfunction",self.qmc.BTfunction)
            settings.setValue("ETfunction",self.qmc.ETfunction)
            settings.setValue("resetqsettings",self.resetqsettings)
            settings.setValue("plotcurves",self.qmc.plotcurves)
            settings.setValue("plotcurvecolor",self.qmc.plotcurvecolor)
            #curve styles 
            settings.beginGroup("CurveStyles")
            settings.setValue("BTlinestyle",self.qmc.BTlinestyle)
            settings.setValue("BTdrawstyle",self.qmc.BTdrawstyle)
            settings.setValue("BTlinewidth",self.qmc.BTlinewidth)
            settings.setValue("BTmarker",self.qmc.BTmarker)
            settings.setValue("BTmarkersize",self.qmc.BTmarkersize)
            settings.setValue("ETlinestyle",self.qmc.ETlinestyle)
            settings.setValue("ETdrawstyle",self.qmc.ETdrawstyle)
            settings.setValue("ETlinewidth",self.qmc.ETlinewidth)
            settings.setValue("ETmarker",self.qmc.ETmarker)
            settings.setValue("ETmarkersize",self.qmc.ETmarkersize)
            settings.setValue("BTdeltalinestyle",self.qmc.BTdeltalinestyle)
            settings.setValue("BTdeltadrawstyle",self.qmc.BTdeltadrawstyle)
            settings.setValue("BTdeltalinewidth",self.qmc.BTdeltalinewidth)
            settings.setValue("BTdeltamarker",self.qmc.BTdeltamarker)
            settings.setValue("BTdeltamarkersize",self.qmc.BTdeltamarkersize)
            settings.setValue("ETdeltalinestyle",self.qmc.ETdeltalinestyle)
            settings.setValue("ETdeltadrawstyle",self.qmc.ETdeltadrawstyle)
            settings.setValue("ETdeltalinewidth",self.qmc.ETdeltalinewidth)
            settings.setValue("ETdeltamarker",self.qmc.ETdeltamarker)
            settings.setValue("ETdeltamarkersize",self.qmc.ETdeltamarkersize)
            settings.setValue("BTbacklinestyle",self.qmc.BTbacklinestyle)
            settings.setValue("BTbackdrawstyle",self.qmc.BTbackdrawstyle)
            settings.setValue("BTbacklinewidth",self.qmc.BTbacklinewidth)
            settings.setValue("BTbackmarker",self.qmc.BTbackmarker)
            settings.setValue("BTbackmarkersize",self.qmc.BTbackmarkersize)
            settings.setValue("ETbacklinestyle",self.qmc.ETbacklinestyle)
            settings.setValue("ETbackdrawstyle",self.qmc.ETbackdrawstyle)
            settings.setValue("ETbacklinewidth",self.qmc.ETbacklinewidth)
            settings.setValue("ETbackmarker",self.qmc.ETbackmarker)
            settings.setValue("ETbackmarkersize",self.qmc.ETbackmarkersize)
            settings.setValue("BTBdeltalinestyle",self.qmc.BTBdeltalinestyle)
            settings.setValue("BTBdeltadrawstyle",self.qmc.BTBdeltadrawstyle)
            settings.setValue("BTBdeltalinewidth",self.qmc.BTBdeltalinewidth)
            settings.setValue("BTBdeltamarker",self.qmc.BTBdeltamarker)
            settings.setValue("BTBdeltamarkersize",self.qmc.BTBdeltamarkersize)
            settings.setValue("ETBdeltalinestyle",self.qmc.ETBdeltalinestyle)
            settings.setValue("ETBdeltadrawstyle",self.qmc.ETBdeltadrawstyle)
            settings.setValue("ETBdeltalinewidth",self.qmc.ETBdeltalinewidth)
            settings.setValue("ETBdeltamarker",self.qmc.ETBdeltamarker)
            settings.setValue("ETBdeltamarkersize",self.qmc.ETBdeltamarkersize)
            settings.setValue("extralinestyles1",self.qmc.extralinestyles1)
            settings.setValue("extralinestyles2",self.qmc.extralinestyles2)
            settings.setValue("extradrawstyles1",self.qmc.extradrawstyles1)
            settings.setValue("extradrawstyles2",self.qmc.extradrawstyles2)
            settings.setValue("extralinewidths1",self.qmc.extralinewidths1)
            settings.setValue("extralinewidths2",self.qmc.extralinewidths2)
            settings.setValue("extramarkers1",self.qmc.extramarkers1)
            settings.setValue("extramarkers2",self.qmc.extramarkers2)
            settings.setValue("extramarkersizes1",self.qmc.extramarkersizes1)
            settings.setValue("extramarkersizes2",self.qmc.extramarkersizes2)
            settings.endGroup()
            #background settings
            settings.beginGroup("background")
            settings.setValue("backgrounddetails",aw.qmc.backgroundDetails)
            settings.setValue("backgroundevents",aw.qmc.backgroundeventsflag)
            settings.setValue("DeltaETB",aw.qmc.DeltaETBflag)
            settings.setValue("DeltaBTB",aw.qmc.DeltaBTBflag)
            settings.setValue("alignFCs",aw.qmc.flagalignFCs)
            settings.endGroup()
            settings.setValue("autosaveflag",self.qmc.autosaveflag)
            settings.setValue("autosaveprefix",self.qmc.autosaveprefix)
            settings.beginGroup("WebLCDs")
            settings.setValue("active",self.WebLCDs)
            settings.setValue("port",self.WebLCDsPort)
            settings.setValue("alerts",self.WebLCDsAlerts)
            settings.endGroup()
            settings.setValue("LargeLCDs",self.LargeLCDs)
            #custom event buttons
            settings.beginGroup("ExtraEventButtons")
            settings.setValue("buttonlistmaxlen",self.buttonlistmaxlen)
            settings.setValue("extraeventstypes",self.extraeventstypes)
            settings.setValue("extraeventsvalues",self.extraeventsvalues)
            settings.setValue("extraeventsactionstrings",self.extraeventsactionstrings)
            settings.setValue("extraeventsactions",self.extraeventsactions)
            settings.setValue("extraeventsdescriptions",self.extraeventsdescriptions)
            settings.setValue("extraeventsvisibility",self.extraeventsvisibility)
            settings.setValue("extraeventslabels",self.extraeventslabels)
            settings.setValue("extraeventbuttoncolor",self.extraeventbuttoncolor)
            settings.setValue("extraeventbuttontextcolor",self.extraeventbuttontextcolor)
            settings.setValue("extraeventsbuttonsflag",self.extraeventsbuttonsflag)
            settings.setValue("buttonpalette",self.buttonpalette)
            settings.setValue("buttonpalettemaxlen",self.buttonpalettemaxlen)
            settings.endGroup()
            settings.beginGroup("grid")
            settings.setValue("xgrid",self.qmc.xgrid)
            settings.setValue("ygrid",self.qmc.ygrid)
            settings.setValue("zgrid",self.qmc.zgrid)
            settings.setValue("gridlinestyle",self.qmc.gridlinestyle)
            settings.setValue("gridthickness",self.qmc.gridthickness)
            settings.setValue("gridalpha",self.qmc.gridalpha)
            settings.setValue("xrotation",self.qmc.xrotation)
            settings.endGroup()
            settings.beginGroup("Sliders")
            settings.setValue("slidervisibilities",self.eventslidervisibilities)
            settings.setValue("slideractions",self.eventslideractions)
            settings.setValue("slidercommands",self.eventslidercommands)
            settings.setValue("slideroffsets",self.eventslideroffsets)
            settings.setValue("sliderfactors",self.eventsliderfactors)
            settings.endGroup()
            settings.beginGroup("Quantifiers")
            settings.setValue("quantifieractive",self.eventquantifieractive)
            settings.setValue("quantifiersource",self.eventquantifiersource)
            settings.setValue("quantifiermin",self.eventquantifiermin)
            settings.setValue("quantifiermax",self.eventquantifiermax)
            settings.setValue("quantifiercoarse",self.eventquantifiercoarse)
            settings.endGroup()
            settings.setValue("roastpropertiesflag",self.qmc.roastpropertiesflag)
            settings.setValue("customflavorlabels",self.qmc.customflavorlabels)
            try:
                settings.setValue("appearance",str(aw.style().objectName()).lower())
            except:
                pass
            settings.setValue("dpi",aw.dpi)

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info() 
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None, QApplication.UnicodeUTF8),QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " closeEvent()  @line " + str(exc_tb.tb_lineno))

    #used for trouble shooting.
    def readartisansettings(self):
        general,device,phases,statistics,events,delay,colors,cupping,extras,serial,axes,roast,alarms = {},{},{},{},{},{},{},{},{},{},{},{},{}
        #read window geometry
        rect = self.geometry()
        height = str(rect.height())
        width = str(rect.width())
        general["geometry"] = height + "x" + width                #custom made string
        general["mode"] = str(self.qmc.mode)
        device["id"] = str(self.qmc.device)
        device["controlETpid"] = str(self.ser.controlETpid)
        device["readBTpid"] = str(self.ser.readBTpid)
        device["arduinoETChannel"] = str(self.ser.arduinoETChannel)
        device["arduinoBTChannel"] = str(self.ser.arduinoBTChannel)
        device["arduinoATChannel"] = str(self.ser.arduinoATChannel)
        phases["Phases"] = str(self.qmc.phases)
        phases["PhasesEspress"] = str(self.qmc.phases_espresso)
        phases["PhasesFilter"] = str(self.qmc.phases_filter)
        phases["phasesbuttonflag"] = str(self.qmc.phasesbuttonflag)
        phases["watermarks"] = str(self.qmc.watermarksflag)
        phases["phasesLCDs"] = str(self.qmc.phasesLCDflag)
        phases["autoDry"] = str(self.qmc.autoDRYflag)
        phases["autoFCs"] = str(self.qmc.autoFCsFlag)
        statistics["Statistics"] = str(self.qmc.statisticsflags)
        statistics["StatisticsConds"] = str(self.qmc.statisticsconditions)
        events["eventsbuttonflag"] = str(self.eventsbuttonflag)
        events["minieventsflag"] = str(self.minieventsflag)
        events["eventsGraphflag"] = str(self.qmc.eventsGraphflag)
        events["etypes"] = u(list(map(u,self.qmc.etypes)))
        events["eventsshowflag"] = str(self.qmc.eventsshowflag)
        events["autoCharge"] = str(self.qmc.autoChargeFlag)
        events["autoDrop"] = str(self.qmc.autoDropFlag)
        events["markTP"] = str(self.qmc.markTPflag)
        events["EvalueColor"] = str(self.qmc.EvalueColor)
        events["EvalueMarker"] = str(self.qmc.EvalueMarker)
        events["Evaluelinethickness"] = str(self.qmc.Evaluelinethickness)
        events["Evaluealpha"] = str(self.qmc.Evaluealpha)
        delay["Delay"] = str(self.qmc.delay)
        colors["Colors"] = str(self.qmc.palette)
        colors["LCDColors"] = str(self.lcdpaletteB)
        colors["LEDColors"] = str(self.lcdpaletteF)
        cupping["Flavors"] = u(list(map(u,self.qmc.flavorlabels)))
        cupping["flavorstartangle"] = str(self.qmc.flavorstartangle)
        serial["comport"] = str(self.ser.comport)
        serial["baudrate"] = str(self.ser.baudrate)
        serial["bytesize"]= str(self.ser.bytesize)
        serial["stopbits"]= str(self.ser.stopbits)
        serial["parity"]= str(self.ser.parity)
        serial["timeout"]= str(self.ser.timeout)
        for key in list(self.fujipid.PXR.keys()):
            device["PXR:" + key] = str(self.fujipid.PXR[key][0])   # key modified
        for key in list(self.fujipid.PXG4.keys()):            
            device["PXG:" + key] = str(self.fujipid.PXG4[key][0])  # key modified
        for key in list(self.dtapid.dtamem.keys()):            
            device["DTA:" + key] = str(self.dtapid.dtamem[key][0]) # key modified
        general["sound"]= str(self.soundflag)
        extras["DeltaET"]= str(self.qmc.DeltaETflag)
        extras["DeltaBT"]= str(self.qmc.DeltaBTflag)
        extras["DeltaETlcd"]= str(self.qmc.DeltaETlcdflag)
        extras["DeltaBTlcd"]= str(self.qmc.DeltaBTlcdflag)
        extras["deltafilter"]= str(self.qmc.deltafilter)
        extras["curvefilter"]= str(self.qmc.curvefilter)
        extras["smoothingwindowsize"]= str(self.qmc.smoothingwindowsize)
        extras["Projection"]= str(self.qmc.projectFlag)
        extras["ProjectionMode"]= str(self.qmc.projectionmode)
        extras["ETtarget"]= str(self.qmc.ETtarget)
        extras["BTtarget"]= str(self.qmc.BTtarget)
        extras["ET2target"]= str(self.qmc.ET2target)
        extras["BT2target"]= str(self.qmc.BT2target)
        extras["HUDMode"]= str(self.HUDfunction)                      # key modified
        extras["hudETpid"]= str(self.qmc.hudETpid)
        extras["Beep"]= str(self.soundflag)
        axes["xmin"]= str(self.qmc.startofx)
        axes["xmax"]= str(self.qmc.endofx)
        axes["ymax"]= str(self.qmc.ylimit)
        axes["ymin"]= str(self.qmc.ylimit_min)
        axes["zmax"]= str(self.qmc.zlimit)
        axes["zmin"]= str(self.qmc.zlimit_min)
        axes["resetmaxtime"] = str(self.qmc.stringfromseconds(self.qmc.resetmaxtime))
        axes["legendloc"] = str(self.qmc.legendloc)
        roast["operator"]= u(self.qmc.operator)
        roast["roastertype"] = u(self.qmc.roastertype)
        roast["densitySampleVolume"] = str(self.qmc.density[2])
        roast["densitySampleVolumeUnit"]= u(self.qmc.density[3])
        roast["beansize"]= str(self.qmc.beansize)
        alarms["alarmflag"]= str(self.qmc.alarmflag) 
        alarms["alarmguard"]= str(self.qmc.alarmguard)
        alarms["alarmnegguard"]= str(self.qmc.alarmnegguard)
        alarms["alarmtime"]= str(self.qmc.alarmtime)
        alarms["alarmoffset"]= str(self.qmc.alarmoffset)
        alarms["alarmcond"]= str(self.qmc.alarmcond)
        alarms["alarmsource"]= u(self.qmc.alarmsource)
        alarms["alarmaction"]= u(self.qmc.alarmaction)
        alarms["alarmbeep"]= str(self.qmc.alarmbeep)
        alarms["alarmstrings"]= list(map(u,list(self.qmc.alarmstrings)))
        general["profilepath"]= u(self.userprofilepath)
        #save extra devices
        device["extradevices"]= str(self.qmc.extradevices)
        device["extradevicecolor1"]= str(self.qmc.extradevicecolor1)
        device["extradevicecolor2"]= str(self.qmc.extradevicecolor2)
        device["extraname1"]= u(self.qmc.extraname1)
        device["extraname2"]= u(self.qmc.extraname2)
        device["extramathexpression1"]= str(self.qmc.extramathexpression1)
        device["extramathexpression2"]= str(self.qmc.extramathexpression2)
        #save extra serial comm ports settings
        serial["extracomport"]= str(self.extracomport)
        serial["extrabaudrate"]= str(self.extrabaudrate)
        serial["extrabytesize"]= str(self.extrabytesize)
        serial["extraparity"]= str(self.extraparity)
        serial["extrastopbits"]= str(self.extrastopbits)
        serial["extratimeout"]= str(self.extratimeout)
        device["BTfunction"]= str(self.qmc.BTfunction)
        device["ETfunction"]= str(self.qmc.ETfunction)
        serial["extraserlength"]= str(len(self.extraser))
        general["resetqsettings"]= str(self.resetqsettings)
        extras["plotcurves"]= str(self.qmc.plotcurves)
        extras["plotcurvecolor"]= str(self.qmc.plotcurvecolor)
        #custom event buttons
        events["buttonlistmaxlen"]= str(self.buttonlistmaxlen)
        events["extraeventstypes"]= u(self.extraeventstypes)
        events["extraeventsvalues"]= str(self.extraeventsvalues)
        events["extraeventsactionstrings"]= str(self.extraeventsactionstrings)
        events["extraeventsactions"]= str(self.extraeventsactions)
        events["extraeventsdescriptions"]= u(self.extraeventsdescriptions)
        events["extraeventsvisibility"]= str(self.extraeventsvisibility)
        events["extraeventslabels"]= u(self.extraeventslabels)
        events["extraeventbuttoncolor"]= str(self.extraeventbuttoncolor)
        events["extraeventbuttontextcolor"]= str(self.extraeventbuttontextcolor)
        events["extraeventsbuttonsflag"]= str(self.extraeventsbuttonsflag)
        events["buttonpalettemaxlen"]= str(self.buttonpalettemaxlen)
        events["buttonpalette"]= str(self.buttonpalette)
        axes["xgrid"]= str(self.qmc.xgrid)
        axes["ygrid"]= str(self.qmc.ygrid)
        axes["zgrid"]= str(self.qmc.zgrid)
        axes["gridlinestyle"]= str(self.qmc.gridlinestyle)
        axes["gridthickness"]= str(self.qmc.gridthickness)
        axes["gridalpha"]= str(self.qmc.gridalpha)
        axes["xrotation"]= str(self.qmc.xrotation)
        general["extraLCDvisibility1"] = str(self.extraLCDvisibility1)
        general["extraLCDvisibility2"] = str(self.extraLCDvisibility2)
        general["extraCurveVisibility1"] = str(self.extraCurveVisibility1)
        general["extraCurveVisibility2"] = str(self.extraCurveVisibility2)
        settingsx = [general,device,phases,statistics,events,delay,colors,cupping,extras,serial,axes,roast,alarms]
        #keep same order
        settingsnames = ["general","device config","phases config","statistics config","events config","sampling interval","colors config",
                         "cupping config","extras config","serial config","axes config","roast properties","alarms config"]
        return settingsx,settingsnames

    def updateExtraLCDvisibility(self):
        n = len(self.qmc.extradevices)
        for i in range(n):
            if i < aw.nLCDS:
                if self.extraLCDvisibility1[i]:
                    if i < len(self.qmc.extraname1):
                        self.extraLCDlabel1[i].setText("<big><b>" + self.qmc.extraname1[i] + "</b></big>")
                    self.extraLCDframe1[i].setVisible(True)
                    self.extraLCD1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
                else:
                    self.extraLCDframe1[i].setVisible(False)
                if self.extraLCDvisibility2[i]:
                    if i < len(self.qmc.extraname2):
                        self.extraLCDlabel2[i].setText("<big><b>" + self.qmc.extraname2[i] + "</b></big>")
                    self.extraLCDframe2[i].setVisible(True)
                    self.extraLCD2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
                else:
                    self.extraLCDframe2[i].setVisible(False)
        #hide the rest (just in case)
        for i in range(n,aw.nLCDS):
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)

    def closeApp(self):
        if aw.qmc.checkSaved(): # if not canceled
            if self.full_screen_mode_active:
                self.showNormal()
            if aw.qmc.flagon:
                aw.qmc.ToggleMonitor()
            if aw.WebLCDs:
                aw.stopWebLCDs()
                aw.WebLCDs = True # to ensure they are started again on restart
            if aw.LargeLCDs and aw.largeLCDs_dialog:
                tmp_LargeLCDs = aw.LargeLCDs # we keep the state to properly store it in the settings
                aw.largeLCDs_dialog.close()
                aw.LargeLCDs = tmp_LargeLCDs
            self.closeEventSettings(self)
            # now wait until the current sampling thread is terminated
            while aw.qmc.flagsamplingthreadrunning:
                libtime.sleep(.01)
            try:
                self.closeserialports()
            except Exception:
                pass
            QApplication.exit()

    def closeserialports(self):
        # close main instrument port
        aw.ser.closeport()
        # close extra device ports
        for i in range(len(aw.extraser)):
            try:
                if aw.extraser[i].SP.isOpen():
                    aw.extraser[i].SP.close()
            except:
                pass
        # close modbus port
        aw.modbus.disconnect()
        # close scale port
        try:
            if aw.scale:
                aw.scale.closeport()
        except:
            pass
        # close color meter port
        try:
            if aw.color:
                aw.color.closeport()
        except:
            pass

    def fileQuit(self):
        self.closeApp()

    def filePrint(self):
        image = QPixmap.grabWidget(aw.qmc).toImage()
#        image = aw.qmc().grab().toImage()
        
        if image.isNull():
            return
        if self.printer is None:
            self.printer = QPrinter(QPrinter.HighResolution)
            self.printer.setPageSize(QPrinter.Letter)
        form = QPrintDialog(self.printer, self)
        if form.exec_():
            painter = QPainter(self.printer)
            rect = painter.viewport()
            size = image.size()
            size.scale(rect.size(), Qt.KeepAspectRatio)
            painter.setViewport(rect.x(), rect.y(), size.width(),size.height())
            painter.setWindow(image.rect()) #scale to fit page
            if isinstance(image, QPixmap):
                painter.drawPixmap(0,0,image)
            else:
                painter.drawImage(0, 0, image)

    def htmlReport(self):
        try:
            rcParams['path.effects'] = []
            HTML_REPORT_TEMPLATE = u("""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>""") + u(QApplication.translate("HTML Report Template", "Roasting Report", None, QApplication.UnicodeUTF8)) + u("""</title>
<style type="text/css">
td { 
  vertical-align: top;
  padding: 0px 0px 0px 5px;
}
th {
  text-align: right;
  vertical-align: top;
}
</style>
</head>
<body>
<center>
<h1>$title</h1>

<table border="1" cellpadding="10" width="80%">
<tr>
<td>
<center>
<table>
<tr>
<td>
<table width="230">
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Date:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$datetime</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Beans:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$beans</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Size:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$size</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Weight:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$weight</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Degree:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$degree</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Volume:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$volume</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Density:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$density</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Moisture:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$moisture</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Ambient:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$humidity</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Roaster:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$roaster</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Operator:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$operator</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Cupping:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$cup</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Color:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$color</td>
</tr>
</table>
</td>
<td>
<table width="230">
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "CHARGE:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$charge</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "TP:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$TP</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "DRY:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$DRY</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "FCs:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$FCs</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "FCe:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$FCe</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "SCs:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$SCs</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "SCe:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$SCe</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "DROP:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$drop</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "COOL:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$cool</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "MET:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$met</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "RoR:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$ror</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "ETBTa:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$etbta</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "CM:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$cm</td>
</tr>
</table>
</td>
<td>
<table width="250">
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Drying:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$dry_phase</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Maillard:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$mid_phase</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Development:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$finish_phase</td>
</tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Cooling:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$cool_phase</td>
</tr>
<tr><th></th><td></td></tr>
<tr><th></th><td></td></tr>
<tr>
<th>""") + u(QApplication.translate("HTML Report Template", "Background:", None, QApplication.UnicodeUTF8)) + u("""</th>
<td>$background</td>
</tr>
</table>
</td>
</tr>
</table>
</center>
</td>
</tr>
<tr>
<td style="vertical-align:middle" align="center"><img alt='roast graph' width="650" src='file:///$graph_image'></td>
</tr>
<tr>
<td><center><b>""" + unicode(QApplication.translate("HTML Report Template", "Events", None, QApplication.UnicodeUTF8)) + """</b></center><br>
$specialevents
</td>
</tr>
<tr>
<td>
<center><b>""") + u(QApplication.translate("HTML Report Template", "Roasting Notes", None, QApplication.UnicodeUTF8)) + u("""</b></center>
$roasting_notes$roast_attributes
</td>
</tr>
</table>
<table border="1" cellpadding="10" style="page-break-inside:avoid"  width="80%">
<tr>
<td style="vertical-align:middle" align="center"><img alt='flavor graph' width="550" src='file:///$flavor_image'></td>
</tr>
<tr>
<td><center><b>""") + u(QApplication.translate("HTML Report Template", "Cupping Notes", None, QApplication.UnicodeUTF8)) + u("""</b></center>
$cupping_notes
</td>
</tr>
</table>
</center>
</body>
</html>
        """)
            beans = u(cgi.escape(self.qmc.beans))
            if len(beans) > 43:
                beans = u(beans[:41] + "&hellip;")
                
            cp = aw.computedProfileInformation()
            
            if "CHARGE_ET" in cp and "CHARGE_BT" in cp:
                if self.qmc.mode == "F":
                    charge = u("BT %.0fF <br>ET %.0fF"%(cp["CHARGE_BT"],cp["CHARGE_ET"]))
                else:
                    charge = u("BT %.0f&deg;C <br>ET %.0f&deg;C"%(cp["CHARGE_BT"],cp["CHARGE_ET"]))
            else:
                charge = u("--")
            dryphase, midphase, finishphase, coolphase = self.phases2html(cp)
            etbta = u("--")
            if "total_ts" in cp and cp["total_ts"] != 0:
                etbta = u("%d"%(cp["total_ts"]))
                if "total_ts_ET" in cp and "total_ts_BT" in cp:
                    etbta += u(" [%d-%d]"%(cp["total_ts_ET"],cp["total_ts_BT"]))
            tmpdir = u(QDir.tempPath() + "/")
            graph_image = "roastlog-graph"
            if platf == 'Darwin':
                graph_image = u(QDir(tmpdir).filePath(graph_image + ".svg"))
                try:
                    os.remove(graph_image)
                except OSError:
                    pass
                self.qmc.fig.savefig(graph_image)
            else:
                image = QPixmap.grabWidget(aw.qmc).toImage()
    #            #resize GRAPH image to 650 pixels width
    #            image = image.scaledToWidth(650,1)
                #save GRAPH image
                graph_image = u(QDir(tmpdir).filePath(graph_image + ".png"))
                try:
                    os.remove(graph_image)
                except OSError:
                    pass
                image.save(graph_image)
            #add some random number to force HTML reloading
            graph_image = graph_image + "?dummy=" + str(int(libtime.time()))
            #obtain flavor chart image
            self.qmc.flavorchart()
            flavor_image = "roastlog-flavor"
            if platf == 'Darwin':
                flavor_image = u(QDir(tmpdir).filePath(flavor_image + ".svg"))
                try:
                    os.remove(flavor_image)
                except OSError:
                    pass
                self.qmc.fig.savefig(flavor_image)
            else:
                image = QPixmap.grabWidget(aw.qmc).toImage()
                #resize FLAVOR image to 550 pixels width
    #            image = image.scaledToWidth(550,1)
                #save GRAPH image
                flavor_image = u(QDir(tmpdir).filePath(flavor_image + ".png"))
                try:
                    os.remove(flavor_image)
                except OSError:
                    pass
                image.save(flavor_image)
            flavor_image = flavor_image + "?dummy=" + str(int(libtime.time()))
            #return screen to GRAPH profile mode
            self.qmc.redraw(recomputeAllDeltas=False)
            met = u("--")
            if "MET" in cp:
                met = "%.0f"%cp["MET"] + "&deg;" + self.qmc.mode
            ror = u("--")
            if "total_ror" in cp:
                ror = u("%d%s%s%s"%(cp["total_ror"],uchr(176),aw.qmc.mode,QApplication.translate("Label", "/m",None, QApplication.UnicodeUTF8)))
            if "set_density" in cp:
                density = u("%.1fg/l (set)"%cp["set_density"])
            else:
                density = u("--")
            if  self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
                weight = u(self.volume_weight2html(self.qmc.weight[0],self.qmc.weight[1],self.qmc.weight[2],cp["weight_loss"]))
            else:
                weight = u("--")
            if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0:
                volume = u(self.volume_weight2html(self.qmc.volume[0],self.qmc.volume[1],self.qmc.volume[2],cp["volume_gain"]))
            else:
                volume = u("--")
            if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0 and self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
                degree = u(self.roast_degree(cp["weight_loss"]))
                if "set_density" in cp:
                    if "green_density" in cp and "roasted_density" in cp:
                        density = u("%.1fg/l (set)<br>%.1fg/l (green)<br>%.1fg/l (roasted)"%(cp["set_density"],cp["green_density"],cp["roasted_density"]))
                elif "green_density" in cp and "roasted_density" in cp:
                    density = u("%.1fg/l (green)<br>%.1fg/l (roasted)"%(cp["green_density"],cp["roasted_density"]))
            else:
                degree = u("--")

            moisture = u("")
            if "moisture_greens" in cp:
                moisture = u("%d%%"%cp["moisture_greens"])
                moisture += " (" + u(QApplication.translate("Label","greens")) + ")"
                if "moisture_roasted" in cp:
                    moisture += u("<br>")
            if "moisture_roasted" in cp:
                moisture += u("%d%%"%cp["moisture_roasted"])
                moisture += " (" + u(QApplication.translate("Label","roasted")) + ")"
                
            humidity = u("")
            if "ambient_humidity" in cp:
                humidity += u("%d%%"%cp["ambient_humidity"])
                if "ambient_temperature" in cp:
                    humidity += u(" at %d%s"%(cp["ambient_temperature"],self.qmc.mode))
            else:
                if "ambient_temperature" in cp:
                    humidity += u("%d%s"%(cp["ambient_temperature"],self.qmc.mode))
            if len(humidity) == 0:
                humidity = u("--")
            if self.qmc.whole_color or self.qmc.ground_color:
                color = u(str(self.qmc.whole_color) + "/" + str(self.qmc.ground_color))
                if self.qmc.color_system_idx:
                    color = color + u(" (" + self.qmc.color_systems[self.qmc.color_system_idx] + ")")
            else:
                color = u("--")
            if "det" in cp:
                cm = u("%.1f/%.1f" % (cp["det"],cp["dbt"])) + uchr(176) + aw.qmc.mode
            else:
                cm = u("--")
            if aw.qmc.titleB == None or aw.qmc.titleB == "":
                background = u("--")
            else:
                background = u(aw.qmc.titleB)
            html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                title=u(cgi.escape(self.qmc.title)),
                datetime=u(self.qmc.roastdate.toString()), #alt: unicode(self.qmc.roastdate.toString('MM.dd.yyyy')),
                beans=beans,
                weight=weight,
                degree=degree,
                volume=volume,
                roaster=u(cgi.escape(self.qmc.roastertype)),
                operator=u(cgi.escape(self.qmc.operator)),
                cup=u(str(aw.float2float(self.cuppingSum()))),
                color=color,
                charge=charge,
                size=u("--" if aw.qmc.beansize == 0.0 else str(aw.qmc.beansize) + "mm"),
                density=density,
                moisture=moisture,
                humidity=humidity,
                TP=self.event2html(cp,"TP_time","TP_BT"),
                DRY=self.event2html(cp,"DRY_time","DRY_BT"),
                FCs=self.event2html(cp,"FCs_time","FCs_BT"),
                FCe=self.event2html(cp,"FCe_time","FCe_BT"),
                SCs=self.event2html(cp,"SCs_time","SCs_BT"),
                SCe=self.event2html(cp,"SCe_time","SCe_BT"),
                drop=self.event2html(cp,"DROP_time","DROP_BT"),
                cool=self.event2html(cp,"COOL_time",None,"DROP_time"),
                met=met,
                cm=cm,
                dry_phase=dryphase,
                mid_phase=midphase,
                finish_phase=finishphase,
                cool_phase=coolphase,
                background=background,
                ror= ror,
                etbta=etbta,
                roasting_notes=self.note2html(self.qmc.roastingnotes),
                roast_attributes=self.roastattributes(),
                graph_image=graph_image,
                flavor_image=flavor_image,
                specialevents=self.specialevents2html(),
                cupping_notes=self.note2html(self.qmc.cuppingnotes))
            f = None
            try:
                filename = u(QDir(tmpdir).filePath("Roastlog.html"))
                try:
                    os.remove(filename)
                except OSError:
                    pass
                f = codecs.open(filename, 'w', encoding='utf-8')
                for i in range(len(html)):
                    f.write(html[i])
                f.close()
                full_path = "file:///" + filename
                QDesktopServices.openUrl(QUrl(full_path, QUrl.TolerantMode)) 
                
            except IOError as e:
                aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " htmlReport() %1").arg(str(e)))
            finally:
                if f:
                    f.close()
        except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " htmlReport() %1").arg(str(e)),exc_tb.tb_lineno)

    # returns a string with all the activated roast attributes
    def roastattributes(self):
        res = []
        if aw.qmc.heavyFC_flag:
            res.append(u(QApplication.translate("CheckBox","Heavy FC", None, QApplication.UnicodeUTF8)))
        if aw.qmc.lowFC_flag:
            res.append(u(QApplication.translate("CheckBox","Low FC", None, QApplication.UnicodeUTF8)))
        if aw.qmc.lightCut_flag:
            res.append(u(QApplication.translate("CheckBox","Light Cut", None, QApplication.UnicodeUTF8)))
        if aw.qmc.darkCut_flag:
            res.append(u(QApplication.translate("CheckBox","Dark Cut", None, QApplication.UnicodeUTF8)))
        if aw.qmc.drops_flag:
            res.append(u(QApplication.translate("CheckBox","Drops", None, QApplication.UnicodeUTF8)))
        if aw.qmc.oily_flag:
            res.append(u(QApplication.translate("CheckBox","Oily", None, QApplication.UnicodeUTF8)))
        if aw.qmc.uneven_flag:
            res.append(u(QApplication.translate("CheckBox","Uneven", None, QApplication.UnicodeUTF8)))
        if aw.qmc.tipping_flag:
            res.append(u(QApplication.translate("CheckBox","Tipping", None, QApplication.UnicodeUTF8)))
        if aw.qmc.scorching_flag:
            res.append(u(QApplication.translate("CheckBox","Scorching", None, QApplication.UnicodeUTF8)))
        if aw.qmc.divots_flag:
            res.append(u(QApplication.translate("CheckBox","Divots", None, QApplication.UnicodeUTF8)))
        if len(res) > 0:
            return u("\n<center><pre>" + ', '.join(res) + "</pre></center>")
        else:
            return u("")

    def cuppingSum(self):
        score = 0.
        nflavors = len(self.qmc.flavors)
        for i in range(nflavors):   
            score += self.qmc.flavors[i]
        score /= (nflavors)
        score *= 10.
        return score

    def volume_weight2html(self,amount,out,unit,change):
        if amount:
            return str(amount) + unit + "<br>" + str(out) + unit + " (" + "%.1f"%change + "%)"
        else:
            return "--"

    def phases2html(self,cp):
        dryphase = midphase = finishphase = coolphase = "--"
        if "totaltime" in cp:
            totaltime = cp["totaltime"]
            #dryphase
            if "dryphasetime" in cp:
                dryphasetime = cp["dryphasetime"]
                dryphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["dryphasetime"]),int(round(dryphasetime*100./totaltime)))
                if "dry_phase_ror" in cp:
                    dryphase += "<br>%.1f%s%s/min"%(cp["dry_phase_ror"],uchr(176),aw.qmc.mode)
                if "dry_phase_ts" in cp:
                    dryphase += "<br>%d"%(cp["dry_phase_ts"])
                    if "dry_phase_ts_ET" in cp and "dry_phase_ts_BT" in cp:
                        dryphase += " [%d-%d]"%(cp["dry_phase_ts_ET"],cp["dry_phase_ts_BT"])
                    if "dryphaseeval" in cp:
                        dryphase += "<br>" + cp["dryphaseeval"]
            #midphase
            if "midphasetime" in cp:
                midphasetime = cp["midphasetime"]
                midphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["midphasetime"]),int(round(midphasetime*100./totaltime)))
                if "mid_phase_ror" in cp:
                    midphase += "<br>%.1f%s%s/min"%(cp["mid_phase_ror"],uchr(176),aw.qmc.mode)
                if "mid_phase_ts" in cp:
                    midphase += "<br>%d"%(cp["mid_phase_ts"])
                    if "mid_phase_ts_ET" in cp and "mid_phase_ts_BT" in cp:
                        midphase += " [%d-%d]"%(cp["mid_phase_ts_ET"],cp["mid_phase_ts_BT"])
                if "midphaseeval" in cp:
                    midphase += "<br>" + cp["midphaseeval"]
            #finishphase
            if "finishphasetime" in cp:
                finishphasetime = cp["finishphasetime"]
                finishphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["finishphasetime"]),int(round(finishphasetime*100./totaltime)))
                if "finish_phase_ror" in cp:
                    finishphase += "<br>%.1f%s%s/min"%(cp["finish_phase_ror"],uchr(176),aw.qmc.mode)
                if "finish_phase_ts" in cp:
                    finishphase += "<br>%d"%(cp["finish_phase_ts"])
                    if "finish_phase_ts_ET" in cp and "finish_phase_ts_BT" in cp:
                        finishphase += " [%d-%d]"%(cp["finish_phase_ts_ET"],cp["finish_phase_ts_BT"])
                if "finishphaseeval" in cp:
                    finishphase += "<br>" + cp["finishphaseeval"]
            #coolphase
            if "coolphasetime" in cp:
                coolphasetime = cp["coolphasetime"]
                coolphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["coolphasetime"]),int(round(coolphasetime*100./totaltime)))
                if "coolphaseeval" in cp:
                    coolphase += "<br>" + cp["coolphaseeval"]
        return dryphase, midphase, finishphase, coolphase

    def event2html(self,cp,time_key,BT_key=None,prev_time_key=None):
        res = "--"
        if prev_time_key and prev_time_key in cp and time_key in cp:
            res = self.qmc.stringfromseconds(cp[time_key]) + " (" + self.qmc.stringfromseconds(cp[time_key] - cp[prev_time_key]) + "m)"
        elif time_key in cp and BT_key in cp:
            res = self.qmc.stringfromseconds(cp[time_key])+ " (%.0f"%cp[BT_key] + "&deg;" + self.qmc.mode + ")"
        return u(res)

    def specialevents2html(self):
        html = u("")
        if self.qmc.specialevents and len(self.qmc.specialevents) > 0:
            html += u('<center>\n<table cellpadding="2">\n')
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
            else:
                start = 0
            # sort events by time/index
            sevents = sorted(self.qmc.specialevents)
            seventsString = []
            seventsType = [] 
            seventsValue = [] 
            for i in range(len(sevents)):
                sorted_pos = self.qmc.specialevents.index(sevents[i])
                seventsString.append(self.qmc.specialeventsStrings[sorted_pos])
                seventsType.append(self.qmc.specialeventstype[sorted_pos])
                seventsValue.append(self.qmc.specialeventsvalue[sorted_pos])
            for i in range(len(self.qmc.specialevents)):
                html += ("<tr>"+
                     "\n<td>" + str(i+1) + "</td><td>[" +
                     self.qmc.stringfromseconds(int(self.qmc.timex[sevents[i]] - start)) +
                     "</td><td>at " + "%.1f"%self.qmc.temp2[sevents[i]] + self.qmc.mode +
#                     "]</td><td>" + seventsString[i] + "</td><td>(" + u(self.qmc.etypesf(seventsType[i])) + " to " + self.qmc.eventsvalues(seventsValue[i]) + ")</td></tr>\n")
                     "]</td><td>" + seventsString[i] + ("</td></tr>\n" if seventsType[i] == 4 else ("</td><td>(" + u(self.qmc.etypesf(seventsType[i])) + " to " + self.qmc.eventsvalues(seventsValue[i]) + ")</td></tr>\n")))
            html += '</table>\n</center>'
        return u(html)

    def note2html(self,notes):
        notes_html = u("")
        for i in range(len(notes)):
            if ord(u(notes[i])) == 9:
                notes_html += u(" &nbsp&nbsp&nbsp&nbsp ")
            elif u(notes[i]) == "\n":
                notes_html += u("<br>\n")
            else:           
                notes_html += u(notes[i])
        return notes_html

    #finds closest Bean Temperature in aw.qmc.temp2 given an input time. timex and temp2 always have same dimension
    def BTfromseconds(self,seconds):
        if len(self.qmc.timex):
            #find when input time crosses timex
            for i in range(len(self.qmc.timex)):
                if self.qmc.timex[i] > seconds:
                    break
            return float(self.qmc.temp2[i-1])           #return the BT temperature
        else:
            return 0.0

    #finds closest Environmental Temperature in aw.qmc.temp1 given an input time. timex and temp1 always have same dimension
    def ETfromseconds(self,seconds):
        if len(self.qmc.timex):
            #find when input time crosses timex
            for i in range(len(self.qmc.timex)):
                if self.qmc.timex[i] > seconds:
                    break
            return float(self.qmc.temp1[i-1])           #return the ET temperature
        else:
            return 0.0

    # converts times (values of timex) to indices
    def time2index(self,time):
        for i in range(len(self.qmc.timex)):
            if self.qmc.timex[i] >= time:
                if i > 0 and abs(time - self.qmc.timex[i]) > abs(time - self.qmc.timex[i-1]):
                    return i-1
                else:
                    return i
        return -1

    #returns the index of the lowest point in BT; return -1 if no such value found
    def findTP(self):
        TP = 1000
        idx = 0
        start = 0
        end = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if EOR_index > start and EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[2]
        if FCs_index > start and FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0] 
        if SOR_index > start and SOR_index < end:
            start = SOR_index
        for i in range(end - 1, start -1, -1):
            if self.qmc.temp2[i] > 0 and self.qmc.temp2[i] < TP:
                TP = self.qmc.temp2[i]
                idx = i
        return idx

    def defect_estimation_phase(self,phase_length,lower_limit,upper_limit,short_taste,optimal_taste,long_taste):
        result = optimal_taste
        third_of_optimal_phase = (upper_limit - lower_limit) / 3.0
        if phase_length < lower_limit:
            result = short_taste
        elif phase_length > upper_limit:
            result = long_taste
        elif phase_length < lower_limit + third_of_optimal_phase:
            result = short_taste + '/' + result
        elif phase_length > upper_limit - third_of_optimal_phase:
            result = result + '/' + long_taste
        return result

    #Flavor defect estimation chart for each leg. Thanks to Jim Schulman 
    def defect_estimation(self):
        dryphasetime = self.qmc.statisticstimes[1]
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        coolphasetime = self.qmc.statisticstimes[4]
        PerfectPhase = u(QApplication.translate("Flavor Scope Label", "OK",None, QApplication.UnicodeUTF8))
        ShortDryingPhase = u(QApplication.translate("Flavor Scope Label", "Grassy",None, QApplication.UnicodeUTF8))
        LongDryingPhase = u(QApplication.translate("Flavor Scope Label", "Leathery",None, QApplication.UnicodeUTF8))
        ShortTo1CPhase = u(QApplication.translate("Flavor Scope Label", "Toasty",None, QApplication.UnicodeUTF8))
        LongTo1CPhase = u(QApplication.translate("Flavor Scope Label", "Bready",None, QApplication.UnicodeUTF8))
        ShortFinishPhase = u(QApplication.translate("Flavor Scope Label", "Acidic",None, QApplication.UnicodeUTF8))
        LongFinishPhase = u(QApplication.translate("Flavor Scope Label", "Flat",None, QApplication.UnicodeUTF8))
        ShortCoolPhase = u(QApplication.translate("Flavor Scope Label", "Fracturing",None, QApplication.UnicodeUTF8))
        PerfectCoolPhase = u(QApplication.translate("Flavor Scope Label", "Sweet",None, QApplication.UnicodeUTF8))
        LongCoolPhase = u(QApplication.translate("Flavor Scope Label", "Less Sweet",None, QApplication.UnicodeUTF8))
        #CHECK CONDITIONS
        #if dry phase time < 3 mins (180 seconds) or less than 26% of the total time
        #  => ShortDryingPhase
        #if dry phase time > 6 mins or more than 40% of the total time
        #  => LongDryingPhase
        st1 = self.defect_estimation_phase(dryphasetime,self.qmc.statisticsconditions[0],self.qmc.statisticsconditions[1],ShortDryingPhase,PerfectPhase,LongDryingPhase)
        #if mid phase time < 5 minutes
        #  => ShortTo1CPhase
        #if mid phase time > 10 minutes
        #  => LongTo1CPhase
        st2 = self.defect_estimation_phase(midphasetime,self.qmc.statisticsconditions[2],self.qmc.statisticsconditions[3],ShortTo1CPhase,PerfectPhase,LongTo1CPhase)
        #if finish phase is less than 3 mins
        #  => ShortFinishPhase
        #if finish phase is over 6 minutes
        #  => LongFinishPhase
        st3 = self.defect_estimation_phase(finishphasetime,self.qmc.statisticsconditions[4],self.qmc.statisticsconditions[5],ShortFinishPhase,PerfectPhase,LongFinishPhase)
        #if cool phase is less than 2 mins
        #  => ShortCoolPhase
        #if cool phase is over 4 minutes
        #  => LongCoolPhase
        st4 = self.defect_estimation_phase(coolphasetime,self.qmc.statisticsconditions[6],self.qmc.statisticsconditions[7],ShortCoolPhase,PerfectCoolPhase,LongCoolPhase)
        return (st1,st2,st3,st4)

    #returns the index of the end of the dry phase (returns -1 if dry end cannot be determined)
    #if given, starts at TP_index and looks forward, otherwise it looks backwards from end of roast (EoR)
    #find index with smallest abs() difference between aw.qmc.phases[1] and BT (temp2)
    def findDryEnd(self,TP_index=None):
        sd = 1000
        nsd = 1000
        index = 0
        start = 0
        end = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if EOR_index > start and EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[6]
        if FCs_index > start and FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0] 
        if SOR_index > start and SOR_index < end:
            start = SOR_index
        # try to consider only indices from TP of roast on and not before
        TP = TP_index
        # if TP not yet computed, let's try to compute it
        if TP == None:
            TP = self.findTP()
        if TP > start and TP < end:
            start = TP
        for i in range(end -1, start -1, -1):
            nsd = abs(self.qmc.temp2[i]- self.qmc.phases[1])
            if nsd < sd:
                sd = nsd
                index = i
        return index

    # returns True if a BT break at i-2 is detected
    # idea:
    # . average delta before i-2 is not negative
    # . average delta after i-2 is negative and twice as high (absolute) as the one before
    def BTbreak(self,i):
        if len(self.qmc.timex)>5 and i < len(self.qmc.timex):
            d1 = self.qmc.temp2[i-5] - self.qmc.temp2[i-4]
            d2 = self.qmc.temp2[i-4] - self.qmc.temp2[i-3]
            d3 = self.qmc.temp2[i-1] - self.qmc.temp2[i-2]
            d4 = self.qmc.temp2[i] - self.qmc.temp2[i-1]
            dpre = (d1 + d2) / 2.0
            dpost = (d3 + d4) / 2.0
            #print("BTbreak",self.qmc.temp2[i],d3 < .0,d4 < .0,abs(dpost),(0.5 + (2.5 * abs(dpre))))
            if d3 < .0 and d4 < .0 and (abs(dpost) > (0.5 + (2.5 * abs(dpre)))):
                return True
            else:
                return False
        else:
            return False

    # this can be used to find the CHARGE index as well as the DROP index by using
    # 0 or the DRY index as start index, respectively
    def findBTbreak(self,start_index=0,end_index=0):
        result = 0        
        # determine average deltaBT wrt. the two previous measurements
        # the deltaBT values wrt. the next two measurements must by twice as high and negative
        # then our current measurement is the one of CHARGE/DROP
        for i in range(start_index,len(self.qmc.timex)):
            if end_index and i > end_index:
                break
            if i>3:
                if self.BTbreak(i):
                    result = i - 2
                    break
        return result

    #calculate the AREA under BT and ET
    def ts(self,start=None,end=None):
        delta = ET = BT = 0.0
        if (start == 0 and end == 0) or (start and (start < 0 or (start == 0 and self.qmc.timeindex[0] < 0))):
            return 0,0,0
        else:
            try:
                for i in range((start or self.qmc.timeindex[0]),min(len(self.qmc.timex)-1,(end or self.qmc.timeindex[6]))):
                    # eliminate wrong readings
                    e1 = self.qmc.temp1[i]
                    if e1 > 500:
                        e1 = 0
                    e2 = self.qmc.temp1[i]
                    if e2 > 500:
                        e2 = 0
                    e = (max(0,e1) + max(0,e2)) / 2.0
                    b = (max(0,self.qmc.temp2[i]) + max(0,self.qmc.temp2[i+1])) / 2.0
                    dt = (self.qmc.timex[i+1] - self.qmc.timex[i])
                    delta += (e - b) * dt
                    ET += e * dt
                    BT += b * dt
            except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ts() %1").arg(str(e)),exc_tb.tb_lineno)
            return int(round(delta/60)), int(round(ET/60)), int(round(BT/60))

    #Find rate of change of each phase. TP_index (by aw.findTP()) is the index of the TP and dryEndIndex that of the end of drying (by aw.findDryEnd())
    #Note: For the dryphase, the RoR for the dryphase is calculated for the segment starting from TP ending at DE
    def RoR(self,TP_index,dryEndIndex):
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        BTdrycross = None
        rc1 = rc2 = rc3 = 0.
        if dryEndIndex > -1 and dryEndIndex < len(self.qmc.temp2):
            BTdrycross = self.qmc.temp2[dryEndIndex]
        if BTdrycross and TP_index < 1000 and TP_index > -1 and dryEndIndex and TP_index < len(self.qmc.temp2):
            LP = self.qmc.temp2[TP_index]
            #avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[TP_index]
            if divisor:
                rc1 = ((BTdrycross - LP) / divisor)*60.
            else:
                rc1 = 0
        if self.qmc.timeindex[2]:
            if midphasetime and BTdrycross:
                rc2 = ((self.qmc.temp2[self.qmc.timeindex[2]] - BTdrycross)/midphasetime)*60.
            if finishphasetime:
                rc3 = ((self.qmc.temp2[self.qmc.timeindex[6]]- self.qmc.temp2[self.qmc.timeindex[2]])/finishphasetime)*60.
        return (rc1,rc2,rc3)

    def viewErrorLog(self):
        self.error = errorDlg(self)
        self.error.show()
        QApplication.processEvents()
        self.error.setModal(False)

    def viewSerialLog(self):
        self.serialDLG = serialLogDlg(self)
        self.serialDLG.show()
        QApplication.processEvents()
        self.serialDLG.setModal(False)
        
        
    def viewartisansettings(self):
        settingsDLG = artisansettingsDlg(self)
        settingsDLG.show()

    def viewplatform(self):
        self.platformDLG = platformDlg(self)
        self.platformDLG.show()
        QApplication.processEvents()
        self.platformDLG.setModal(False)

    def viewMessageLog(self):
        self.message = messageDlg(self)
        self.message.show()
        QApplication.processEvents()
        self.message.setModal(False)

    def helpAbout(self):
        coredevelopers = "<br>Rafael Cobo &amp; Marko Luther"
        contributors = u("<br>") + uchr(199) + u("etin Barut, Marcio Carnerio, Bradley Collins, ")
        contributors += u("Sebastien Delgrande, Kalle Deligeorgakis, Jim Gall, ")
        contributors += u("Frans Goddijn, Rich Helms, Kyle Iseminger, Ingo, ")
        contributors += u("Savvas Kiretsis, Lukas Kolbe, David Lahoz, ")
        contributors += u("Runar Ostnes, Carlos Pascual, Claudia Raddatz, ")
        contributors += u("Matthew Sewell, Bertrand Souville, Minoru Yoshida, ")
        contributors += u("Wa'il, Alex Fan, Piet Dijk, Rubens Gardelli, ")
        contributors += u("David Trebilcock, Zolt") + uchr(225) + u("n Kis, Miroslav Stankovic, ")
        contributors += u("Barrie Fairley, Ziv Sade, Nicholas Seckar, ")
        contributors += u("Morten M") + uchr(252) + u("nchow")
        contributors += u(", Andrzej Kie") + uchr(322) + u("basi") + uchr(324) + u("ski, Marco Cremonese, Josef Gander")
        contributors += u(", Paolo Scimone")
        box = QMessageBox(self)
        #create a html QString
        from scipy import __version__ as SCIPY_VERSION_STR
        box.about(self,
                QApplication.translate("About", "About",None, QApplication.UnicodeUTF8),
                u("""<big><b>{0}</b> {1}</big> ({2})
                <p>
                <b>Based on:</b><br>Python {3}, Qt {4}, PyQt {5}, Matplotlib {6}, NumPy {7}, SciPy {8}
                </p>
                <p>
                <b>{9}</b> {10}
                </p>
                <p>
                <b>{11}</b> {12}
                </p>""").format(
                "Artisan",
                str(__version__),
                str(__revision__),
                platform.python_version(),
                QT_VERSION_STR,
                PYQT_VERSION_STR,
                mpl.__version__,
                numpy.__version__,
                SCIPY_VERSION_STR,
                QApplication.translate("About", "Core developers:",None, QApplication.UnicodeUTF8),
                coredevelopers,
                QApplication.translate("About", "Contributors:",None, QApplication.UnicodeUTF8),
                contributors))

    def showAboutQt(self):
        QApplication.instance().aboutQt()
        
    def helpHelp(self):
        QDesktopServices.openUrl(QUrl("http://coffeetroupe.com/artisandocs/", QUrl.TolerantMode))

    def applicationscreenshot(self):
        imag = QPixmap().grabWidget(self)
#        imag = self.grab()
        fmt = 'png'
        initialPath = QDir.currentPath() + "/ArtisanScreenshot." + fmt
        fileName = QFileDialog.getSaveFileName(self, "Artisan ScreenShot",
                initialPath,
                "%s Files (*.%s);;All Files (*)"%(fmt.upper(),fmt))
        if fileName:
            imag.save(fileName, fmt) 

    def retrieveWeightIn(self,tare=0):
        v = aw.scale.readWeight() # read value from scale in 'g'
        if v != None and v > -1:
            v = v - tare
            if aw.qmc.weight[2] != 'g':
                v = v / 1000.0
            aw.qmc.weight[0] = v

    def retrieveWeightOut(self,tare=0):
        v = aw.scale.readWeight() # read value from scale in 'g'
        if v != None and v > -1:
            v = v - tare
            if aw.qmc.weight[2] != 'g':
                v = v / 1000.0
            aw.qmc.weight[1] = v

    def desktopscreenshot(self):
        imag = QPixmap.grabWindow(QApplication.desktop().winId())
        fmt = 'png'
        initialPath = QDir.currentPath() + "/DesktopScreenshot." + fmt
        fileName = QFileDialog.getSaveFileName(self, "Desktop ScreenShot",
                initialPath,
                "%s Files (*.%s);;All Files (*)"%(fmt.upper(),fmt))
        if fileName:
            imag.save(fileName, fmt)
            
    def oversampling(self):
        aw.qmc.oversampling = not aw.qmc.oversampling
        aw.oversamplingAction.setChecked(aw.qmc.oversampling)
        if aw.qmc.oversampling and self.qmc.delay < aw.qmc.oversampling_min_delay:
            QMessageBox.warning(self,QApplication.translate("Message", "Warning",None, 
            QApplication.UnicodeUTF8),QApplication.translate("Message", 
            "Oversampling is only active with a sampling interval equal or larger than 3s.",None, QApplication.UnicodeUTF8))


    def calibratedelay(self):
        calSpinBox = QDoubleSpinBox()
        calSpinBox.setRange(aw.qmc.min_delay/1000.,30.)
        calSpinBox.setValue(self.qmc.delay/1000.)
        calSpinBox.setAlignment(Qt.AlignRight)
        secondsdelay, ok = QInputDialog.getDouble(self,
                QApplication.translate("Message", "Sampling Interval",None, QApplication.UnicodeUTF8),
                QApplication.translate("Message", "Seconds",None, QApplication.UnicodeUTF8),
                calSpinBox.value(),aw.qmc.min_delay/1000.,30.)
        if ok:
            self.qmc.delay = int(secondsdelay*1000.)
            if self.qmc.delay <= self.qmc.min_delay + 1000:
                QMessageBox.warning(self,QApplication.translate("Message", "Warning",None, QApplication.UnicodeUTF8),QApplication.translate("Message", "A tight sampling interval might lead to instability on some machines. We suggest a minimum of 3s.",None, QApplication.UnicodeUTF8))

    def setcommport(self):
        dialog = comportDlg(self)
        if dialog.exec_():
            # set serial port
            self.ser.comport = str(dialog.comportEdit.getSelection())
            self.ser.baudrate = int(str(dialog.baudrateComboBox.currentText()))              #int changes QString to int
            self.ser.bytesize = int(str(dialog.bytesizeComboBox.currentText()))
            self.ser.stopbits = int(str(dialog.stopbitsComboBox.currentText()))
            self.ser.parity = str(dialog.parityComboBox.currentText())
            self.ser.timeout = int(str(dialog.timeoutEdit.text()))
            # set modbus port
            self.modbus.comport = str(dialog.modbus_comportEdit.getSelection())
            self.modbus.baudrate = int(str(dialog.modbus_baudrateComboBox.currentText()))              #int changes QString to int
            self.modbus.bytesize = int(str(dialog.modbus_bytesizeComboBox.currentText()))
            self.modbus.stopbits = int(str(dialog.modbus_stopbitsComboBox.currentText()))
            self.modbus.parity = str(dialog.modbus_parityComboBox.currentText())
            self.modbus.timeout = int(str(dialog.modbus_timeoutEdit.text()))
            self.modbus.input1slave = int(str(dialog.modbus_input1slaveEdit.text()))
            self.modbus.input1register = int(str(dialog.modbus_input1registerEdit.text()))
            self.modbus.input1code = int(str(dialog.modbus_input1code.currentText()))
            self.modbus.input1mode = str(dialog.modbus_input1mode.currentText())
            self.modbus.input1float = bool(dialog.modbus_input1float.isChecked())            
            self.modbus.input2slave = int(str(dialog.modbus_input2slaveEdit.text()))
            self.modbus.input2register = int(str(dialog.modbus_input2registerEdit.text()))
            self.modbus.input2code = int(str(dialog.modbus_input2code.currentText()))
            self.modbus.input2mode = str(dialog.modbus_input2mode.currentText())
            self.modbus.input2float = bool(dialog.modbus_input2float.isChecked())     
            self.modbus.input3slave = int(str(dialog.modbus_input3slaveEdit.text()))
            self.modbus.input3register = int(str(dialog.modbus_input3registerEdit.text()))
            self.modbus.input3code = int(str(dialog.modbus_input3code.currentText()))
            self.modbus.input3mode = str(dialog.modbus_input3mode.currentText())
            self.modbus.input3float = bool(dialog.modbus_input3float.isChecked())     
            self.modbus.input4slave = int(str(dialog.modbus_input4slaveEdit.text()))
            self.modbus.input4register = int(str(dialog.modbus_input4registerEdit.text()))
            self.modbus.input4code = int(str(dialog.modbus_input4code.currentText()))
            self.modbus.input4float = bool(dialog.modbus_input4float.isChecked())
            self.modbus.input4mode = str(dialog.modbus_input4mode.currentText())
            self.modbus.littleEndianFloats = bool(dialog.modbus_littleEndianFloats.isChecked())
            self.modbus.type = int(dialog.modbus_type.currentIndex())
            self.modbus.host = str(dialog.modbus_hostEdit.text())
            try:
                self.modbus.port = int(str(dialog.modbus_portEdit.text()))
            except:
                pass
            # switch to ittle-endian if needed (HACK!!)
#            if self.modbus.littleEndianFloats:
#                minimalmodbus._bytestringToFloat = littleEndianBytestringToFloat
#            else:
#                minimalmodbus._bytestringToFloat = bigEndianBytestringToFloat
            # set scale port
            self.scale.device = str(dialog.scale_deviceEdit.currentText())                #unicode() changes QString to a python string
            self.scale.comport = str(dialog.scale_comportEdit.getSelection())
            self.scale.baudrate = int(str(dialog.scale_baudrateComboBox.currentText()))              #int changes QString to int
            self.scale.bytesize = int(str(dialog.scale_bytesizeComboBox.currentText()))
            self.scale.stopbits = int(str(dialog.scale_stopbitsComboBox.currentText()))
            self.scale.parity = str(dialog.scale_parityComboBox.currentText())
            self.scale.timeout = int(str(dialog.scale_timeoutEdit.text()))
            # set color port
            self.color.device = str(dialog.color_deviceEdit.currentText())                #unicode() changes QString to a python string
            self.color.comport = str(dialog.color_comportEdit.getSelection())
            self.color.baudrate = int(str(dialog.color_baudrateComboBox.currentText()))              #int changes QString to int
            self.color.bytesize = int(str(dialog.color_bytesizeComboBox.currentText()))
            self.color.stopbits = int(str(dialog.color_stopbitsComboBox.currentText()))
            self.color.parity = str(dialog.color_parityComboBox.currentText())
            self.color.timeout = int(str(dialog.color_timeoutEdit.text()))

    def PIDcontrol(self):
        #pid
        if self.qmc.device == 0 or self.qmc.device == 26:
            if self.ser.controlETpid[0] == 0:
                dialog = PXG4pidDlgControl(self)
            elif self.ser.controlETpid[0] == 1:
                dialog = PXRpidDlgControl(self)
            elif self.ser.controlETpid[0] == 2:
                dialog = DTApidDlgControl(self)
            #modeless style dialog 
            dialog.show()
            dialog.setFixedSize(dialog.size())
            QApplication.processEvents()
            dialog.setModal(False)
        #arduino
        elif self.qmc.device == 19:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.ControlModifier:
                self.arduino.togglePID()
            else:
                dialog = ArduinoDlgControl(self)
                #modeless style dialog 
                dialog.show()
                dialog.setFixedSize(dialog.size());

    def deviceassigment(self):
        dialog = DeviceAssignmentDlg(self)
        dialog.show()

    def showstatistics(self):
        dialog = StatisticsDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
        
    def Windowconfig(self):
        dialog = WindowsDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
        
    def autosaveconf(self):
        dialog = autosaveDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())

    def calculator(self):
        self.dialog = calculatorDlg(self)
        self.dialog.show()
        self.dialog.setFixedSize(self.dialog.size())
        QApplication.processEvents()
        self.dialog.setModal(False)

    def largeLCDs(self):
        if not self.largeLCDs_dialog:
            self.largeLCDs_dialog = LargeLCDs(self)
            self.LargeLCDs = True
        self.largeLCDs_dialog.show()
        self.largeLCDs_dialog.raise_()
        self.largeLCDs_dialog.activateWindow()
        QApplication.processEvents()
        self.largeLCDs_dialog.setModal(False)

    def graphwheel(self):
        if self.qmc.designerflag:
            self.stopdesigner()
        wheeldialog = WheelDlg(self)
        wheeldialog.show()
        wheeldialog.setFixedSize(wheeldialog.size())

    def background(self):
        dialog = backgroundDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
        
    def deleteBackground(self):
        self.qmc.backgroundpath = ""
        self.qmc.titleB = ""
        self.qmc.temp1B, self.qmc.temp2B, self.qmc.timeB = [],[],[]
        self.qmc.backgroundEvents, self.qmc.backgroundEtypes = [],[]
        self.qmc.backgroundEvalues, self.qmc.backgroundEStrings,self.qmc.backgroundFlavors = [],[],[]
        self.qmc.timeindexB = [-1,0,0,0,0,0,0]
        self.qmc.backmoveflag = 1

    def switch(self):
        try:
            if aw.qmc.checkSaved():
                foreground_profile_path = aw.curFile
                background_profile_path = aw.qmc.backgroundpath
                if background_profile_path:
                    # load background into foreground
                    aw.loadFile(background_profile_path)
                else:
                    # reset
                    aw.qmc.reset(soundOn=False)
                if foreground_profile_path:
                    # load foreground into background
                    aw.loadbackground(u(foreground_profile_path))
                    aw.qmc.background = True
                    aw.qmc.timealign(redraw=False)
                else:
                    # delete background
                    self.deleteBackground()
                if foreground_profile_path or background_profile_path:
                    aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception:
            pass
#            import traceback
#            traceback.print_exc(file=sys.stdout)

    def flavorchart(self):
        dialog = flavorDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())

    def designerTriggered(self):
        if self.qmc.designerflag:
            self.stopdesigner()
        else:
            self.startdesigner()

    def startdesigner(self):
        self.qmc.designer()

    def stopdesigner(self):
        self.qmc.reset()

    def editgraph(self):
        editgraphdialog = editGraphDlg(self)
        editgraphdialog.show()
        editgraphdialog.setFixedSize(editgraphdialog.size())

    def editphases(self):
        dialog = phasesGraphDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
        
    def eventsconf(self):
        dialog = EventsDlg(self)
        dialog.exec_()

    def alarmconfig(self):
        if self.qmc.device != 18:
            dialog = AlarmDlg(self)
            dialog.show()
        else:
            QMessageBox.information(self,QApplication.translate("Message", "Alarm Config",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("Message", "Alarms are not available for device None",None, QApplication.UnicodeUTF8))

    def switchLanguageFlag(self,locale,value):
        if locale == "en" or locale == "en_US":
            self.EnglishLanguage.setChecked(value)
        elif locale == "de":
            self.GermanLanguage.setChecked(value)
        elif locale == "fr":
            self.FrenchLanguage.setChecked(value)
        elif locale == "es":
            self.SpanishLanguage.setChecked(value)
        elif locale == "sv":
            self.SwedishLanguage.setChecked(value)
        elif locale == "it":
            self.ItalianLanguage.setChecked(value)
        elif locale == "zh_CH":
            self.ChineseChinaLanguage.setChecked(value)
        elif locale == "zh_TW":
            self.ChineseTaiwanLanguage.setChecked(value)
        elif locale == "el":
            self.GreekLanguage.setChecked(value)
        elif locale == "no":
            self.NorwegianLanguage.setChecked(value)
        elif locale == "nl":
            self.DutchLanguage.setChecked(value)
        elif locale == "ko":
            self.KoreanLanguage.setChecked(value)
        elif locale == "pt":
            self.PortugueseLanguage.setChecked(value)
        elif locale == "pt":
            self.PortugueseLanguage.setChecked(value)
        elif locale == "ru":
            self.RussianLanguage.setChecked(value)
        elif locale == "ar":
            self.ArabicLanguage.setChecked(value)
        elif locale == "fi":
            self.FinishLanguage.setChecked(value)
        elif locale == "tr":
            self.TurkishLanguage.setChecked(value)
        elif locale == "ja":
            self.JapaneseLanguage.setChecked(value)
        elif locale == "hu":
            self.HungarianLanguage.setChecked(value)
        elif locale == "he":
            self.PolishLanguage.setChecked(value)
        elif locale == "pl":
            self.HebrewLanguage.setChecked(value)
    
    def changelocale(self,languagelocale):
        if locale != languagelocale:
            # switch old flag off
            self.switchLanguageFlag(locale,False)
            # switch new flag on
            self.switchLanguageFlag(languagelocale,True)
            settings = QSettings()
            settings.setValue('locale', languagelocale)
            QMessageBox.information(self,QApplication.translate("Message", "Switch Language",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("Message","Language successfully changed. Restart the application.",None, QApplication.UnicodeUTF8))

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    def weight_loss(self,green,roasted):
        if float(green) == 0.0 or float(green) < float(roasted):
            return 0.
        else:
            return 100. * ((float(green) - float(roasted)) / float(green))

    # from RoastMagazine (corrected by substracting 1% based on experience)
    # http://www.roastmagazine.com/resources/Roasting101_Articles/Roast_SeptOct05_LightRoasting.pdf
    def roast_degree(self,percent):
        if percent < 13.5:
            return ""
        elif percent < 14.5:
            return u(QApplication.translate("Label", "City",None, QApplication.UnicodeUTF8))
        elif percent < 15.5:
            return u(QApplication.translate("Label", "City+",None, QApplication.UnicodeUTF8))
        elif percent < 16.5:
            return u(QApplication.translate("Label", "Full City",None, QApplication.UnicodeUTF8))
        elif percent < 17.5:
            return u(QApplication.translate("Label", "Full City+",None, QApplication.UnicodeUTF8))
        elif percent < 18.5:
            return u(QApplication.translate("Label", "Light French",None, QApplication.UnicodeUTF8))
        else:
            return u(QApplication.translate("Label", "French",None, QApplication.UnicodeUTF8))

    def importK202(self):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import K202 CSV",None, QApplication.UnicodeUTF8))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                csvReader = csv.DictReader(csvFile,["Date","Time","T1","T1unit","T2","T2unit"],delimiter='\t')
                zero_t = None
                roastdate = None
                unit = None
                for item in csvReader:
                    try:
                        #set date
                        if not roastdate:
                            roastdate = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            self.qmc.roastdate = roastdate
                        #set zero
                        if not zero_t:
                            date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            zero = QDateTime()
                            zero.setDate(date)
                            zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            zero_t = zero.toTime_t()
                        #set temperature mode
                        if not unit:
                            unit = item['T1unit']
                            if unit == "F" and self.qmc.mode == "C":
                                self.qmc.fahrenheitMode()
                            if unit == "C" and self.qmc.mode == "F":
                                self.qmc.celsiusMode()
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        self.qmc.timex.append(float(dt.toTime_t() - zero_t))
                        self.qmc.temp1.append(float(item['T1'].replace(',','.')))
                        self.qmc.temp2.append(float(item['T2'].replace(',','.')))
                    except ValueError:
                        pass
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.sendmessage(QApplication.translate("Message","K202 file loaded successfully", None, QApplication.UnicodeUTF8))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " importK202(): %1").arg(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " importK202(): %1").arg(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importK202() %1").arg(str(ex)),exc_tb.tb_lineno)

    def importK204(self):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import K204 CSV",None, QApplication.UnicodeUTF8))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                csvReader = csv.DictReader(csvFile,["Date","Time","T1","T2","T3","T4"],delimiter='\t')
                zero_t = None
                roastdate = None
                # we add an extra device if needed
                if len(self.qmc.extradevices) == 0:
                    self.addDevice()
                for item in csvReader:
                    try:
                        #set date
                        if not roastdate:
                            roastdate = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            self.qmc.roastdate = roastdate
                        #set zero
                        if not zero_t:
                            date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            zero = QDateTime()
                            zero.setDate(date)
                            zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            zero_t = zero.toTime_t()
    # The K204 export does not contain a trace of the temperature mode.
    # We have to assume here that the mode was set correctly before the import.
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        tx = float(dt.toTime_t() - zero_t)
                        self.qmc.timex.append(tx)
                        t1 = float(item['T1'].replace(',','.'))
                        if t1 > 800 or t1 < 0.0:
                            t1 = 0.0
                        self.qmc.temp1.append(t1)
                        t2 = float(item['T2'].replace(',','.'))
                        if t2 > 800 or t2 < 0.0:
                            t2 = 0.0
                        self.qmc.temp2.append(t2)
                        if len(self.qmc.extradevices) > 0:
                            self.qmc.extratimex[0].append(tx)
                            t3 = float(item['T3'].replace(',','.'))
                            if t3 > 800 or t3 < 0.0:
                                t3 = 0.0
                            self.qmc.extratemp1[0].append(t3)
                            t4 = float(item['T4'].replace(',','.'))
                            if t4 > 800 or t4 < 0.0:
                                t2 = 0.0
                            self.qmc.extratemp2[0].append(t4)
                    except ValueError:
                        pass
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.sendmessage(QApplication.translate("Message","K204 file loaded successfully", None, QApplication.UnicodeUTF8))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " importK204(): %1").arg(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " importK204(): %1").arg(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importK204() %1").arg(str(ex)),exc_tb.tb_lineno)

    def importHH506RA(self):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import HH506RA CSV", None, QApplication.UnicodeUTF8))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                data = csv.reader(csvFile,delimiter='\t')
                #read file header
                header = next(data)
                zero = QDateTime()
                date = QDate.fromString(header[0].split('Date:')[1],"yyyy'/'MM'/'dd")
                self.qmc.roastdate = date
                zero.setDate(date)
                zero.setTime(QTime.fromString(header[1].split('Time:')[1],"hh':'mm':'ss"))
                zero_t = zero.toTime_t()
                #read column headers
                fields = next(data)
                unit = None
                #read data
                for row in data:
                    items = list(zip(fields, row))
                    item = {}
                    for (name, value) in items:
                        item[name] = value.strip()
                    #set temperature mode
                    if not unit:
                        unit = item['Unit']
                        if unit == "F" and self.qmc.mode == "C":
                            self.qmc.fahrenheitMode()
                        if unit == "C" and self.qmc.mode == "F":
                            self.qmc.celsiusMode()
                    #add one measurement
                    dt = QDateTime()
                    dt.setDate(QDate.fromString(item['Date'],"yyyy'/'MM'/'dd"))
                    dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                    self.qmc.timex.append(float(dt.toTime_t() - zero_t))
                    self.qmc.temp1.append(float(item['T1']))
                    self.qmc.temp2.append(float(item['T2']))
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.sendmessage(QApplication.translate("Message","HH506RA file loaded successfully", None, QApplication.UnicodeUTF8))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " importHH506RA(): %1").arg(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " importHH506RA(): %1").arg(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importHH506RA() %1").arg(str(ex)),exc_tb.tb_lineno)

    #checks or creates directory structure
    def dirstruct(self):
        currentdir = QDir().current()     #selects the current dir
        if not currentdir.exists(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8)):
            currentdir.mkdir(QApplication.translate("Directory","profiles",None, QApplication.UnicodeUTF8))
        #check/create 'other' directory inside profiles/
        otherpath = QString(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8) + "/" + QApplication.translate("Directory","other", None, QApplication.UnicodeUTF8))
        if not currentdir.exists(otherpath):
            currentdir.mkdir(otherpath)
        #find current year,month
        date =  QDate.currentDate()
        #check / create year dir 
        yearpath = QString(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8) + "/" + str(date.year()))
        if not currentdir.exists(yearpath):
            currentdir.mkdir(yearpath)
        #check /create month dir to store profiles
        monthpath = QString(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8) + "/" + str(date.year()) + "/" + str(date.month()))
        if not currentdir.exists(monthpath):
            currentdir.mkdir(monthpath)
        if len(self.profilepath) == 0:
            self.profilepath = monthpath

    #resizes and saves graph to a new width w 
    def resize(self,w,transformationmode):
        try: 
            image = QPixmap.grabWidget(aw.qmc)
#            image = aw.qmc.grab()
            if w != 0:
                image = image.scaledToWidth(w,transformationmode)
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as PNG", None, QApplication.UnicodeUTF8),ext="*.png")
            if filename:
                if ".png" not in filename:
                    filename += ".png"
                image.save(filename)
                x = image.width()
                y = image.height()
                self.sendmessage(QApplication.translate("Message","%1  size(%2,%3) saved", None, QApplication.UnicodeUTF8).arg(str(filename)).arg(str(x)).arg(str(y)))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " resize() %1").arg(str(ex)))

    def saveVectorGraph(self,extension=".pdf"):
        try: 
            if extension == ".pdf":
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as PDF", None, QApplication.UnicodeUTF8),ext=extension)
            else:
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as SVG", None, QApplication.UnicodeUTF8),ext=extension)
            if filename:
                if extension not in filename:
                    filename += extension
                aw.qmc.fig.savefig(filename)
                self.sendmessage(QApplication.translate("Message","%1 saved", None, QApplication.UnicodeUTF8).arg(str(filename)))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " saveVectorGraph() %1").arg(str(ex)))

    #displays Dialog for the setting of the HUD
    def hudset(self):
        hudDl = HUDDlg(self)
        hudDl.show()
        hudDl.setFixedSize(hudDl.size())

    def showHUDmetrics(self):
        if self.qmc.hudresizeflag:
            #turn off
            self.qmc.toggleHUD()
            #turn back ON to adquire new size
            self.qmc.toggleHUD()
            self.qmc.hudresizeflag = False
        if len(self.qmc.temp2) > 1:  #Need this because viewProjections use rate of change (two values needed)
            ETreachTime,BTreachTime,ET2reachTime,BT2reachTime = self.qmc.getTargetTime()
            if ETreachTime > 0 and ETreachTime < 2000:
                text1 = u(QApplication.translate("Label","%1 to reach ET %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(ETreachTime))).arg(str(self.qmc.ETtarget) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text1 = text1 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+ETreachTime))))
            else:
                text1 = u(QApplication.translate("Label","%1 to reach ET %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.ETtarget) + self.qmc.mode))
            if ET2reachTime > 0 and ET2reachTime < 2000:
                text2 = u(QApplication.translate("Label","%1 to reach ET %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(ET2reachTime))).arg(str(self.qmc.ET2target) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text2 = text2 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+ET2reachTime))))
            else:
                text2 = u(QApplication.translate("Label","%1 to reach ET %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.ET2target) + self.qmc.mode))
                
            if BTreachTime > 0 and BTreachTime < 2000:    
                text3 = u(QApplication.translate("Label","%1 to reach BT %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(BTreachTime))).arg(str(self.qmc.BTtarget) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text3 = text3 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+BTreachTime))))
            else:
                text3 = u(QApplication.translate("Label","%1 to reach BT %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.BTtarget) + self.qmc.mode))
            if BT2reachTime > 0 and BT2reachTime < 2000:
                text4 = u(QApplication.translate("Label","%1 to reach BT %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(BT2reachTime))).arg(str(self.qmc.BT2target) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text4 = text4 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+BT2reachTime))))        
            else:
                text4 = u(QApplication.translate("Label","%1 to reach BT %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.BT2target) + self.qmc.mode))
            ####  Phase Texts #####
            phasetext1 = u("") # lower textline
            phasetext2 = u("") # higher textline
            if self.qmc.timeindex[2]: # after FCs
                FCs_time = self.qmc.timex[self.qmc.timeindex[2]]
                if self.qmc.timeindex[6]: # after DROP
                    afterFCs = self.qmc.timex[self.qmc.timeindex[6]] - FCs_time
                else:
                    afterFCs = self.qmc.timex[-1] - FCs_time
                phasetext1 = u(QApplication.translate("Label","%1 after FCs", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(afterFCs))))
            if self.qmc.timeindex[3]: # after FCe
                FCe_time = self.qmc.timex[self.qmc.timeindex[3]]
                if self.qmc.timeindex[6]: # after DROP
                    afterFCe = self.qmc.timex[self.qmc.timeindex[6]] - FCe_time
                else:
                    afterFCe = self.qmc.timex[-1] - FCe_time
                phasetext2 = u(QApplication.translate("Label","%1 after FCe", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(afterFCe))))
                if self.qmc.timeindex[2]:
                    phasetext2 = phasetext2 + u(" (") + u(self.qmc.stringfromseconds(int(FCe_time - self.qmc.timex[self.qmc.timeindex[2]]))) + u(" FC)")
            ####   ET pid    ######
            error = self.qmc.ETtarget - self.qmc.temp1[-1]
            differror = error - self.qmc.pidpreviouserror
            difftime = self.qmc.timex[-1] - self.qmc.timex[-2]
            if not difftime: difftime = 0.01
            proportionalterm = self.qmc.hudETpid[0]*error
            integralterm = self.qmc.hudETpid[1]*differror*difftime
            derivativeterm = self.qmc.hudETpid[2]*differror/difftime
            self.qmc.pidpreviouserror = error
            MV = proportionalterm + integralterm + derivativeterm   # Manipulated Variable
            if MV > 100.:MV = 100.
            elif MV < 0.:MV = 0.
            MVV = int(round(MV))
            pidstring = "ET pid = %i "%MVV
            ##### end of ET pid
            qImage = QImage(self.qmc.fig.canvas.buffer_rgba(), self.qmc.size().width(), self.qmc.size().height(), QImage.Format_ARGB32_Premultiplied).rgbSwapped()
            # QImage.Format_RGB32, QImage.Format_ARGB32
            img = QPixmap.fromImage(qImage)
#            img = QPixmap().grabWidget(self.qmc)
#            img = self.qmc.grab()
            Wwidth = self.qmc.size().width()
            Wheight = self.qmc.size().height()
            #Draw begins
            p = QPainter(img)
            #chose font
    #        font = QFont('Utopia', 14, -1)
    #        p.setFont(font)
            p.setOpacity(0.8)
            p.setPen(QColor("slategrey"))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/4.5),QString(text1))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/5.3),QString(text2))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/6.6),QString(text3))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/8.5),QString(text4))
            #draw pid
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/3),QString(pidstring))
            p.drawRect(Wwidth/7+140, Wheight - Wheight/3-12, 100, 12)
            p.fillRect(Wwidth/7+140, Wheight - Wheight/3-12, MVV, 12, QColor("pink"))
            delta = u(QApplication.translate("Label","ET - BT = %1", None, QApplication.UnicodeUTF8).arg("%.1f"%(self.qmc.temp1[-1] - self.qmc.temp2[-1])))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/3.5),QString(delta))
            #draw phase texts
            p.drawText(QPoint(Wwidth/2 + 100,Wheight - Wheight/6),QString(phasetext1))
            p.drawText(QPoint(Wwidth/2 + 100,Wheight - Wheight/8),QString(phasetext2))
            p.end()
            self.HUD.setPixmap(img)

    def showHUDthermal(self):
        if self.qmc.hudresizeflag:
            #turn off
            self.qmc.toggleHUD()
            #turn back ON to adquire new size
            self.qmc.toggleHUD()
            self.qmc.hudresizeflag = False
        img = QPixmap().grabWidget(self.qmc)
#        img = self.qmc.grab()
        p = QPainter(img)
        Wwidth= self.qmc.size().width()
        Wheight = self.qmc.size().height()
        p.setOpacity(1)
        p.setPen(QColor(96,255,237)) #color the rectangle the same as HUD button
        p.drawRect(10,10, Wwidth - 20, Wheight - 20)
        if self.qmc.mode == "F" and self.qmc.temp1:
            ETradius = int(self.qmc.temp1[-1]/3)
            BTradius = int(self.qmc.temp2[-1]/3)
        elif self.qmc.mode == "C" and self.qmc.temp1:
            ETradius = int(self.qmc.fromCtoF(self.qmc.temp1[-1]/3))
            BTradius = int(self.qmc.fromCtoF(self.qmc.temp2[-1]/3))
        else:
            ETradius = 50
            BTradius = 50
        Tradius = 300
        p.setOpacity(0.5)
        g = QRadialGradient(Wwidth/2, Wheight/2, ETradius)
        beanbright =  100 - ETradius
        if beanbright < 0: beanbright = 0
        g.setColorAt(0.0, QColor(240,255,beanbright))  #bean center
        g.setColorAt(.5, Qt.yellow)
        g.setColorAt(.8, Qt.red)
        g.setColorAt(1.,QColor("lightgrey"))
        p.setBrush(QBrush(g))
        #draw thermal circle
        p.setPen(0)
        p.drawEllipse(Wwidth/2 -Tradius/2 , Wheight/2 - Tradius/2 , Tradius,Tradius)
        #draw ET circle
        p.setBrush(0)
        p.setPen(QColor("black"))
        p.drawEllipse(Wwidth/2 -ETradius/2 , Wheight/2 - ETradius/2 , ETradius,ETradius)
        #draw BT circle
        p.drawEllipse(Wwidth/2 -BTradius/2 , Wheight/2 - BTradius/2 , BTradius,BTradius)
        delta = QApplication.translate("Label","ET - BT = %1%2", None, QApplication.UnicodeUTF8).arg("%.1f"%(self.qmc.temp1[-1] - self.qmc.temp2[-1])).arg(self.qmc.mode)
        p.setFont(QFont('Utopia', 14, -1))
        p.drawText(QPoint(Wwidth/2,Wheight/2),QString(delta))
        p.end()
        self.HUD.setPixmap(img)

    #used by WheelGraphDlg()
    #wrap values in unicode(.) if and only if those are of type string
    def getWheelGraph(self):
        wheel = {}
        #convert labels to unicode
        for i in range(len(self.qmc.wheelnames)):
            for x in range(len(self.qmc.wheelnames[i])):
                self.qmc.wheelnames[i][x]= u(self.qmc.wheelnames[i][x])
        #two dimension lists
        wheel["wheelnames"] = self.qmc.wheelnames
        wheel["segmentlengths"] = self.qmc.segmentlengths
        wheel["segmentsalpha"] = self.qmc.segmentsalpha
        wheel["wradii"] = self.qmc.wradii
        wheel["startangle"] = self.qmc.startangle
        wheel["projection"] = self.qmc.projection
        wheel["wheeltextsize"] = self.qmc.wheeltextsize 
        wheel["wheelcolor"] = self.qmc.wheelcolor
        wheel["wheelparent"] = self.qmc.wheellabelparent
        wheel["wheeledge"] = self.qmc.wheeledge
        wheel["wheellinewidth"] = self.qmc.wheellinewidth
        wheel["wheellinecolor"] = self.qmc.wheellinecolor
        wheel["wheelaspect"] = self.qmc.wheelaspect
        return wheel

    def loadWheel(self,filename):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                wheel = self.deserialize(filename)
                self.qmc.wheelnames = wheel["wheelnames"]
                self.qmc.segmentlengths = wheel["segmentlengths"]
                self.qmc.segmentsalpha = wheel["segmentsalpha"]
                self.qmc.wradii = wheel["wradii"]
                self.qmc.startangle = wheel["startangle"]
                self.qmc.projection = wheel["projection"]
                self.qmc.wheeltextsize = wheel["wheeltextsize"] 
                self.qmc.wheelcolor = wheel["wheelcolor"]
                self.qmc.wheellabelparent = wheel["wheelparent"]
                self.qmc.wheeledge = wheel["wheeledge"]
                self.qmc.wheellinewidth = wheel["wheellinewidth"]
                self.qmc.wheellinecolor = wheel["wheellinecolor"]
                if "wheelaspect" in wheel:
                    self.qmc.wheelaspect = wheel["wheelaspect"]
                else:
                    self.qmc.wheelaspect = 1.0
            else:
                message = QApplication.translate("Message","Invalid Wheel graph format", None, QApplication.UnicodeUTF8)
                self.sendmessage(message)
                return
            message =QApplication.translate("Message","Wheel Graph succesfully open", None, QApplication.UnicodeUTF8)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " loadWheel() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except ValueError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " loadWheel() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None, QApplication.UnicodeUTF8) + " loadWheel() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()

    def showSymbolicHelp(self):
        string1 = "<UL><LI><b>abs(x)</b> " + u(QApplication.translate("Message","Return the absolute value of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>acos(x)</b> " + u(QApplication.translate("Message","Return the arc cosine (measured in radians) of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>asin(x)</b> " + u(QApplication.translate("Message","Return the arc sine (measured in radians) of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>atan(x)</b> " + u(QApplication.translate("Message","Return the arc tangent (measured in radians) of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>cos(x)</b> " + u(QApplication.translate("Message","Return the cosine of x (measured in radians).",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>degrees(x)</b> " + u(QApplication.translate("Message", "Convert angle x from radians to degrees.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>exp(x)</b> " + u(QApplication.translate("Message", "Return e raised to the power of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>log(x[, base])</b> " + u(QApplication.translate("Message", "Return the logarithm of x to the given base. ",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>log10(x)</b> " + u(QApplication.translate("Message", "Return the base 10 logarithm of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>min(x,y)</b> " + u(QApplication.translate("Message", "Return the minimum of x and y.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>max(x,y)</b> " + u(QApplication.translate("Message", "Return the maximum of x and y.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>pow(x, y)</b> " + u(QApplication.translate("Message", "Return x**y (x to the power of y).",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>radians(x)</b> " + u(QApplication.translate("Message", "Convert angle x from degrees to radians.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>sin(x)</b> " + u(QApplication.translate("Message", "Return the sine of x (measured in radians).",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>sqrt(x)</b> " + u(QApplication.translate("Message", "Return the square root of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>tan(x)</b> " + u(QApplication.translate("Message", "Return the tangent of x (measured in radians).",None, QApplication.UnicodeUTF8))
        string1 += "</UL>"
        string2 = "<UL><LI><b>x current curve value</b>"
        string2 += "<LI><b>Y1</b> " + u(QApplication.translate("Message", "ET value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y2</b> " + u(QApplication.translate("Message", "BT value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y3</b> " + u(QApplication.translate("Message", "Extra #1 T1 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y4</b> " + u(QApplication.translate("Message", "Extra #1 T2 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y5</b> " + u(QApplication.translate("Message", "Extra #2 T1 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y6</b> " + u(QApplication.translate("Message", "Extra #2 T2 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>...</b> "
        string2 += "<LI><b>ETB</b> " + u(QApplication.translate("Message", "current background ET",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>BTB</b> " + u(QApplication.translate("Message", "current background BT",None, QApplication.UnicodeUTF8))
        string2 += "</UL>"
        string2 += "<br>"
        string2 += u(QApplication.translate("Message", "Yn holds values sampled in the actual interval if refering to ET/BT or extra channels from devices listed before, otherwise Yn hold values sampled in the previous interval",None, QApplication.UnicodeUTF8))
        #format help
        string3 = "<TABLE  WIDTH=550><TR><TH>"
        string3 += QApplication.translate("Message",  "MATHEMATICAL FUNCTIONS",None, QApplication.UnicodeUTF8)
        string3 += "</TH><TH>"
        string3 += QApplication.translate("Message",  "SYMBOLIC VARIABLES",None, QApplication.UnicodeUTF8)
        string3 += "</TH></TR><TR><TD NOWRAP>" + string1 + "</TD><TD>" + string2 + "</TD></TR></TABLE>"
        QMessageBox.information(self,QApplication.translate("Message", "Symbolic Functions",None, QApplication.UnicodeUTF8),string3)

    def toggleextraeventrows(self):
        if self.extraeventsbuttonsflag:
            if aw.qmc.flagon:
                aw.hideExtraButtons()
            self.extraeventsbuttonsflag = 0
        else:
            if aw.qmc.flagon:
                aw.showExtraButtons()
            self.extraeventsbuttonsflag = 1

    #orders extra event buttons based on max number of buttons
    def realignbuttons(self):
        #clear buttons
#        mainbuttunslen = len(self.lowerbuttondialog.buttons())
#        diff = mainbuttunslen - 9
#        for i in range(diff):
#            self.lowerbuttondialog.removeButton(self.buttonlist[i])
        self.e1buttondialog.clear()
        self.e2buttondialog.clear()
        self.e3buttondialog.clear()
        self.e4buttondialog.clear()
        self.buttonlist = []
        for i in range(len(self.extraeventstypes)):
            self.buttonlist.append(QPushButton())
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(self.extraeventbuttontextcolor[i],self.extraeventbuttoncolor[i])
            self.buttonlist[i].setStyleSheet(style)
            self.buttonlist[i].setMinimumHeight(50)
            self.buttonlist[i].setText(self.extraeventslabels[i])
            self.buttonlist[i].setFocusPolicy(Qt.NoFocus)
            self.connect(self.buttonlist[i], SIGNAL("clicked()"), lambda ee=i:self.recordextraevent(ee))
            #add button to row (CHANGED: now never add extra buttons to default button set)
#            lowerbuttonvisiblebuttons = len(aw.lowerbuttondialog.buttons())
#            for i in range(len(aw.qmc.buttonvisibility)):
#                # remove the invisible ones
#                if not aw.qmc.buttonvisibility[i]:
#                    lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
#            if not self.eventsbuttonflag: # remove another count if EVENT button is invisible
#                lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
            if False: #lowerbuttonvisiblebuttons < self.buttonlistmaxlen:
                self.lowerbuttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
            elif len(self.e1buttondialog.buttons()) < self.buttonlistmaxlen:
                self.e1buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e1buttondialog.setContentsMargins(0,10,0,0)
            elif len(self.e2buttondialog.buttons()) < self.buttonlistmaxlen:
                self.e2buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e2buttondialog.setContentsMargins(0,10,0,0)
            elif len(self.e3buttondialog.buttons()) < self.buttonlistmaxlen:
                self.e3buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e3buttondialog.setContentsMargins(0,10,0,0)
            else:
                self.e4buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e4buttondialog.setContentsMargins(0,10,0,0)
        self.settooltip()
        self.update_extraeventbuttons_visibility()

    #assigns tooltips to extra event buttons
    def settooltip(self):
        for i in range(len(self.buttonlist)):
            tip = u(QApplication.translate("Tooltip","<b>Label</b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventslabels[i]) + "<br>"
            tip += u(QApplication.translate("Tooltip","<b>Description </b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventsdescriptions[i]) + "<br>"
            if self.extraeventstypes[i] < 4:
                tip += u(QApplication.translate("Tooltip","<b>Type </b>= ", None, QApplication.UnicodeUTF8)) + u(self.qmc.etypesf(self.extraeventstypes[i])) + "<br>"
                tip += u(QApplication.translate("Tooltip","<b>Value </b>= ", None, QApplication.UnicodeUTF8)) + u(int(round((self.extraeventsvalues[i]-1)*10.))) + "<br>" 
            tip += u(QApplication.translate("Tooltip","<b>Documentation </b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventsactionstrings[i]) + "<br>"
            tip += u(QApplication.translate("Tooltip","<b>Button# </b>= ", None, QApplication.UnicodeUTF8)) + str(i+1)
            self.buttonlist[i].setToolTip(tip)

    def update_extraeventbuttons_visibility(self):
        for i in range(len(self.buttonlist)):
            if self.extraeventsvisibility[i]:
                self.buttonlist[i].setVisible(True)
            else:
                self.buttonlist[i].setVisible(False)

    #transfers a palette number to current buttons
    def transferbuttonsto(self,pindex):
        copy = []
        copy.append(self.extraeventstypes[:])
        copy.append(self.extraeventsvalues[:])
        copy.append(self.extraeventsactions[:])
        copy.append(self.extraeventsvisibility[:])
        copy.append(self.extraeventsactionstrings[:])
        copy.append(self.extraeventslabels[:])
        copy.append(self.extraeventsdescriptions[:])
        copy.append(self.extraeventbuttoncolor[:])
        copy.append(self.extraeventbuttontextcolor[:])
        # added slider settings
        copy.append(self.eventslidervisibilities[:])
        copy.append(self.eventslideractions[:])
        copy.append(self.eventslidercommands[:])
        copy.append(self.eventslideroffsets[:])
        copy.append(self.eventsliderfactors[:])
        self.buttonpalette[pindex] = copy[:] 
        self.buttonpalettemaxlen[pindex] = self.buttonlistmaxlen
        self.sendmessage(QApplication.translate("Message","Buttons copied to Palette #%i"%(pindex), None, QApplication.UnicodeUTF8))

    #stores a palette number from current buttons
    def setbuttonsfrom(self,pindex):
        copy = self.buttonpalette[pindex][:]
        if len(copy):
            self.extraeventstypes = copy[0][:]
            self.extraeventsvalues = copy[1][:]
            self.extraeventsactions = copy[2][:]
            self.extraeventsvisibility = copy[3][:]
            self.extraeventsactionstrings = copy[4][:]
            self.extraeventslabels = copy[5][:]
            self.extraeventsdescriptions = copy[6][:]
            self.extraeventbuttoncolor = copy[7][:]
            self.extraeventbuttontextcolor = copy[8][:]
            # added slider settings
            if len(copy[9]) == 4:
                self.eventslidervisibilities = copy[9][:]
            if len(copy[10]) == 4:
                self.eventslideractions = copy[10][:]
            if len(copy[11]) == 4:
                self.eventslidercommands = copy[11][:]
            if len(copy[12]) == 4:
                self.eventslideroffsets = copy[12][:]
            if len(copy[13]) == 4:
                self.eventsliderfactors = copy[13][:]
            self.buttonlistmaxlen = self.buttonpalettemaxlen[pindex]
            self.realignbuttons()
            self.sendmessage(QApplication.translate("Message","Palette #%i restored"%(pindex), None, QApplication.UnicodeUTF8))
            return 1  #success
        else:
            self.sendmessage(QApplication.translate("Message","Palette #%i empty"%(pindex), None, QApplication.UnicodeUTF8))
            return 0  #failed

    def backuppaletteeventbuttons(self):
        palette = {}
        #convert labels to unicode
        for i in range(len(self.buttonpalette)):
            key = str(i)
            palette[key] = self.buttonpalette[i]
        palette["maxlen"] = self.buttonpalettemaxlen
        try:
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Palettes",None, QApplication.UnicodeUTF8),ext="*.apal")
            if filename:
                #write
                self.serialize(filename,palette)
                self.sendmessage(QApplication.translate("Message","Palettes saved",None, QApplication.UnicodeUTF8))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:",None, QApplication.UnicodeUTF8) + " backuppaletteeventbuttons(): %1").arg(str(ex)))
            return

    def loadPalettes(self,filename):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                palette = self.deserialize(filename)
                self.buttonpalettemaxlen = list(map(int,palette["maxlen"]))
                for i in range(10):  #10 palettes (0-9)
                    key = str(i)
                    nextpalette = [[], [], [], [], [], [], [], [], [], [], [], [], [], []]
                    if len(palette[key]):
                        for x in range(9):
                            if x < 4:
                                if x == 1:
                                    nextpalette[x] = list(map(float,palette[key][x]))     #  type double
                                else:
                                    nextpalette[x] = list(map(int,palette[key][x]))     #  type int
                            else:
                                nextpalette[x] = list(map(str,palette[key][x])) #  type unicode
                        # read in extended palette data containing slider settings:
                        if len(palette[key])==14:
                            nextpalette[9] = list(map(int,palette[key][9]))     #  type int
                            nextpalette[10] = list(map(int,palette[key][10]))     #  type int
                            nextpalette[11] = list(map(str,palette[key][11])) #  type unicode
                            nextpalette[12] = list(map(int,palette[key][12]))     #  type int
                            nextpalette[13] = list(map(float,palette[key][13]))     #  type double
                        else:
                            nextpalette[9] = self.buttonpalette[9]
                            nextpalette[10] = self.buttonpalette[10]
                            nextpalette[11] = self.buttonpalette[11]
                            nextpalette[12] = self.buttonpalette[12]
                            nextpalette[13] = self.buttonpalette[13]
                    self.buttonpalette[i] = nextpalette[:]
            else:
                message = QApplication.translate("Message","Invalid palettes file format", None, QApplication.UnicodeUTF8)
                self.sendmessage(message)
                return
            message =QApplication.translate("Message","Palettes loaded", None, QApplication.UnicodeUTF8)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " loadPalettes() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None, QApplication.UnicodeUTF8) + " loadPalettes() %1").arg(str(ex)),exc_tb.tb_lineno)
            return

    def restorepaletteeventbuttons(self):
        filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Palettes",None, QApplication.UnicodeUTF8),path=self.profilepath)
        if filename:
            self.loadPalettes(filename)

    def loadAlarms(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            alarms = json.load(infile)
            infile.close()
            aw.qmc.alarmflag = alarms["alarmflags"]
            aw.qmc.alarmguard = alarms["alarmguards"]
            aw.qmc.alarmnegguard = alarms["alarmnegguards"]
            aw.qmc.alarmtime = alarms["alarmtimes"]
            aw.qmc.alarmoffset = alarms["alarmoffsets"]
            aw.qmc.alarmcond = alarms["alarmconds"]
            aw.qmc.alarmsource = alarms["alarmsources"]
            aw.qmc.alarmtemperature = alarms["alarmtemperatures"]
            aw.qmc.alarmaction = alarms["alarmactions"]
            aw.qmc.alarmbeep = alarms["alarmbeep"]
            aw.qmc.alarmstrings = alarms["alarmstrings"]
            message =QApplication.translate("Message","Alarms loaded", None, QApplication.UnicodeUTF8)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " loadAlarms() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None, QApplication.UnicodeUTF8) + " loadAlarms() %1").arg(str(ex)),exc_tb.tb_lineno)
            return


########################################################################################
#####################  Artisan QDialog Subclass  #######################################
########################################################################################

class ArtisanDialog(QDialog):
    def __init__(self, parent=None):
        super(ArtisanDialog,self).__init__(parent)

    def keyPressEvent(self,event):
        key = int(event.key())
        #uncomment next line to find the integer value of a key
        #print key
        modifiers = QApplication.keyboardModifiers()
        if key == 16777216 or (key == 87 and modifiers == Qt.ControlModifier): #ESCAPE or CMD-W
            self.close()

class ArtisanMessageBox(QMessageBox):
    def __init__(self, parent = None, title=None, text=None, timeout=0): 
        super(ArtisanMessageBox, self).__init__(parent)
        self.setWindowTitle(title)
        self.setText(text)
        self.setIcon(QMessageBox.Information)
        self.setStandardButtons(QMessageBox.Ok)
        self.setDefaultButton(QMessageBox.Ok)
        self.timeout = timeout # configured timeout, defaults to 0 (no timeout)
        self.currentTime = 0 # counts seconds after timer start
        
    def showEvent(self,event):
        self.currentTime = 0
        if (self.timeout and self.timeout != 0):
            self.startTimer(1000)
    
    def timerEvent(self,event):
        self.currentTime = self.currentTime + 1
        if (self.currentTime >= self.timeout):
            self.done(0)

##########################################################################
#####################     QR Image   #####################################
##########################################################################

class QRImage(qrcode.image.base.BaseImage):
    def __init__(self, border, width, box_size):
        self.border = border
        self.width = width
        self.box_size = box_size
        size = (width + border * 2) * box_size
        self._image = QImage(
            size, size, QImage.Format_RGB16)
        self._image.fill(Qt.white)

    def pixmap(self):
        return QPixmap.fromImage(self._image)

    def drawrect(self, row, col):
        painter = QPainter(self._image)
        painter.fillRect(
            (col + self.border) * self.box_size,
            (row + self.border) * self.box_size,
            self.box_size, self.box_size,
            Qt.black)

    def save(self, stream, kind=None):
        pass
        
##########################################################################
#####################     HUD  EDIT DLG     ##############################
##########################################################################

class HUDDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(HUDDlg,self).__init__(parent)
        
        self.setWindowTitle(QApplication.translate("Form Caption","Extras", None, QApplication.UnicodeUTF8))
        self.setModal(True)
        # keep old values to be restored on Cancel
        self.org_DeltaET = aw.qmc.DeltaETflag
        self.org_DeltaBT = aw.qmc.DeltaBTflag
        self.org_DeltaETlcd = aw.qmc.DeltaETlcdflag
        self.org_DeltaBTlcd = aw.qmc.DeltaBTlcdflag
        self.org_Projection = aw.qmc.projectFlag
        self.org_patheffects = aw.qmc.patheffects
        self.org_graphstyle = aw.qmc.graphstyle
        self.org_graphfont = aw.qmc.graphfont
        self.org_HUDbuttonflag = aw.qmc.HUDbuttonflag
        self.showHUDbutton = QCheckBox(QApplication.translate("Label", "HUD Button", None, QApplication.UnicodeUTF8))
        self.showHUDbutton.setChecked(aw.qmc.HUDbuttonflag)
        self.showHUDbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(self.showHUDbutton,SIGNAL("stateChanged(int)"),lambda i=0:self.showHUDbuttonToggle(i))
        ETLabel = QLabel(QApplication.translate("Label", "ET Target 1",None, QApplication.UnicodeUTF8))
        ETLabel.setAlignment(Qt.AlignRight)
        BTLabel = QLabel(QApplication.translate("Label", "BT Target 1",None, QApplication.UnicodeUTF8))
        BTLabel.setAlignment(Qt.AlignRight)        
        ET2Label = QLabel(QApplication.translate("Label", "ET Target 2",None, QApplication.UnicodeUTF8))
        ET2Label.setAlignment(Qt.AlignRight)
        BT2Label = QLabel(QApplication.translate("Label", "BT Target 2",None, QApplication.UnicodeUTF8))
        BT2Label.setAlignment(Qt.AlignRight)        
        modeLabel = QLabel(QApplication.translate("Label", "Mode",None, QApplication.UnicodeUTF8))
        modeLabel.setAlignment(Qt.AlignRight)
        ETPIDLabel = QLabel(QApplication.translate("Label", "ET p-i-d 1",None, QApplication.UnicodeUTF8))
        #delta ET
        self.DeltaET = QCheckBox(QApplication.translate("CheckBox", "DeltaET",None, QApplication.UnicodeUTF8))
        self.DeltaET.setChecked(aw.qmc.DeltaETflag)
        #delta BT
        self.DeltaBT = QCheckBox(QApplication.translate("CheckBox", "DeltaBT",None, QApplication.UnicodeUTF8))
        self.DeltaBT.setChecked(aw.qmc.DeltaBTflag)
        filterlabel = QLabel(QApplication.translate("Label", "Smooth Deltas",None, QApplication.UnicodeUTF8))
        #DeltaFilter holds the number of pads in filter
        self.DeltaFilter = QSpinBox()
        self.DeltaFilter.setSingleStep(1)
        self.DeltaFilter.setRange(0,40)
        self.DeltaFilter.setAlignment(Qt.AlignRight)
        self.DeltaFilter.setValue(aw.qmc.deltafilter/2)
        self.connect(self.DeltaFilter ,SIGNAL("editingFinished()"),lambda x=0:self.changeDeltaFilter(0))
        curvefilterlabel = QLabel(QApplication.translate("Label", "Smooth Curves",None, QApplication.UnicodeUTF8))
        #Filter holds the number of pads in filter
        self.Filter = QSpinBox()
        self.Filter.setSingleStep(1)
        self.Filter.setRange(0,40)
        self.Filter.setAlignment(Qt.AlignRight)
        self.Filter.setValue(aw.qmc.curvefilter/2)
        self.connect(self.Filter,SIGNAL("editingFinished()"),lambda x=0:self.changeFilter(0))        
        windowlabel = QLabel(QApplication.translate("Label", "Window",None, QApplication.UnicodeUTF8))
        #Window holds the number of pads in filter
        self.Window = QSpinBox()
        self.Window.setSingleStep(1)
        self.Window.setRange(0,40)
        self.Window.setAlignment(Qt.AlignRight)
        self.Window.setValue(aw.qmc.smoothingwindowsize)
        self.connect(self.Window,SIGNAL("editingFinished()"),lambda x=0:self.changeWindow(0))        
        #filterspikes
        self.FilterSpikes = QCheckBox(QApplication.translate("CheckBox", "Smooth Spikes",None, QApplication.UnicodeUTF8))
        self.FilterSpikes.setChecked(aw.qmc.filterDropOuts)
        self.connect(self.FilterSpikes,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDropFilter(i))
        self.FilterSpikes.setFocusPolicy(Qt.NoFocus)    
        #altsmoothing
        self.AltSmoothing = QCheckBox(QApplication.translate("CheckBox", "Smooth2",None, QApplication.UnicodeUTF8))
        self.AltSmoothing.setChecked(aw.qmc.altsmoothing)
        self.connect(self.AltSmoothing,SIGNAL("stateChanged(int)"),lambda i=0:self.changeAltSmoothing(i))
        self.AltSmoothing.setFocusPolicy(Qt.NoFocus)
        #dropspikes
        self.DropSpikes = QCheckBox(QApplication.translate("CheckBox", "Drop Spikes",None, QApplication.UnicodeUTF8))
        self.DropSpikes.setChecked(aw.qmc.dropSpikes)
        self.connect(self.DropSpikes,SIGNAL("stateChanged(int)"),lambda i=0:self.changeSpikeFilter(i))
        self.DropSpikes.setFocusPolicy(Qt.NoFocus)
        #min-max-limits
        self.MinMaxLimits = QCheckBox(QApplication.translate("CheckBox", "Limits",None, QApplication.UnicodeUTF8))
        self.MinMaxLimits.setChecked(aw.qmc.minmaxLimits)
        self.connect(self.MinMaxLimits,SIGNAL("stateChanged(int)"),lambda i=0:self.changeMinMaxLimits(i))
        self.MinMaxLimits.setFocusPolicy(Qt.NoFocus)
        #swapETBT flag
        self.swapETBT = QCheckBox(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8) + " <-> " + QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8))
        self.swapETBT.setChecked(aw.qmc.swapETBT)
        self.swapETBT.setFocusPolicy(Qt.NoFocus)
        self.connect(self.swapETBT,SIGNAL("stateChanged(int)"),lambda i=0:self.changeSwapETBT(i))
        #limits
        minlabel = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxlabel = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))
        self.minLimit = QSpinBox()
        self.minLimit.setRange(0,1000)    #(min,max)
        self.minLimit.setAlignment(Qt.AlignRight)
        self.minLimit.setMinimumWidth(80)
        self.minLimit.setValue(aw.qmc.filterDropOut_tmin)
        self.maxLimit = QSpinBox()
        self.maxLimit.setRange(0,1000)
        self.maxLimit.setAlignment(Qt.AlignRight)
        self.maxLimit.setMinimumWidth(80)
        self.maxLimit.setValue(aw.qmc.filterDropOut_tmax)
        if aw.qmc.mode == "F":
            self.minLimit.setSuffix(" F")
            self.maxLimit.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.minLimit.setSuffix(" C")
            self.maxLimit.setSuffix(" C")
        #show projection
        self.projectCheck = QCheckBox(QApplication.translate("CheckBox", "Projection",None, QApplication.UnicodeUTF8))
        self.projectionmodeComboBox = QComboBox()
        self.projectionmodeComboBox.addItems([QApplication.translate("ComboBox","linear",None, QApplication.UnicodeUTF8),
                                              QApplication.translate("ComboBox","newton",None, QApplication.UnicodeUTF8)])
        self.projectionmodeComboBox.setCurrentIndex(aw.qmc.projectionmode)
        self.connect(self.projectionmodeComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.projectionmodeComboBox.currentIndex() :self.changeProjectionMode(i))
        self.projectCheck.setChecked(aw.qmc.projectFlag)
        self.connect(self.DeltaET,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaET(i))         #toggle
        self.connect(self.DeltaBT,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaBT(i))         #toggle
        self.connect(self.projectCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.changeProjection(i)) #toggle
        
        deltaSpanLabel = QLabel(QApplication.translate("Label", "Delta Span",None, QApplication.UnicodeUTF8))
        self.deltaSpan = QComboBox()
        self.spanitems = range(1,16)
        self.deltaSpan.addItems([str(i) + "s" for i in self.spanitems])
        try:
            self.deltaSpan.setCurrentIndex(self.spanitems.index(aw.qmc.deltaspan))
        except:
            pass
        self.connect(self.deltaSpan,SIGNAL("currentIndexChanged(int)"),lambda i=0:self.changeDeltaSpan(i))  #toggle

        self.modeComboBox = QComboBox()
        self.modeComboBox.setMaximumWidth(100)
        self.modeComboBox.setMinimumWidth(55)
        self.modeComboBox.addItems([QApplication.translate("ComboBox","metrics",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("ComboBox","thermal",None, QApplication.UnicodeUTF8)])
        self.modeComboBox.setCurrentIndex(aw.HUDfunction)
        self.ETlineEdit = QLineEdit(str(aw.qmc.ETtarget))
        self.ETlineEdit.setAlignment(Qt.AlignRight)
        self.BTlineEdit = QLineEdit(str(aw.qmc.BTtarget))
        self.BTlineEdit.setAlignment(Qt.AlignRight)
        self.ETlineEdit.setValidator(QIntValidator(0, 1000, self.ETlineEdit))
        self.BTlineEdit.setValidator(QIntValidator(0, 1000, self.BTlineEdit))
        self.ETlineEdit.setMaximumWidth(60)
        self.BTlineEdit.setMaximumWidth(60)
        self.ET2lineEdit = QLineEdit(str(aw.qmc.ET2target))
        self.ET2lineEdit.setAlignment(Qt.AlignRight)
        self.BT2lineEdit = QLineEdit(str(aw.qmc.BT2target))
        self.BT2lineEdit.setAlignment(Qt.AlignRight)
        self.ET2lineEdit.setValidator(QIntValidator(0, 1000, self.ET2lineEdit))
        self.BT2lineEdit.setValidator(QIntValidator(0, 1000, self.BT2lineEdit))
        self.ET2lineEdit.setMaximumWidth(60)
        self.BT2lineEdit.setMaximumWidth(60)
        self.ETpidP = QLineEdit(str(aw.qmc.hudETpid[0]))
        self.ETpidP.setAlignment(Qt.AlignRight)
        self.ETpidI = QLineEdit(str(aw.qmc.hudETpid[1]))
        self.ETpidI.setAlignment(Qt.AlignRight)
        self.ETpidD = QLineEdit(str(aw.qmc.hudETpid[2]))
        self.ETpidD.setAlignment(Qt.AlignRight)
        self.ETpidP.setValidator(QIntValidator(0, 1000, self.ETpidP))
        self.ETpidI.setValidator(QIntValidator(0, 1000, self.ETpidI))
        self.ETpidD.setValidator(QIntValidator(0, 1000, self.ETpidD))
        self.ETpidP.setMaximumWidth(60)
        self.ETpidI.setMaximumWidth(60)
        self.ETpidD.setMaximumWidth(60)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.updatetargets)
        hudLayout = QGridLayout()
        hudLayout.addWidget(BTLabel,0,0)
        hudLayout.addWidget(self.BTlineEdit,0,1)
        hudLayout.addWidget(BT2Label,0,2)
        hudLayout.addWidget(self.BT2lineEdit,0,3)
        hudLayout.addWidget(ETLabel,1,0)
        hudLayout.addWidget(self.ETlineEdit,1,1)
        hudLayout.addWidget(ET2Label,1,2)
        hudLayout.addWidget(self.ET2lineEdit,1,3)
        hudLayout.addWidget(ETPIDLabel,2,0)
        hudLayout.addWidget(self.ETpidP,2,1)
        hudLayout.addWidget(self.ETpidI,2,2)
        hudLayout.addWidget(self.ETpidD,2,3)
        hudLayout.addWidget(modeLabel,3,0)
        hudLayout.addWidget(self.modeComboBox,3,1)
        hudLayout.addWidget(self.showHUDbutton,3,3)
        rorLayout = QGridLayout()
        rorLayout.addWidget(self.projectCheck,0,0)
        rorLayout.addWidget(self.projectionmodeComboBox,0,1)
        rorLayout.addWidget(self.DeltaET,1,0)
        rorLayout.addWidget(self.DeltaBT,1,1)
        rorLayout.addWidget(deltaSpanLabel,1,2)
        rorLayout.addWidget(self.deltaSpan,1,3)
        rorBoxLayout = QHBoxLayout()
        rorBoxLayout.addLayout(rorLayout)
        rorBoxLayout.addStretch()
        self.DeltaETlcd = QCheckBox(QApplication.translate("CheckBox", "DeltaET",None, QApplication.UnicodeUTF8))
        self.DeltaETlcd.setChecked(aw.qmc.DeltaETlcdflag)
        self.DeltaBTlcd = QCheckBox(QApplication.translate("CheckBox", "DeltaBT",None, QApplication.UnicodeUTF8))
        self.DeltaBTlcd.setChecked(aw.qmc.DeltaBTlcdflag)
        self.DecimalPlaceslcd = QCheckBox(QApplication.translate("CheckBox", "Decimal Places",None, QApplication.UnicodeUTF8))
        self.DecimalPlaceslcd.setChecked(aw.qmc.LCDdecimalplaces)
        self.connect(self.DeltaETlcd,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaETlcd(i))         #toggle
        self.connect(self.DeltaBTlcd,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaBTlcd(i))         #toggle
        self.connect(self.DecimalPlaceslcd,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDecimalPlaceslcd(i))         #toggle
        lcdsLayout = QHBoxLayout()
        lcdsLayout.addWidget(self.DeltaETlcd)
        lcdsLayout.addSpacing(15)
        lcdsLayout.addWidget(self.DeltaBTlcd)
        lcdsLayout.addSpacing(15)
        lcdsLayout.addWidget(self.DecimalPlaceslcd)
        lcdsLayout.addStretch()
        sensitivityLayout = QHBoxLayout()
        sensitivityLayout.addWidget(curvefilterlabel)
        sensitivityLayout.addWidget(self.Filter)
        sensitivityLayout.addSpacing(30)
        sensitivityLayout.addWidget(filterlabel)
        sensitivityLayout.addWidget(self.DeltaFilter)
        sensitivityLayout.addStretch()
        spikesLayout = QHBoxLayout()
        spikesLayout.addWidget(self.FilterSpikes)
        spikesLayout.addSpacing(30)
        spikesLayout.addWidget(self.AltSmoothing)
        spikesLayout.addStretch()
        spikesLayout.addWidget(windowlabel)
        spikesLayout.addWidget(self.Window)
        curvesLayout = QVBoxLayout()
        curvesLayout.addLayout(rorBoxLayout)
        curvesLayout.addLayout(sensitivityLayout)
        curvesLayout.addLayout(spikesLayout)
        rorGroupLayout = QGroupBox(QApplication.translate("GroupBox","Curves",None, QApplication.UnicodeUTF8))
        rorGroupLayout.setLayout(curvesLayout)
        rorLCDGroupLayout = QGroupBox(QApplication.translate("GroupBox","LCDs",None, QApplication.UnicodeUTF8))
        rorLCDGroupLayout.setLayout(lcdsLayout)
        hudGroupLayout = QGroupBox(QApplication.translate("GroupBox","HUD",None, QApplication.UnicodeUTF8))
        hudGroupLayout.setLayout(hudLayout)
        inputFilterGrid = QGridLayout()
        inputFilterGrid.setColumnMinimumWidth(3,20)
        inputFilterGrid.addWidget(self.swapETBT,0,0)
        inputFilterGrid.addWidget(self.MinMaxLimits,1,0)
        inputFilterGrid.addWidget(minlabel,1,1)
        inputFilterGrid.addWidget(self.minLimit,1,2)
        inputFilterGrid.addWidget(maxlabel,1,4)
        inputFilterGrid.addWidget(self.maxLimit,1,5)
        inputFilterGrid.addWidget(self.DropSpikes,2,0)
        inputFilterHBox = QHBoxLayout()
        inputFilterHBox.addLayout(inputFilterGrid)
        inputFilterHBox.addStretch()
        inputFilterGroupLayout = QGroupBox(QApplication.translate("GroupBox","Input Filters",None, QApplication.UnicodeUTF8))
        inputFilterGroupLayout.setLayout(inputFilterHBox)
        # path effects
        effectslabel = QLabel(QApplication.translate("Label", "Path Effects",None, QApplication.UnicodeUTF8))
        self.PathEffects = QSpinBox()
        self.PathEffects.setSingleStep(1)
        self.PathEffects.setRange(0,5)
        self.PathEffects.setAlignment(Qt.AlignRight)
        self.PathEffects.setValue(aw.qmc.patheffects)
        self.connect(self.PathEffects ,SIGNAL("editingFinished()"),lambda x=0:self.changePathEffects())
        pathEffectsLayout = QHBoxLayout()
        pathEffectsLayout.addWidget(effectslabel)
        pathEffectsLayout.addWidget(self.PathEffects)
        pathEffectsLayout.addWidget(effectslabel)
        pathEffectsLayout.addStretch()
        # graph style
        stylelabel = QLabel(QApplication.translate("Label", "Style",None, QApplication.UnicodeUTF8))
        self.GraphStyle = QComboBox()
        self.GraphStyle.addItems([QApplication.translate("ComboBox","classic",None, QApplication.UnicodeUTF8),
                                  QApplication.translate("ComboBox","xkcd",None, QApplication.UnicodeUTF8)])
        self.GraphStyle.setCurrentIndex(aw.qmc.graphstyle)
        self.connect(self.GraphStyle,SIGNAL("currentIndexChanged(int)"),lambda i=self.GraphStyle.currentIndex():self.changeGraphStyle(i))
        # graph font
        fontlabel = QLabel(QApplication.translate("Label", "Font",None, QApplication.UnicodeUTF8))
        self.GraphFont = QComboBox()
        # no Comic on Linux!
        if platf == "Linux":
            self.GraphFont.addItems([QApplication.translate("ComboBox","Default",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","Humor",None, QApplication.UnicodeUTF8)])
        else:
            self.GraphFont.addItems([QApplication.translate("ComboBox","Default",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","Humor",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","Comic",None, QApplication.UnicodeUTF8)])
        self.GraphFont.setCurrentIndex(aw.qmc.graphfont)
        self.connect(self.GraphFont,SIGNAL("currentIndexChanged(int)"),lambda i=self.GraphFont.currentIndex():self.changeGraphFont(i))
        graphLayout = QHBoxLayout()
        graphLayout.addWidget(stylelabel)
        graphLayout.addWidget(self.GraphStyle)
        graphLayout.addStretch()
        graphLayout.addWidget(fontlabel)
        graphLayout.addWidget(self.GraphFont)
        # styles group
        stylesLayout = QVBoxLayout()
        stylesLayout.addLayout(pathEffectsLayout)
        stylesLayout.addLayout(graphLayout)
        styleGroupLayout = QGroupBox(QApplication.translate("GroupBox","Look",None, QApplication.UnicodeUTF8))
        styleGroupLayout.setLayout(stylesLayout)
        #tab0
        tab0Layout = QVBoxLayout()
        tab0Layout.addWidget(rorGroupLayout)
        tab0Layout.addWidget(rorLCDGroupLayout)
        tab0Layout.addWidget(styleGroupLayout)
        tab0Layout.addStretch()
        #tab1
        tab1Layout = QVBoxLayout()
        tab1Layout.addWidget(inputFilterGroupLayout)
        tab1Layout.addWidget(hudGroupLayout)
        tab1Layout.addStretch()
        #tab2
        #Equation plotter
        equlabel = QLabel(QApplication.translate("Label", "Y(x)",None, QApplication.UnicodeUTF8))
        self.equedit1 = QLineEdit(aw.qmc.plotcurves[0])
        self.equedit2 = QLineEdit(aw.qmc.plotcurves[1])
        self.equedit3 = QLineEdit(aw.qmc.plotcurves[2])
        self.equedit4 = QLineEdit(aw.qmc.plotcurves[3])
        self.equedit5 = QLineEdit(aw.qmc.plotcurves[4])
        self.equedit6 = QLineEdit(aw.qmc.plotcurves[5])
        color1Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color1Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color1Button, SIGNAL("clicked()"),lambda x=0: self.setcurvecolor(x))
        color2Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color2Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color2Button, SIGNAL("clicked()"),lambda x=1: self.setcurvecolor(x))
        color3Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color3Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color3Button, SIGNAL("clicked()"),lambda x=2: self.setcurvecolor(x))
        color4Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color4Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color4Button, SIGNAL("clicked()"),lambda x=3: self.setcurvecolor(x))
        color5Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color5Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color5Button, SIGNAL("clicked()"),lambda x=4: self.setcurvecolor(x))
        color6Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color6Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color6Button, SIGNAL("clicked()"),lambda x=5: self.setcurvecolor(x))
        equdrawbutton = QPushButton(QApplication.translate("Button","Plot",None, QApplication.UnicodeUTF8))
        equdrawbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(equdrawbutton,SIGNAL("clicked()"),self.plotequ)
        equbackgroundbutton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        equbackgroundbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(equbackgroundbutton ,SIGNAL("clicked()"),self.setbackgroundequ1)
        equvdevicebutton = QPushButton(QApplication.translate("Button","Virtual Device",None, QApplication.UnicodeUTF8))
        equvdevicebutton.setFocusPolicy(Qt.NoFocus)
        self.connect(equvdevicebutton ,SIGNAL("clicked()"),self.setvdevice)
        saveImgButton = QPushButton(QApplication.translate("Button","Save Image",None, QApplication.UnicodeUTF8))
        saveImgButton.setFocusPolicy(Qt.NoFocus)
        saveImgButton.setToolTip(QApplication.translate("Tooltip","Save image using current graph size to a png format",None, QApplication.UnicodeUTF8))
        self.connect(saveImgButton, SIGNAL("clicked()"),lambda x=0,i=1:aw.resize(x,i))
        helpcurveButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpcurveButton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpcurveButton, SIGNAL("clicked()"),aw.showSymbolicHelp)
        curve1Layout = QGridLayout()
        curve1Layout.addWidget(self.equedit1,0,0)
        curve1Layout.addWidget(color1Button,0,1)
        curve1Layout.addWidget(equbackgroundbutton,0,2)
        curve1Layout.addWidget(self.equedit2,1,0)
        curve1Layout.addWidget(color2Button,1,1)
        curve1Layout.addWidget(equvdevicebutton,1,2)
        plot1GroupBox = QGroupBox()
        plot1GroupBox.setLayout(curve1Layout)
        curveLayout = QGridLayout()
        curveLayout.addWidget(self.equedit3,0,0)
        curveLayout.addWidget(color3Button,0,1)
        curveLayout.addWidget(self.equedit4,1,0)
        curveLayout.addWidget(color4Button,1,1)
        curveLayout.addWidget(self.equedit5,2,0)
        curveLayout.addWidget(color5Button,2,1)
        curveLayout.addWidget(self.equedit6,3,0)
        curveLayout.addWidget(color6Button,3,1)
        curvebuttonlayout = QHBoxLayout()
        curvebuttonlayout.addWidget(equdrawbutton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(saveImgButton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(helpcurveButton)
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(equlabel)
        tab2Layout.addWidget(plot1GroupBox)
        tab2Layout.addLayout(curveLayout)
        tab2Layout.addLayout(curvebuttonlayout)
        tab2Layout.addStretch()
        ##### TAB 3
        self.interpCheck = QCheckBox(QApplication.translate("CheckBox","Show",None, QApplication.UnicodeUTF8))
        self.interpCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.interpCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.interpolation(i)) #toggle
        self.interpComboBox = QComboBox()
        self.interpComboBox.setMaximumWidth(100)
        self.interpComboBox.setMinimumWidth(55)
        self.interpComboBox.addItems([QApplication.translate("ComboBox","linear",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","cubic",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","nearest",None, QApplication.UnicodeUTF8)])
        self.interpComboBox.setToolTip(QApplication.translate("Tooltip", "linear: linear interpolation\ncubic: 3rd order spline interpolation\nnearest: y value of the nearest point", None, QApplication.UnicodeUTF8))
        self.interpComboBox.setFocusPolicy(Qt.NoFocus)
        self.connect(self.interpComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.interpComboBox.currentIndex() :self.changeInterpolationMode(i))
#         'linear'  : linear interpolation
#         'cubic'   : 3rd order spline interpolation
#         'nearest' : take the y value of the nearest point
        self.univarCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None, QApplication.UnicodeUTF8))
        self.univarCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.univarCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.univar(i)) #toggle
        univarButton = QPushButton(QApplication.translate("Button","Info",None, QApplication.UnicodeUTF8))
        univarButton.setFocusPolicy(Qt.NoFocus)
        univarButton.setMaximumSize(univarButton.sizeHint())
        univarButton.setMinimumSize(univarButton.minimumSizeHint()) 
        polyfitdeglabel = QLabel("deg")
        self.polyfitdeg = QSpinBox()
        self.polyfitdeg.setFocusPolicy(Qt.NoFocus)
        self.polyfitdeg.setRange(1,4)
        self.polyfitdeg.setAlignment(Qt.AlignRight)
        self.polyfitdeg.setMinimumWidth(20)
        # build list of available curves
        self.curves = []
        self.curvenames = []
        self.c1ComboBox = QComboBox()
        self.c2ComboBox = QComboBox()
        self.connect(univarButton,SIGNAL("clicked()"),self.showunivarinfo)
        self.polyfitCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None, QApplication.UnicodeUTF8))
        self.polyfitCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.polyfitCheck,SIGNAL("clicked(bool)"),lambda i=0:self.polyfit(i)) #toggle
        self.result = QLabel()
        self.result.setStyleSheet("background-color:'lightgrey';")
        startlabel = QLabel(QApplication.translate("Label", "Start",None, QApplication.UnicodeUTF8))
        endlabel = QLabel(QApplication.translate("Label", "End",None, QApplication.UnicodeUTF8))
        self.startEdit = QLineEdit()
        self.startEdit.setMaximumWidth(60)
        self.startEdit.setAlignment(Qt.AlignRight)
        self.endEdit = QLineEdit()
        self.endEdit.setMaximumWidth(60)
        self.endEdit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.startEdit.setValidator(QRegExpValidator(regextime,self))
        self.startEdit.setText("00:00")
        self.endEdit.setValidator(QRegExpValidator(regextime,self))
        if len(aw.qmc.timex) > 0:
            self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[-1]))
        else:
            self.endEdit.setText("00:00")
        # calculate event list
        self.events = self.eventlist()
        self.eventAComboBox = QComboBox()
        self.eventAComboBox.addItems([""] + [i[0] for i in self.events])
        self.eventAComboBox.setCurrentIndex(0)
        self.connect(self.eventAComboBox,SIGNAL("currentIndexChanged(int)"),self.calcEventRC)
        self.eventBComboBox = QComboBox()
        self.eventBComboBox.addItems([i[0] for i in self.events] + [""])
        self.eventBComboBox.setCurrentIndex(len(self.events))
        self.connect(self.eventBComboBox,SIGNAL("currentIndexChanged(int)"),self.calcEventRC)
        tab3Layout = QVBoxLayout()
        interLayout = QHBoxLayout()
        interLayout.addWidget(self.interpCheck)
        interLayout.addStretch()
        interLayout.addWidget(self.interpComboBox)
        interGroupLayout = QGroupBox(QApplication.translate("GroupBox","Interpolate",None, QApplication.UnicodeUTF8))
        interGroupLayout.setLayout(interLayout)
        uniLayout = QHBoxLayout()
        uniLayout.addWidget(self.univarCheck)
        uniLayout.addStretch()
        uniLayout.addWidget(univarButton)
        univarGroupLayout = QGroupBox(QApplication.translate("GroupBox","Univariate",None, QApplication.UnicodeUTF8))
        univarGroupLayout.setLayout(uniLayout)
        polytimes = QHBoxLayout()
        polytimes.addWidget(startlabel)
        polytimes.addWidget(self.startEdit)
        polytimes.addStretch()
        polytimes.addWidget(self.endEdit)
        polytimes.addWidget(endlabel)
        polyevents = QHBoxLayout()
        polyevents.addWidget(self.eventAComboBox)
        polyevents.addStretch()
        polyevents.addWidget(self.eventBComboBox)
        polyCurves = QHBoxLayout()
        polyCurves.addWidget(self.c1ComboBox)
        polyCurves.addStretch()
        polyCurves.addWidget(self.c2ComboBox)
        polyLayout = QHBoxLayout()
        polyLayout.addWidget(self.polyfitCheck)
        polyLayout.addStretch()
        polyLayout.addWidget(polyfitdeglabel)
        polyLayout.addWidget(self.polyfitdeg)
        polyVLayout = QVBoxLayout()
        polyVLayout.addLayout(polyLayout)
        polyVLayout.addLayout(polytimes)
        polyVLayout.addLayout(polyevents)
        polyVLayout.addLayout(polyCurves)
        polyVLayout.addWidget(self.result)
        polyfitGroupLayout = QGroupBox(QApplication.translate("GroupBox","Polyfit",None, QApplication.UnicodeUTF8))
        polyfitGroupLayout.setLayout(polyVLayout)
        tab3Layout.addWidget(interGroupLayout)
        tab3Layout.addWidget(univarGroupLayout)
        tab3Layout.addWidget(polyfitGroupLayout)
        tab3Layout.addStretch()
        ##### TAB 4
        self.styleComboBox = QComboBox()
        available = list(map(str, list(QStyleFactory.keys())))
        self.styleComboBox.addItems(available)
        self.styleComboBox.setFocusPolicy(Qt.NoFocus)
        try:
            #pylint: disable=E1102
            self.styleComboBox.setCurrentIndex(list(map(lambda x:x.lower(),available)).index(str(aw.style().objectName()).lower()))
        except:
            pass
        self.connect(self.styleComboBox,SIGNAL("currentIndexChanged(int)"),lambda i:self.setappearance())
        self.resolutionSpinBox = QSpinBox()
        self.resolutionSpinBox.setRange(40,200)
        self.resolutionSpinBox.setSingleStep(5)
        self.resolutionSpinBox.setValue(aw.dpi)
        self.resolutionSpinBox.setFocusPolicy(Qt.NoFocus)
        resButton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        resButton.setFocusPolicy(Qt.NoFocus)
        self.connect(resButton,SIGNAL("clicked()"),self.changedpi)
        defresButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        defresButton.setFocusPolicy(Qt.NoFocus)
        self.connect(defresButton,SIGNAL("clicked()"),self.setdefaults)
        appLayout = QHBoxLayout()
        appLayout.addStretch()
        appLayout.addWidget(self.styleComboBox)
        appearanceGroupWidget = QGroupBox(QApplication.translate("GroupBox","Appearance",None, QApplication.UnicodeUTF8))
        appearanceGroupWidget.setLayout(appLayout)
        setresLayout = QHBoxLayout()
        setresLayout.addStretch()
        setresLayout.addWidget(self.resolutionSpinBox)
        setresLayout.addWidget(resButton)
        resLayout = QVBoxLayout()
        resLayout.addLayout(setresLayout)
        resolutionGroupWidget = QGroupBox(QApplication.translate("GroupBox","Resolution",None, QApplication.UnicodeUTF8))
        resolutionGroupWidget.setLayout(resLayout)
        defresLayout = QHBoxLayout()
        defresLayout.addStretch()
        defresLayout.addWidget(defresButton)
        self.soundCheck = QCheckBox(QApplication.translate("CheckBox", "Beep",None, QApplication.UnicodeUTF8))
        self.soundCheck.setChecked(aw.soundflag) 
        self.soundCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.soundCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.soundset(i)) #toggle
        sLayout = QHBoxLayout()
        sLayout.addStretch()
        sLayout.addWidget(self.soundCheck)
        soundGroupWidget = QGroupBox(QApplication.translate("GroupBox","Sound",None, QApplication.UnicodeUTF8))
        soundGroupWidget.setLayout(sLayout)
        # tick
        # port
        self.WebLCDsURL = QLabel()
        self.WebLCDsURL.setOpenExternalLinks(True)
        self.WebLCDsFlag = QCheckBox()
        self.WebLCDsFlag.setChecked(aw.WebLCDs)
        self.WebLCDsFlag.setFocusPolicy(Qt.NoFocus)
        self.WebLCDsPortLabel = QLabel(QApplication.translate("Label", "Port", None, QApplication.UnicodeUTF8))
        self.WebLCDsPort = QLineEdit(str(aw.WebLCDsPort))
        self.WebLCDsPort.setAlignment(Qt.AlignRight)
        self.WebLCDsPort.setValidator(QRegExpValidator(QRegExp(r"^[0-9]{1,4}$"),self))
        self.WebLCDsPort.setMaximumWidth(45)
#        # we disable WebLCDs feature for now on non Mac OS X systems
#        if platf in ['Windows']: # not sys.platform.startswith("darwin"):
#            self.WebLCDsFlag.setDisabled(True)
#            self.WebLCDsPort.setDisabled(True)
        self.QRpic = QLabel() # the QLabel holding the QR code image
        if aw.WebLCDs:
            self.setWebLCDsURL()
        else:
            self.WebLCDsURL.setText("")
            self.QRpic.setPixmap(QPixmap())
        self.WebLCDsAlerts = QCheckBox(QApplication.translate("CheckBox", "Alarm Popups",None, QApplication.UnicodeUTF8))
        self.WebLCDsAlerts.setChecked(aw.WebLCDsAlerts)
        self.WebLCDsAlerts.setFocusPolicy(Qt.NoFocus)
        if not aw.WebLCDs:
            self.WebLCDsAlerts.setDisabled(True)
        self.connect(self.WebLCDsAlerts,SIGNAL("stateChanged(int)"),lambda i=0:self.toggleWebLCDsAlerts()) #toggle
        self.connect(self.WebLCDsPort,SIGNAL("editingFinished()"),lambda x=0:self.changeWebLCDsPort())
        self.connect(self.WebLCDsFlag,SIGNAL("clicked(bool)"),lambda i=0:self.toggleWebLCDs(i))
        WebLCDsLayout = QHBoxLayout()
        WebLCDsLayout.addWidget(self.WebLCDsFlag)
        WebLCDsLayout.addSpacing(20)
        WebLCDsLayout.addWidget(self.WebLCDsPortLabel)
        WebLCDsLayout.addWidget(self.WebLCDsPort)
        WebLCDsLayout.addStretch()
        WebLCDsLayout.addWidget(self.WebLCDsURL)
        WebLCDsLayoutHLayout = QHBoxLayout()
        WebLCDsLayoutHLayout.addWidget(self.WebLCDsAlerts)
        WebLCDsLayoutHLayout.addStretch()
        WebLCDsLayoutHLayout.addWidget(self.QRpic)
        WebLCDsLayoutVLayout = QVBoxLayout()
        WebLCDsLayoutVLayout.addLayout(WebLCDsLayout)
        WebLCDsLayoutVLayout.addLayout(WebLCDsLayoutHLayout)
        WebLCDsGroupWidget = QGroupBox(QApplication.translate("GroupBox","WebLCDs",None, QApplication.UnicodeUTF8))
        WebLCDsGroupWidget.setLayout(WebLCDsLayoutVLayout)
        tab5Layout = QVBoxLayout()
        tab5Layout.addWidget(appearanceGroupWidget)
        tab5Layout.addWidget(resolutionGroupWidget)
        tab5Layout.addWidget(soundGroupWidget)
        tab5Layout.addWidget(WebLCDsGroupWidget)
        tab5Layout.addStretch()
        tab5Layout.addLayout(defresLayout)
        ############################  TABS LAYOUT
        TabWidget = QTabWidget()
        C0Widget = QWidget()
        C0Widget.setLayout(tab0Layout)
        TabWidget.addTab(C0Widget,QApplication.translate("Tab","Graph",None, QApplication.UnicodeUTF8))
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","HUD",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Plotter",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Math",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","UI",None, QApplication.UnicodeUTF8))
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(cancelButton)
        buttonsLayout.addWidget(okButton)
        #incorporate layouts
        Slayout = QVBoxLayout()
        Slayout.addWidget(TabWidget,1)
        Slayout.addStretch()
        Slayout.addLayout(buttonsLayout)
        Slayout.setSizeConstraint(QLayout.SetFixedSize)
        self.connect(TabWidget,SIGNAL("currentChanged(int)"),lambda i=0:self.tabSwitched(i))
        self.setLayout(Slayout)
        self.connect(self.startEdit,SIGNAL("editingFinished()"),lambda i=0:self.polyfitcurveschanged(1))
        self.connect(self.endEdit,SIGNAL("editingFinished()"),lambda i=0:self.polyfitcurveschanged(2))
        self.connect(self.polyfitdeg,SIGNAL("valueChanged(int)"),lambda i=0:self.polyfitcurveschanged(3))
        self.connect(self.c1ComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.c1ComboBox.currentIndex() :self.polyfitcurveschanged(4))
        self.connect(self.c2ComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.c2ComboBox.currentIndex() :self.polyfitcurveschanged(5))

    def toggleWebLCDsAlerts(self):
        aw.WebLCDsAlerts = not aw.WebLCDsAlerts
        
    def changeWebLCDsPort(self):
        aw.WebLCDsPort = int(self.WebLCDsPort.text())
        
    def setWebLCDsURL(self):
        url_str = self.getWebLCDsURL()
        # set URL label
        self.WebLCDsURL.setText('<a href="' + url_str + '">' + url_str + '</a>')
        # set QR label  
        qr = qrcode.QRCode(
            version=None, # 1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=4,
            border=1,
            image_factory=QRImage)
        qr.add_data(url_str)
        qr.make(fit=True)
        self.QRpic.setPixmap(qr.make_image().pixmap())
        
        
    def getWebLCDsURL(self):
        localIP = [(s.connect(('8.8.8.8', 80)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1]
        return 'http://' + str(localIP) + ':' + str(aw.WebLCDsPort) + '/artisan'
        
    def toggleWebLCDs(self,i):
        if i:
            self.WebLCDsAlerts.setDisabled(False)
            self.WebLCDsPort.setDisabled(True)
            self.setWebLCDsURL()
            res = aw.startWebLCDs()
            if not res:
                self.WebLCDsPort.setDisabled(False)
                self.WebLCDsURL.setText("")
                self.QRpic.setPixmap(QPixmap())
                self.WebLCDsFlag.setChecked(False)
            else:
                self.WebLCDsFlag.setChecked(True)
        else:   
            self.WebLCDsAlerts.setDisabled(True)
            self.WebLCDsFlag.setChecked(False)
            self.WebLCDsPort.setDisabled(False)
            self.WebLCDsURL.setText("")
            self.QRpic.setPixmap(QPixmap())
            aw.stopWebLCDs()
            
    def showHUDbuttonToggle(self,i):
        if i:
            aw.qmc.HUDbuttonflag = True
            aw.button_18.setVisible(True)
        else:
            aw.qmc.HUDbuttonflag = False
            aw.button_18.setVisible(False)

    def changedpi(self):
        try:
            value = self.resolutionSpinBox.value()
            aw.setdpi(value)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " changedpi(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setdefaults(self):
        self.resolutionSpinBox.setValue(80)
        self.changedpi()
        app.setStyle(aw.defaultAppearance)

    def setcurvecolor(self,x):
        try:
            colorf = aw.colordialog(QColor(aw.qmc.plotcurvecolor[x]))
            if colorf.isValid():
                colorname = str(colorf.name())
                aw.qmc.plotcurvecolor[x] = colorname
            self.plotequ()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setcurvecolor(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setvdevice(self):
        # compute values
        EQU = [str(self.equedit1.text()),str(self.equedit2.text())]
        for e in range(2):
            #create y range
            y_range = []
            for i in range(len(aw.qmc.timex)):
                y_range.append(self.eval_curve_expression(EQU[e],aw.qmc.timex[i]))
            if e:
                extratemp2 = y_range
            else:
                extratemp1 = y_range
        # add device
        aw.addDevice() 
        aw.qmc.extradevices[-1] = 25
        
        # set colors
        aw.qmc.extradevicecolor1[-1] = aw.qmc.plotcurvecolor[0]
        aw.qmc.extradevicecolor2[-1] = aw.qmc.plotcurvecolor[1]
        # set expressions
        aw.qmc.extramathexpression1[-1] = str(self.equedit1.text())
        aw.qmc.extramathexpression2[-1] = str(self.equedit2.text())
        # set values       
        aw.qmc.extratemp1[-1] = extratemp1
        aw.qmc.extratemp2[-1] = extratemp2
        aw.qmc.extratimex[-1] = aw.qmc.timex[:]
        # redraw
        aw.qmc.redraw(recomputeAllDeltas=False)

    def setbackgroundequ1(self):
        try:
            equ = str(self.equedit1.text())
            aw.qmc.plotcurves[0] = equ
            if len(equ):
                aw.qmc.resetlines()
                #create x range
                x_range = list(range(aw.qmc.startofx,aw.qmc.endofx))
                #create y range
                y_range = []
                for i in range(len(x_range)):
                    y_range.append(self.eval_curve_expression(equ,x_range[i]))
                aw.qmc.timeB = x_range[:]
                aw.qmc.temp1B = y_range[:]
                aw.qmc.temp2B = [-100]*len(x_range)
                aw.qmc.background = True
                aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setbackgroundequ1(): %1").arg(str(e)),exc_tb.tb_lineno)

    def plotequ(self):
        try:
            EQU = [str(self.equedit1.text()),str(self.equedit2.text()),
                   str(self.equedit3.text()),str(self.equedit4.text()),
                   str(self.equedit5.text()),str(self.equedit6.text())]
            aw.qmc.plotcurves = EQU[:]
            aw.qmc.resetlines()
            for e in range(5):
                #create x range
                x_range = list(range(int(aw.qmc.startofx),int(aw.qmc.endofx)))
                #create y range
                y_range = []
                for i in range(len(x_range)):
                    y_range.append(self.eval_curve_expression(EQU[e],x_range[i]))
                aw.qmc.ax.plot(x_range, y_range, color=aw.qmc.plotcurvecolor[e], linestyle = '-', linewidth=1)
            aw.qmc.fig.canvas.draw()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " plotequ(): %1").arg(str(e)),exc_tb.tb_lineno)

    def eval_curve_expression(self,mathexpression,x):
        if len(mathexpression):
            if mathexpression[0] == "#":
                return
            #Since eval() is very powerful, for security reasons, only the functions in this dictionary will be allowed
            mathdictionary = {"min":min,"max":max,"sin":math.sin,"cos":math.cos,"tan":math.tan,"pow":math.pow,"exp":math.exp,"pi":math.pi,"e":math.e,
                              "abs":abs,"acos":math.acos,"asin":math.asin,"atan":math.atan,"log":math.log,"radians":math.radians,
                              "sqrt":math.sqrt,"atan2":math.atan,"degrees":math.degrees}
            try:
                x = float(x)
                mathdictionary['x'] = x         #add x to the math dictionary assigning the key "x" to its float value
                #if Ys in expression
                if "Y" in mathexpression:
                    #extract Ys
                    Yval = []                   #extract value number example Y9 = 9
                    mlen = len(mathexpression)
                    for i in range(mlen):
                        if mathexpression[i] == "Y":
                            #find Y number
                            if i+1 < mlen:                          #check for out of range
                                if mathexpression[i+1].isdigit():
                                    number = mathexpression[i+1]
                                else:
                                    number = "1"
                            #check for double digit
                            if i+2 < mlen:
                                if mathexpression[i+2].isdigit() and mathexpression[i+1].isdigit():
                                    number += mathexpression[i+2]
                            Yval.append(number)

                    #build Ys float values
                    if len(aw.qmc.timex) > 1:
                        index = aw.qmc.time2index(x)
                        Y = [aw.qmc.temp1[index],aw.qmc.temp2[index]]
                        if len(aw.qmc.extratimex):
                            if len(aw.qmc.extratimex[0]):
                                for i in range(len(aw.qmc.extradevices)):
                                    Y.append(aw.qmc.extratemp1[i][index])
                                    Y.append(aw.qmc.extratemp2[i][index])
                        #add Ys and their value to math dictionary
                        for i in range(len(Yval)):
                            mathdictionary["Y"+ Yval[i]] = Y[int(Yval[i])-1]
                    else:
                        for i in range(len(Yval)):
                            mathdictionary["Y"+ Yval[i]] = 0
                res = eval(mathexpression,{"__builtins__":None},mathdictionary)
                if res == None:
                    return -1
                else:
                    return res
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " Plotter: %1").arg(str(e)),exc_tb.tb_lineno)
                return -1
        return -1

    def setappearance(self):
        try:
            app.setStyle(str(self.styleComboBox.currentText()))
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setappearance(): %1").arg(str(e)),exc_tb.tb_lineno)

#    def showsound(self):
#        try:
#            warnings.simplefilter('ignore', Warning) #for Complex warning 
#            aw.sendmessage(QApplication.translate("Message","Testing Mike...", None, QApplication.UnicodeUTF8))
#            aw.stack.setCurrentIndex(2)
#            aw.sound.opensound()
#            for i in range(80):
#                msg = str(80-i)
#                self.status.showMessage(msg,500)
#                aw.sound.blitsound()
#            aw.stack.setCurrentIndex(0)
#            aw.sound.closesound()
#            aw.sendmessage("")
#            warnings.simplefilter('default', Warning)
#        except Exception as e:
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror(QApplication.translate("Error Message", "showsound(): %1 ",None, QApplication.UnicodeUTF8).arg(str(e)),exc_tb.tb_lineno)

    def saveinterp(self):
        pass

    def showunivarinfo(self):
        if aw.qmc.timeindex[6]:
            aw.qmc.univariateinfo()
        else:
            aw.sendmessage(QApplication.translate("Univariate: no profile data available", None, QApplication.UnicodeUTF8))

    def univar(self,i):
        if self.univarCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[6]:
                aw.qmc.univariate()
            else:
                aw.sendmessage(QApplication.translate("Error Message", "Univariate: no profile data available", None, QApplication.UnicodeUTF8))
                self.univarCheck.setChecked(False)
        else:
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)
            
    def calcEventRC(self):
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        
        Aevent = int(self.eventAComboBox.currentIndex())
        if Aevent == 0:
            a = 0
        else:
            a = self.events[Aevent-1][1]
                        
        Bevent = int(self.eventBComboBox.currentIndex())
        if Bevent == len(self.events):
            b = len(aw.qmc.timex) - 1
        else:
            b = self.events[Bevent][1]
        self.startEdit.setDisabled(True)
        self.startEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[a] - start))
        self.startEdit.setDisabled(False)
        self.endEdit.setDisabled(True)
        self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[b] - start))
        self.endEdit.setDisabled(False)
        self.polyfitcurveschanged(0)

    def eventlist(self):
        events = []
        if aw.qmc.timeindex[0] > -1:
            events.append(("CHARGE",aw.qmc.timeindex[0]))
        names = [
            QApplication.translate("Table", "DRY END",None, QApplication.UnicodeUTF8),
            QApplication.translate("Table", "FC START",None, QApplication.UnicodeUTF8),
            QApplication.translate("Table", "FC END",None, QApplication.UnicodeUTF8),
            QApplication.translate("Table", "SC START",None, QApplication.UnicodeUTF8),
            QApplication.translate("Table", "SC END",None, QApplication.UnicodeUTF8),
            QApplication.translate("Table", "DROP",None, QApplication.UnicodeUTF8),
            QApplication.translate("Table", "COOL",None, QApplication.UnicodeUTF8)]
        for e in range(len(names)):
            if aw.qmc.timeindex[e+1]:
                events.append((names[e],aw.qmc.timeindex[e+1]))
        for e in range(len(aw.qmc.specialevents)):
            events.append((str("Event " + str(e+1)),aw.qmc.specialevents[e]))
        return events

    def doPolyfit(self):
        l = min(len(aw.qmc.timex),len(self.curves[self.c1ComboBox.currentIndex()]),len(self.curves[self.c2ComboBox.currentIndex()]))
        starttime = aw.qmc.stringtoseconds(str(self.startEdit.text()))
        endtime = aw.qmc.stringtoseconds(str(self.endEdit.text()))
        if starttime == -1 or endtime == -1:
            self.result.setText("")
            return
        if  endtime > aw.qmc.timex[-1] or endtime < starttime:
            self.result.setText("")
            return
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        startindex = aw.qmc.time2index(starttime + start)
        endindex = min(l,aw.qmc.time2index(endtime + start))
        z = aw.qmc.polyfit(self.curves[self.c1ComboBox.currentIndex()],self.curves[self.c2ComboBox.currentIndex()],
           self.polyfitdeg.value(),startindex,endindex,self.deltacurves[self.c2ComboBox.currentIndex()])
        if z != None:
            s = ""
            sign = "+"
            z = z[::-1]
            for i in range(len(z)):
                v = abs(z[i])
                if round(v,3) != 0.0:
                    if i == 0:
                        s = "%.3f" % v
                    elif i == 1:
                        if s != "":
                            s = " " + sign + " " + s
                        s = "%.3fx" % v + s
                    else:
                        if s != "":
                            s = " " + sign + " " + s
                        s = "%.3fx^%i" % (v,i) + s
                    if z[i] < 0:
                        sign = "-"
                    else:
                        sign = "+"
            if sign == "-":
                s = sign + s
            self.result.setText(s)
        else:
            self.result.setText("")

    def polyfitcurveschanged(self,i):
        self.polyfitdeg.blockSignals(True)
        self.polyfitdeg.setDisabled(True)
        self.startEdit.blockSignals(True)
        self.startEdit.setDisabled(True)
        self.endEdit.blockSignals(True)
        self.endEdit.setDisabled(True)
        if self.polyfitCheck.isChecked() and len(aw.qmc.timex) > 2:
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)
            self.doPolyfit()
        else:
            self.result.setText("")
        self.polyfitdeg.setDisabled(False) #blockSignals(False)
        self.startEdit.setDisabled(False)
        self.startEdit.blockSignals(False)
        self.endEdit.setDisabled(False)
        self.endEdit.blockSignals(False)
        self.polyfitdeg.setDisabled(False)
        self.polyfitdeg.blockSignals(False)
        self.polyfitdeg.setFocus()

    def tabSwitched(self,i):
        if i != 3:
            if self.polyfitCheck.isChecked():
                self.polyfitCheck.setChecked(False)
#                self.polyfit(0)
        else:
            self.collectCurves()

    # TODO: add background curves temp1B, temp2B, timeB, delta1B, delta2B (could be of different size!)
    def collectCurves(self):
        idx = 0
        self.curves = []
        self.curvenames = []
        self.deltacurves = [] # list of flags. True if delta curve, False otherwise
        if aw.qmc.DeltaETflag:
            self.curvenames.append(QApplication.translate("ComboBox","DeltaET",None, QApplication.UnicodeUTF8))
            self.curves.append(aw.qmc.delta1)
            self.deltacurves.append(True)
            idx = idx + 1
        if aw.qmc.DeltaBTflag:
            self.curvenames.append(QApplication.translate("ComboBox","DeltaBT",None, QApplication.UnicodeUTF8))
            self.curves.append(aw.qmc.delta2)
            self.deltacurves.append(True)
            idx = idx + 1
        self.curvenames.append(QApplication.translate("ComboBox","ET",None, QApplication.UnicodeUTF8))
        self.curvenames.append(QApplication.translate("ComboBox","BT",None, QApplication.UnicodeUTF8))
        self.curves.append(aw.qmc.temp1)
        self.curves.append(aw.qmc.temp2)
        self.deltacurves.append(False)
        self.deltacurves.append(False)
        for i in range(len(aw.qmc.extradevices)):
            self.curvenames.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            self.curvenames.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
            self.curves.append(aw.qmc.extratemp1[i])
            self.curves.append(aw.qmc.extratemp2[i])
            self.deltacurves.append(False)
            self.deltacurves.append(False)
        self.c1ComboBox.setDisabled(True) #blockSignals(True)
        self.c2ComboBox.setDisabled(True) #blockSignals(True)
        self.c1ComboBox.clear()
        self.c1ComboBox.addItems(self.curvenames)
        self.c2ComboBox.clear()
        self.c2ComboBox.addItems(self.curvenames)
        self.c1ComboBox.setDisabled(False) #blockSignals(False)
        self.c2ComboBox.setDisabled(False) #blockSignals(False)
        self.c1ComboBox.setCurrentIndex(idx)
        self.c2ComboBox.setCurrentIndex(idx+1)

    def polyfit(self,i):
        if self.polyfitCheck.isChecked():
            #check for finished roast
            if len(aw.qmc.timex) > 2:
                self.doPolyfit()
            else:
                aw.sendmessage(QApplication.translate("Error Message", "Polyfit: no profile data available", None, QApplication.UnicodeUTF8))
                self.polyfitCheck.setChecked(False)
        else:
            self.result.setText("")
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)

    def interpolation(self,i):
        mode = str(self.interpComboBox.currentText())
        if self.interpCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[6]:
                aw.qmc.drawinterp(mode)
            else:
                aw.sendmessage(QApplication.translate("Message","Interpolation failed: no profile available", None, QApplication.UnicodeUTF8))
                self.interpCheck.setChecked(False)
        else:
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)

    def soundset(self,i):
        if aw.soundflag == 0:
            aw.soundflag = 1
            aw.sendmessage(QApplication.translate("Message","Sound turned ON", None, QApplication.UnicodeUTF8))
            aw.soundpop()
        else:
            aw.soundflag = 0
            aw.sendmessage(QApplication.translate("Message","Sound turned OFF", None, QApplication.UnicodeUTF8))

    def changeDeltaET(self,i):
        aw.qmc.DeltaETflag = not aw.qmc.DeltaETflag
        if aw.qmc.crossmarker:
            aw.qmc.togglecrosslines() # turn crossmarks off to adjust for new coordinate system
        aw.qmc.redraw(recomputeAllDeltas=True)
        
    def changeDeltaSpan(self,i):
        if aw.qmc.deltaspan != self.spanitems[i]:
            aw.qmc.deltaspan = self.spanitems[i]
            aw.qmc.updateDeltaSamples()
            aw.qmc.redraw(recomputeAllDeltas=True)
        
    def changeDecimalPlaceslcd(self,i):
        if self.DecimalPlaceslcd.isChecked():
            aw.qmc.LCDdecimalplaces = 1
            aw.setLCDsDigitCount(5)
        else:
            aw.qmc.LCDdecimalplaces = 0
            aw.setLCDsDigitCount(3)

    def changeDeltaBT(self,i):
        aw.qmc.DeltaBTflag = not aw.qmc.DeltaBTflag
        if aw.qmc.crossmarker:
            aw.qmc.togglecrosslines() # turn crossmarks off to adjust for new coordinate system
        aw.qmc.redraw(recomputeAllDeltas=True)

    def changeDeltaETlcd(self,i):
        aw.qmc.DeltaETlcdflag = not aw.qmc.DeltaETlcdflag
        aw.LCD4frame.setVisible(aw.qmc.DeltaETlcdflag)

    def changeDeltaBTlcd(self,i):
        aw.qmc.DeltaBTlcdflag = not aw.qmc.DeltaBTlcdflag
        aw.LCD5frame.setVisible(aw.qmc.DeltaBTlcdflag)

    def changePathEffects(self):
        try:
            v = self.PathEffects.value()
            if v != aw.qmc.patheffects:
                self.PathEffects.blockSignals(True)
                aw.qmc.patheffects = v
                aw.qmc.redraw(recomputeAllDeltas=False)
                self.PathEffects.blockSignals(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "changePathEffects(): %1").arg(str(e)),exc_tb.tb_lineno)

    def changeGraphStyle(self,n):
        aw.qmc.graphstyle = n
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changeGraphFont(self,n):
        aw.qmc.graphfont = n
        aw.setFonts()

    def changeDeltaFilter(self,i):
        try:
            v = self.DeltaFilter.value()*2 + 1
            if v != aw.qmc.deltafilter:
                self.DeltaFilter.setDisabled(True)
                self.DeltaFilter.blockSignals(True)
                aw.qmc.deltafilter = v
                aw.qmc.redraw(recomputeAllDeltas=True)
                self.DeltaFilter.setDisabled(False)
                self.DeltaFilter.blockSignals(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "changeDeltaFilter(): %1").arg(str(e)),exc_tb.tb_lineno)

    def changeDropFilter(self,i):
        aw.qmc.filterDropOuts = not aw.qmc.filterDropOuts
        aw.qmc.redraw(recomputeAllDeltas=False,smooth=True)
        
    def changeAltSmoothing(self,i):
        aw.qmc.altsmoothing = not aw.qmc.altsmoothing
        aw.qmc.redraw(recomputeAllDeltas=False,smooth=True)

    def changeSpikeFilter(self,i):
        aw.qmc.dropSpikes = not aw.qmc.dropSpikes

    def changeMinMaxLimits(self,i):
        aw.qmc.minmaxLimits = not aw.qmc.minmaxLimits
        
    def changeSwapETBT(self,i):
        aw.qmc.swapETBT = not aw.qmc.swapETBT

    def changeWindow(self,i):
        try:
            v = self.Window.value()
            if v != aw.qmc.smoothingwindowsize:
                self.Window.setDisabled(True)
                aw.qmc.smoothingwindowsize = v
                aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
                self.Window.setDisabled(False)
                self.Window.setFocus()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " changeWindow(): %1").arg(str(e)),exc_tb.tb_lineno)
        
    def changeFilter(self,i):
        try:
            v = self.Filter.value()*2 + 1
            if v != aw.qmc.curvefilter:
                self.Filter.setDisabled(True)
                aw.qmc.curvefilter = v
                aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
                self.Filter.setDisabled(False)
                self.Filter.setFocus()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " changeFilter(): %1").arg(str(e)),exc_tb.tb_lineno)

    def changeProjection(self,i):
        aw.qmc.projectFlag = not aw.qmc.projectFlag
        if not aw.qmc.projectFlag:
            #erase old projections
            aw.qmc.resetlines()

    def changeProjectionMode(self,i):
        aw.qmc.projectionmode = i

    def changeInterpolationMode(self,i):
        aw.qmc.resetlines()
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.interpolation(i)

    #cancel button
    def close(self):
        #restore settings
        aw.qmc.DeltaETflag = self.org_DeltaET
        aw.qmc.DeltaBTflag = self.org_DeltaBT
        aw.qmc.DeltaETlcdflag = self.org_DeltaETlcd
        aw.qmc.DeltaBTlcdflag = self.org_DeltaBTlcd
        if aw.qmc.flagon:
            aw.lcd4.setVisible(aw.qmc.DeltaETlcdflag)
            aw.label4.setVisible(aw.qmc.DeltaETlcdflag)
            aw.lcd5.setVisible(aw.qmc.DeltaBTlcdflag)
            aw.label5.setVisible(aw.qmc.DeltaBTlcdflag)
        aw.qmc.projectFlag = self.org_Projection
        aw.qmc.patheffects = self.org_patheffects
        aw.qmc.graphstyle = self.org_graphstyle
        aw.qmc.graphfont = self.org_graphfont
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.accept()

    #button OK
    def updatetargets(self):
        aw.qmc.filterDropOuts = self.FilterSpikes.isChecked()
        aw.qmc.altsmoothing = self.AltSmoothing.isChecked()
        aw.qmc.dropSpikes = self.DropSpikes.isChecked()
        aw.qmc.minmaxLimits = self.MinMaxLimits.isChecked()
        aw.qmc.filterDropOut_tmin = int(self.minLimit.value())
        aw.qmc.filterDropOut_tmax = int(self.maxLimit.value())
        mode = u(self.modeComboBox.currentText())
        if mode == QApplication.translate("ComboBox","metrics", None, QApplication.UnicodeUTF8):
            aw.HUDfunction = 0
        elif mode == QApplication.translate("ComboBox","thermal", None, QApplication.UnicodeUTF8):
            aw.HUDfunction = 1
        aw.qmc.ETtarget = int(str(self.ETlineEdit.text()))
        aw.qmc.BTtarget = int(str(self.BTlineEdit.text()))
        aw.qmc.ET2target = int(str(self.ET2lineEdit.text()))
        aw.qmc.BT2target = int(str(self.BT2lineEdit.text()))
        if aw.qmc.ETtarget > aw.qmc.ET2target: # swap such that ETtarget < ET2target
            aw.qmc.ETtarget = int(str(self.ET2lineEdit.text()))
            aw.qmc.ET2target = int(str(self.ETlineEdit.text()))
        if aw.qmc.BTtarget > aw.qmc.BT2target: # swap such that BTtarget < BT2target
            aw.qmc.BTtarget = int(str(self.BT2lineEdit.text()))
            aw.qmc.BT2target = int(str(self.BTlineEdit.text()))
        aw.qmc.hudETpid[0] = int(str(self.ETpidP.text()))
        aw.qmc.hudETpid[1] = int(str(self.ETpidI.text()))
        aw.qmc.hudETpid[2] = int(str(self.ETpidD.text()))
        string = u(QApplication.translate("Message","[ET target 1 = %1] [BT target 1 = %2] [ET target 2 = %3] [BT target 2 = %4]", None, QApplication.UnicodeUTF8).arg(str(aw.qmc.ETtarget)).arg(str(aw.qmc.BTtarget)).arg(str(aw.qmc.ET2target)).arg(str(aw.qmc.BT2target)))
        aw.sendmessage(string)
        aw.qmc.resetlinecountcaches()
        aw.qmc.resetdeltalines()
        aw.qmc.resetlines()
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.accept()

########################################################################################
#####################  Volume Calculator DLG  ##########################################
########################################################################################

class volumeCalculatorDlg(ArtisanDialog):
    def __init__(self, parent = None, weightIn=None, weightOut=None,
        weightunit=0,volumeunit=0,
        inlineedit=None,outlineedit=None,tare=0): # weight in and out expected in g (int)
        # weightunit 0:g, 1:Kg  volumeunit 0:ml, 1:l
        super(volumeCalculatorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Volume Calculator",None, QApplication.UnicodeUTF8))

        if aw.scale.device != None and aw.scale.device != "" and aw.scale.device != "None":
            self.scale_connected = True
        else:
            self.scale_connected = False

        self.weightIn = weightIn
        self.weightOut = weightOut
        
        # the units
        self.weightunit = weightunit
        self.volumeunit = volumeunit
        
        # the results
        self.inVolume = None
        self.outVolume = None
        
        # the QLineedits of the RoastProperties dialog to be updated
        self.inlineedit = inlineedit
        self.outlineedit = outlineedit
        
        # the current active tare
        self.tare = tare
        
        # Unit Group
        unitvolumeLabel = QLabel("<b>" + u(QApplication.translate("Label","Unit", None, QApplication.UnicodeUTF8)) + "</b>")
        self.unitvolumeEdit = QLineEdit(str(aw.qmc.volumeCalcUnit))
        self.unitvolumeEdit.setValidator(QIntValidator(0, 9999,self.unitvolumeEdit))
        self.unitvolumeEdit.setMinimumWidth(60)
        self.unitvolumeEdit.setMaximumWidth(60)
        self.unitvolumeEdit.setAlignment(Qt.AlignRight)
        unitvolumeUnit = QLabel(QApplication.translate("Label","ml", None, QApplication.UnicodeUTF8))
        
        # unit button
        unitButton = QPushButton(QApplication.translate("Button", "unit",None, QApplication.UnicodeUTF8))
        self.connect(unitButton, SIGNAL("clicked()"),self.unitWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        unitButton.setMaximumSize(60,35)
#        unitButton.setMinimumSize(60,35) 
        unitButton.setFocusPolicy(Qt.NoFocus)

        unitLayout = QHBoxLayout()
        if self.scale_connected:
            unitLayout.addStretch()
        unitLayout.addStretch()
        unitLayout.addWidget(unitvolumeLabel)
        unitLayout.addWidget(self.unitvolumeEdit)
        unitLayout.addWidget(unitvolumeUnit)
        unitLayout.addStretch()
        if self.scale_connected:
            unitLayout.addWidget(unitButton)
        
        # In Group
        coffeeinunitweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Unit Weight", None, QApplication.UnicodeUTF8)) + "</b>")
        self.coffeeinweightEdit = QLineEdit(aw.qmc.volumeCalcWeightInStr)
        self.coffeeinweightEdit.setMinimumWidth(60)
        self.coffeeinweightEdit.setMaximumWidth(60)
        self.coffeeinweightEdit.setAlignment(Qt.AlignRight)
        coffeeinunitweightUnit = QLabel(QApplication.translate("Label","g", None, QApplication.UnicodeUTF8))

        coffeeinweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Weight", None, QApplication.UnicodeUTF8)) + "</b>")
        self.coffeeinweight = QLineEdit()
        if self.weightIn:
            self.coffeeinweight.setText(str(aw.float2float(self.weightIn)))
        self.coffeeinweight.setMinimumWidth(60)
        self.coffeeinweight.setMaximumWidth(60)
        self.coffeeinweight.setAlignment(Qt.AlignRight)
        self.coffeeinweight.setReadOnly(True)
        self.coffeeinweight.setFocusPolicy(Qt.NoFocus)
        if weightunit:
            coffeeinweightUnit = QLabel(QApplication.translate("Label","Kg", None, QApplication.UnicodeUTF8))
        else:
            coffeeinweightUnit = QLabel(QApplication.translate("Label","g", None, QApplication.UnicodeUTF8))
        
        coffeeinvolumeLabel = QLabel("<b>" + u(QApplication.translate("Label","Volume", None, QApplication.UnicodeUTF8)) + "</b>")
        self.coffeeinvolume = QLineEdit()
        self.coffeeinvolume.setMinimumWidth(60)
        self.coffeeinvolume.setMaximumWidth(60)
        
        palette = QPalette()
        palette.setColor(self.coffeeinvolume.foregroundRole(), QColor('red'))
        self.coffeeinvolume.setPalette(palette)
        
        self.coffeeinvolume.setAlignment(Qt.AlignRight)
        self.coffeeinvolume.setReadOnly(True)
        self.coffeeinvolume.setFocusPolicy(Qt.NoFocus)
        if volumeunit:
            coffeeinvolumeUnit = QLabel(QApplication.translate("Label","l", None, QApplication.UnicodeUTF8))
        else:
            coffeeinvolumeUnit = QLabel(QApplication.translate("Label","ml", None, QApplication.UnicodeUTF8))
            
        # in button
        inButton = QPushButton(QApplication.translate("Button", "in",None, QApplication.UnicodeUTF8))
        self.connect(inButton, SIGNAL("clicked()"),self.inWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        inButton.setMaximumSize(60,35)
#        inButton.setMinimumSize(60,35) 
        inButton.setFocusPolicy(Qt.NoFocus)        
        
        inGrid = QGridLayout()
        inGrid.addWidget(coffeeinweightLabel,0,0)
        inGrid.addWidget(self.coffeeinweight,0,1)
        inGrid.addWidget(coffeeinweightUnit,0,2)
        inGrid.addWidget(coffeeinvolumeLabel,1,0)
        inGrid.addWidget(self.coffeeinvolume,1,1)
        inGrid.addWidget(coffeeinvolumeUnit,1,2)
        
        volumeInLayout = QHBoxLayout()
        volumeInLayout.addWidget(coffeeinunitweightLabel)
        volumeInLayout.addWidget(self.coffeeinweightEdit)
        volumeInLayout.addWidget(coffeeinunitweightUnit)
        volumeInLayout.addSpacing(15)
        volumeInLayout.addLayout(inGrid)
        
        inButtonLayout = QHBoxLayout()
        inButtonLayout.addWidget(inButton)
        inButtonLayout.addStretch()
        
        volumeInVLayout = QVBoxLayout()
        volumeInVLayout.addLayout(volumeInLayout)
        if self.scale_connected:
            volumeInVLayout.addLayout(inButtonLayout)
        
        volumeInGroupLayout = QGroupBox(QApplication.translate("Label","in", None, QApplication.UnicodeUTF8))
        volumeInGroupLayout.setLayout(volumeInVLayout)
        if weightIn == None:
            volumeInGroupLayout.setDisabled(True)

        self.resetInVolume()

        # Out Group
        coffeeoutunitweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Unit Weight", None, QApplication.UnicodeUTF8)) + "</b>")
        self.coffeeoutweightEdit = QLineEdit(aw.qmc.volumeCalcWeightOutStr)
        self.coffeeoutweightEdit.setMinimumWidth(60)
        self.coffeeoutweightEdit.setMaximumWidth(60)
        self.coffeeoutweightEdit.setAlignment(Qt.AlignRight)
        coffeeoutunitweightUnit = QLabel(QApplication.translate("Label","g", None, QApplication.UnicodeUTF8))

        coffeeoutweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Weight", None, QApplication.UnicodeUTF8)) + "</b>")
        self.coffeeoutweight = QLineEdit()
        if self.weightOut:
            self.coffeeoutweight.setText(str(aw.float2float(self.weightOut)))        
        self.coffeeoutweight.setMinimumWidth(60)
        self.coffeeoutweight.setMaximumWidth(60)
        self.coffeeoutweight.setAlignment(Qt.AlignRight)
        self.coffeeoutweight.setReadOnly(True)
        self.coffeeoutweight.setFocusPolicy(Qt.NoFocus)
        if weightunit:
            coffeeoutweightUnit = QLabel(QApplication.translate("Label","Kg", None, QApplication.UnicodeUTF8))
        else:
            coffeeoutweightUnit = QLabel(QApplication.translate("Label","g", None, QApplication.UnicodeUTF8))

        coffeeoutvolumeLabel = QLabel("<b>" + u(QApplication.translate("Label","Volume", None, QApplication.UnicodeUTF8)) + "</b>")
        self.coffeeoutvolume = QLineEdit()
        self.coffeeoutvolume.setMinimumWidth(60)
        self.coffeeoutvolume.setMaximumWidth(60)
        
        palette = QPalette()
        palette.setColor(self.coffeeoutvolume.foregroundRole(), QColor('red'))
        self.coffeeoutvolume.setPalette(palette)

        self.coffeeoutvolume.setAlignment(Qt.AlignRight)
        self.coffeeoutvolume.setReadOnly(True)
        self.coffeeoutvolume.setFocusPolicy(Qt.NoFocus)
        if volumeunit:
            coffeeoutvolumeUnit = QLabel(QApplication.translate("Label","l", None, QApplication.UnicodeUTF8))
        else:
            coffeeoutvolumeUnit = QLabel(QApplication.translate("Label","ml", None, QApplication.UnicodeUTF8))

        # out button
        outButton = QPushButton(QApplication.translate("Button", "out",None, QApplication.UnicodeUTF8))
        self.connect(outButton, SIGNAL("clicked()"),self.outWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        outButton.setMaximumSize(60,35)
#        outButton.setMinimumSize(60,35) 
        outButton.setFocusPolicy(Qt.NoFocus)
                
        outGrid = QGridLayout()
        outGrid.addWidget(coffeeoutweightLabel,0,0)
        outGrid.addWidget(self.coffeeoutweight,0,1)
        outGrid.addWidget(coffeeoutweightUnit,0,2)
        outGrid.addWidget(coffeeoutvolumeLabel,1,0)
        outGrid.addWidget(self.coffeeoutvolume,1,1)
        outGrid.addWidget(coffeeoutvolumeUnit,1,2)
        
        volumeOutLayout = QHBoxLayout()
        volumeOutLayout.addWidget(coffeeoutunitweightLabel)
        volumeOutLayout.addWidget(self.coffeeoutweightEdit)
        volumeOutLayout.addWidget(coffeeoutunitweightUnit)
        volumeOutLayout.addSpacing(15)
        volumeOutLayout.addLayout(outGrid)
        
        outButtonLayout = QHBoxLayout()
        outButtonLayout.addWidget(outButton)
        outButtonLayout.addStretch()
        
        volumeOutVLayout = QVBoxLayout()
        volumeOutVLayout.addLayout(volumeOutLayout)
        if self.scale_connected:
            volumeOutVLayout.addLayout(outButtonLayout)
        
        volumeOutGroupLayout = QGroupBox(QApplication.translate("Label","out", None, QApplication.UnicodeUTF8))
        volumeOutGroupLayout.setLayout(volumeOutVLayout)
        if weightOut == None:
            volumeOutGroupLayout.setDisabled(True)

        self.resetOutVolume()
        
        self.connect(self.coffeeinweightEdit,SIGNAL("editingFinished()"),self.resetInVolume)
        self.connect(self.coffeeoutweightEdit,SIGNAL("editingFinished()"),self.resetOutVolume)
        self.connect(self.unitvolumeEdit,SIGNAL("editingFinished()"),self.resetVolume)

        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.updateVolumes)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)

        mainlayout = QVBoxLayout()
        mainlayout.addLayout(unitLayout)
        mainlayout.addWidget(volumeInGroupLayout)
        mainlayout.addWidget(volumeOutGroupLayout)
        mainlayout.addLayout(buttonLayout)
        self.setLayout(mainlayout)
        self.coffeeinweightEdit.setFocus()
        
    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        key = int(event.key())
        if key == 16777220 and self.scale_connected: # ENTER key pressed
            v = self.retrieveWeight()
            if v and v != 0:
                if self.unitvolumeEdit.hasFocus():
                    self.unitvolumeEdit.setText(str(v))
                elif self.coffeeinweightEdit.hasFocus():
                    self.coffeeinweightEdit.setText(str(v))
                elif self.coffeeoutweightEdit.hasFocus():
                    self.coffeeoutweightEdit.setText(str(v))
                    
    def widgetWeight(self,widget):
        if widget.text() != "":
            c = widget.text().toFloat()[0]
        else:
            c = 0.
        v = aw.float2float(self.retrieveWeight(c))
        widget.setText(str(v))
        
    def unitWeight(self):
        self.widgetWeight(self.unitvolumeEdit)
        
    def inWeight(self):
        self.widgetWeight(self.coffeeinweightEdit)
        
    def outWeight(self):
        self.widgetWeight(self.coffeeoutweightEdit)
        
    def retrieveWeight(self,current=0):
        v = aw.scale.readWeight() # read value from scale in 'g'
        if v != None and v > -1: # value received
            # substruct tare
            return (v - self.tare)
        elif current != 0:
            # substruct tare from current value
            return current - self.tare
        else:
            return 0

    def resetVolume(self):
        self.resetInVolume()
        self.resetOutVolume()

    def resetInVolume(self):
        try:
            if self.volumeunit:
                k = 1000.
            else:
                k = 1.
            if self.weightunit:
                j = 1000.
            else:
                j = 1.
            line = self.coffeeinweightEdit.text()
            if line == None or str(line).strip() == "":
                self.coffeeinvolume.setText("")
                self.inVolume = None
            else:
                res = self.weightIn / (k * (float(str(self.coffeeinweightEdit.text())) / (j * float(self.unitvolumeEdit.text()))))
                if self.volumeunit:
                    self.coffeeinvolume.setText(str(aw.float2float(res,4)))
                else:
                    self.coffeeinvolume.setText(str(aw.float2float(res)))
                self.inVolume = res
        except:
            pass

    def resetOutVolume(self):
        try:
            if self.volumeunit:
                k = 1000.
            else:
                k = 1.
            if self.weightunit:
                j = 1000.
            else:
                j = 1.
            line = self.coffeeoutweightEdit.text()
            if line == None or str(line).strip() == "":
                self.coffeeoutvolume.setText("")
                self.outVolume = None
            else:
                res = self.weightOut / (k * (float(str(self.coffeeoutweightEdit.text())) / (j * float(self.unitvolumeEdit.text()))))
                if self.volumeunit:
                    self.coffeeoutvolume.setText(str(aw.float2float(res,4)))
                else:
                    self.coffeeoutvolume.setText(str(aw.float2float(res)))
                self.outVolume = res
        except:
            pass

    def updateVolumes(self):
        if self.inVolume and self.inVolume != "":
            if self.volumeunit:
                self.inlineedit.setText(str(aw.float2float(self.inVolume,4)))
            else:
                self.inlineedit.setText(str(aw.float2float(self.inVolume)))
        if self.outVolume and self.outVolume != "":
            if self.volumeunit:
                self.outlineedit.setText(str(aw.float2float(self.outVolume,4)))
            else:
                self.outlineedit.setText(str(aw.float2float(self.outVolume)))
        self.closeEvent(None)
        
    def closeEvent(self,_):
        if self.unitvolumeEdit.text() and self.unitvolumeEdit.text() != "":
            aw.qmc.volumeCalcUnit = int(round(float(self.unitvolumeEdit.text())))
            aw.qmc.volumeCalcWeightInStr = str(self.coffeeinweightEdit.text())
            aw.qmc.volumeCalcWeightOutStr = str(self.coffeeoutweightEdit.text())
        self.accept()

    def close(self):
        self.closeEvent(None)
    

########################################################################################
#####################  ROAST PROPERTIES EDIT GRAPH DLG  ################################
########################################################################################

class editGraphDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(editGraphDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Properties",None, QApplication.UnicodeUTF8))
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #MARKERS
        chargelabel = QLabel("<b>" + u(QApplication.translate("Label", "CHARGE",None, QApplication.UnicodeUTF8)) + "</b>")
        chargelabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        chargelabel.setStyleSheet("background-color:'#f07800';")
        self.chargeedit = QLineEdit(aw.qmc.stringfromseconds(0))
        self.chargeedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.chargeeditcopy = aw.qmc.stringfromseconds(0)
        self.chargeedit.setValidator(QRegExpValidator(regextime,self))
        self.chargeedit.setMaximumWidth(50)
        self.chargeedit.setMinimumWidth(50)
        chargelabel.setBuddy(self.chargeedit)
        self.charge_idx = 0
        self.drop_idx = 0
        charge_str = ""
        drop_str = ""
        if len(aw.qmc.timex):
            TP_index = aw.findTP()
            if aw.qmc.timeindex[1]:
                #manual dryend available
                dryEndIndex = aw.qmc.timeindex[1]
            else:
                #find when dry phase ends 
                dryEndIndex = aw.findDryEnd(TP_index)
            self.charge_idx = aw.findBTbreak(0,dryEndIndex)
            self.drop_idx = aw.findBTbreak(dryEndIndex)
            if self.charge_idx != 0 and self.charge_idx != aw.qmc.timeindex[0]:
                charge_str = aw.qmc.stringfromseconds(int(aw.qmc.timex[self.charge_idx]))
            if self.drop_idx != 0 and self.drop_idx != aw.qmc.timeindex[6]:
                drop_str = aw.qmc.stringfromseconds(int(aw.qmc.timex[self.drop_idx]-aw.qmc.timex[aw.qmc.timeindex[0]]))
        self.chargeestimate = QLabel(charge_str)
#        self.chargeestimate.setMaximumWidth(50)
#        self.chargeestimate.setMinimumWidth(50)
        drylabel = QLabel("<b>" + u(QApplication.translate("Label", "DRY END",None, QApplication.UnicodeUTF8)) + "</b>")
        drylabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        drylabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[1]:
            t2 = int(aw.qmc.timex[aw.qmc.timeindex[1]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t2 = 0
        self.dryedit = QLineEdit(aw.qmc.stringfromseconds(t2))
        self.dryedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.dryeditcopy = aw.qmc.stringfromseconds(t2)
        self.dryedit.setValidator(QRegExpValidator(regextime,self))
        self.dryedit.setMaximumWidth(50)
        self.dryedit.setMinimumWidth(50)
        drylabel.setBuddy(self.dryedit)
        Cstartlabel = QLabel("<b>" + u(QApplication.translate("Label","FC START",None, QApplication.UnicodeUTF8)) + "</b>")
        Cstartlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        Cstartlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[2]:
            t3 = int(aw.qmc.timex[aw.qmc.timeindex[2]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t3 = 0
        self.Cstartedit = QLineEdit(aw.qmc.stringfromseconds(t3))
        self.Cstartedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.Cstarteditcopy = aw.qmc.stringfromseconds(t3)
        self.Cstartedit.setValidator(QRegExpValidator(regextime,self))
        self.Cstartedit.setMaximumWidth(50)
        self.Cstartedit.setMinimumWidth(50)
        Cstartlabel.setBuddy(self.Cstartedit)
        
        Cendlabel = QLabel("<b>" + u(QApplication.translate("Label","FC END",None, QApplication.UnicodeUTF8)) + "</b>")
        Cendlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        Cendlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[3]:
            t4 = int(aw.qmc.timex[aw.qmc.timeindex[3]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t4 = 0
        self.Cendedit = QLineEdit(aw.qmc.stringfromseconds(t4))
        self.Cendedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.Cendeditcopy = aw.qmc.stringfromseconds(t4)
        self.Cendedit.setValidator(QRegExpValidator(regextime,self))
        self.Cendedit.setMaximumWidth(50)
        self.Cendedit.setMinimumWidth(50)
        Cendlabel.setBuddy(self.Cendedit)
        CCstartlabel = QLabel("<b>" + u(QApplication.translate("Label","SC START",None, QApplication.UnicodeUTF8)) + "</b>")
        CCstartlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        CCstartlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[4]:
            t5 = int(aw.qmc.timex[aw.qmc.timeindex[4]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t5 = 0
        self.CCstartedit = QLineEdit(aw.qmc.stringfromseconds(t5))
        self.CCstartedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.CCstarteditcopy = aw.qmc.stringfromseconds(t5)
        self.CCstartedit.setValidator(QRegExpValidator(regextime,self))
        self.CCstartedit.setMaximumWidth(50)
        self.CCstartedit.setMinimumWidth(50)
        CCstartlabel.setBuddy(self.CCstartedit)
        CCendlabel = QLabel("<b>" + u(QApplication.translate("Label","SC END",None, QApplication.UnicodeUTF8)) + "</b>")
        CCendlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        CCendlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[5]:
            t6 = int(aw.qmc.timex[aw.qmc.timeindex[5]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t6 = 0
        self.CCendedit = QLineEdit(aw.qmc.stringfromseconds(t6))
        self.CCendedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.CCendeditcopy = aw.qmc.stringfromseconds(t6)
        self.CCendedit.setValidator(QRegExpValidator(regextime,self))
        self.CCendedit.setMaximumWidth(50)
        self.CCendedit.setMinimumWidth(50)
        CCendlabel.setBuddy(self.CCendedit)
        droplabel = QLabel("<b>" + u(QApplication.translate("Label", "DROP",None, QApplication.UnicodeUTF8)) + "</b>")
        droplabel.setStyleSheet("background-color:'#f07800';")
        droplabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        if aw.qmc.timeindex[6]:
            t7 = int(aw.qmc.timex[aw.qmc.timeindex[6]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t7 = 0
        self.dropedit = QLineEdit(aw.qmc.stringfromseconds(t7))
        self.dropedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.dropeditcopy = aw.qmc.stringfromseconds(t7)
        self.dropedit.setValidator(QRegExpValidator(regextime,self))
        self.dropedit.setMaximumWidth(50)
        self.dropedit.setMinimumWidth(50)
        droplabel.setBuddy(self.dropedit)
        self.dropestimate = QLabel(drop_str)
#        self.dropestimate.setMaximumWidth(50)
#        self.dropestimate.setMinimumWidth(50)
        coollabel = QLabel("<b>" + u(QApplication.translate("Label", "COOL",None, QApplication.UnicodeUTF8)) + "</b>")
        coollabel.setStyleSheet("background-color:'#6666ff';")
        coollabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        if aw.qmc.timeindex[7]:
            t8 = int(aw.qmc.timex[aw.qmc.timeindex[7]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t8 = 0
        self.cooledit = QLineEdit(aw.qmc.stringfromseconds(t8))
        self.cooledit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.cooleditcopy = aw.qmc.stringfromseconds(t8)
        self.cooledit.setValidator(QRegExpValidator(regextime,self))
        self.cooledit.setMaximumWidth(50)
        self.cooledit.setMinimumWidth(50)
        coollabel.setBuddy(self.cooledit)
        self.roastproperties = QCheckBox(QApplication.translate("CheckBox","Delete roast properties on RESET", None, QApplication.UnicodeUTF8))
        self.roastproperties.setChecked(bool(aw.qmc.roastpropertiesflag))
        self.connect(self.roastproperties,SIGNAL("stateChanged(int)"),self.roastpropertiesChanged)
        # EVENTS
        #table for showing events
        self.eventtable = QTableWidget()
        self.eventtable.setTabKeyNavigation(True)
        self.eventtablecopy = []
        self.createEventTable()
        self.ordereventTableButton = QPushButton(QApplication.translate("Button", "Order",None, QApplication.UnicodeUTF8))
        self.ordereventTableButton.setFocusPolicy(Qt.NoFocus)
        self.ordereventTableButton.setMaximumSize(self.ordereventTableButton.sizeHint())
        self.ordereventTableButton.setMinimumSize(self.ordereventTableButton.minimumSizeHint())
        self.connect(self.ordereventTableButton,SIGNAL("clicked()"),self.orderEventTable)
        self.neweventTableButton = QPushButton(QApplication.translate("Button", "Add",None, QApplication.UnicodeUTF8))
        self.neweventTableButton.setFocusPolicy(Qt.NoFocus)
        self.neweventTableButton.setMaximumSize(self.neweventTableButton.sizeHint())
        self.neweventTableButton.setMinimumSize(self.neweventTableButton.minimumSizeHint())
        self.connect(self.neweventTableButton,SIGNAL("clicked()"),self.addEventTable)
        self.deleventTableButton = QPushButton(QApplication.translate("Button", "Delete",None, QApplication.UnicodeUTF8))
        self.deleventTableButton.setFocusPolicy(Qt.NoFocus)
        self.deleventTableButton.setMaximumSize(self.deleventTableButton.sizeHint())
        self.deleventTableButton.setMinimumSize(self.deleventTableButton.minimumSizeHint())
        self.connect(self.deleventTableButton,SIGNAL("clicked()"),self.deleteEventTable)
        #DATA Table
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        #self.createDataTable()        
        #TITLE
        titlelabel = QLabel("<b>" + u(QApplication.translate("Label", "Title",None, QApplication.UnicodeUTF8)) + "</b>")
        self.titleedit = QLineEdit(aw.qmc.title)
        #Date
        datelabel1 = QLabel("<b>" + u(QApplication.translate("Label", "Date",None, QApplication.UnicodeUTF8)) + "</b>")
        date = aw.qmc.roastdate.toString()
        dateedit = QLineEdit(date)
        dateedit.setReadOnly(True)
        dateedit.setStyleSheet("background-color:'lightgrey'")
        #Beans
        beanslabel = QLabel("<b>" + u(QApplication.translate("Label", "Beans",None, QApplication.UnicodeUTF8)) + "</b>")
        self.beansedit = QTextEdit()
        self.beansedit.setMaximumHeight(45)
        if aw.qmc.beans is not None:
            self.beansedit.setPlainText(QString(aw.qmc.beans))
        #roaster
        self.roaster = QLineEdit(aw.qmc.roastertype)
        #operator
        self.operator = QLineEdit(aw.qmc.operator)
        #weight
        weightlabel = QLabel("<b>" + u(QApplication.translate("Label", "Weight",None, QApplication.UnicodeUTF8)) + "</b>")
        weightinlabel = QLabel(QApplication.translate("Label", " in",None, QApplication.UnicodeUTF8))
        weightoutlabel = QLabel(QApplication.translate("Label", " out",None, QApplication.UnicodeUTF8))
        inw = str(aw.qmc.weight[0])
        outw = str(aw.qmc.weight[1])
        self.weightinedit = QLineEdit(inw)
        self.weightinedit.setValidator(QDoubleValidator(0., 9999., 1, self.weightinedit))
        self.weightinedit.setMinimumWidth(60)
        self.weightinedit.setMaximumWidth(60)
        self.weightinedit.setAlignment(Qt.AlignRight)
        self.weightoutedit = QLineEdit(outw)
        self.weightoutedit.setValidator(QDoubleValidator(0., 9999., 1, self.weightoutedit))
        self.weightoutedit.setMinimumWidth(60)
        self.weightoutedit.setMaximumWidth(60)
        self.weightoutedit.setAlignment(Qt.AlignRight)
        self.weightpercentlabel = QLabel(QApplication.translate("Label", " %",None, QApplication.UnicodeUTF8))
        self.weightpercentlabel.setMinimumWidth(45)
        self.weightpercentlabel.setMaximumWidth(45)
        self.roastdegreelabel = QLabel("")
        self.roastdegreelabel.setMinimumWidth(80)
        self.roastdegreelabel.setMaximumWidth(80)
        self.percent()
        self.connect(self.weightoutedit,SIGNAL("editingFinished()"),self.weightouteditChanged)
        self.connect(self.weightinedit,SIGNAL("editingFinished()"),self.weightineditChanged)
        self.unitsComboBox = QComboBox()
        self.unitsComboBox.setMaximumWidth(60)
        self.unitsComboBox.setMinimumWidth(60)
        self.unitsComboBox.addItems([QApplication.translate("ComboBox", "g", None, QApplication.UnicodeUTF8),
                                     QApplication.translate("ComboBox", "Kg", None, QApplication.UnicodeUTF8)])
        if aw.qmc.weight[2] == QApplication.translate("ComboBox", "g", None, QApplication.UnicodeUTF8):
            self.unitsComboBox.setCurrentIndex(0)
        else:
            self.unitsComboBox.setCurrentIndex(1)
        self.connect(self.unitsComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.unitsComboBox.currentIndex() :self.changeWeightUnit(i))
        #volume
        volumelabel = QLabel("<b>" + u(QApplication.translate("Label", "Volume",None, QApplication.UnicodeUTF8)) + "</b>")
        volumeinlabel = QLabel(QApplication.translate("Label", " in",None, QApplication.UnicodeUTF8))
        volumeoutlabel = QLabel(QApplication.translate("Label", " out",None, QApplication.UnicodeUTF8))
        inv = str(aw.qmc.volume[0])
        outv = str(aw.qmc.volume[1])
        self.volumeinedit = QLineEdit(inv)
        self.volumeinedit.setValidator(QDoubleValidator(0., 9999., 1, self.volumeinedit))
        self.volumeinedit.setMinimumWidth(60)
        self.volumeinedit.setMaximumWidth(60)
        self.volumeinedit.setAlignment(Qt.AlignRight)
        self.volumeoutedit = QLineEdit(outv)
        self.volumeoutedit.setValidator(QDoubleValidator(0., 9999., 1, self.volumeoutedit))
        self.volumeoutedit.setMinimumWidth(60)
        self.volumeoutedit.setMaximumWidth(60)
        self.volumeoutedit.setAlignment(Qt.AlignRight)
        self.volumepercentlabel = QLabel(QApplication.translate("Label", " %",None, QApplication.UnicodeUTF8))
        self.volumepercentlabel.setMinimumWidth(45)
        self.volumepercentlabel.setMaximumWidth(45)
        self.volume_percent()
        self.connect(self.volumeoutedit,SIGNAL("editingFinished()"),self.volume_percent)
        self.connect(self.volumeinedit,SIGNAL("editingFinished()"),self.volume_percent)
        self.volumeUnitsComboBox = QComboBox()
        self.volumeUnitsComboBox.setMaximumWidth(60)
        self.volumeUnitsComboBox.setMinimumWidth(60)
        self.volumeUnitsComboBox.addItems([QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8),
                                           QApplication.translate("ComboBox", "l",None, QApplication.UnicodeUTF8)])
        if aw.qmc.volume[2] == QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8):
            self.volumeUnitsComboBox.setCurrentIndex(0)
        else:
            self.volumeUnitsComboBox.setCurrentIndex(1)
        self.connect(self.volumeUnitsComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.volumeUnitsComboBox.currentIndex() :self.changeVolumeUnit(i))
        self.calculateddensitylabel = QLabel("")
        self.connect(self.weightoutedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.weightinedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.volumeoutedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.volumeinedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.volumeUnitsComboBox,SIGNAL("currentIndexChanged(int)"),self.calculated_density)
        self.connect(self.unitsComboBox,SIGNAL("currentIndexChanged(int)"),self.calculated_density)
        #density
        bean_density_label = QLabel("<b>" + u(QApplication.translate("Label", "Density",None, QApplication.UnicodeUTF8)) + "</b>")
        self.bean_density_weight_edit = QLineEdit(str(aw.qmc.density[0]))
        self.bean_density_weight_edit.setValidator(QDoubleValidator(0., 9999., 1,self.bean_density_weight_edit))
        self.bean_density_weight_edit.setMinimumWidth(60)
        self.bean_density_weight_edit.setMaximumWidth(60)
        self.bean_density_weight_edit.setAlignment(Qt.AlignRight)
        self.bean_density_weightUnitsComboBox = QComboBox()
        self.bean_density_weightUnitsComboBox.setMaximumWidth(60)
        self.bean_density_weightUnitsComboBox.setMinimumWidth(60)
        self.bean_density_weightUnitsComboBox.addItems([QApplication.translate("ComboBox", "g",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("ComboBox", "Kg",None, QApplication.UnicodeUTF8)])
        if aw.qmc.density[1] == QApplication.translate("ComboBox", "g",None, QApplication.UnicodeUTF8):
            self.bean_density_weightUnitsComboBox.setCurrentIndex(0)
        else:
            self.bean_density_weightUnitsComboBox.setCurrentIndex(1)
        bean_density_per_label = QLabel(QApplication.translate("Label", "per",None, QApplication.UnicodeUTF8))
        self.bean_density_volume_edit = QLineEdit(str(aw.qmc.density[2]))
        self.bean_density_volume_edit.setValidator(QDoubleValidator(0., 9999., 1,self.bean_density_volume_edit))
        self.bean_density_volume_edit.setMinimumWidth(60)
        self.bean_density_volume_edit.setMaximumWidth(60)
        self.bean_density_volume_edit.setAlignment(Qt.AlignRight)
        self.bean_density_volumeUnitsComboBox = QComboBox()
        self.bean_density_volumeUnitsComboBox.setMaximumWidth(60)
        self.bean_density_volumeUnitsComboBox.setMinimumWidth(60)
        self.bean_density_volumeUnitsComboBox.addItems([QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("ComboBox", "l",None, QApplication.UnicodeUTF8)])
        if aw.qmc.density[3] == QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8):
            self.bean_density_volumeUnitsComboBox.setCurrentIndex(0)
        else:
            self.bean_density_volumeUnitsComboBox.setCurrentIndex(1)
        self.standarddensitylabel = QLabel("")
        self.standard_density()
        self.connect(self.bean_density_volume_edit,SIGNAL("editingFinished()"),self.standard_density)
        self.connect(self.bean_density_weight_edit,SIGNAL("editingFinished()"),self.standard_density)
        self.connect(self.bean_density_weightUnitsComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.unitsComboBox.currentIndex() :self.changeDensityWeightUnit(i))
        self.connect(self.bean_density_volumeUnitsComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.unitsComboBox.currentIndex() :self.changeDensityVolumeUnit(i))
        
        # volume calc button
        volumeCalcButton = QPushButton(QApplication.translate("Button", "calc",None, QApplication.UnicodeUTF8))
        self.connect(volumeCalcButton, SIGNAL("clicked()"),self.volumeCalculator)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        volumeCalcButton.setMaximumSize(60,35)
#        volumeCalcButton.setMinimumSize(60,35) 
        volumeCalcButton.setFocusPolicy(Qt.NoFocus)
        
        #bean size
        bean_size_label = QLabel("<b>" + u(QApplication.translate("Label", "Bean Size",None, QApplication.UnicodeUTF8)) + "</b>")
        self.bean_size_edit = QLineEdit(str(aw.qmc.beansize))
        self.bean_size_edit.setValidator(QDoubleValidator(0., 10., 1,self.bean_density_weight_edit))
        self.bean_size_edit.setMinimumWidth(45)
        self.bean_size_edit.setMaximumWidth(45)
        self.bean_size_edit.setAlignment(Qt.AlignRight)
        bean_size_unit_label = QLabel(QApplication.translate("Label", "mm",None, QApplication.UnicodeUTF8))
        #bean color
        whole_color_label = QLabel("<b>" + u(QApplication.translate("Label", "Whole Color",None, QApplication.UnicodeUTF8)) + "</b>")
        self.whole_color_edit = QLineEdit(str(aw.qmc.whole_color))
        self.whole_color_edit.setValidator(QIntValidator(0, 1000, self.bean_density_weight_edit))
        self.whole_color_edit.setMinimumWidth(45)
        self.whole_color_edit.setMaximumWidth(45)
        self.whole_color_edit.setAlignment(Qt.AlignRight)
        ground_color_label = QLabel("<b>" + u(QApplication.translate("Label", "Ground Color",None, QApplication.UnicodeUTF8)) + "</b>")
        self.ground_color_edit = QLineEdit(str(aw.qmc.ground_color))
        self.ground_color_edit.setValidator(QIntValidator(0, 1000, self.bean_density_weight_edit))
        self.ground_color_edit.setMinimumWidth(45)
        self.ground_color_edit.setMaximumWidth(45)
        self.ground_color_edit.setAlignment(Qt.AlignRight)
        self.bean_size_edit.setAlignment(Qt.AlignRight)
        self.colorSystemComboBox = QComboBox()
        self.colorSystemComboBox.addItems(aw.qmc.color_systems)
        self.colorSystemComboBox.setCurrentIndex(aw.qmc.color_system_idx)
        #Moisture Greens
        moisture_greens_label = QLabel("<b>" + u(QApplication.translate("Label", "Moisture Greens",None, QApplication.UnicodeUTF8)) + "</b>")
#        moisture_greens_unitslabel = QLabel(aw.qmc.mode)
        moisture_greens_unit_label = QLabel(QApplication.translate("Label", "%",None, QApplication.UnicodeUTF8))
        self.moisture_greens_edit = QLineEdit()
        self.moisture_greens_edit.setText(str(aw.qmc.moisture_greens))
        self.moisture_greens_edit.setMaximumWidth(50)
        self.moisture_greens_edit.setValidator(QDoubleValidator(0., 100., 1, self.moisture_greens_edit))
        self.moisture_greens_edit.setAlignment(Qt.AlignRight)
        #Moisture Roasted
        #bag humidity
        moisture_roasted_label = QLabel("<b>" + u(QApplication.translate("Label", "Moisture Roasted",None, QApplication.UnicodeUTF8)) + "</b>")
        moisture_roasted_unit_label = QLabel(QApplication.translate("Label", "%",None, QApplication.UnicodeUTF8))
        self.moisture_roasted_edit = QLineEdit()
        self.moisture_roasted_edit.setText(str(aw.qmc.moisture_roasted))
        self.moisture_roasted_edit.setMaximumWidth(50)
        self.moisture_roasted_edit.setValidator(QDoubleValidator(0., 100., 1, self.moisture_roasted_edit))
        self.moisture_roasted_edit.setAlignment(Qt.AlignRight)
        self.connect(self.moisture_greens_edit,SIGNAL("editingFinished()"),self.calculated_organic_loss)        
        self.connect(self.moisture_roasted_edit,SIGNAL("editingFinished()"),self.calculated_organic_loss)
        #Ambient temperature (uses display mode as unit (F or C)
        ambientlabel = QLabel("<b>" + u(QApplication.translate("Label", "Ambient Conditions",None, QApplication.UnicodeUTF8)) + "</b>")
        ambientunitslabel = QLabel(aw.qmc.mode)
        ambient_humidity_unit_label = QLabel(QApplication.translate("Label", "%",None, QApplication.UnicodeUTF8))
        self.ambient_humidity_edit = QLineEdit()
        self.ambient_humidity_edit.setText(str(aw.qmc.ambient_humidity))
        self.ambient_humidity_edit.setMaximumWidth(50)
        self.ambient_humidity_edit.setValidator(QDoubleValidator(0., 100., 1, self.ambient_humidity_edit))  
        self.ambient_humidity_edit.setAlignment(Qt.AlignRight) 
        ambient_humidity_at_label = QLabel(QApplication.translate("Label", "at",None, QApplication.UnicodeUTF8))
        self.ambientedit = QLineEdit()
        self.ambientedit.setText(str(aw.qmc.ambientTemp))
        self.ambientedit.setMaximumWidth(50)
        self.ambientedit.setValidator(QDoubleValidator(0., 200., 1, self.ambientedit))  
        self.ambientedit.setAlignment(Qt.AlignRight)       
        self.ambientedit_tempUnitsComboBox = QComboBox()
        self.ambientedit_tempUnitsComboBox.setMaximumWidth(60)
        self.ambientedit_tempUnitsComboBox.setMinimumWidth(60)
        self.calculateorganiclosslabel = QLabel("")
        # NOTES
        roastertypelabel = QLabel()
        roastertypelabel.setText("<b>" + u(QApplication.translate("Label", "Roaster",None, QApplication.UnicodeUTF8)) + "</b>")
        operatorlabel = QLabel()
        operatorlabel.setText("<b>" + u(QApplication.translate("Label", "Operator",None, QApplication.UnicodeUTF8)) + "</b>")
        roastinglabel = QLabel("<b>" + u(QApplication.translate("Label", "Roasting Notes",None, QApplication.UnicodeUTF8)) + "</b>")
        self.roastingeditor = QTextEdit()
        if aw.qmc.roastingnotes is not None:
            self.roastingeditor.setPlainText(QString(aw.qmc.roastingnotes))
        cuppinglabel = QLabel("<b>" + u(QApplication.translate("Label", "Cupping Notes",None, QApplication.UnicodeUTF8)) + "</b>")
        self.cuppingeditor =  QTextEdit()
        if aw.qmc.cuppingnotes is not None:
            self.cuppingeditor.setPlainText(QString(aw.qmc.cuppingnotes))
        # Flags
        self.heavyFC = QCheckBox(QApplication.translate("CheckBox","Heavy FC", None, QApplication.UnicodeUTF8))
        self.heavyFC.setChecked(aw.qmc.heavyFC_flag)
        self.connect(self.heavyFC,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("heavyFC",x))
        self.lowFC = QCheckBox(QApplication.translate("CheckBox","Low FC", None, QApplication.UnicodeUTF8))
        self.lowFC.setChecked(aw.qmc.lowFC_flag)
        self.connect(self.lowFC,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("lowFC",x))
        self.lightCut = QCheckBox(QApplication.translate("CheckBox","Light Cut", None, QApplication.UnicodeUTF8))
        self.lightCut.setChecked(aw.qmc.lightCut_flag)
        self.connect(self.lightCut,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("lightCut",x))
        self.darkCut = QCheckBox(QApplication.translate("CheckBox","Dark Cut", None, QApplication.UnicodeUTF8))
        self.darkCut.setChecked(aw.qmc.darkCut_flag)
        self.connect(self.darkCut,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("darkCut",x))        
        self.drops = QCheckBox(QApplication.translate("CheckBox","Drops", None, QApplication.UnicodeUTF8))
        self.drops.setChecked(aw.qmc.drops_flag)
        self.connect(self.drops,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("drops",x))
        self.oily = QCheckBox(QApplication.translate("CheckBox","Oily", None, QApplication.UnicodeUTF8))
        self.oily.setChecked(aw.qmc.oily_flag)
        self.connect(self.oily,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("oily",x))
        self.uneven = QCheckBox(QApplication.translate("CheckBox","Uneven", None, QApplication.UnicodeUTF8))
        self.uneven.setChecked(aw.qmc.uneven_flag)
        self.tipping = QCheckBox(QApplication.translate("CheckBox","Tipping", None, QApplication.UnicodeUTF8))
        self.tipping.setChecked(aw.qmc.tipping_flag)
        self.scorching = QCheckBox(QApplication.translate("CheckBox","Scorching", None, QApplication.UnicodeUTF8))
        self.scorching.setChecked(aw.qmc.scorching_flag)
        self.divots = QCheckBox(QApplication.translate("CheckBox","Divots", None, QApplication.UnicodeUTF8))
        self.divots.setChecked(aw.qmc.divots_flag)
        # Save button
        saveButton = QPushButton(QApplication.translate("Button", "OK",None, QApplication.UnicodeUTF8))
        self.connect(saveButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        saveButton.setMaximumSize(saveButton.sizeHint())
        saveButton.setMinimumSize(saveButton.minimumSizeHint()) 
        #Cancel Button
        cancelButton = QPushButton(QApplication.translate("Button", "Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        cancelButton.setMaximumSize(cancelButton.sizeHint())
        cancelButton.setMinimumSize(cancelButton.minimumSize())
        
        # container tare
        self.tareComboBox = QComboBox()
        self.tareComboBox.addItem("<edit> TARE")
        self.tareComboBox.addItem("")
        self.tareComboBox.insertSeparator(1)
        self.tareComboBox.addItems(aw.qmc.container_names)
        self.tareComboBox.setMaximumWidth(80)
        self.tareComboBox.setMinimumWidth(80)
        self.tareComboBox.setCurrentIndex(aw.qmc.container_idx + 3)
        self.connect(self.tareComboBox,SIGNAL("currentIndexChanged(int)"),self.tareChanged)
        self.tarePopupEnabled = True # controls if the popup will process tareChange events
        
        # in button
        inButton = QPushButton(QApplication.translate("Button", "in",None, QApplication.UnicodeUTF8))
        self.connect(inButton, SIGNAL("clicked()"),self.inWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        inButton.setMaximumSize(60,35)
#        inButton.setMinimumSize(60,35) 
        inButton.setFocusPolicy(Qt.NoFocus)
        # out button
        outButton = QPushButton(QApplication.translate("Button", "out",None, QApplication.UnicodeUTF8))
        self.connect(outButton, SIGNAL("clicked()"),self.outWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        outButton.setMaximumSize(60,35)
#        outButton.setMinimumSize(60,35) 
        outButton.setFocusPolicy(Qt.NoFocus)
        # scan whole button
        scanWholeButton = QPushButton(QApplication.translate("Button", "scan",None, QApplication.UnicodeUTF8))
        self.connect(scanWholeButton, SIGNAL("clicked()"),self.scanWholeColor)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        scanWholeButton.setMaximumSize(60,35)
#        scanWholeButton.setMinimumSize(60,35) 
        scanWholeButton.setFocusPolicy(Qt.NoFocus)
        # scan ground button
        scanGroundButton = QPushButton(QApplication.translate("Button", "scan",None, QApplication.UnicodeUTF8))
        self.connect(scanGroundButton, SIGNAL("clicked()"),self.scanGroundColor)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
#        scanGroundButton.setMaximumSize(60,35)
#        scanGroundButton.setMinimumSize(60,35) 
        scanGroundButton.setFocusPolicy(Qt.NoFocus)
        # Ambient Temperature Source Selector
        self.ambientComboBox = QComboBox()
        self.ambientComboBox.addItems(self.buildAmbientTemperatureSourceList())
        self.ambientComboBox.setCurrentIndex(aw.qmc.ambientTempSource)
        self.connect(self.ambientComboBox, SIGNAL("currentIndexChanged(int)"),self.ambientComboBoxIndexChanged)
        ambientSourceLabel = QLabel(QApplication.translate("Label", "Ambient Source",None, QApplication.UnicodeUTF8))
        updateAmbientTemp = QPushButton(QApplication.translate("Button", "calc",None, QApplication.UnicodeUTF8))
        updateAmbientTemp.setFocusPolicy(Qt.NoFocus)
        self.connect(updateAmbientTemp, SIGNAL("clicked()"),self.updateAmbientTemp)
        ##### LAYOUTS
        timeLayout = QGridLayout()
        timeLayout.setVerticalSpacing(3)
        timeLayout.addWidget(chargelabel,0,0)
        timeLayout.addWidget(drylabel,0,1)
        timeLayout.addWidget(Cstartlabel,0,2)
        timeLayout.addWidget(Cendlabel,0,3)
        timeLayout.addWidget(CCstartlabel,0,4)
        timeLayout.addWidget(CCendlabel,0,5)
        timeLayout.addWidget(droplabel,0,6)
        timeLayout.addWidget(coollabel,0,7)
        timeLayout.addWidget(self.chargeedit,1,0,Qt.AlignHCenter)
        timeLayout.addWidget(self.dryedit,1,1,Qt.AlignHCenter)
        timeLayout.addWidget(self.Cstartedit,1,2,Qt.AlignHCenter)
        timeLayout.addWidget(self.Cendedit,1,3,Qt.AlignHCenter)
        timeLayout.addWidget(self.CCstartedit,1,4,Qt.AlignHCenter)
        timeLayout.addWidget(self.CCendedit,1,5,Qt.AlignHCenter)
        timeLayout.addWidget(self.dropedit,1,6,Qt.AlignHCenter)
        timeLayout.addWidget(self.cooledit,1,7,Qt.AlignHCenter)
        if charge_str != "" or drop_str != "":
            timeLayout.addWidget(self.chargeestimate,2,0,Qt.AlignHCenter)
            timeLayout.addWidget(self.dropestimate,2,6,Qt.AlignHCenter)
        textLayout = QGridLayout()
        textLayout.addWidget(datelabel1,0,0)
        textLayout.addWidget(dateedit,0,1)
        textLayout.addWidget(titlelabel,1,0)
        textLayout.addWidget(self.titleedit,1,1)
        textLayout.addWidget(beanslabel,2,0)
        textLayout.addWidget(self.beansedit,2,1)
        textLayout.addWidget(roastertypelabel,3,0)
        textLayout.addWidget(self.roaster,3,1)
        textLayout.addWidget(operatorlabel,4,0)
        textLayout.addWidget(self.operator,4,1)
        weightLayout = QHBoxLayout()
        weightLayout.setSpacing(0)
        weightLayout.addWidget(weightlabel)
        weightLayout.addSpacing(18)
        weightLayout.addWidget(self.unitsComboBox)
        weightLayout.addSpacing(15)
        weightLayout.addWidget(self.weightinedit)
        weightLayout.addSpacing(1)
        weightLayout.addWidget(weightinlabel)
        weightLayout.addSpacing(15)
        weightLayout.addWidget(self.weightoutedit)
        weightLayout.addSpacing(1)
        weightLayout.addWidget(weightoutlabel)
        weightLayout.addSpacing(15)
        weightLayout.addWidget(self.weightpercentlabel)
#        weightLayout.addSpacing(10)
#        weightLayout.addWidget(self.roastdegreelabel)
        weightLayout.addStretch()  
        if aw.scale.device != None and aw.scale.device != "" and aw.scale.device != "None":
            weightLayout.addWidget(self.tareComboBox)
            weightLayout.addSpacing(10)
            weightLayout.addWidget(inButton) 
            weightLayout.addSpacing(10)
            weightLayout.addWidget(outButton)
        volumeLayout = QHBoxLayout()
        volumeLayout.setSpacing(0)
        volumeLayout.addWidget(volumelabel)
        volumeLayout.addSpacing(14)
        volumeLayout.addWidget(self.volumeUnitsComboBox)
        volumeLayout.addSpacing(15)
        volumeLayout.addWidget(self.volumeinedit)
        volumeLayout.addSpacing(1)
        volumeLayout.addWidget(volumeinlabel)
        volumeLayout.addSpacing(15)
        volumeLayout.addWidget(self.volumeoutedit)
        volumeLayout.addSpacing(1)
        volumeLayout.addWidget(volumeoutlabel)
        volumeLayout.addSpacing(15)
        volumeLayout.addWidget(self.volumepercentlabel)
        volumeLayout.addStretch()
        volumeLayout.addWidget(volumeCalcButton)
        densityLayout = QHBoxLayout()
        densityLayout.setContentsMargins(0,0,0,0)
        densityLayout.setSpacing(0)
        densityLayout.addWidget(bean_density_label)
        densityLayout.addSpacing(13)
        densityLayout.addWidget(self.bean_density_weightUnitsComboBox)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(self.bean_density_weight_edit)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(bean_density_per_label)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(self.bean_density_volumeUnitsComboBox)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(self.bean_density_volume_edit)
        densityLayout.addSpacing(20)
        densityLayout.addWidget(self.standarddensitylabel)
        densityLayout.addStretch()
        beansizeLayout = QHBoxLayout()
        beansizeLayout.setContentsMargins(0,0,0,0)
        beansizeLayout.setSpacing(0)
        beansizeLayout.addWidget(bean_size_label)
        beansizeLayout.addSpacing(15)
        beansizeLayout.addWidget(self.bean_size_edit)
        beansizeLayout.addSpacing(5)
        beansizeLayout.addWidget(bean_size_unit_label)
        beansizeLayout.addStretch()
        colorLayout = QHBoxLayout()
        colorLayout.setSpacing(0)
        colorLayout.addWidget(whole_color_label)
        colorLayout.addSpacing(15)
        colorLayout.addWidget(self.whole_color_edit)
        if aw.color.device != None and aw.color.device != "" and aw.color.device != "None":
            colorLayout.addSpacing(5)
            colorLayout.addWidget(scanWholeButton)
        colorLayout.addSpacing(25)
        colorLayout.addWidget(ground_color_label)
        colorLayout.addSpacing(15)
        colorLayout.addWidget(self.ground_color_edit)
        if aw.color.device != None and aw.color.device != "" and aw.color.device != "None":
            colorLayout.addSpacing(5)
            colorLayout.addWidget(scanGroundButton)
        colorLayout.addStretch()
        colorLayout.addWidget(self.colorSystemComboBox)        
        humidityGrid = QGridLayout()
        humidityGrid.addWidget(moisture_greens_label,0,0)
        humidityGrid.addWidget(self.moisture_greens_edit,0,1)
        humidityGrid.addWidget(moisture_greens_unit_label,0,2)
        humidityGrid.addWidget(moisture_roasted_label,1,0)
        humidityGrid.addWidget(self.moisture_roasted_edit,1,1)
        humidityGrid.addWidget(moisture_roasted_unit_label,1,2)
        humidityGrid.addWidget(ambientSourceLabel,1,9,Qt.AlignRight)
        humidityGrid.addWidget(ambientlabel,2,0)
        humidityGrid.addWidget(self.ambient_humidity_edit,2,1)
        humidityGrid.addWidget(ambient_humidity_unit_label,2,2)
        humidityGrid.addWidget(ambient_humidity_at_label,2,4)
        humidityGrid.addWidget(self.ambientedit,2,6)
        humidityGrid.addWidget(ambientunitslabel,2,7)
        humidityGrid.addWidget(updateAmbientTemp,2,8)
        humidityGrid.addWidget(self.ambientComboBox,2,9,Qt.AlignRight)
        roastFlagsLayout = QHBoxLayout()
        roastFlagsGrid = QGridLayout()
        roastFlagsGrid.addWidget(self.lowFC,0,0)
        roastFlagsGrid.addWidget(self.heavyFC,1,0)
        roastFlagsGrid.addWidget(self.lightCut,0,1)
        roastFlagsGrid.addWidget(self.darkCut,1,1)
        roastFlagsGrid.addWidget(self.drops,0,2)
        roastFlagsGrid.addWidget(self.oily,1,2)
        roastFlagsGrid.addWidget(self.uneven,0,3)
        roastFlagsGrid.addWidget(self.tipping,1,3)
        roastFlagsGrid.addWidget(self.scorching,0,4)
        roastFlagsGrid.addWidget(self.divots,1,4)
        roastFlagsLayout.addLayout(roastFlagsGrid)
        roastFlagsLayout.addStretch()
        anotationLayout = QVBoxLayout()
        anotationLayout.addWidget(roastinglabel)
        anotationLayout.addWidget(self.roastingeditor)
        anotationLayout.addLayout(roastFlagsLayout)
        anotationLayout.addWidget(cuppinglabel)
        anotationLayout.addWidget(self.cuppingeditor)
        okLayout = QHBoxLayout()
        okLayout.addStretch()
        okLayout.addWidget(cancelButton,0)
        okLayout.addWidget(saveButton,1)
        okLayout.setContentsMargins(0, 0, 0, 0) # left, top, right, bottom
        timeLayoutBox = QHBoxLayout()
#        timeLayout.setSpacing(3)
#        timeLayout.setContentsMargins(0, 0, 0, 0)
        timeLayoutBox.addStretch()
        timeLayoutBox.addLayout(timeLayout)
        timeLayoutBox.addStretch()
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(timeLayoutBox)
#        mainLayout.setSpacing(3)
        mainLayout.setContentsMargins(3, 3, 3, 3)
        timeGroupLayout = QGroupBox(QApplication.translate("GroupBox", "Times",None, QApplication.UnicodeUTF8))
        timeGroupLayout.setLayout(mainLayout)
        eventbuttonLayout = QHBoxLayout()
        eventbuttonLayout.addStretch()
        eventbuttonLayout.addWidget(self.ordereventTableButton)
        eventbuttonLayout.addWidget(self.deleventTableButton)
        eventbuttonLayout.addWidget(self.neweventTableButton)
        #tab 1
        self.tab1aLayout = QVBoxLayout()
        self.tab1aLayout.setMargin(0)
        self.tab1aLayout.setSpacing(2)
        self.tab1aLayout.addWidget(timeGroupLayout)
        self.tab1aLayout.addStretch()
        self.tab1aLayout.addLayout(textLayout)
        self.tab1aLayout.addStretch()
        self.tab1aLayout.addLayout(weightLayout)
        self.tab1aLayout.addLayout(volumeLayout)
        self.tab1bLayout = QVBoxLayout()
        self.tab1bLayout.setMargin(0)
        self.tab1bLayout.setSpacing(2)
        self.tab1bLayout.addLayout(densityLayout)
        self.tab1bLayout.addLayout(beansizeLayout)
        self.tab1bLayout.addLayout(colorLayout)
        self.tab1bLayout.addLayout(humidityGrid)
        roastpropertiesLayout = QHBoxLayout()
        roastpropertiesLayout.addWidget(self.roastproperties)
        roastpropertiesLayout.addStretch()
        tab1Layout = QVBoxLayout()
        tab1Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab1Layout.setMargin(0)
        tab1Layout.addLayout(self.tab1aLayout)
        tab1Layout.addLayout(self.tab1bLayout)
        tab1Layout.addLayout(roastpropertiesLayout)
        self.calculated_density()
        #tab 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addLayout(anotationLayout)
        tab2Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab2Layout.setMargin(0)
        #tab3 events
        tab3Layout = QVBoxLayout()
        tab3Layout.addWidget(self.eventtable)
        tab3Layout.addLayout(eventbuttonLayout)
        tab3Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab3Layout.setMargin(0)
        #tab 4 data
        tab4Layout = QVBoxLayout()
        tab4Layout.addWidget(self.datatable) 
        tab4Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom 
        tab4Layout.setMargin(0)
        #tabwidget
        self.TabWidget = QTabWidget()
        self.TabWidget.setContentsMargins(0,0,0,0)
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab", "General",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab", "Notes",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab", "Events",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        self.TabWidget.addTab(C4Widget,QApplication.translate("Tab", "Data",None, QApplication.UnicodeUTF8))        
        self.connect(self.TabWidget,SIGNAL("currentChanged(int)"),lambda i=0:self.tabSwitched(i))
        #incorporate layouts
        totallayout = QVBoxLayout()
        totallayout.addWidget(self.TabWidget)
        totallayout.addLayout(okLayout)
#        totallayout.setMargin(5)
        totallayout.setContentsMargins(10,10,10,0)
        #totallayout.addStretch()
        #totallayout.addLayout(buttonsLayout)
        self.setLayout(totallayout)

    # calcs volume (in ml) from density (in g/l) and weight (in g)
    def calc_volume(self,density,weight):
        return (1./density) * weight * 1000

    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        key = int(event.key())
        if key == 16777220 and aw.scale.device != None and aw.scale.device != "" and aw.scale.device != "None": # ENTER key pressed and scale connected
            if self.weightinedit.hasFocus():
                self.inWeight()
            elif self.weightoutedit.hasFocus():
                self.outWeight()
            elif self.volumeinedit.hasFocus() and (str(self.volumeinedit.text()) == "" or float(self.volumeinedit.text()) == 0.):
                try:
                    dw = float(str(self.bean_density_weight_edit.text()))
                    dv = float(str(self.bean_density_volume_edit.text()))                    
                    if self.bean_density_weightUnitsComboBox.currentText() != QApplication.translate("ComboBox","g", None, QApplication.UnicodeUTF8) :
                        dw = dw * 1000.0
                    if self.bean_density_volumeUnitsComboBox.currentText() == QApplication.translate("ComboBox","ml", None, QApplication.UnicodeUTF8) :
                        dv = dv / 1000.0
                    d = dw / dv
                    w = self.weightinedit.text()
                    if self.unitsComboBox.currentIndex() == 1:
                        w = w * 1000.0
                    if d and d != "" and w and w != "":
                        # calculate in-volume from density and weight
                        d = float(d)
                        w = float(w)
                        res = self.calc_volume(d,w)
                        if self.volumeUnitsComboBox.currentIndex() == 1:
                            res = res / 1000.0
                            self.volumeinedit.setText(str(aw.float2float(res,4)))
                        else:
                            self.volumeinedit.setText(str(aw.float2float(res)))
                except:
                    pass
                        
    def tareChanged(self,i):
        if i == 0 and self.tarePopupEnabled:
            self.tareDLG = tareDlg(self,tarePopup=self)
            self.tareDLG.show()
            QApplication.processEvents()
            # reset index and popup
            self.tareComboBox.setCurrentIndex(aw.qmc.container_idx + 3)

    def changeUnit(self,i,lineedits):
        for le in lineedits:
            if le.text() and le.text() != "":
                wi = float(le.text())
                if wi != 0.0:
                    if i == 0:
                        le.setText(str(wi*1000.))
                    else:
                        le.setText(str(wi/1000.))

    def changeWeightUnit(self,i):
        aw.qmc.weight[2] = u(self.unitsComboBox.currentText())
        self.changeUnit(i,[self.weightinedit,self.weightoutedit])
        
    def changeVolumeUnit(self,i):
        aw.qmc.volume[2] = u(self.volumeUnitsComboBox.currentText())
        self.changeUnit(i,[self.volumeinedit,self.volumeoutedit])
        
    def changeDensityWeightUnit(self,i):
        aw.qmc.density[1] = u(self.bean_density_volumeUnitsComboBox.currentText())
        self.changeUnit(i,[self.bean_density_weight_edit])

    def changeDensityVolumeUnit(self,i):
        aw.qmc.density[3] = u(self.bean_density_volumeUnitsComboBox.currentText())
        self.changeUnit(i,[self.bean_density_volume_edit])

    def tabSwitched(self,i):
        if i == 3:
            self.createDataTable()
            
    def roastflagChanged(self,flagname,x):
        if x == Qt.Checked:
            if flagname == "heavyFC":
                self.lowFC.setChecked(False)
            elif flagname == "lowFC":
                self.heavyFC.setChecked(False)
            elif flagname == "lightCut":
                self.darkCut.setChecked(False)
            elif flagname == "darkCut":
                self.lightCut.setChecked(False)
            elif flagname == "drops":
                self.oily.setChecked(False)
            elif flagname == "oily":
                self.drops.setChecked(False)

    def ambientComboBoxIndexChanged(self,i):
        aw.qmc.ambientTempSource = i

    def buildAmbientTemperatureSourceList(self):
        extra_names = []
        for i in range(len(aw.qmc.extradevices)):
            extra_names.append(u(i) + "xT1: " + aw.qmc.extraname1[i])
            extra_names.append(u(i) + "xT2: " + aw.qmc.extraname2[i])
        return ["",
                QApplication.translate("ComboBox","ET",None, QApplication.UnicodeUTF8),
                QApplication.translate("ComboBox","BT",None, QApplication.UnicodeUTF8)] + extra_names

    def updateAmbientTemp(self):
        aw.qmc.updateAmbientTemp()
        self.ambientedit.setText(str(aw.qmc.ambientTemp))

    def scanWholeColor(self):
        v = aw.color.readColor()
        if v >= 0 and v <= 250:
            aw.qmc.whole_color = v
            self.whole_color_edit.setText(str(v))

    def scanGroundColor(self):
        v = aw.color.readColor()
        v = max(0,min(250,v))
        aw.qmc.ground_color = v
        self.ground_color_edit.setText(str(v))

    def volumeCalculator(self):
        weightin = None
        weightout = None
        try:
            weightin = float(self.weightinedit.text())
        except:
            pass
        try:
            weightout = float(self.weightoutedit.text())
        except:
            pass
        if self.bean_density_weightUnitsComboBox.currentText() != QApplication.translate("ComboBox","g", None, QApplication.UnicodeUTF8):
            k = 1000.
        else:
            k = 1.
        if weightin:
            weightin = weightin * k
        else:
            weightin = None
        if weightout:
            weightout = weightout * k
        else:
            weightout = None
        tare = 0
        try:
            tare_idx = self.tareComboBox.currentIndex() - 3
            if tare_idx > -1:
                tare = aw.qmc.container_weights[tare_idx]
        except:
            pass
        volumedialog = volumeCalculatorDlg(self,
            weightIn=weightin,
            weightOut=weightout,
            weightunit=self.unitsComboBox.currentIndex(),
            volumeunit=self.volumeUnitsComboBox.currentIndex(),
            inlineedit=self.volumeinedit,
            outlineedit=self.volumeoutedit,
            tare=tare)
        volumedialog.show()
        volumedialog.setFixedSize(volumedialog.size())        

    def outWeight(self):
        tare = 0
        try:
            tare_idx = self.tareComboBox.currentIndex() - 3
            if tare_idx > -1:
                tare = aw.qmc.container_weights[tare_idx]
        except:
            pass
        previous_out = aw.qmc.weight[1]
        aw.retrieveWeightOut(tare)
        if tare != 0 and previous_out == aw.qmc.weight[1] and self.weightoutedit.text() != "" and self.weightoutedit.text().toFloat()[0] != 0.0:
            # no value received from scale:
            # we reduce the tare from the outWeight
            text_out = self.weightoutedit.text().toFloat()[0]
            if aw.qmc.weight[2] != 'g':
                text_out = ((text_out*1000.) - tare) / 1000.
            else:
                text_out = text_out - tare
            self.weightoutedit.setText(str(aw.float2float(text_out)))
        elif previous_out != aw.qmc.weight[1]:
            self.weightoutedit.setText(str(aw.float2float(aw.qmc.weight[1])))

    def inWeight(self):
        tare = 0
        try:
            tare_idx = self.tareComboBox.currentIndex() - 3
            if tare_idx > -1:
                tare = aw.qmc.container_weights[tare_idx]
        except:
            pass
        previous_in = aw.qmc.weight[0]
        aw.retrieveWeightIn(tare)
        if tare != 0 and previous_in == aw.qmc.weight[0] and self.weightinedit.text() != "" and self.weightinedit.text().toFloat()[0] != 0.0:
            # no value received from scale:
            # we reduce the tare from the inWeight
            text_in = self.weightinedit.text().toFloat()[0]
            if aw.qmc.weight[2] != 'g':
                text_in = ((text_in*1000.) - tare) / 1000.
            else:
                text_in = text_in - tare
            self.weightinedit.setText(str(aw.float2float(text_in)))
        elif previous_in != aw.qmc.weight[0]:
            self.weightinedit.setText(str(aw.float2float(aw.qmc.weight[0])))

    def roastpropertiesChanged(self):
        if self.roastproperties.isChecked():
            aw.qmc.roastpropertiesflag = 1
        else:
            aw.qmc.roastpropertiesflag = 0

    def createDataTable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.timex)
        self.datatable.setRowCount(ndata)
        columns = [QApplication.translate("Table", "Time",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "ET",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "BT",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "DeltaET",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "DeltaBT",None, QApplication.UnicodeUTF8)]
        for i in range(len(aw.qmc.extratimex)):
            columns.append(aw.qmc.extraname1[i])
            columns.append(aw.qmc.extraname2[i])
        columns.append("") # add a last dummy table that extends
        self.datatable.setColumnCount(len(columns))
        self.datatable.setHorizontalHeaderLabels(columns)
        self.datatable.setAlternatingRowColors(True)
        self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
        self.datatable.setSelectionMode(QTableWidget.SingleSelection)
        self.datatable.setShowGrid(True)
        self.datatable.verticalHeader().setResizeMode(2)
        for i in range(ndata):
            Rtime = QTableWidgetItem(aw.qmc.stringfromseconds(int(round(aw.qmc.timex[i]-aw.qmc.timex[aw.qmc.timeindex[0]]))))
            Rtime.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            if aw.qmc.LCDdecimalplaces:
                fmtstr = "%.1f"
            else:
                fmtstr = "%.0f"
            ET = QTableWidgetItem(fmtstr%aw.qmc.temp1[i])
            BT = QTableWidgetItem(fmtstr%aw.qmc.temp2[i])
            ET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            BT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            if i > 0 and (aw.qmc.timex[i]-aw.qmc.timex[i-1]):
                deltaET = QTableWidgetItem("%.1f"%(60*(aw.qmc.temp1[i]-aw.qmc.temp1[i-1])/(aw.qmc.timex[i]-aw.qmc.timex[i-1])))
                deltaBT = QTableWidgetItem("%.1f"%(60*(aw.qmc.temp2[i]-aw.qmc.temp2[i-1])/(aw.qmc.timex[i]-aw.qmc.timex[i-1])))
            else:
                deltaET = QTableWidgetItem("--")
                deltaBT = QTableWidgetItem("--")
            deltaET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            deltaBT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            if i:                
                    #identify by color and add notation
                if i == aw.qmc.timeindex[0]:
                    Rtime.setBackgroundColor(QColor('#f07800'))
                    text = QApplication.translate("Table", "CHARGE",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[1]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "DRY END",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[2]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "FC START",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[3]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "FC END",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[4]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "SC START",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[5]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "SC END",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[6]:
                    Rtime.setBackgroundColor(QColor('#f07800'))
                    text = QApplication.translate("Table", "DROP",None, QApplication.UnicodeUTF8)
                elif i == aw.qmc.timeindex[7]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "COOL",None, QApplication.UnicodeUTF8)
                else:
                    text = u("")
                Rtime.setText(text + u(" " + Rtime.text()))
                    
            if i in aw.qmc.specialevents:
                Rtime.setBackgroundColor(QColor('yellow'))
                index = aw.qmc.specialevents.index(i)
                text = QApplication.translate("Table", "EVENT #%2 %3%4",None, QApplication.UnicodeUTF8).arg(str(index+1)).arg(aw.qmc.etypesf(aw.qmc.specialeventstype[index])[0]).arg(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[index]))
                Rtime.setText(text + u(" " + Rtime.text()))
#            self.datatable.setItem(i,0,Atime) 
            self.datatable.setItem(i,0,Rtime)
            self.datatable.setItem(i,1,ET)
            self.datatable.setItem(i,2,BT)
            self.datatable.setItem(i,3,deltaET)
            self.datatable.setItem(i,4,deltaBT)
            j = 5
            for k in range(len(aw.qmc.extratimex)):
                if len(aw.qmc.extratemp1) > k and len(aw.qmc.extratemp1[k]) > i:
                    extra_qtw1 = QTableWidgetItem(fmtstr%aw.qmc.extratemp1[k][i])
                    extra_qtw1.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                    self.datatable.setItem(i,j,extra_qtw1)
                if len(aw.qmc.extratemp2) > k and len(aw.qmc.extratemp2[k]) > i:
                    extra_qtw2 = QTableWidgetItem(fmtstr%aw.qmc.extratemp2[k][i])
                    extra_qtw2.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                    self.datatable.setItem(i,j+1,extra_qtw2)
                j = j + 2
        header = self.datatable.horizontalHeader()
        header.setResizeMode(0, QHeaderView.Fixed)
        header.setResizeMode(1, QHeaderView.Fixed)
        header.setResizeMode(2, QHeaderView.Fixed)
        header.setResizeMode(3, QHeaderView.Fixed)
        header.setResizeMode(4, QHeaderView.Fixed)
        header.setResizeMode(len(columns) - 1, QHeaderView.Stretch)
        self.datatable.resizeColumnsToContents()

    def createEventTable(self):
        self.eventtable.clear()
        nevents = len(aw.qmc.specialevents)
        self.eventtable.setRowCount(nevents)
        self.eventtable.setColumnCount(5)
        self.eventtable.setHorizontalHeaderLabels([QApplication.translate("Table", "Time", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "BT", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "Description", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "Type", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "Value", None, QApplication.UnicodeUTF8)])
        self.eventtable.setAlternatingRowColors(True)
        self.eventtable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.eventtable.setSelectionBehavior(QTableWidget.SelectRows)
        self.eventtable.setSelectionMode(QTableWidget.SingleSelection)
        self.eventtable.setShowGrid(True)
        self.eventtable.verticalHeader().setResizeMode(2)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        regexvalue = QRegExp(r"^100|\d?\d?$")
        self.eventtable.setShowGrid(True) 
        etypes = aw.qmc.getetypes()
        #populate table
        for i in range(nevents):
            #create widgets
            typeComboBox = QComboBox()
            typeComboBox.addItems(etypes)
            typeComboBox.setCurrentIndex(aw.qmc.specialeventstype[i])

            btline = QLineEdit()
            btline.setReadOnly(True)
            btline.setAlignment(Qt.AlignRight)
            bttemp = "%.0f"%(aw.qmc.temp2[aw.qmc.specialevents[i]]) + aw.qmc.mode
            self.eventtablecopy.append(btline) 
            btline.setText(bttemp)
            
            valueEdit = QLineEdit()
            valueEdit.setAlignment(Qt.AlignRight)
            valueEdit.setValidator(QRegExpValidator(regexvalue,self))
            valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[i]))
            
            timeline = QLineEdit()
            timeline.setAlignment(Qt.AlignRight)
            timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[i]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
            self.eventtablecopy.append(str(timez)) 
            timeline.setText(timez)
            timeline.setValidator(QRegExpValidator(regextime,self))
            
            stringline = QLineEdit(aw.qmc.specialeventsStrings[i])
            #add widgets to the table
            self.eventtable.setCellWidget(i,0,timeline)
            self.eventtable.setCellWidget(i,1,btline)
            self.eventtable.setCellWidget(i,2,stringline)
            self.eventtable.setCellWidget(i,3,typeComboBox)
            self.eventtable.setCellWidget(i,4,valueEdit)
#        self.eventtable.resizeColumnsToContents()
        header = self.eventtable.horizontalHeader()
        #header.setStretchLastSection(True)
        header.setResizeMode(0, QHeaderView.Fixed)
        header.setResizeMode(1, QHeaderView.Fixed)
        header.setResizeMode(2, QHeaderView.Stretch)
        header.setResizeMode(3, QHeaderView.ResizeToContents)
        header.setResizeMode(4, QHeaderView.Fixed)
        # improve width of Time column
        self.eventtable.setColumnWidth(0,60)
        self.eventtable.setColumnWidth(1,65)
#        self.eventtable.setColumnWidth(2,315)
        self.eventtable.setColumnWidth(4,55)
        # header.setResizeMode(QHeaderView.Stretch)

    def saveEventTable(self):
        nevents = self.eventtable.rowCount() 
        for i in range(nevents):
            timez = self.eventtable.cellWidget(i,0)
            if self.eventtablecopy[i] !=  str(timez.text()):
                aw.qmc.specialevents[i] = aw.qmc.time2index(aw.qmc.timex[aw.qmc.timeindex[0]]+ aw.qmc.stringtoseconds(str(timez.text())))
            description = self.eventtable.cellWidget(i,2)
            aw.qmc.specialeventsStrings[i] = u(description.text())
            etype = self.eventtable.cellWidget(i,3)
            aw.qmc.specialeventstype[i] = etype.currentIndex()
            evalue = self.eventtable.cellWidget(i,4).text()
            aw.qmc.specialeventsvalue[i] = aw.qmc.str2eventsvalue(str(evalue))

    def orderEventTable(self):
        nevents = len(aw.qmc.specialevents)
        if nevents:
            for i in range(nevents-1):
                if aw.qmc.specialevents[i] > aw.qmc.specialevents[i+1]:
                    itime = aw.qmc.specialevents[i]
                    itype = aw.qmc.specialeventstype[i]
                    istring = aw.qmc.specialeventsStrings[i]
                    ivalue = aw.qmc.specialeventsvalue[i]
                    aw.qmc.specialevents[i] = aw.qmc.specialevents[i+1]
                    aw.qmc.specialeventstype[i] = aw.qmc.specialeventstype[i+1]
                    aw.qmc.specialeventsStrings[i] = aw.qmc.specialeventsStrings[i+1]
                    aw.qmc.specialeventsvalue[i] = aw.qmc.specialeventsvalue[i+1]
                    aw.qmc.specialevents[i+1] = itime
                    aw.qmc.specialeventstype[i+1] = itype
                    aw.qmc.specialeventsStrings[i+1] = istring
                    aw.qmc.specialeventsvalue[i+1] = ivalue
                    self.orderEventTable()
                    return
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)

    def addEventTable(self):
        if len(aw.qmc.timex):
            self.saveEventTable()
            aw.qmc.specialevents.append(len(aw.qmc.timex)-1)   #qmc.specialevents holds indexes in qmx.timex. Initialize event index
            aw.qmc.specialeventstype.append(0)
            aw.qmc.specialeventsStrings.append(str(len(aw.qmc.specialevents)))
            aw.qmc.specialeventsvalue.append(0)
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            message = QApplication.translate("Message","Event #%1 added", None, QApplication.UnicodeUTF8).arg(str(len(aw.qmc.specialevents))) 
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No profile found", None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)

    def deleteEventTable(self):
        if len(aw.qmc.specialevents):
            self.saveEventTable()
            # check for selection
            selected = self.eventtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                aw.qmc.specialevents = aw.qmc.specialevents[0:selected_row] + aw.qmc.specialevents[selected_row + 1:]
                aw.qmc.specialeventstype = aw.qmc.specialeventstype[0:selected_row] + aw.qmc.specialeventstype[selected_row + 1:]
                aw.qmc.specialeventsStrings = aw.qmc.specialeventsStrings[0:selected_row] + aw.qmc.specialeventsStrings[selected_row + 1:]
                aw.qmc.specialeventsvalue = aw.qmc.specialeventsvalue[0:selected_row] + aw.qmc.specialeventsvalue[selected_row + 1:]
                message = QApplication.translate("Message"," Event #%1 deleted", None, QApplication.UnicodeUTF8).arg(str(selected_row+1))
            else:
                aw.qmc.specialevents.pop()
                aw.qmc.specialeventstype.pop()
                aw.qmc.specialeventsStrings.pop()
                aw.qmc.specialeventsvalue.pop()
                message = QApplication.translate("Message"," Event #%1 deleted", None, QApplication.UnicodeUTF8).arg(str(len(aw.qmc.specialevents)+1))
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No events found", None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)

    def weightouteditChanged(self):
        self.percent()

    def weightineditChanged(self):
        self.percent()
        
    def percent(self):
        percent = 0.
        try:
            if self.weightoutedit.text() != "" and float(str(self.weightoutedit.text())) != 0.0:
                percent = aw.weight_loss(float(str(self.weightinedit.text())),float(str(self.weightoutedit.text())))
        except:
            pass
        percentstring =  "%.1f" %(percent) + "%"
        self.weightpercentlabel.setText(QString(percentstring))    #weight percent loss
# do not disclose this roast degree resulting from an oversimplified calculation
#        roastdegreestring = ""
#        if percent > 0.:
#            roastdegreestring = aw.roast_degree(percent)
#        self.roastdegreelabel.setText(QString(roastdegreestring))

    def volume_percent(self):
        percent = 0.
        try:
            if self.volumeoutedit.text() != "" and float(str(self.volumeoutedit.text())) != 0.0:
                percent = aw.weight_loss(float(str(self.volumeoutedit.text())),float(str(self.volumeinedit.text())))
        except:
            pass
        percentstring =  "%.1f" %(percent) + "%"
        self.volumepercentlabel.setText(QString(percentstring))    #volume percent gain
        
    def calc_density(self):
        din = dout = 0.0
        if self.volumeinedit.text() != "" and self.volumeoutedit.text() != "" and self.weightinedit.text() != "" and self.weightoutedit.text() != "":
            volumein = float(str(self.volumeinedit.text()))
            volumeout = float(str(self.volumeoutedit.text()))
            weightin = float(str(self.weightinedit.text()))
            weightout = float(str(self.weightoutedit.text()))
            if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
                if self.volumeUnitsComboBox.currentText() == QApplication.translate("ComboBox","ml", None, QApplication.UnicodeUTF8) :
                    volumein = volumein / 1000.0
                    volumeout = volumeout / 1000.0
                if self.unitsComboBox.currentText() != QApplication.translate("ComboBox","g", None, QApplication.UnicodeUTF8) :
                    weightin = weightin * 1000.0
                    weightout = weightout * 1000.0
                din = (weightin / volumein) 
                dout = (weightout / volumeout)
        return din,dout

    def calculated_density(self):
        din, dout = self.calc_density()
        if din > 0. and dout > 0.:
            self.calculateddensitylabel.setText(QApplication.translate("Label","Density in: %1 g/l   =>   Density out: %2 g/l", None, QApplication.UnicodeUTF8).arg("%.1f"%din).arg("%.1f"%dout))
            self.tab1aLayout.addWidget(self.calculateddensitylabel)
            # set also the green density if not yet set
            if (str(self.bean_density_weight_edit.text()) == "" or float(str(self.bean_density_weight_edit.text())) == 0.) and \
                (str(self.bean_density_volume_edit.text()) == "" or float(str(self.bean_density_volume_edit.text())) in [0.,1.]):
                self.bean_density_weightUnitsComboBox.setCurrentIndex(0) # "g"
                self.bean_density_volumeUnitsComboBox.setCurrentIndex(1) # "l"
                self.bean_density_weight_edit.setText(str(aw.float2float(din)))
                self.bean_density_volume_edit.setText("1.0")
        else:
            self.calculateddensitylabel.setText("")
            self.tab1aLayout.removeWidget(self.calculateddensitylabel)
        self.calculated_organic_loss()
            
    def calc_organic_loss(self):
        wloss = 0. # weight (moisture + organic)
        mloss = 0. # moisture
        try:
            if self.weightpercentlabel.text() and self.weightpercentlabel.text() != "":
                wloss = float(self.weightpercentlabel.text().split("%")[0])
        except:
            pass
        try:
            if self.moisture_greens_edit.text() and self.moisture_greens_edit.text() != "" and self.moisture_roasted_edit.text() and self.moisture_roasted_edit.text() != "":
                m_in = float(self.moisture_greens_edit.text())
                m_out = float(self.moisture_roasted_edit.text())
                if m_in > 0 and m_out > 0:
                    mloss = m_in - m_out
        except:
            pass
        if mloss != 0. and wloss != 0.:
            return mloss, wloss - mloss
        else:
            return 0., 0.

    def calculated_organic_loss(self):
        mloss, oloss = self.calc_organic_loss()
        if oloss > 0. and mloss > 0.:
            self.calculateorganiclosslabel.setText(QApplication.translate("Label","Moisture loss: %1%    Organic loss: %2%", None, QApplication.UnicodeUTF8).arg("%.1f"%mloss).arg("%.1f"%oloss))
            self.tab1bLayout.addWidget(self.calculateorganiclosslabel)
        else:
            self.calculateorganiclosslabel.setText("")
            self.tab1bLayout.removeWidget(self.calculateorganiclosslabel)

    def standard_density(self):
        if self.bean_density_volume_edit.text() != "" and \
            float(self.bean_density_volume_edit.text()) != 0.0 and  \
            self.bean_density_weight_edit.text() != "" and \
            float(self.bean_density_weight_edit.text()) != 0.0 and \
            not (float(self.bean_density_volume_edit.text()) == 1. and  
            self.bean_density_volumeUnitsComboBox.currentIndex() == 1 and 
            self.bean_density_weightUnitsComboBox.currentIndex() == 0):
            volume = float(str(self.bean_density_volume_edit.text()))
            weight = float(str(self.bean_density_weight_edit.text()))
            if self.bean_density_volumeUnitsComboBox.currentText() == QApplication.translate("ComboBox","ml", None, QApplication.UnicodeUTF8) :
                volume = volume / 1000.0
            if self.bean_density_weightUnitsComboBox.currentText() != QApplication.translate("ComboBox","g", None, QApplication.UnicodeUTF8) :
                weight = weight * 1000.0
            self.standarddensitylabel.setText(QApplication.translate("Label","(%1 g/l)", None, QApplication.UnicodeUTF8).arg((weight / volume)))
        else:
            self.standarddensitylabel.setText("")

    def accept(self):
        #check for graph
        if len(aw.qmc.timex):
            
            #prevents accidentally deleting a modified profile.
            aw.qmc.safesaveflag = True
            if self.chargeeditcopy != str(self.chargeedit.text()):
                #if there is a CHARGE recorded and the time entered is positive. Use relative time
                if aw.qmc.stringtoseconds(str(self.chargeedit.text())) > 0 and aw.qmc.timeindex[0] != -1:
                    startindex = aw.qmc.time2index(aw.qmc.timex[aw.qmc.timeindex[0]] + aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm()
                #if there is a CHARGE recorded and the time entered is negative. Use relative time
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) < 0 and aw.qmc.timeindex[0] != -1:
                    relativetime = aw.qmc.timex[aw.qmc.timeindex[0]]-abs(aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    startindex = aw.qmc.time2index(relativetime)
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm()
                #if there is _no_ CHARGE recorded and the time entered is positive. Use absolute time 
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) > 0 and aw.qmc.timeindex[0] == -1:
                    startindex = aw.qmc.time2index(aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm()
                #if there is _no_ CHARGE recorded and the time entered is negative. ERROR
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) < 0 and aw.qmc.timeindex[0] == -1:
                    aw.qmc.adderror(QApplication.translate("Error Message", "Unable to move CHARGE to a value that does not exist",None, QApplication.UnicodeUTF8))
                    return
            # check CHARGE (with index aw.qmc.timeindex[0])
            if aw.qmc.timeindex[0] == -1:
#                aw.qmc.timeindex[0] = 0
                start = 0                   #relative start time
            else:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            if self.dryeditcopy != str(self.dryedit.text()):
                s = aw.qmc.stringtoseconds(str(self.dryedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[1] = 0
                else:
                    dryindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[1] = dryindex
            if self.Cstarteditcopy != str(self.Cstartedit.text()):
                s = aw.qmc.stringtoseconds(str(self.Cstartedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[2] = 0
                else:
                    fcsindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[2] = fcsindex
            if self.Cendeditcopy != str(self.Cendedit.text()):
                s = aw.qmc.stringtoseconds(str(self.Cendedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[3] = 0
                else:
                    fceindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[3] = fceindex
            if self.CCstarteditcopy != str(self.CCstartedit.text()):
                s = aw.qmc.stringtoseconds(str(self.CCstartedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[4] = 0
                else:
                    scsindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[4] = scsindex
            if self.CCendeditcopy != str(self.CCendedit.text()):
                s = aw.qmc.stringtoseconds(str(self.CCendedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[5] = 0
                elif aw.qmc.stringtoseconds(str(self.CCendedit.text())) > 0:
                    sceindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[5] = sceindex
            if self.dropeditcopy != str(self.dropedit.text()):
                s = aw.qmc.stringtoseconds(str(self.dropedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[6] = 0
                else:
                    dropindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[6] = dropindex
            if self.cooleditcopy != str(self.cooledit.text()):
                s = aw.qmc.stringtoseconds(str(self.cooledit.text()))
                if s <= 0:
                    aw.qmc.timeindex[7] = 0
                else:
                    coolindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[7] = coolindex
            if aw.qmc.phasesbuttonflag:   
                # adjust phases by DryEnd and FCs events
                if aw.qmc.timeindex[1]:
                    aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                if aw.qmc.timeindex[2]:
                    aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            self.saveEventTable()
        # Update Title
#        aw.qmc.ax.set_title(aw.arabicReshape(u(self.titleedit.text())),size=18,color=aw.qmc.palette["title"])
        aw.qmc.title = u(self.titleedit.text())
        aw.qmc.container_idx = self.tareComboBox.currentIndex() - 3
        # Update beans
        aw.qmc.beans = u(self.beansedit.toPlainText())
        #update ambient temperature source
        aw.qmc.ambientTempSource = self.ambientComboBox.currentIndex()
        #update weight
        try:
            aw.qmc.weight[0] = float(str(self.weightinedit.text()))
        except:
            aw.qmc.weight[0] = 0
        try:
            aw.qmc.weight[1] = float(str(self.weightoutedit.text()))
        except:
            aw.qmc.weight[1] = 0
        aw.qmc.weight[2] =u(self.unitsComboBox.currentText())
        #update volume
        try:
            aw.qmc.volume[0] = float(str(self.volumeinedit.text()))
        except:
            aw.qmc.volume[0] = 0
        try:
            aw.qmc.volume[1] = float(str(self.volumeoutedit.text()))
        except:
            aw.qmc.volume[1] = 0
        aw.qmc.volume[2] = u(self.volumeUnitsComboBox.currentText())
        #update density
        try:
            aw.qmc.density[0] = float(str(self.bean_density_weight_edit.text()))
        except:
            aw.qmc.density[0] = 0
        aw.qmc.density[1] = u(self.bean_density_weightUnitsComboBox.currentText())
        try:
            aw.qmc.density[2] = float(str(self.bean_density_volume_edit.text()))
        except:
            aw.qmc.density[2] = 0
        aw.qmc.density[3] = u(self.bean_density_volumeUnitsComboBox.currentText())
        #update bean size
        try:
            aw.qmc.beansize = float(str(self.bean_size_edit.text()))
        except:
            aw.qmc.beansize = 0.0
        #update roastflags
        aw.qmc.heavyFC_flag = self.heavyFC.isChecked()
        aw.qmc.lowFC_flag = self.lowFC.isChecked()
        aw.qmc.lightCut_flag = self.lightCut.isChecked()
        aw.qmc.darkCut_flag = self.darkCut.isChecked()
        aw.qmc.drops_flag = self.drops.isChecked()
        aw.qmc.oily_flag = self.oily.isChecked()
        aw.qmc.uneven_flag = self.uneven.isChecked()
        aw.qmc.tipping_flag = self.tipping.isChecked()
        aw.qmc.scorching_flag = self.scorching.isChecked()
        aw.qmc.divots_flag = self.divots.isChecked()
        #update color
        aw.qmc.whole_color = int(str(self.whole_color_edit.text()))
        aw.qmc.ground_color = int(str(self.ground_color_edit.text()))
        aw.qmc.color_system_idx = self.colorSystemComboBox.currentIndex()
        #update greens moisture
        try:
            aw.qmc.moisture_greens = float(str(self.moisture_greens_edit.text()))
        except:
            aw.qmc.moisture_greens = 0.
        #update roasted moisture
        try:
            aw.qmc.moisture_roasted = float(str(self.moisture_roasted_edit.text()))
        except:
            aw.qmc.moisture_roasted = 0.
        #update ambient temperature
        try:
            aw.qmc.ambientTemp = float(str(self.ambientedit.text()))
            if math.isnan(aw.qmc.ambientTemp):
                aw.qmc.ambientTemp = 0.0
        except:
            aw.qmc.ambientTemp = 0.0
        #update ambient humidity
        try:
            aw.qmc.ambient_humidity = float(str(self.ambient_humidity_edit.text()))
        except:
            aw.qmc.ambient_humidity = 0
        #update notes
        aw.qmc.roastertype = u(self.roaster.text())
        aw.qmc.operator = u(self.operator.text())
        aw.qmc.roastingnotes = u(self.roastingeditor.toPlainText())
        aw.qmc.cuppingnotes = u(self.cuppingeditor.toPlainText())
        aw.sendmessage(QApplication.translate("Message","Roast properties updated but profile not saved to disk", None, QApplication.UnicodeUTF8))
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.close()


##########################################################################
#####################  VIEW Tare  ########################################
##########################################################################


class tareDlg(ArtisanDialog):
    def __init__(self, parent = None, tarePopup = None):
        super(tareDlg,self).__init__(parent)
        self.tarePopup = tarePopup
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Tare Setup", None, QApplication.UnicodeUTF8))

        self.taretable = QTableWidget()
        self.taretable.setTabKeyNavigation(True)
        self.createTareTable()
        
        self.connect(self.taretable,SIGNAL("itemSelectionChanged()"),self.selectionChanged)
        
        addButton = QPushButton(QApplication.translate("Button","Add", None, QApplication.UnicodeUTF8))
        addButton.setFocusPolicy(Qt.NoFocus)
        self.delButton = QPushButton(QApplication.translate("Button","Delete", None, QApplication.UnicodeUTF8))
        self.delButton.setDisabled(True)
        self.delButton.setFocusPolicy(Qt.NoFocus)
        
        self.connect(addButton,SIGNAL("clicked()"),self.addTare)
        self.connect(self.delButton,SIGNAL("clicked()"),self.delTare)
        
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton,SIGNAL("clicked()"),self.close)
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        contentbuttonLayout = QHBoxLayout()
        contentbuttonLayout.addStretch()
        contentbuttonLayout.addWidget(addButton)
        contentbuttonLayout.addWidget(self.delButton)
        contentbuttonLayout.addStretch()

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        layout = QVBoxLayout()
        layout.addWidget(self.taretable)
        layout.addLayout(contentbuttonLayout)
        layout.addLayout(buttonLayout)
        self.setLayout(layout)
        
    def selectionChanged(self):
        if len(self.taretable.selectedRanges()) > 0:
            self.delButton.setDisabled(False)
        else:
            self.delButton.setDisabled(False)
        
    def closeEvent(self,_):
        self.saveTareTable()
        # update popup
        self.tarePopup.tarePopupEnabled = False
        self.tarePopup.tareComboBox.clear()
        self.tarePopup.tareComboBox.addItem("<edit> TARE")
        self.tarePopup.tareComboBox.addItem("")
        self.tarePopup.tareComboBox.insertSeparator(2)
        self.tarePopup.tareComboBox.addItems(aw.qmc.container_names)
        self.tarePopup.tareComboBox.setCurrentIndex(2) # reset to the empty entry
        aw.qmc.container_idx = -1
        self.tarePopup.tarePopupEnabled = True
        self.accept()

    def addTare(self):
#        self.taretable.setSortingEnabled(False)
        rows = self.taretable.rowCount()
        self.taretable.setRowCount(rows + 1)
        #add widgets to the table
        name = QLineEdit()
        name.setAlignment(Qt.AlignRight)
        name.setText("name")
        w = aw.scale.readWeight() # read value from scale in 'g'
        weight = QLineEdit()
        weight.setAlignment(Qt.AlignRight)
        if w > -1:
            weight.setText(str(w))
        else:
            weight.setText(str(0))
        weight.setValidator(QIntValidator(0,999,weight))    
        self.taretable.setCellWidget(rows,0,name)
        self.taretable.setCellWidget(rows,1,weight)
#        self.taretable.setSortingEnabled(True)
        
    def delTare(self):
        selected = self.taretable.selectedRanges()
        if len(selected) > 0:
            bindex = selected[0].topRow()
            if bindex >= 0:
#                self.taretable.setSortingEnabled(False)
                self.taretable.removeRow(bindex)
#                self.taretable.setSortingEnabled(True)

    def saveTareTable(self):
        tars = self.taretable.rowCount() 
        names = []
        weights = []
        for i in range(tars):
            name = u(self.taretable.cellWidget(i,0).text())
            weight = int(round(float(self.taretable.cellWidget(i,1).text())))
            names.append(name)
            weights.append(weight)            
        aw.qmc.container_names = names
        aw.qmc.container_weights = weights
        
    def createTareTable(self):
        self.taretable.clear()        
        self.taretable.setRowCount(len(aw.qmc.container_names))
        self.taretable.setColumnCount(2)
        self.taretable.setHorizontalHeaderLabels([QApplication.translate("Table","Name",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Weight",None, QApplication.UnicodeUTF8)])
        self.taretable.setAlternatingRowColors(True)
        self.taretable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.taretable.setSelectionBehavior(QTableWidget.SelectRows)
        self.taretable.setSelectionMode(QTableWidget.SingleSelection)
        self.taretable.setShowGrid(True)
        self.taretable.verticalHeader().setResizeMode(2)
        for i in range(len(aw.qmc.container_names)):
            #add widgets to the table
            name = QLineEdit()
            name.setAlignment(Qt.AlignRight)
            name.setText(aw.qmc.container_names[i])
            weight = QLineEdit()
            weight.setAlignment(Qt.AlignRight)
            weight.setText(str(aw.qmc.container_weights[i]))
            weight.setValidator(QIntValidator(0,999,weight))
            
            self.taretable.setCellWidget(i,0,name)
            self.taretable.setCellWidget(i,1,weight)
        header = self.taretable.horizontalHeader()
        header.setResizeMode(0, QHeaderView.Stretch)
        header.setResizeMode(1, QHeaderView.Fixed)
#        header.setResizeMode(QHeaderView.Stretch)
        self.taretable.setColumnWidth(1,65)
#        self.taretable.setSortingEnabled(True)


##########################################################################
#####################  VIEW PLATFORM      ################################
##########################################################################

class platformDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(platformDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Artisan Platform", None, QApplication.UnicodeUTF8))
        platformdic = {}
        platformdic["Architecture"] = str(platform.architecture())
        platformdic["Machine"] = str(platform.machine())
        platformdic["Platform name"] =  str(platform.platform())
        platformdic["Processor"] = str(platform.processor())
        platformdic["Python Build"] = str(platform.python_build())
        platformdic["Python Compiler"] = str(platform.python_compiler())
        platformdic["Python Branch"] = str(platform.python_branch())
        platformdic["Python Implementation"] = str(platform.python_implementation())
        platformdic["Python Revision"] = str(platform.python_revision())
        platformdic["Release"] = str(platform.release())
        platformdic["System"] = str(platform.system())
        platformdic["Version"] = str(platform.version())
        platformdic["Python version"] = str(platform.python_version())
        system = str(platform.system())
        if system == "Windows":
            platformdic["Win32"] = str(platform.win32_ver())
        elif system == "Darwin":
            platformdic["Mac"] = str(platform.mac_ver())
        elif system == "Linux":
            platformdic["Linux"] = str(platform.linux_distribution())
            platformdic["Libc"] = str(platform.libc_ver())
        htmlplatform = "<b>version =</b> " + __version__ + " (" + __revision__ + ")<br>"
        for key in sorted(platformdic):
            htmlplatform += "<b>" + key + " = </b> <i>" + platformdic[key] + "</i><br>"
        platformEdit = QTextEdit()
        platformEdit.setHtml(htmlplatform)
        platformEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(platformEdit)
        self.setLayout(layout)

##########################################################################
#####################  VIEW ATISAN SETTINGS ##############################
##########################################################################

class artisansettingsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(artisansettingsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Settings Viewer", None, QApplication.UnicodeUTF8))
        self.htmlsettings = ""
        self.ncategoriesComboBox = QComboBox()
        self.settingsEdit = QTextEdit()
        self.settingsEdit.setReadOnly(True)
        names = self.getstring()
        self.ncategoriesComboBox.addItems(names)
        self.connect(self.ncategoriesComboBox,SIGNAL("currentIndexChanged(int)"),self.searchstringfromcombobox)
        searchButton = QPushButton(QApplication.translate("Button","Search", None, QApplication.UnicodeUTF8))
        searchButton.setMaximumWidth(150)
        self.connect(searchButton,SIGNAL("clicked()"),self.findtext)
        self.searchbox = QLineEdit(aw.searchtextartisansettings)
        updateButton = QPushButton(QApplication.translate("Button","Update", None, QApplication.UnicodeUTF8))
        updateButton.setMaximumWidth(150)
        self.connect(updateButton,SIGNAL("clicked()"),self.getstring)
        searchlayout = QHBoxLayout()
        searchlayout.addWidget(self.ncategoriesComboBox)
        searchlayout.addWidget(self.searchbox)
        searchlayout.addWidget(searchButton)
        layout = QVBoxLayout()
        layout.addLayout(searchlayout)
        layout.addWidget(self.settingsEdit)
        layout.addWidget(updateButton)
        self.setLayout(layout)

    def findtext(self):
        aw.searchtextartisansettings = str(self.searchbox.text())
        if not self.settingsEdit.find(self.searchbox.text()):
            self.settingsEdit.find(self.searchbox.text(),QTextDocument.FindBackward)

    def searchstringfromcombobox(self):
        if not self.settingsEdit.find(self.ncategoriesComboBox.currentText()):
            self.settingsEdit.find(self.ncategoriesComboBox.currentText(),QTextDocument.FindBackward)

    def getstring(self):
        self.htmlsettings = "<body bgcolor=\"black\">"
        self.htmlsettings += "<font color=\"white\">"
        self.htmlsettings += "version = " +__version__ +"<br><br>"
        settingsdictlist,settingsnameslist = aw.readartisansettings()
        pcolors = ["grey","blue"]
        for n in range(len(settingsnameslist)):
            self.htmlsettings += "<p><b><font color=\"orange\">%s </font></b></p>"%settingsnameslist[n].upper()
            self.htmlsettings += "<p style=\"background-color: %s\">"%pcolors[n%2]
            for keys in sorted(settingsdictlist[n]):
                self.htmlsettings += "<b>&nbsp;&nbsp;" + keys + " = </b> <i>" + u(settingsdictlist[n][keys]) + "</i><br><br>"
            self.htmlsettings += "</p>"
        self.htmlsettings += "</body></font>"
        self.settingsEdit.setHtml(self.htmlsettings)
        return settingsnameslist

##########################################################################
#####################  VIEW SERIAL LOG DLG  ##############################
##########################################################################

class serialLogDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(serialLogDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Serial Log", None, QApplication.UnicodeUTF8))
        self.serialcheckbox = QCheckBox(QApplication.translate("CheckBox","Serial Log ON/OFF", None, QApplication.UnicodeUTF8))
        self.serialcheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF logs serial communication",None, QApplication.UnicodeUTF8))
        self.serialcheckbox.setChecked(aw.seriallogflag)
        self.connect(self.serialcheckbox,SIGNAL("stateChanged(int)"),self.serialcheckboxChanged)
        self.serialEdit = QTextEdit()
        self.serialEdit.setReadOnly(True)
        self.serialEdit.setHtml(self.getstring())
        updateButton = QPushButton(QApplication.translate("Button","Update", None, QApplication.UnicodeUTF8))
        updateButton.setMaximumWidth(150)
        self.connect(updateButton,SIGNAL("clicked()"),self.update)
        layout = QVBoxLayout()
        layout.addWidget(self.serialcheckbox,0)
        layout.addWidget(self.serialEdit,1)
        layout.addWidget(updateButton,1)
        self.setLayout(layout)

    def getstring(self):
        #convert list of serial comm an html string
        htmlserial = "version = " +__version__ +"<br><br>"
        lenl = len(aw.seriallog)
        for i in range(len(aw.seriallog)):
            htmlserial += "<b>" + str(lenl-i) + "</b> " + aw.seriallog[-i-1] + "<br><br>"
        return htmlserial

    def update(self):
        if not aw.seriallogflag:
            self.serialcheckbox.setChecked(True)
        self.serialEdit.setText(self.getstring())

    def serialcheckboxChanged(self):
        if self.serialcheckbox.isChecked():
            aw.seriallogflag = True
        else:
            aw.seriallogflag = False

##########################################################################
#####################  VIEW ERROR LOG DLG  ###############################
##########################################################################

class errorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(errorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Error Log", None, QApplication.UnicodeUTF8))
        #convert list of errors to an html string
        htmlerr = "version = " +__version__ +"<br><br>"
        lenl = len(aw.qmc.errorlog)
        for i in range(len(aw.qmc.errorlog)):
            htmlerr += "<b>" + str(lenl-i) + "</b> <i>" + aw.qmc.errorlog[-i-1] + "</i><br><br>"
        enumber = len(aw.qmc.errorlog)
        labelstr =  "<b>"+ QApplication.translate("Label","Number of errors found %1", None, QApplication.UnicodeUTF8).arg(str(enumber)) + "</b>"
        elabel = QLabel(labelstr)
        errorEdit = QTextEdit()
        errorEdit.setHtml(htmlerr)
        errorEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(elabel,0)
        layout.addWidget(errorEdit,1)
        self.setLayout(layout)

##########################################################################
#####################  MESSAGE HISTORY DLG  ##############################
##########################################################################

class messageDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(messageDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Message History", None, QApplication.UnicodeUTF8))
        #convert list of messages to an html string
        htmlmessage = ""
        for i in range(len(aw.messagehist)):
            htmlmessage += "<b>" + str(len(aw.messagehist)-i) + "</b> <i>" + aw.messagehist[-i-1] + "</i><br><br>"
        messageEdit = QTextEdit()
        messageEdit.setHtml(htmlmessage)
        messageEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(messageEdit,0)
        self.setLayout(layout)

##########################################################################
#####################  AUTOSAVE DLG  #####################################
##########################################################################

class autosaveDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(autosaveDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Keyboard Autosave [a]", None, QApplication.UnicodeUTF8))
        self.prefixEdit = QLineEdit(aw.qmc.autosaveprefix)
        self.prefixEdit.setToolTip(QApplication.translate("Tooltip", "Automatic generated name = This text + date + time",None, QApplication.UnicodeUTF8))
        autochecklabel = QLabel(QApplication.translate("CheckBox","Autosave [a]", None, QApplication.UnicodeUTF8))
        self.autocheckbox = QCheckBox()
        self.autocheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF of automatic saving when pressing keyboard letter [a]",None, QApplication.UnicodeUTF8))
        self.autocheckbox.setChecked(aw.qmc.autosaveflag)
        prefixlabel = QLabel()
        prefixlabel.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        prefixlabel.setText(u(QApplication.translate("Label", "Prefix",None, QApplication.UnicodeUTF8)))
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel", None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        pathButton = QPushButton(QApplication.translate("Button","Path", None, QApplication.UnicodeUTF8))
        pathButton.setFocusPolicy(Qt.NoFocus)
        self.pathEdit = QLineEdit(str(aw.qmc.autosavepath))
        self.pathEdit.setToolTip(QApplication.translate("Tooltip", "Sets the directory to store batch profiles when using the letter [a]",None, QApplication.UnicodeUTF8))
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.autoChanged)
        self.connect(pathButton,SIGNAL("clicked()"),self.getpath)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        autolayout = QGridLayout()
        autolayout.addWidget(self.autocheckbox,0,0,Qt.AlignRight)
        autolayout.addWidget(autochecklabel,0,1)
        autolayout.addWidget(prefixlabel,1,0)
        autolayout.addWidget(self.prefixEdit,1,1)
        autolayout.addWidget(pathButton,2,0)
        autolayout.addWidget(self.pathEdit,2,1)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(autolayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def getpath(self):
        filename = aw.ArtisanExistingDirectoryDialog(msg=QApplication.translate("Form Caption","AutoSave Path", None, QApplication.UnicodeUTF8))
        self.pathEdit.setText(filename)

    def autoChanged(self):
        aw.qmc.autosavepath = str(self.pathEdit.text())
        if self.autocheckbox.isChecked():
            aw.qmc.autosaveflag = 1
            aw.qmc.autosaveprefix = self.prefixEdit.text()
            message = QApplication.translate("Message","Autosave ON. Prefix: %1").arg(self.prefixEdit.text())
            aw.sendmessage(message)
        else:
            aw.qmc.autosaveflag = 0
            message = QApplication.translate("Message","Autosave OFF", None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
        self.close()

##########################################################################
#####################  WINDOW PROPERTIES DLG  ############################
##########################################################################

class WindowsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(WindowsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Axes",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        xlimitLabel = QLabel(QApplication.translate("Label", "Max",None, QApplication.UnicodeUTF8))
        xlimitLabel_min = QLabel(QApplication.translate("Label", "Min",None, QApplication.UnicodeUTF8))
        ylimitLabel = QLabel(QApplication.translate("Label", "Max",None, QApplication.UnicodeUTF8))
        ylimitLabel_min = QLabel(QApplication.translate("Label", "Min",None, QApplication.UnicodeUTF8))
        zlimitLabel = QLabel(QApplication.translate("Label", "Max",None, QApplication.UnicodeUTF8))
        zlimitLabel_min = QLabel(QApplication.translate("Label", "Min",None, QApplication.UnicodeUTF8))
        self.xlimitEdit = QLineEdit()
        self.xlimitEdit.setMaximumWidth(60)
        self.xlimitEdit.setMinimumWidth(60)
        self.xlimitEdit.setAlignment(Qt.AlignRight)
        self.xlimitEdit_min = QLineEdit()
        self.xlimitEdit_min.setMaximumWidth(60)
        self.xlimitEdit_min.setMinimumWidth(60)
        self.xlimitEdit_min.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.xlimitEdit.setValidator(QRegExpValidator(regextime,self))
        self.xlimitEdit_min.setValidator(QRegExpValidator(regextime,self))
        self.ylimitEdit = QLineEdit()
        self.ylimitEdit.setMaximumWidth(60)
        self.ylimitEdit_min = QLineEdit()
        self.ylimitEdit_min.setMaximumWidth(60)
        self.ylimitEdit.setValidator(QIntValidator(0, 850, self.ylimitEdit))
        self.ylimitEdit_min.setValidator(QIntValidator(-150, 500, self.ylimitEdit_min))
        self.ylimitEdit.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.ylimitEdit_min.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zlimitEdit = QLineEdit()
        self.zlimitEdit.setMaximumWidth(60)
        self.zlimitEdit_min = QLineEdit()
        self.zlimitEdit_min.setMaximumWidth(60)
        self.zlimitEdit.setValidator(QIntValidator(0, 500, self.zlimitEdit))
        self.zlimitEdit_min.setValidator(QIntValidator(-200, 250, self.zlimitEdit_min))
        self.zlimitEdit.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zlimitEdit_min.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.xlimitEdit.setText(aw.qmc.stringfromseconds(aw.qmc.endofx))
        if aw.qmc.timeindex[0] != -1:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx - aw.qmc.timex[aw.qmc.timeindex[0]]))
        else:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx))
        self.ylimitEdit.setText(str(aw.qmc.ylimit))
        self.ylimitEdit_min.setText(str(aw.qmc.ylimit_min))
        self.zlimitEdit.setText(str(aw.qmc.zlimit))
        self.zlimitEdit_min.setText(str(aw.qmc.zlimit_min))
        xrotationlabel = QLabel(QApplication.translate("Label", "Rotation",None, QApplication.UnicodeUTF8))
        self.xrotationSpinBox = QSpinBox()
        self.xrotationSpinBox.setRange(0,90)
        self.xrotationSpinBox.setSingleStep(5)
        self.xrotationSpinBox.setValue(aw.qmc.xrotation)
        self.connect(self.xrotationSpinBox, SIGNAL("valueChanged(int)"),self.changexrotation)
        self.xrotationSpinBox.setMaximumWidth(40)
        self.legendComboBox = QComboBox()
        self.legendComboBox.setMaximumWidth(160)
        legendlocs = ["",#QApplication.translate("ComboBox", "none",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "upper right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "upper left",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "lower left",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "lower right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "center left",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "center right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "lower center",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "upper center",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "center",None, QApplication.UnicodeUTF8)]
        self.legendComboBox.addItems(legendlocs)
        self.legendComboBox.setCurrentIndex(aw.qmc.legendloc)
        self.connect(self.legendComboBox,SIGNAL("currentIndexChanged(int)"),self.changelegendloc)
        resettimelabel = QLabel(QApplication.translate("Label", "Initial Max",None, QApplication.UnicodeUTF8))
        self.resetEdit = QLineEdit()
        self.resetEdit.setMaximumWidth(60)
        self.resetEdit.setMinimumWidth(60)
        self.resetEdit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.resetEdit.setValidator(QRegExpValidator(regextime,self))
        self.resetEdit.setText(aw.qmc.stringfromseconds(aw.qmc.resetmaxtime))
        # fixmaxtime flag
        self.fixmaxtimeFlag = QCheckBox(QApplication.translate("CheckBox", "Lock Max",None, QApplication.UnicodeUTF8))
        self.fixmaxtimeFlag.setChecked(aw.qmc.fixmaxtime)
        # locktimex flag
        self.locktimexFlag = QCheckBox(QApplication.translate("CheckBox", "Lock",None, QApplication.UnicodeUTF8))
        self.locktimexFlag.setChecked(aw.qmc.locktimex)
        # time axis steps
        timegridlabel = QLabel(QApplication.translate("Label", "Step",None, QApplication.UnicodeUTF8))
        self.xaxislencombobox = QComboBox()
        timelocs =   [
                    #QApplication.translate("ComboBox", "30 seconds",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "1 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "2 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "3 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "4 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "5 minute",None, QApplication.UnicodeUTF8)]
        self.xaxislencombobox.addItems(timelocs)
#        self.timeconversion = [30,60,120,180,240,300]
        self.timeconversion = [60,120,180,240,300]
        try:
            self.xaxislencombobox.setCurrentIndex(self.timeconversion.index(aw.qmc.xgrid))
        except:
            self.xaxislencombobox.setCurrentIndex(0)
        self.connect(self.xaxislencombobox,SIGNAL("currentIndexChanged(int)"),self.xaxislenloc)
        ygridlabel = QLabel(QApplication.translate("Label", "Step",None, QApplication.UnicodeUTF8))
        self.ygridSpinBox = QSpinBox()
        self.ygridSpinBox.setRange(1,100)
        self.ygridSpinBox.setSingleStep(5)
        self.ygridSpinBox.setValue(aw.qmc.ygrid)
        self.ygridSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.connect(self.ygridSpinBox, SIGNAL("valueChanged(int)"),self.changeygrid)
        self.ygridSpinBox.setMaximumWidth(60)
        zgridlabel = QLabel(QApplication.translate("Label", "Step",None, QApplication.UnicodeUTF8))
        self.zgridSpinBox = QSpinBox()
        self.zgridSpinBox.setRange(1,100)
        self.zgridSpinBox.setSingleStep(5)
        self.zgridSpinBox.setValue(aw.qmc.zgrid)
        self.zgridSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.connect(self.zgridSpinBox, SIGNAL("valueChanged(int)"),self.changezgrid)
        self.zgridSpinBox.setMaximumWidth(60)
        linestylegridlabel = QLabel(QApplication.translate("Label", "Style",None, QApplication.UnicodeUTF8))
        self.gridstylecombobox = QComboBox()
        gridstyles = [QApplication.translate("ComboBox", "solid",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "dashed",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "dashed-dot",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "dotted",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "None",None, QApplication.UnicodeUTF8)]
        self.gridstylecombobox.addItems(gridstyles) 
        self.gridstylecombobox.setCurrentIndex(aw.qmc.gridlinestyle)
        self.connect(self.gridstylecombobox,SIGNAL("currentIndexChanged(int)"),self.changegridstyle)
        gridthicknesslabel = QLabel(QApplication.translate("Label", "Width",None, QApplication.UnicodeUTF8))
        self.gridwidthSpinBox = QSpinBox()
        self.gridwidthSpinBox.setRange(1,5)
        self.gridwidthSpinBox.setValue(aw.qmc.gridthickness)
        self.connect(self.gridwidthSpinBox, SIGNAL("valueChanged(int)"),self.changegridwidth)
        self.gridwidthSpinBox.setMaximumWidth(40)
        gridalphalabel = QLabel(QApplication.translate("Label", "Opaqueness",None, QApplication.UnicodeUTF8))
        self.gridalphaSpinBox = QSpinBox()
        self.gridalphaSpinBox.setRange(1,10)
        self.gridalphaSpinBox.setValue(int(aw.qmc.gridalpha*10))
        self.connect(self.gridalphaSpinBox, SIGNAL("valueChanged(int)"),self.changegridalpha)
        self.gridalphaSpinBox.setMaximumWidth(40)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        resetButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        resetButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.updatewindow)
        self.connect(resetButton,SIGNAL("clicked()"),self.reset)
        xlayout = QGridLayout()
        xlayout.addWidget(self.locktimexFlag,0,0)
        xlayout.addWidget(xlimitLabel_min,1,0)
        xlayout.addWidget(self.xlimitEdit_min,1,1)
        xlayout.addWidget(xlimitLabel,1,2)
        xlayout.addWidget(self.xlimitEdit,1,3)
        xlayout.addWidget(timegridlabel,2,0)
        xlayout.addWidget(self.xaxislencombobox,2,1)
        xlayout.addWidget(resettimelabel,2,2)
        xlayout.addWidget(self.resetEdit,2,3)
        xlayout.addWidget(xrotationlabel,3,0)
        xlayout.addWidget(self.fixmaxtimeFlag,3,2)
        xlayout.addWidget(self.xrotationSpinBox,3,1)
        ylayout = QGridLayout()
        ylayout.addWidget(ylimitLabel_min,0,0)
        ylayout.addWidget(self.ylimitEdit_min,0,1)
        ylayout.addWidget(ylimitLabel,0,2)
        ylayout.addWidget(self.ylimitEdit,0,3)
        ylayout.addWidget(ygridlabel,1,0)
        ylayout.addWidget(self.ygridSpinBox,1,1)
        zlayout = QGridLayout()
        zlayout.addWidget(zlimitLabel_min,0,0)
        zlayout.addWidget(self.zlimitEdit_min,0,1)
        zlayout.addWidget(zlimitLabel,0,2)
        zlayout.addWidget(self.zlimitEdit,0,3)
        zlayout.addWidget(zgridlabel,1,0)
        zlayout.addWidget(self.zgridSpinBox,1,1)
        legentlayout = QHBoxLayout()
        legentlayout.addWidget(self.legendComboBox,0,Qt.AlignLeft)
        graphgridlayout = QGridLayout()
        graphgridlayout.addWidget(linestylegridlabel,1,0)
        graphgridlayout.addWidget(self.gridstylecombobox,1,1,Qt.AlignLeft)
        graphgridlayout.addWidget(gridthicknesslabel,1,2)
        graphgridlayout.addWidget(self.gridwidthSpinBox,1,3,Qt.AlignLeft)
        graphgridlayout.addWidget(gridalphalabel,2,0)
        graphgridlayout.addWidget(self.gridalphaSpinBox,2,1,Qt.AlignLeft)
        xGroupLayout = QGroupBox(QApplication.translate("GroupBox","Time Axis",None, QApplication.UnicodeUTF8))
        xGroupLayout.setLayout(xlayout)
        yGroupLayout = QGroupBox(QApplication.translate("GroupBox","Temperature Axis",None, QApplication.UnicodeUTF8))
        yGroupLayout.setLayout(ylayout)
        zGroupLayout = QGroupBox(QApplication.translate("GroupBox","DeltaBT/DeltaET Axis",None, QApplication.UnicodeUTF8))
        zGroupLayout.setLayout(zlayout)
        legendLayout = QGroupBox(QApplication.translate("GroupBox","Legend Location",None, QApplication.UnicodeUTF8))
        legendLayout.setLayout(legentlayout)
        GridGroupLayout = QGroupBox(QApplication.translate("GroupBox","Grid",None, QApplication.UnicodeUTF8))
        GridGroupLayout.setLayout(graphgridlayout)
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(resetButton)
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(xGroupLayout)
        mainLayout.addWidget(yGroupLayout)
        mainLayout.addWidget(zGroupLayout)
        mainLayout.addWidget(legendLayout)
        mainLayout.addWidget(GridGroupLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def changexrotation(self):
        aw.qmc.xrotation = self.xrotationSpinBox.value()
        self.xrotationSpinBox.setDisabled(True)
        aw.qmc.xaxistosm()
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.xrotationSpinBox.setDisabled(False)
        self.xrotationSpinBox.setFocus()

    def changegridalpha(self):
        aw.qmc.gridalpha = self.gridalphaSpinBox.value()/10.
        self.gridalphaSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.gridalphaSpinBox.setDisabled(False)
        self.gridalphaSpinBox.setFocus()

    def changegridwidth(self):
        aw.qmc.gridthickness = self.gridwidthSpinBox.value()
        self.gridwidthSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.gridwidthSpinBox.setDisabled(False)
        self.gridwidthSpinBox.setFocus()

    def changegridstyle(self):
        aw.qmc.gridlinestyle = self.gridstylecombobox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changelegendloc(self):
        aw.qmc.legendloc = self.legendComboBox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def xaxislenloc(self):
        aw.qmc.xgrid = self.timeconversion[self.xaxislencombobox.currentIndex()]
        aw.qmc.xaxistosm()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changeygrid(self):
        aw.qmc.ygrid = self.ygridSpinBox.value()
        self.ygridSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.ygridSpinBox.setDisabled(False)
        self.ygridSpinBox.setFocus()

    def changezgrid(self):
        aw.qmc.zgrid = self.zgridSpinBox.value()
        self.zgridSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.zgridSpinBox.setDisabled(False)
        self.zgridSpinBox.setFocus()

    # exit dialog with OK
    def updatewindow(self):
        yl = int(str(self.ylimitEdit.text()))
        yl_min = int(str(self.ylimitEdit_min.text()))
        if yl > yl_min:
            aw.qmc.ylimit = yl
            aw.qmc.ylimit_min = yl_min
        zl = int(str(self.zlimitEdit.text()))
        zl_min = int(str(self.zlimitEdit_min.text()))
        if zl > zl_min:
            aw.qmc.zlimit = zl
            aw.qmc.zlimit_min = zl_min
        aw.qmc.endofx = aw.qmc.stringtoseconds(str(self.xlimitEdit.text()))
        resettime = aw.qmc.stringtoseconds(str(self.resetEdit.text()))
        startedittime_str = str(self.xlimitEdit_min.text())
        if startedittime_str != None and startedittime_str != "":
            starteditime = aw.qmc.stringtoseconds(startedittime_str)
            if starteditime >= 0 and aw.qmc.timeindex[0] != -1:
                aw.qmc.startofx = aw.qmc.timex[aw.qmc.timeindex[0]] + starteditime
            elif starteditime >= 0 and aw.qmc.timeindex[0] == -1:
                aw.qmc.startofx = starteditime
            elif starteditime < 0 and aw.qmc.timeindex[0] != -1:
                aw.qmc.startofx = aw.qmc.timex[aw.qmc.timeindex[0]]-abs(starteditime)
            else:
                aw.qmc.startofx = starteditime
            aw.qmc.locktimex_start = starteditime
        else:
            aw.qmc.startofx = 0
            aw.qmc.locktimex_start = 0
        if resettime > 0:
            aw.qmc.resetmaxtime = resettime
        aw.qmc.fixmaxtime = self.fixmaxtimeFlag.isChecked()
        aw.qmc.locktimex = self.locktimexFlag.isChecked()
        aw.qmc.redraw(recomputeAllDeltas=False)
        string = QApplication.translate("Message","xlimit = (%3,%4) ylimit = (%1,%2) zlimit = (%5,%6)",None, QApplication.UnicodeUTF8).arg(str(self.ylimitEdit_min.text())).arg(str(self.ylimitEdit.text())).arg(str(self.xlimitEdit_min.text())).arg(str(self.xlimitEdit.text())).arg(str(self.zlimitEdit_min.text())).arg(str(self.zlimitEdit.text()))                                   
        aw.sendmessage(string)
        self.close()

    def reset(self):
        if len(aw.qmc.timex) > 1:
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(int(aw.qmc.timex[-1])))
        else:
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(60))
        self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(0))
        if aw.qmc.mode == "F":
            self.ylimitEdit.setText("750")
            self.ylimitEdit_min.setText("0")
            self.zlimitEdit.setText("100")
            self.zlimitEdit_min.setText("0")
        else:
            self.ylimitEdit.setText("400")
            self.ylimitEdit_min.setText("0")
            self.zlimitEdit.setText("40")
            self.zlimitEdit_min.setText("0")

##########################################################################
#####################  ROAST CALCULATOR DLG   ############################
##########################################################################

class calculatorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(calculatorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Calculator",None, QApplication.UnicodeUTF8))
        #RATE OF CHANGE
        self.result1 = QLabel(QApplication.translate("Label", "Enter two times along profile",None, QApplication.UnicodeUTF8))
        self.result2 = QLabel()
        self.result2.setStyleSheet("background-color:'lightgrey';")
        startlabel = QLabel(QApplication.translate("Label", "Start (00:00)",None, QApplication.UnicodeUTF8))
        endlabel = QLabel(QApplication.translate("Label", "End (00:00)",None, QApplication.UnicodeUTF8))
        self.startEdit = QLineEdit()
        self.endEdit = QLineEdit()
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.startEdit.setValidator(QRegExpValidator(regextime,self))
        self.endEdit.setValidator(QRegExpValidator(regextime,self))
        self.connect(self.startEdit,SIGNAL("editingFinished()"),self.calculateRC)
        self.connect(self.endEdit,SIGNAL("editingFinished()"),self.calculateRC)
        nevents = len(aw.qmc.specialevents)
        events_found = [QApplication.translate("ComboBox","Event #0",None, QApplication.UnicodeUTF8)]
        for i in range(nevents):
            events_found.append(QApplication.translate("ComboBox","Event #%1",None, QApplication.UnicodeUTF8).arg(str(i+1)))
        self.eventAComboBox = QComboBox()
        self.eventAComboBox.addItems(events_found)
        self.connect(self.eventAComboBox,SIGNAL("currentIndexChanged(int)"),self.calcEventRC)
        self.eventBComboBox = QComboBox()
        self.eventBComboBox.addItems(events_found)
        self.connect(self.eventBComboBox,SIGNAL("currentIndexChanged(int)"),self.calcEventRC)
        #TEMPERATURE CONVERSION
        flabel = QLabel(QApplication.translate("Label", "Fahrenheit",None, QApplication.UnicodeUTF8))
        clabel = QLabel(QApplication.translate("Label", "Celsius",None, QApplication.UnicodeUTF8))
        self.faEdit = QLineEdit()
        self.ceEdit = QLineEdit()
        self.faEdit.setValidator(QDoubleValidator(-999., 9999., 2, self.faEdit))
        self.ceEdit.setValidator(QDoubleValidator(-999., 9999., 2, self.ceEdit))
        self.connect(self.faEdit,SIGNAL("editingFinished()"),lambda x="FtoC":self.convertTemp(x))
        self.connect(self.ceEdit,SIGNAL("editingFinished()"),lambda x="CtoF":self.convertTemp(x))
        #WEIGHT CONVERSION
        self.WinComboBox = QComboBox()
        weightunits = [QApplication.translate("ComboBox","g",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","Kg",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","lb",None, QApplication.UnicodeUTF8)]
        self.WinComboBox.addItems(weightunits)
        self.WinComboBox.setMaximumWidth(80)
        self.WinComboBox.setMinimumWidth(80)
        self.WoutComboBox = QComboBox()
        self.WoutComboBox.setMaximumWidth(80)
        self.WoutComboBox.setMinimumWidth(80)
        self.WoutComboBox.addItems(weightunits)
        self.WoutComboBox.setCurrentIndex(2)
        self.WinEdit = QLineEdit()
        self.WoutEdit = QLineEdit()
        self.WinEdit.setMaximumWidth(70)
        self.WoutEdit.setMaximumWidth(70)
        #self.WinEdit.setMinimumWidth(60)
        #self.WoutEdit.setMinimumWidth(60)
        self.WinEdit.setValidator(QDoubleValidator(0., 99999., 2, self.WinEdit))
        self.WoutEdit.setValidator(QDoubleValidator(0., 99999., 2, self.WoutEdit))
        self.connect(self.WinEdit,SIGNAL("editingFinished()"),lambda x="ItoO":self.convertWeight(x))
        self.connect(self.WoutEdit,SIGNAL("editingFinished()"),lambda x="OtoI":self.convertWeight(x))
        #VOLUME CONVERSION
        self.VinComboBox = QComboBox()
        volumeunits = [QApplication.translate("ComboBox","liter",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","gallon",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","quart",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","pint",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","cup",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","cm^3",None, QApplication.UnicodeUTF8)]
        self.VinComboBox.addItems(volumeunits)
        self.VinComboBox.setMaximumWidth(80)
        self.VinComboBox.setMinimumWidth(80)
        self.VoutComboBox = QComboBox()
        self.VoutComboBox.setMaximumWidth(80)
        self.VoutComboBox.setMinimumWidth(80)
        self.VoutComboBox.addItems(volumeunits)
        self.VoutComboBox.setCurrentIndex(4)
        self.VinEdit = QLineEdit()
        self.VoutEdit = QLineEdit()
        self.VinEdit.setMaximumWidth(70)
        self.VoutEdit.setMaximumWidth(70)
        #self.VinEdit.setMinimumWidth(60)
        #self.VoutEdit.setMinimumWidth(60)
        self.VinEdit.setValidator(QDoubleValidator(0., 99999., 2, self.VinEdit))
        self.VoutEdit.setValidator(QDoubleValidator(0., 99999., 2, self.VoutEdit))
        self.connect(self.VinEdit,SIGNAL("editingFinished()"),lambda x="ItoO":self.convertVolume(x))
        self.connect(self.VoutEdit,SIGNAL("editingFinished()"),lambda x="OtoI":self.convertVolume(x))
        #LAYOUTS
        #Rate of chage
        calrcLayout = QGridLayout()
        calrcLayout.addWidget(startlabel,0,0)
        calrcLayout.addWidget(endlabel,0,1)
        calrcLayout.addWidget(self.startEdit,1,0)
        calrcLayout.addWidget(self.endEdit,1,1)
        calrcLayout.addWidget(self.eventAComboBox ,2,0)
        calrcLayout.addWidget(self.eventBComboBox ,2,1)
        rclayout = QVBoxLayout()
        rclayout.addWidget(self.result1,0)
        rclayout.addWidget(self.result2,1)
        rclayout.addLayout(calrcLayout,2)
        #temperature conversion
        tempLayout = QGridLayout()
        tempLayout.addWidget(flabel,0,0)
        tempLayout.addWidget(clabel,0,1)
        tempLayout.addWidget(self.faEdit,1,0)
        tempLayout.addWidget(self.ceEdit,1,1)
        #weight conversions
        weightLayout = QHBoxLayout()
        weightLayout.addWidget(self.WinComboBox)
        weightLayout.addWidget(self.WinEdit)
        weightLayout.addWidget(self.WoutEdit)
        weightLayout.addWidget(self.WoutComboBox)
        #volume conversions
        volumeLayout = QHBoxLayout()
        volumeLayout.addWidget(self.VinComboBox)
        volumeLayout.addWidget(self.VinEdit)
        volumeLayout.addWidget(self.VoutEdit)
        volumeLayout.addWidget(self.VoutComboBox)
        RoCGroup = QGroupBox(QApplication.translate("GroupBox","Rate of Change",None, QApplication.UnicodeUTF8))
        RoCGroup.setLayout(rclayout)
        tempConvGroup = QGroupBox(QApplication.translate("GroupBox","Temperature Conversion",None, QApplication.UnicodeUTF8))
        tempConvGroup.setLayout(tempLayout)
        weightConvGroup = QGroupBox(QApplication.translate("GroupBox","Weight Conversion",None, QApplication.UnicodeUTF8))
        weightConvGroup.setLayout(weightLayout)
        volumeConvGroup = QGroupBox(QApplication.translate("GroupBox","Volume Conversion",None, QApplication.UnicodeUTF8))
        volumeConvGroup.setLayout(volumeLayout)
        #main
        mainlayout = QVBoxLayout()
        mainlayout.setSpacing(10)
        mainlayout.addWidget(RoCGroup)
        mainlayout.addWidget(tempConvGroup)
        mainlayout.addWidget(weightConvGroup)
        mainlayout.addWidget(volumeConvGroup)
        mainlayout.addStretch()
        self.setLayout(mainlayout)

    def calcEventRC(self):
        nevents = len(aw.qmc.specialevents)
        Aevent = int(self.eventAComboBox.currentIndex())
        Bevent = int(self.eventBComboBox.currentIndex())
        if Aevent <= nevents and Bevent <= nevents and Aevent and Bevent:
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            self.startEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Aevent-1]] - start))
            self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Bevent-1]] - start))
            self.calculateRC()

    #calculate rate of change
    def calculateRC(self):
        if len(aw.qmc.timex)>2:
            if not len(self.startEdit.text()) or not len(self.endEdit.text()):
                #empty field
                return
            starttime = aw.qmc.stringtoseconds(str(self.startEdit.text()))
            endtime = aw.qmc.stringtoseconds(str(self.endEdit.text()))
            if starttime == -1 or endtime == -1:
                self.result1.setText(QApplication.translate("Label", "Time syntax error. Time not valid",None, QApplication.UnicodeUTF8))
                self.result2.setText("")
                return
            if  endtime > aw.qmc.timex[-1] or endtime < starttime:
                self.result1.setText(QApplication.translate("Label", "Error: End time smaller than Start time",None, QApplication.UnicodeUTF8))
                self.result2.setText("")
                return
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            startindex = aw.qmc.time2index(starttime + start)
            endindex = aw.qmc.time2index(endtime + start)
            #delta
            deltatime = aw.qmc.timex[endindex] -  aw.qmc.timex[startindex]
            deltatemperature = aw.qmc.temp2[endindex] - aw.qmc.temp2[startindex]
            if deltatime == 0:
                deltaseconds = 0
            else:
                deltaseconds = deltatemperature/deltatime
            deltaminutes = deltaseconds*60.
            string1 = QApplication.translate("Label", "Best approximation was made from %1 to %2",None, QApplication.UnicodeUTF8).arg(aw.qmc.stringfromseconds(aw.qmc.timex[startindex]- start)).arg(aw.qmc.stringfromseconds(aw.qmc.timex[endindex]- start))
            string2 = QApplication.translate("Label", "<b>%1</b> %2/sec, <b>%3</b> %4/min",None, QApplication.UnicodeUTF8).arg("%.2f"%(deltaseconds)).arg(aw.qmc.mode).arg("%.2f"%(deltaminutes)).arg(aw.qmc.mode)
            self.result1.setText(string1)
            self.result2.setText(string2)
        else:
            self.result1.setText(QApplication.translate("Label", "No profile found",None, QApplication.UnicodeUTF8))
            self.result2.setText("")

    def convertTemp(self,x):
        if x == "FtoC":
            newC = aw.qmc.fromFtoC(float(str(self.faEdit.text())))
            result = "%.2f"%newC
            self.ceEdit.setText(result)
        elif x == "CtoF":
            newF = aw.qmc.fromCtoF(float(str(self.ceEdit.text())))
            result = "%.2f"%newF
            self.faEdit.setText(result)

    def convertWeight(self,x):
        #                g,            kg,         lb
        convtable = [
                        [1.,           0.001,      0.00220462262     ],    # g
                        [1000,         1.,         2.205             ],    # Kg
                        [453.591999,   0.45359237, 1.                ]     # lb
                    ]
        if x == "ItoO":
            inx = float(str(self.WinEdit.text()))
            outx = inx*convtable[self.WinComboBox.currentIndex()][self.WoutComboBox.currentIndex()]
            self.WoutEdit.setText("%.2f"%outx)
            
        elif x == "OtoI":
            outx = float(str(self.WoutEdit.text()))
            inx = outx*convtable[self.WoutComboBox.currentIndex()][self.WinComboBox.currentIndex()]
            self.WinEdit.setText("%.2f"%inx)

    def convertVolume(self,x):
                        #liter          gal             qt              pt              cup             cm^3
        convtable = [
                        [1.,            0.26417205,     1.05668821,     2.11337643,     4.22675284,     1000.                ],    # liter
                        [3.78541181,    1.,             4.,             8.,             16,             3785.4117884         ],    # gallon
                        [0.94635294,    0.25,           1.,             2.,             4.,             946.352946           ],    # quart
                        [0.47317647,    0.125,          0.5,            1.,             2.,             473.176473           ],    # pint
                        [0.23658823,    0.0625,         0.25,           0.5,            1.,             236.5882365          ],    # cup
                        [0.001,         2.6417205e-4,   1.05668821e-3,  2.11337641e-3,  4.2267528e-3,   1.                   ]     # cm^3
                    ]
        if x == "ItoO":
            inx = float(str(self.VinEdit.text()))
            outx = inx*convtable[self.VinComboBox.currentIndex()][self.VoutComboBox.currentIndex()]
            self.VoutEdit.setText("%.3f"%outx)
            
        elif x == "OtoI":
            outx = float(str(self.VoutEdit.text()))
            inx = outx*convtable[self.VoutComboBox.currentIndex()][self.VinComboBox.currentIndex()]
            self.VinEdit.setText("%.3f"%inx)

##########################################################################
#####################  EVENTS CONFIGURATION DLG     ######################
##########################################################################
#accessed through menu conf

class EventsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(EventsDlg,self).__init__(parent)
        titlefont = QFont()
        titlefont.setBold(True)
        titlefont.setWeight(75)
        self.setWindowTitle(QApplication.translate("Form Caption","Events",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        self.storeState()
        ## TAB 1
        self.eventsbuttonflag = QCheckBox(QApplication.translate("CheckBox","Button",None, QApplication.UnicodeUTF8))
        self.eventsbuttonflag.setChecked(bool(aw.eventsbuttonflag))
        self.connect(self.eventsbuttonflag,SIGNAL("stateChanged(int)"),self.eventsbuttonflagChanged)
        self.eventsshowflagbox = QCheckBox(QApplication.translate("CheckBox","Show",None, QApplication.UnicodeUTF8))
        self.eventsshowflagbox.setChecked(bool(aw.qmc.eventsshowflag))
        self.connect(self.eventsshowflagbox,SIGNAL("stateChanged(int)"),self.eventsshowflagChanged)
        self.minieventsflag = QCheckBox(QApplication.translate("CheckBox","Mini Editor",None, QApplication.UnicodeUTF8))
        self.minieventsflag.setToolTip(QApplication.translate("Tooltip","Allows to enter a description of the last event",None, QApplication.UnicodeUTF8))
        self.minieventsflag.setChecked(bool(aw.minieventsflag))
        self.connect(self.minieventsflag,SIGNAL("stateChanged(int)"),self.minieventsflagChanged)
        barstylelabel = QLabel(QApplication.translate("Label","Bars",None, QApplication.UnicodeUTF8))
        barstyles = ["",
                    QApplication.translate("ComboBox","Type",None, QApplication.UnicodeUTF8),
                    QApplication.translate("ComboBox","Value",None, QApplication.UnicodeUTF8)]
        self.bartypeComboBox =  QComboBox()
        self.bartypeComboBox.setFocusPolicy(Qt.NoFocus)
        self.bartypeComboBox.setMaximumWidth(80)
        self.bartypeComboBox.addItems(barstyles)
        self.bartypeComboBox.setCurrentIndex(aw.qmc.eventsGraphflag)
        self.connect(self.bartypeComboBox,SIGNAL("currentIndexChanged(int)"),self.eventsGraphTypeflagChanged)
        typelabel1 = QLabel("1")
        typelabel2 = QLabel("2")
        typelabel3 = QLabel("3")
        typelabel4 = QLabel("4")
        self.etype0 = QLineEdit(aw.qmc.etypesf(0))
        self.etype0.setCursorPosition(0)
        self.etype1 = QLineEdit(aw.qmc.etypesf(1))
        self.etype1.setCursorPosition(0)
        self.etype2 = QLineEdit(aw.qmc.etypesf(2))
        self.etype2.setCursorPosition(0)
        self.etype3 = QLineEdit(aw.qmc.etypesf(3))
        self.etype3.setCursorPosition(0)
        self.etype0.setMaximumWidth(80)
        self.etype1.setMaximumWidth(80)
        self.etype2.setMaximumWidth(80)
        self.etype3.setMaximumWidth(80)
        self.E1colorButton = QPushButton(aw.qmc.etypesf(0))
        self.E1colorButton.setFocusPolicy(Qt.NoFocus)
        self.E2colorButton = QPushButton(aw.qmc.etypesf(1))
        self.E2colorButton.setFocusPolicy(Qt.NoFocus)
        self.E3colorButton = QPushButton(aw.qmc.etypesf(2))
        self.E3colorButton.setFocusPolicy(Qt.NoFocus)
        self.E4colorButton = QPushButton(aw.qmc.etypesf(3))
        self.E4colorButton.setFocusPolicy(Qt.NoFocus)
        self.connect(self.E1colorButton,SIGNAL("clicked()"),lambda b=0:self.setcoloreventline(b))
        self.connect(self.E2colorButton,SIGNAL("clicked()"),lambda b=1:self.setcoloreventline(b))
        self.connect(self.E3colorButton,SIGNAL("clicked()"),lambda b=2:self.setcoloreventline(b))
        self.connect(self.E4colorButton,SIGNAL("clicked()"),lambda b=3:self.setcoloreventline(b))
        #marker selection for comboboxes
        self.markers = ["",
                        QApplication.translate("Marker","Circle",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Square",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Pentagon",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Diamond",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Star",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Hexagon 1",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Hexagon 2",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","+",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","x",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","None",None, QApplication.UnicodeUTF8)]
        #keys interpreted by matplotlib. Must match order of self.markers 
        self.markervals = [None,"o","s","p","D","*","h","H","+","x","None"]
        #Marker type
        self.marker1typeComboBox =  QComboBox()
        self.marker1typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker1typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[0] in self.markervals:
            self.marker1typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[0]))
        else:
            self.marker1typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.connect(self.marker1typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=0:self.seteventmarker(x,m))
        self.marker2typeComboBox =  QComboBox()
        self.marker2typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker2typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[1] in self.markervals:
            self.marker2typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[1]))
        else:
            self.marker2typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.connect(self.marker2typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=1:self.seteventmarker(x,m))
        self.marker3typeComboBox =  QComboBox()
        self.marker3typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker3typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[2] in self.markervals:
            self.marker3typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[2]))
        else:
            self.marker3typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.connect(self.marker3typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=2:self.seteventmarker(x,m))
        self.marker4typeComboBox =  QComboBox()
        self.marker4typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker4typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[3] in self.markervals:
            self.marker4typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[3]))
        else:
            self.marker4typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.connect(self.marker4typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=3:self.seteventmarker(x,m))
        valuecolorlabel = QLabel(QApplication.translate("Label","Color",None, QApplication.UnicodeUTF8))
        valuecolorlabel.setFont(titlefont)
        valuesymbollabel = QLabel(QApplication.translate("Label","Marker",None, QApplication.UnicodeUTF8))
        valuesymbollabel.setFont(titlefont)
        valuethicknesslabel = QLabel(QApplication.translate("Label","Thickness",None, QApplication.UnicodeUTF8))
        valuethicknesslabel.setFont(titlefont)
        valuealphalabel = QLabel(QApplication.translate("Label","Opacity",None, QApplication.UnicodeUTF8))
        valuealphalabel.setFont(titlefont)
        valuesizelabel = QLabel(QApplication.translate("Label","Size",None, QApplication.UnicodeUTF8))
        valuesizelabel.setFont(titlefont)
        valuecolorlabel.setMaximumSize(80,20)
        valuesymbollabel.setMaximumSize(70,20)
        valuethicknesslabel.setMaximumSize(80,20)
        valuealphalabel.setMaximumSize(80,20)
        valuesizelabel.setMaximumSize(80,20)
        self.E1thicknessSpinBox = QSpinBox()
        self.E1thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E1thicknessSpinBox.setSingleStep(1)
        self.E1thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1thicknessSpinBox.setRange(1,10)
        self.E1thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[0])
        self.connect(self.E1thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w=1, x=0:self.setElinethickness(w,x))
        self.E2thicknessSpinBox = QSpinBox()
        self.E2thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E2thicknessSpinBox.setSingleStep(1)
        self.E2thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2thicknessSpinBox.setRange(1,10)
        self.E2thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[1])
        self.connect(self.E2thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w =1,x=1:self.setElinethickness(w,x))
        self.E3thicknessSpinBox = QSpinBox()
        self.E3thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E3thicknessSpinBox.setSingleStep(1)
        self.E3thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3thicknessSpinBox.setRange(1,10)
        self.E3thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[2])
        self.connect(self.E3thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=2:self.setElinethickness(w,x))
        self.E4thicknessSpinBox = QSpinBox()
        self.E4thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E4thicknessSpinBox.setSingleStep(1)
        self.E4thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4thicknessSpinBox.setRange(1,10)
        self.E4thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[3])
        self.connect(self.E4thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=0:self.setElinethickness(w,x))
        self.E1alphaSpinBox = QDoubleSpinBox()
        self.E1alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E1alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1alphaSpinBox.setRange(.1,1.)
        self.E1alphaSpinBox.setSingleStep(.1)
        self.E1alphaSpinBox.setValue(aw.qmc.Evaluealpha[0])
        self.connect(self.E1alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1,x=0:self.setElinealpha(w,x))
        self.E2alphaSpinBox = QDoubleSpinBox()
        self.E2alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E2alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2alphaSpinBox.setRange(.1,1.)
        self.E2alphaSpinBox.setSingleStep(.1)
        self.E2alphaSpinBox.setValue(aw.qmc.Evaluealpha[1])
        self.connect(self.E1alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1,x=1:self.setElinealpha(w,x))
        self.E3alphaSpinBox = QDoubleSpinBox()
        self.E3alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E3alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3alphaSpinBox.setRange(.1,1.)
        self.E3alphaSpinBox.setSingleStep(.1)
        self.E3alphaSpinBox.setValue(aw.qmc.Evaluealpha[2])
        self.connect(self.E3alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1,x=2:self.setElinealpha(w,x))
        self.E4alphaSpinBox = QDoubleSpinBox()
        self.E4alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E4alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4alphaSpinBox.setRange(.1,1.)
        self.E4alphaSpinBox.setSingleStep(.1)
        self.E4alphaSpinBox.setValue(aw.qmc.Evaluealpha[3])
        self.connect(self.E4alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1, x=3:self.setElinealpha(w,x))
        #Marker size
        self.E1sizeSpinBox = QSpinBox()
        self.E1sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E1sizeSpinBox.setSingleStep(1)
        self.E1sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1sizeSpinBox.setRange(1,14)
        self.E1sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[0])
        self.connect(self.E1sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=0:self.setEmarkersize(w,x))
        self.E2sizeSpinBox = QSpinBox()
        self.E2sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E2sizeSpinBox.setSingleStep(1)
        self.E2sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2sizeSpinBox.setRange(1,14)
        self.E2sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[1])
        self.connect(self.E2sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=1:self.setEmarkersize(w,x))
        self.E3sizeSpinBox = QSpinBox()
        self.E3sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E3sizeSpinBox.setSingleStep(1)
        self.E3sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3sizeSpinBox.setRange(1,14)
        self.E3sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[2])
        self.connect(self.E3sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=2:self.setEmarkersize(w,x))
        self.E4sizeSpinBox = QSpinBox()
        self.E4sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E4sizeSpinBox.setSingleStep(1)
        self.E4sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4sizeSpinBox.setRange(1,14)
        self.E4sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[3])
        self.connect(self.E4sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=3:self.setEmarkersize(w,x))
        self.autoCharge = QCheckBox(QApplication.translate("CheckBox","Auto CHARGE",None, QApplication.UnicodeUTF8))
        self.autoCharge.setChecked(aw.qmc.autoChargeFlag)
        self.autoCharge.setFocusPolicy(Qt.NoFocus)
        self.autoDrop = QCheckBox(QApplication.translate("CheckBox","Auto DROP",None, QApplication.UnicodeUTF8))
        self.autoDrop.setChecked(aw.qmc.autoDropFlag)
        self.autoDrop.setFocusPolicy(Qt.NoFocus)
        self.markTP = QCheckBox(QApplication.translate("CheckBox","Mark TP",None, QApplication.UnicodeUTF8))
        self.markTP.setChecked(aw.qmc.markTPflag)
        self.markTP.setFocusPolicy(Qt.NoFocus)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        closeButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        defaultButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        closeButton.setFocusPolicy(Qt.NoFocus)
        defaultButton.setFocusPolicy(Qt.NoFocus)
        self.connect(closeButton,SIGNAL("clicked()"),self.restoreState)
        self.connect(okButton,SIGNAL("clicked()"),self.updatetypes)
        self.connect(defaultButton,SIGNAL("clicked()"),self.settypedefault)
        ###  TAB 2
        #number of buttons per row
        self.nbuttonslabel = QLabel(QApplication.translate("Label","Max buttons per row", None, QApplication.UnicodeUTF8))
        self.nbuttonsSpinBox = QSpinBox()
        self.nbuttonsSpinBox.setMaximumWidth(100)
        self.nbuttonsSpinBox.setAlignment(Qt.AlignCenter)
        self.nbuttonsSpinBox.setRange(9,30)
        self.nbuttonsSpinBox.setValue(aw.buttonlistmaxlen)
        self.connect(self.nbuttonsSpinBox, SIGNAL("valueChanged(int)"),self.realignbuttons)        
        #table for showing events
        self.eventbuttontable = QTableWidget()
        self.eventbuttontable.setTabKeyNavigation(True)
        self.createEventbuttonTable()
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        addButton.setToolTip(QApplication.translate("Tooltip","Add new extra Event button",None, QApplication.UnicodeUTF8))
        #addButton.setMaximumWidth(100)
        addButton.setFocusPolicy(Qt.NoFocus)
        self.connect(addButton, SIGNAL("clicked()"),self.insertextraeventbutton)
        delButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
        delButton.setToolTip(QApplication.translate("Tooltip","Delete the last extra Event button",None, QApplication.UnicodeUTF8))
        #delButton.setMaximumWidth(100)
        delButton.setFocusPolicy(Qt.NoFocus)
        self.connect(delButton, SIGNAL("clicked()"),self.delextraeventbutton)
        helpButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None, QApplication.UnicodeUTF8))
        helpButton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpButton, SIGNAL("clicked()"),self.showEventbuttonhelp)
        #color patterns
        #flag that prevents changing colors too fast
        self.changingcolorflag = False
        colorpatternlabel = QLabel(QApplication.translate("Label","Color Pattern", None, QApplication.UnicodeUTF8))
        self.colorSpinBox = QSpinBox()
        self.colorSpinBox.setWrapping(True)
        self.colorSpinBox.setMaximumWidth(100)
        self.colorSpinBox.setAlignment(Qt.AlignCenter)
        self.colorSpinBox.setRange(0,359)
        self.connect(self.colorSpinBox, SIGNAL("valueChanged(int)"),self.colorizebuttons)
        ## tab4
        transferpalettebutton = QPushButton(QApplication.translate("Button","Transfer To", None, QApplication.UnicodeUTF8))
        transferpalettebutton.setFocusPolicy(Qt.NoFocus)
        setpalettebutton = QPushButton(QApplication.translate("Button","Restore From", None, QApplication.UnicodeUTF8))
        setpalettebutton.setFocusPolicy(Qt.NoFocus)
        palette = QApplication.translate("Label","palette #", None, QApplication.UnicodeUTF8)
        palettelist = []
        for i in range(10):
            palettelist.append(palette + str(i))
        self.transferpalettecombobox = QComboBox()
        self.transferpalettecombobox.setFocusPolicy(Qt.NoFocus)
        self.transferpalettecombobox.setMaximumWidth(120)
        self.transferpalettecombobox.addItems(palettelist)
        self.connect(transferpalettebutton, SIGNAL("clicked()"),self.transferbuttonsto)
        self.connect(setpalettebutton, SIGNAL("clicked()"),self.setbuttonsfrom)
        backupbutton = QPushButton(QApplication.translate("Button","Save", None, QApplication.UnicodeUTF8))
        backupbutton.setFocusPolicy(Qt.NoFocus)
        restorebutton = QPushButton(QApplication.translate("Button","Load", None, QApplication.UnicodeUTF8))
        restorebutton.setFocusPolicy(Qt.NoFocus)
        backupbutton.setToolTip(QApplication.translate("Tooltip","Backup all palettes to a text file",None, QApplication.UnicodeUTF8))
        restorebutton.setToolTip(QApplication.translate("Tooltip","Restore all palettes from a text file",None, QApplication.UnicodeUTF8))
        backupbutton.setMaximumWidth(140)
        restorebutton.setMaximumWidth(140)
        self.connect(backupbutton, SIGNAL("clicked()"),aw.backuppaletteeventbuttons)
        self.connect(restorebutton, SIGNAL("clicked()"),aw.restorepaletteeventbuttons)
        ## tab3
        eventtitlelabel = QLabel(QApplication.translate("Label","Event", None, QApplication.UnicodeUTF8))
        eventtitlelabel.setFont(titlefont)
        actiontitlelabel = QLabel(QApplication.translate("Label","Action", None, QApplication.UnicodeUTF8))
        actiontitlelabel.setFont(titlefont)
        commandtitlelabel = QLabel(QApplication.translate("Label","Command", None, QApplication.UnicodeUTF8))
        commandtitlelabel.setFont(titlefont)
        offsettitlelabel = QLabel(QApplication.translate("Label","Offset", None, QApplication.UnicodeUTF8))
        offsettitlelabel.setFont(titlefont)
        factortitlelabel = QLabel(QApplication.translate("Label","Factor", None, QApplication.UnicodeUTF8))
        factortitlelabel.setFont(titlefont)
        self.E1visibility = QCheckBox(aw.qmc.etypesf(0))
        self.E1visibility.setFocusPolicy(Qt.NoFocus)
        self.E1visibility.setChecked(bool(aw.eventslidervisibilities[0]))
        self.E2visibility = QCheckBox(aw.qmc.etypesf(1))
        self.E2visibility.setFocusPolicy(Qt.NoFocus)
        self.E2visibility.setChecked(bool(aw.eventslidervisibilities[1]))
        self.E3visibility = QCheckBox(aw.qmc.etypesf(2))
        self.E3visibility.setFocusPolicy(Qt.NoFocus)
        self.E3visibility.setChecked(bool(aw.eventslidervisibilities[2]))
        self.E4visibility = QCheckBox(aw.qmc.etypesf(3))
        self.E4visibility.setFocusPolicy(Qt.NoFocus)
        self.E4visibility.setChecked(bool(aw.eventslidervisibilities[3]))
        self.sliderActionTypes = ["",#QApplication.translate("ComboBox", "None",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Serial Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Modbus Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "DTA Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Call Program",None, QApplication.UnicodeUTF8)]
        self.E1action = QComboBox()
        self.E1action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E1action.setFocusPolicy(Qt.NoFocus)
        self.E1action.addItems(self.sliderActionTypes)
        self.E1action.setCurrentIndex(aw.eventslideractions[0])
        self.E2action = QComboBox()
        self.E2action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E2action.setFocusPolicy(Qt.NoFocus)
        self.E2action.addItems(self.sliderActionTypes)
        self.E2action.setCurrentIndex(aw.eventslideractions[1])
        self.E3action = QComboBox()
        self.E3action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E3action.setFocusPolicy(Qt.NoFocus)
        self.E3action.addItems(self.sliderActionTypes)
        self.E3action.setCurrentIndex(aw.eventslideractions[2])
        self.E4action = QComboBox()
        self.E4action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E4action.setFocusPolicy(Qt.NoFocus)
        self.E4action.addItems(self.sliderActionTypes)
        self.E4action.setCurrentIndex(aw.eventslideractions[3])
        self.E1command = QLineEdit(aw.eventslidercommands[0])
        self.E2command = QLineEdit(aw.eventslidercommands[1])
        self.E3command = QLineEdit(aw.eventslidercommands[2])
        self.E4command = QLineEdit(aw.eventslidercommands[3])
        self.E1offset = QSpinBox()
        self.E1offset.setAlignment(Qt.AlignRight)
        self.E1offset.setRange(-999,999)
        self.E1offset.setValue(aw.eventslideroffsets[0])
        self.E2offset = QSpinBox()
        self.E2offset.setAlignment(Qt.AlignRight)
        self.E2offset.setRange(-999,999)
        self.E2offset.setValue(aw.eventslideroffsets[1])
        self.E3offset = QSpinBox()
        self.E3offset.setAlignment(Qt.AlignRight)
        self.E3offset.setRange(-999,999)
        self.E3offset.setValue(aw.eventslideroffsets[2])
        self.E4offset = QSpinBox()
        self.E4offset.setAlignment(Qt.AlignRight)
        self.E4offset.setRange(-999,999)
        self.E4offset.setValue(aw.eventslideroffsets[3])
        self.E1factor = QDoubleSpinBox()
        self.E1factor.setAlignment(Qt.AlignRight)
        self.E1factor.setRange(-999,999)
        self.E1factor.setDecimals(2)
        self.E1factor.setValue(aw.eventsliderfactors[0])
        self.E1factor.setMaximumWidth(60)
        self.E2factor = QDoubleSpinBox()
        self.E2factor.setAlignment(Qt.AlignRight)
        self.E2factor.setRange(-999,999)
        self.E2factor.setDecimals(2)
        self.E2factor.setValue(aw.eventsliderfactors[1])
        self.E2factor.setMaximumWidth(60)
        self.E3factor = QDoubleSpinBox()
        self.E3factor.setAlignment(Qt.AlignRight)
        self.E3factor.setRange(-999,999)
        self.E3factor.setDecimals(2)
        self.E3factor.setValue(aw.eventsliderfactors[2])
        self.E3factor.setMaximumWidth(60)
        self.E4factor = QDoubleSpinBox()
        self.E4factor.setAlignment(Qt.AlignRight)
        self.E4factor.setRange(-999,999)
        self.E4factor.setDecimals(2)
        self.E4factor.setValue(aw.eventsliderfactors[3])
        self.E4factor.setMaximumWidth(60)
        helpsliderbutton =  QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpsliderbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpsliderbutton, SIGNAL("clicked()"),self.showSliderHelp)
        ## tab4
        qeventtitlelabel = QLabel(QApplication.translate("Label","Event", None, QApplication.UnicodeUTF8))
        qeventtitlelabel.setFont(titlefont)
        sourcetitlelabel = QLabel(QApplication.translate("Label","Source", None, QApplication.UnicodeUTF8))
        sourcetitlelabel.setFont(titlefont)
        mintitlelabel = QLabel(QApplication.translate("Label","Min", None, QApplication.UnicodeUTF8))
        mintitlelabel.setFont(titlefont)
        maxtitlelabel = QLabel(QApplication.translate("Label","Max", None, QApplication.UnicodeUTF8))
        maxtitlelabel.setFont(titlefont)
        coarsetitlelabel = QLabel(QApplication.translate("Label","Coarse", None, QApplication.UnicodeUTF8))
        coarsetitlelabel.setFont(titlefont)
        self.E1active = QCheckBox(aw.qmc.etypesf(0))
        self.E1active.setFocusPolicy(Qt.NoFocus)
        self.E1active.setChecked(bool(aw.eventquantifieractive[0]))
        self.E2active = QCheckBox(aw.qmc.etypesf(1))
        self.E2active.setFocusPolicy(Qt.NoFocus)
        self.E2active.setChecked(bool(aw.eventquantifieractive[1]))
        self.E3active = QCheckBox(aw.qmc.etypesf(2))
        self.E3active.setFocusPolicy(Qt.NoFocus)
        self.E3active.setChecked(bool(aw.eventquantifieractive[2]))
        self.E4active = QCheckBox(aw.qmc.etypesf(3))
        self.E4active.setFocusPolicy(Qt.NoFocus)
        self.E4active.setChecked(bool(aw.eventquantifieractive[3]))
        self.E1coarse = QCheckBox()
        self.E1coarse.setFocusPolicy(Qt.NoFocus)
        self.E1coarse.setChecked(bool(aw.eventquantifiercoarse[0]))
        self.E2coarse = QCheckBox()
        self.E2coarse.setFocusPolicy(Qt.NoFocus)
        self.E2coarse.setChecked(bool(aw.eventquantifiercoarse[1]))
        self.E3coarse = QCheckBox()
        self.E3coarse.setFocusPolicy(Qt.NoFocus)
        self.E3coarse.setChecked(bool(aw.eventquantifiercoarse[2]))
        self.E4coarse = QCheckBox()
        self.E4coarse.setFocusPolicy(Qt.NoFocus)
        self.E4coarse.setChecked(bool(aw.eventquantifiercoarse[3]))
        self.curvenames = []
        self.curvenames.append(QApplication.translate("ComboBox","ET",None, QApplication.UnicodeUTF8))
        self.curvenames.append(QApplication.translate("ComboBox","BT",None, QApplication.UnicodeUTF8))
        for i in range(len(aw.qmc.extradevices)):
            self.curvenames.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            self.curvenames.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
        self.E1SourceComboBox = QComboBox()
        self.E1SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[0] < len(self.curvenames):
            self.E1SourceComboBox.setCurrentIndex(aw.eventquantifiersource[0])
        self.E2SourceComboBox = QComboBox()
        self.E2SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[1] < len(self.curvenames):
            self.E2SourceComboBox.setCurrentIndex(aw.eventquantifiersource[1])
        self.E3SourceComboBox = QComboBox()
        self.E3SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[2] < len(self.curvenames):
            self.E3SourceComboBox.setCurrentIndex(aw.eventquantifiersource[2])
        self.E4SourceComboBox = QComboBox()
        self.E4SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[3] < len(self.curvenames):
            self.E4SourceComboBox.setCurrentIndex(aw.eventquantifiersource[3])
        self.E1min = QSpinBox()
        self.E1min.setAlignment(Qt.AlignRight)
        self.E1min.setRange(-99999,99999)
        self.E1min.setValue(aw.eventquantifiermin[0])
        self.E2min = QSpinBox()
        self.E2min.setAlignment(Qt.AlignRight)
        self.E2min.setRange(-99999,99999)
        self.E2min.setValue(aw.eventquantifiermin[1])
        self.E3min = QSpinBox()
        self.E3min.setAlignment(Qt.AlignRight)
        self.E3min.setRange(-99999,99999)
        self.E3min.setValue(aw.eventquantifiermin[2])
        self.E4min = QSpinBox()
        self.E4min.setAlignment(Qt.AlignRight)
        self.E4min.setRange(-99999,99999)
        self.E4min.setValue(aw.eventquantifiermin[3])
        self.E1max = QSpinBox()
        self.E1max.setAlignment(Qt.AlignRight)
        self.E1max.setRange(-99999,99999)
        self.E1max.setValue(aw.eventquantifiermax[0])
        self.E2max = QSpinBox()
        self.E2max.setAlignment(Qt.AlignRight)
        self.E2max.setRange(-99999,99999)
        self.E2max.setValue(aw.eventquantifiermax[1])
        self.E3max = QSpinBox()
        self.E3max.setAlignment(Qt.AlignRight)
        self.E3max.setRange(-99999,99999)
        self.E3max.setValue(aw.eventquantifiermax[2])
        self.E4max = QSpinBox()
        self.E4max.setAlignment(Qt.AlignRight)
        self.E4max.setRange(-99999,99999)
        self.E4max.setValue(aw.eventquantifiermax[3])
        applyquantifierbutton =  QPushButton(QApplication.translate("Button","Apply",None, QApplication.UnicodeUTF8))
        applyquantifierbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(applyquantifierbutton, SIGNAL("clicked()"),self.applyQuantifiers)
        ### LAYOUTS
        #### tab1 layout
        bartypeLayout = QHBoxLayout()
        bartypeLayout.addWidget(barstylelabel)
        bartypeLayout.addWidget(self.bartypeComboBox,Qt.AlignLeft)
        FlagsLayout = QHBoxLayout()
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.eventsbuttonflag)
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.eventsshowflagbox)
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.minieventsflag)
        FlagsLayout.addStretch()
        FlagsLayout.addSpacing(10)
        FlagsLayout.addLayout(bartypeLayout)
        FlagsLayout.addStretch()
        typeLayout = QGridLayout()
        typeLayout.addWidget(typelabel1,0,0)
        typeLayout.addWidget(self.etype0,0,1)
        typeLayout.addWidget(typelabel2,0,2)
        typeLayout.addWidget(self.etype1,0,3)
        typeLayout.addWidget(typelabel3,0,4)
        typeLayout.addWidget(self.etype2,0,5)
        typeLayout.addWidget(typelabel4,0,6)
        typeLayout.addWidget(self.etype3,0,7)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(closeButton)
        buttonLayout.addWidget(okButton)
        typeHBox = QHBoxLayout()
        typeHBox.addLayout(typeLayout)
        typeHBox.addStretch()
        typeHBox.addWidget(defaultButton)
        TypeGroupLayout = QGroupBox(QApplication.translate("GroupBox","Event Types",None, QApplication.UnicodeUTF8))
        TypeGroupLayout.setLayout(typeHBox)
        self.buttonActionTypes = ["",#QApplication.translate("ComboBox", "None",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Serial Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Call Program",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Modbus Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "DTA Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "IO Command",None, QApplication.UnicodeUTF8)]
        self.CHARGEbutton = QCheckBox(QApplication.translate("CheckBox", "CHARGE",None, QApplication.UnicodeUTF8))
        self.CHARGEbutton.setChecked(bool(aw.qmc.buttonvisibility[0]))
        self.CHARGEbuttonActionType = QComboBox()
        self.CHARGEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.CHARGEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.CHARGEbuttonActionType.addItems(self.buttonActionTypes)
        self.CHARGEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[0])
        self.CHARGEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[0])
        self.CHARGEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.DRYbutton = QCheckBox(QApplication.translate("CheckBox", "DRY END",None, QApplication.UnicodeUTF8))
        self.DRYbutton.setChecked(bool(aw.qmc.buttonvisibility[1]))
        self.DRYbuttonActionType = QComboBox()
        self.DRYbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.DRYbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.DRYbuttonActionType.addItems(self.buttonActionTypes)
        self.DRYbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[1])
        self.DRYbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[1])
        self.DRYbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.FCSbutton = QCheckBox(QApplication.translate("CheckBox", "FC START",None, QApplication.UnicodeUTF8))
        self.FCSbutton.setChecked(bool(aw.qmc.buttonvisibility[2]))
        self.FCSbuttonActionType = QComboBox()
        self.FCSbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.FCSbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.FCSbuttonActionType.addItems(self.buttonActionTypes)
        self.FCSbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[2])
        self.FCSbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[2])
        self.FCSbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.FCEbutton = QCheckBox(QApplication.translate("CheckBox", "FC END",None, QApplication.UnicodeUTF8))
        self.FCEbutton.setChecked(bool(aw.qmc.buttonvisibility[3]))
        self.FCEbuttonActionType = QComboBox()
        self.FCEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.FCEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.FCEbuttonActionType.addItems(self.buttonActionTypes)
        self.FCEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[3])
        self.FCEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[3])
        self.FCEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.SCSbutton = QCheckBox(QApplication.translate("CheckBox", "SC START",None, QApplication.UnicodeUTF8))
        self.SCSbutton.setChecked(bool(aw.qmc.buttonvisibility[4]))
        self.SCSbuttonActionType = QComboBox()
        self.SCSbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.SCSbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SCSbuttonActionType.addItems(self.buttonActionTypes)
        self.SCSbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[4])
        self.SCSbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[4])
        self.SCSbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.SCEbutton = QCheckBox(QApplication.translate("CheckBox", "SC END",None, QApplication.UnicodeUTF8))
        self.SCEbutton.setChecked(bool(aw.qmc.buttonvisibility[5]))
        self.SCEbuttonActionType = QComboBox()
        self.SCEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.SCEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SCEbuttonActionType.addItems(self.buttonActionTypes)
        self.SCEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[5])
        self.SCEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[5])
        self.SCEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.DROPbutton = QCheckBox(QApplication.translate("CheckBox", "DROP",None, QApplication.UnicodeUTF8))
        self.DROPbutton.setChecked(bool(aw.qmc.buttonvisibility[6]))
        self.DROPbuttonActionType = QComboBox()
        self.DROPbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.DROPbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.DROPbuttonActionType.addItems(self.buttonActionTypes)
        self.DROPbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[6])
        self.DROPbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[6])
        self.DROPbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.COOLbutton = QCheckBox(QApplication.translate("CheckBox", "COOL END",None, QApplication.UnicodeUTF8))
        self.COOLbutton.setChecked(bool(aw.qmc.buttonvisibility[7]))
        self.COOLbuttonActionType = QComboBox()
        self.COOLbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.COOLbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.COOLbuttonActionType.addItems(self.buttonActionTypes)
        self.COOLbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[7])
        self.COOLbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[7])
        self.COOLbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        
        self.ONbuttonLabel = QLabel(QApplication.translate("Label", "ON", None, QApplication.UnicodeUTF8))
        self.ONbuttonActionType = QComboBox()
        self.ONbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.ONbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.ONbuttonActionType.addItems(self.buttonActionTypes)
        self.ONbuttonActionType.setCurrentIndex(aw.qmc.extrabuttonactions[0])
        self.ONbuttonActionString = QLineEdit(aw.qmc.extrabuttonactionstrings[0])
        self.ONbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))        
        self.OFFbuttonActionType = QComboBox()
        self.OFFbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.OFFbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.OFFbuttonActionType.addItems(self.buttonActionTypes)
        self.OFFbuttonActionType.setCurrentIndex(aw.qmc.extrabuttonactions[1])
        self.OFFbuttonActionString = QLineEdit(aw.qmc.extrabuttonactionstrings[1])
        self.OFFbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.OFFbuttonLabel = QLabel(QApplication.translate("Label", "OFF", None, QApplication.UnicodeUTF8))
        self.SAMPLINGbuttonActionType = QComboBox()
        self.SAMPLINGbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.SAMPLINGbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SAMPLINGbuttonActionType.addItems(self.buttonActionTypes)
        self.SAMPLINGbuttonActionType.setCurrentIndex(aw.qmc.extrabuttonactions[2])
        self.SAMPLINGbuttonActionString = QLineEdit(aw.qmc.extrabuttonactionstrings[2])
        self.SAMPLINGbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))        
        defaultButtonsLayout = QGridLayout()
        defaultButtonsLayout.addWidget(self.ONbuttonLabel,0,0,Qt.AlignCenter)
        defaultButtonsLayout.addWidget(self.ONbuttonActionType,0,1)
        defaultButtonsLayout.addWidget(self.ONbuttonActionString,0,2)
        defaultButtonsLayout.addWidget(self.CHARGEbutton,1,0)
        defaultButtonsLayout.addWidget(self.CHARGEbuttonActionType,1,1)
        defaultButtonsLayout.addWidget(self.CHARGEbuttonActionString,1,2)
        defaultButtonsLayout.addWidget(self.DRYbutton,2,0)
        defaultButtonsLayout.addWidget(self.DRYbuttonActionType,2,1)
        defaultButtonsLayout.addWidget(self.DRYbuttonActionString,2,2)
        defaultButtonsLayout.addWidget(self.FCSbutton,3,0)
        defaultButtonsLayout.addWidget(self.FCSbuttonActionType,3,1)
        defaultButtonsLayout.addWidget(self.FCSbuttonActionString,3,2)
        defaultButtonsLayout.addWidget(self.FCEbutton,4,0)
        defaultButtonsLayout.addWidget(self.FCEbuttonActionType,4,1)
        defaultButtonsLayout.addWidget(self.FCEbuttonActionString,4,2)
        defaultButtonsLayout.addWidget(self.SCSbutton,5,0)
        defaultButtonsLayout.addWidget(self.SCSbuttonActionType,5,1)
        defaultButtonsLayout.addWidget(self.SCSbuttonActionString,5,2)
        defaultButtonsLayout.addWidget(self.SCEbutton,6,0)
        defaultButtonsLayout.addWidget(self.SCEbuttonActionType,6,1)
        defaultButtonsLayout.addWidget(self.SCEbuttonActionString,6,2)
        defaultButtonsLayout.addWidget(self.DROPbutton,7,0)
        defaultButtonsLayout.addWidget(self.DROPbuttonActionType,7,1)
        defaultButtonsLayout.addWidget(self.DROPbuttonActionString,7,2)
        defaultButtonsLayout.addWidget(self.COOLbutton,8,0)
        defaultButtonsLayout.addWidget(self.COOLbuttonActionType,8,1)
        defaultButtonsLayout.addWidget(self.COOLbuttonActionString,8,2)
        defaultButtonsLayout.addWidget(self.OFFbuttonLabel,9,0,Qt.AlignCenter)
        defaultButtonsLayout.addWidget(self.OFFbuttonActionType,9,1)
        defaultButtonsLayout.addWidget(self.OFFbuttonActionString,9,2)
        defaultButtonsLayout.setContentsMargins(5,5,5,5)
        defaultButtonsLayout.setHorizontalSpacing(10)
        defaultButtonsLayout.setVerticalSpacing(7)
        ButtonGroupLayout = QGroupBox(QApplication.translate("GroupBox","Default Buttons",None, QApplication.UnicodeUTF8))
        ButtonGroupLayout.setLayout(defaultButtonsLayout)
        autoLayout = QHBoxLayout()
        autoLayout.addWidget(self.autoCharge)
        autoLayout.addSpacing(20)
        autoLayout.addWidget(self.autoDrop)
        autoLayout.addSpacing(20)
        autoLayout.addWidget(self.markTP)
        autoLayout.addStretch()
        samplingLayout = QHBoxLayout()
        samplingLayout.addStretch()
        samplingLayout.addWidget(self.SAMPLINGbuttonActionType)
        samplingLayout.addWidget(self.SAMPLINGbuttonActionString)
        samplingLayout.addStretch()
        SamplingGroupLayout = QGroupBox(QApplication.translate("GroupBox","Sampling Interval",None, QApplication.UnicodeUTF8))
        SamplingGroupLayout.setLayout(samplingLayout)
        tab1layout = QVBoxLayout()
        tab1layout.addLayout(FlagsLayout)
        tab1layout.addWidget(TypeGroupLayout)
        tab1layout.addWidget(ButtonGroupLayout)
        tab1layout.addWidget(SamplingGroupLayout)
        tab1layout.addLayout(autoLayout)
        tab1layout.addStretch()
        tab1layout.setContentsMargins(5,5,5,5)
        nbuttonslayout = QHBoxLayout()
        nbuttonslayout.addWidget(self.nbuttonslabel)
        nbuttonslayout.addWidget(self.nbuttonsSpinBox)
        nbuttonslayout.addWidget(colorpatternlabel)
        nbuttonslayout.addWidget(self.colorSpinBox)
        nbuttonslayout.addStretch()
        tab2buttonlayout = QHBoxLayout()
        tab2buttonlayout.addWidget(addButton)
        tab2buttonlayout.addWidget(delButton)
        tab2buttonlayout.addStretch()
        tab2buttonlayout.addWidget(helpButton)
        ### tab2 layout
        tab2layout = QVBoxLayout()
        tab2layout.addWidget(self.eventbuttontable)
        tab2layout.addLayout(nbuttonslayout)
        tab2layout.addLayout(tab2buttonlayout)
        tab2layout.setSpacing(5)
        tab2layout.setContentsMargins(0,10,0,5)
        ### tab4 layout
        paletteGrid = QGridLayout()
        paletteGrid.addWidget(transferpalettebutton,0,0)
        paletteGrid.addWidget(self.transferpalettecombobox,1,1)
        paletteGrid.addWidget(setpalettebutton,2,0)
        paletteBox = QHBoxLayout()
        paletteBox.addStretch()
        paletteBox.addLayout(paletteGrid)
        paletteBox.addStretch()
        paletteGroupLayout = QGroupBox(QApplication.translate("GroupBox","Management",None, QApplication.UnicodeUTF8))
        paletteGroupLayout.setLayout(paletteBox)
        paletteButtons = QHBoxLayout()
        paletteButtons.addStretch()
        paletteButtons.addWidget(restorebutton)
        paletteButtons.addWidget(backupbutton)
        tab3layout = QVBoxLayout()
        tab3layout.addWidget(paletteGroupLayout)
        tab3layout.addLayout(paletteButtons)
        tab3layout.addStretch()
        ### tab5 layout
        valueLayout = QGridLayout()
        valueLayout.addWidget(valuecolorlabel,0,0)
        valueLayout.addWidget(valuesymbollabel,0,1)
        valueLayout.addWidget(valuethicknesslabel,0,2)
        valueLayout.addWidget(valuealphalabel,0,3)
        valueLayout.addWidget(valuesizelabel,0,4)
        valueLayout.addWidget(self.E1colorButton,1,0)
        valueLayout.addWidget(self.marker1typeComboBox,1,1)
        valueLayout.addWidget(self.E1thicknessSpinBox,1,2)
        valueLayout.addWidget(self.E1alphaSpinBox,1,3)
        valueLayout.addWidget(self.E1sizeSpinBox,1,4)
        valueLayout.addWidget(self.E2colorButton,2,0)
        valueLayout.addWidget(self.marker2typeComboBox,2,1)
        valueLayout.addWidget(self.E2thicknessSpinBox,2,2)
        valueLayout.addWidget(self.E2alphaSpinBox,2,3)
        valueLayout.addWidget(self.E2sizeSpinBox,2,4)
        valueLayout.addWidget(self.E3colorButton,3,0)
        valueLayout.addWidget(self.marker3typeComboBox,3,1)
        valueLayout.addWidget(self.E3thicknessSpinBox,3,2)
        valueLayout.addWidget(self.E3alphaSpinBox,3,3)
        valueLayout.addWidget(self.E3sizeSpinBox,3,4)
        valueLayout.addWidget(self.E4colorButton,4,0)
        valueLayout.addWidget(self.marker4typeComboBox,4,1)
        valueLayout.addWidget(self.E4thicknessSpinBox,4,2)
        valueLayout.addWidget(self.E4alphaSpinBox,4,3)
        valueLayout.addWidget(self.E4sizeSpinBox,4,4)
        valueHLayout = QHBoxLayout()
        valueHLayout.addStretch()
        valueHLayout.addLayout(valueLayout)
        valueHLayout.addStretch()
        ### tab3 layout
        tab5Layout = QGridLayout()
        tab5Layout.addWidget(eventtitlelabel,0,0)
        tab5Layout.addWidget(actiontitlelabel,0,1)
        tab5Layout.addWidget(commandtitlelabel,0,2)
        tab5Layout.addWidget(offsettitlelabel,0,3)
        tab5Layout.addWidget(factortitlelabel,0,4)
        tab5Layout.addWidget(self.E1visibility,1,0)
        tab5Layout.addWidget(self.E2visibility,2,0)
        tab5Layout.addWidget(self.E3visibility,3,0)
        tab5Layout.addWidget(self.E4visibility,4,0)
        tab5Layout.addWidget(self.E1action,1,1)
        tab5Layout.addWidget(self.E2action,2,1)
        tab5Layout.addWidget(self.E3action,3,1)
        tab5Layout.addWidget(self.E4action,4,1)
        tab5Layout.addWidget(self.E1command,1,2)
        tab5Layout.addWidget(self.E2command,2,2)
        tab5Layout.addWidget(self.E3command,3,2)
        tab5Layout.addWidget(self.E4command,4,2)
        tab5Layout.addWidget(self.E1offset,1,3)
        tab5Layout.addWidget(self.E2offset,2,3)
        tab5Layout.addWidget(self.E3offset,3,3)
        tab5Layout.addWidget(self.E4offset,4,3)
        tab5Layout.addWidget(self.E1factor,1,4)
        tab5Layout.addWidget(self.E2factor,2,4)
        tab5Layout.addWidget(self.E3factor,3,4)
        tab5Layout.addWidget(self.E4factor,4,4)
        SliderHelpHBox = QHBoxLayout()
        SliderHelpHBox.addStretch()
        SliderHelpHBox.addWidget(helpsliderbutton)
        C5VBox = QVBoxLayout()
        C5VBox.addLayout(tab5Layout)
        C5VBox.addStretch()
        C5VBox.addLayout(SliderHelpHBox)
        ### tab4 layout
        tab6Layout = QGridLayout()
        tab6Layout.addWidget(qeventtitlelabel,0,0)
        tab6Layout.addWidget(sourcetitlelabel,0,1)
        tab6Layout.addWidget(mintitlelabel,0,2)
        tab6Layout.addWidget(maxtitlelabel,0,3)
        tab6Layout.addWidget(coarsetitlelabel,0,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E1active,1,0)
        tab6Layout.addWidget(self.E2active,2,0)
        tab6Layout.addWidget(self.E3active,3,0)
        tab6Layout.addWidget(self.E4active,4,0)
        tab6Layout.addWidget(self.E1SourceComboBox,1,1)
        tab6Layout.addWidget(self.E2SourceComboBox,2,1)
        tab6Layout.addWidget(self.E3SourceComboBox,3,1)
        tab6Layout.addWidget(self.E4SourceComboBox,4,1)
        tab6Layout.addWidget(self.E1min,1,2)
        tab6Layout.addWidget(self.E2min,2,2)
        tab6Layout.addWidget(self.E3min,3,2)
        tab6Layout.addWidget(self.E4min,4,2)
        tab6Layout.addWidget(self.E1max,1,3)
        tab6Layout.addWidget(self.E2max,2,3)
        tab6Layout.addWidget(self.E3max,3,3)
        tab6Layout.addWidget(self.E4max,4,3)
        tab6Layout.addWidget(self.E1coarse,1,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E2coarse,2,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E3coarse,3,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E4coarse,4,4,Qt.AlignCenter)
        QuantifierApplyHBox = QHBoxLayout()
        QuantifierApplyHBox.addStretch()
        QuantifierApplyHBox.addWidget(applyquantifierbutton)
        C6VBox = QVBoxLayout()
        C6VBox.addLayout(tab6Layout)
        C6VBox.addStretch()
        C6VBox.addLayout(QuantifierApplyHBox)
###########################################
        #tab layout
        self.TabWidget = QTabWidget()
        self.connect(self.TabWidget,SIGNAL("currentChanged(int)"),lambda i=i:self.tabSwitched(i))
        C1Widget = QWidget()
        C1Widget.setLayout(tab1layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab","Config",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2layout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab","Buttons",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(C5VBox)
        self.TabWidget.addTab(C5Widget,QApplication.translate("Tab","Sliders",None, QApplication.UnicodeUTF8))
        C6Widget = QWidget()
        C6Widget.setLayout(C6VBox)
        self.TabWidget.addTab(C6Widget,QApplication.translate("Tab","Quantifiers",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab","Palettes",None, QApplication.UnicodeUTF8))
        valueVLayout = QVBoxLayout()
        valueVLayout.addLayout(valueHLayout)
        valueVLayout.addStretch()
        C4Widget = QWidget()
        C4Widget.setLayout(valueVLayout)
        self.TabWidget.addTab(C4Widget,QApplication.translate("Tab","Style",None, QApplication.UnicodeUTF8))
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(self.TabWidget)
        mainLayout.setSpacing(5)
        mainLayout.setContentsMargins(5, 15, 5, 5)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        
    def showSliderHelp(self):
        string = u(QApplication.translate("Message", "<b>Event</b> hide or show the corresponding slider",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Action</b> Perform an action on slider release",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Command</b> depends on the action type ('{}' is replaced by <i>value</i>*<i>factor</i> + <i>offset</i>)",None, QApplication.UnicodeUTF8)) + "<br><br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Serial Command: ASCII serial command or binary a2b_uu(serial command)",None, QApplication.UnicodeUTF8)) + "<br><br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Modbus Command: write([slaveId,register,value],..,[slaveId,register,value]) or wcoils(slaveId,register,[&lt;bool&gt;,..,&lt;bool&gt;]) or wcoils(slaveId,register,&lt;bool&gt;) writes values to the registers in slaves specified by the given ids",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "DTA Command: Insert Data address : value, ex. 4701:1000 and sv is 100. always multiply with 10 if value Unit: 0.1 / ex. 4719:0 stops heating",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Offset</b> added as offset to the slider value",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Factor</b> multiplicator of the slider value",None, QApplication.UnicodeUTF8))
        QMessageBox.information(self,QApplication.translate("Message", "Event custom buttons",None, QApplication.UnicodeUTF8),string)


    def applyQuantifiers(self):
        self.saveQuantifierSettings()
        # recompute the 4 event quantifier linsapces
        aw.computeLinespaces()
        # remove previous quantifier events
        # recompute quantifier events
        for i in range(4):
            if aw.eventquantifieractive[i]:
                temp,timex = aw.quantifier2tempandtime(i)
                if temp:
                    # a temp curve exists
                    linespace = aw.eventquantifierlinspaces[i]
                    if aw.eventquantifiercoarse[i]:
                        linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdcoarse
                    else:
                        linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdfine
                    # loop over that data and classify each value
                    ld = None # last digitized value
                    lt = None # last digitized temp value
                    for ii in range(len(temp)):
                        t = temp[ii]
                        d = aw.digitize(t,linespace,aw.eventquantifiercoarse[i])
                        if d != None and (ld == None or ld != d):
                            # take only changes
                            # and only if significantly different than previous to avoid fluktuation
                            if ld == None or lt == None or linespacethreshold < abs(t - lt):
                                # establish this one
                                ld = d
                                lt = t
                                # add to event table
                                aw.qmc.specialevents.append(aw.qmc.time2index(timex[ii]))
                                aw.qmc.specialeventstype.append(i)
                                aw.qmc.specialeventsStrings.append("Q")
                                aw.qmc.specialeventsvalue.append(float(d+1))
                                aw.qmc.safesaveflag = True
                                
                    # redraw                 
                    aw.qmc.redraw(recomputeAllDeltas=False)
        # add quantifier events
                
        

    def tabSwitched(self,i):
        if i == 0:
            self.saveSliderSettings()
            self.saveQuantifierSettings()
        elif i == 1: # switched to Button tab
            self.createEventbuttonTable()
            self.saveSliderSettings()
            self.saveQuantifierSettings()
        elif i == 2: # switched to Slider tab
            self.updateSliderTab()
            self.saveQuantifierSettings()
        elif i == 3: # switched to Quantifier tab
            self.updateQuantifierTab()
        elif i == 4: # switched to Palette tab
            # store slider settings from Slider tab to global variables
            # store sliders
            self.saveSliderSettings()
            self.saveQuantifierSettings()
            # store buttons
            self.savetableextraeventbutton()
        elif i == 5: # switched to Style tab
            self.updateStyleTab()
            self.saveSliderSettings()
            self.saveQuantifierSettings()

    def updateQuantifierTab(self):
        self.E1active.setText(self.etype0.text())
        self.E2active.setText(self.etype1.text())
        self.E3active.setText(self.etype2.text())
        self.E4active.setText(self.etype3.text())

    def updateStyleTab(self):
        # update color button texts
        self.E1colorButton.setText(self.etype0.text())
        self.E2colorButton.setText(self.etype1.text())
        self.E3colorButton.setText(self.etype2.text())
        self.E4colorButton.setText(self.etype3.text())
        # update markers
        if aw.qmc.EvalueMarker[0] in self.markervals:
            self.marker1typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[0]))
        else:
            self.marker1typeComboBox.setCurrentIndex(0)
        if aw.qmc.EvalueMarker[1] in self.markervals:
            self.marker2typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[1]))
        else:
            self.marker2typeComboBox.setCurrentIndex(0)
        if aw.qmc.EvalueMarker[2] in self.markervals:
            self.marker3typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[2]))
        else:
            self.marker3typeComboBox.setCurrentIndex(0)
        if aw.qmc.EvalueMarker[3] in self.markervals:
            self.marker4typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[3]))
        else:
            self.marker4typeComboBox.setCurrentIndex(0)
        # line thickness
        self.E1thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[0])
        self.E2thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[1])
        self.E3thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[2])
        self.E4thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[3])
        # opacity
        self.E1alphaSpinBox.setValue(aw.qmc.Evaluealpha[0])
        self.E2alphaSpinBox.setValue(aw.qmc.Evaluealpha[1])
        self.E3alphaSpinBox.setValue(aw.qmc.Evaluealpha[2])
        self.E4alphaSpinBox.setValue(aw.qmc.Evaluealpha[3])
        # marker sizes
        self.E1sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[0])
        self.E2sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[1])
        self.E3sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[2])
        self.E4sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[3])

    def updateSliderTab(self):
        # set event names
        self.E1visibility.setText(self.etype0.text())
        self.E2visibility.setText(self.etype1.text())
        self.E3visibility.setText(self.etype2.text())
        self.E4visibility.setText(self.etype3.text())
        # set slider visibility
        self.E1visibility.setChecked(bool(aw.eventslidervisibilities[0]))
        self.E2visibility.setChecked(bool(aw.eventslidervisibilities[1]))
        self.E3visibility.setChecked(bool(aw.eventslidervisibilities[2]))
        self.E4visibility.setChecked(bool(aw.eventslidervisibilities[3]))
        # set slider action
        self.E1action.setCurrentIndex(aw.eventslideractions[0])
        self.E2action.setCurrentIndex(aw.eventslideractions[1])
        self.E3action.setCurrentIndex(aw.eventslideractions[2])
        self.E4action.setCurrentIndex(aw.eventslideractions[3])
        # set slider command
        self.E1command.setText(aw.eventslidercommands[0])
        self.E2command.setText(aw.eventslidercommands[1])
        self.E3command.setText(aw.eventslidercommands[2])
        self.E4command.setText(aw.eventslidercommands[3])
        # set slider offset
        self.E1offset.setValue(aw.eventslideroffsets[0])
        self.E2offset.setValue(aw.eventslideroffsets[1])
        self.E3offset.setValue(aw.eventslideroffsets[2])
        self.E4offset.setValue(aw.eventslideroffsets[3])
        # set slider factors
        self.E1factor.setValue(aw.eventsliderfactors[0])
        self.E2factor.setValue(aw.eventsliderfactors[1])
        self.E3factor.setValue(aw.eventsliderfactors[2])
        self.E4factor.setValue(aw.eventsliderfactors[3])

    def setElinethickness(self,_,val):
        self.E1thicknessSpinBox.setDisabled(True)
        self.E2thicknessSpinBox.setDisabled(True)
        self.E3thicknessSpinBox.setDisabled(True)
        self.E4thicknessSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.Evaluelinethickness[0] = self.E1thicknessSpinBox.value()
        if val == 1:
            aw.qmc.Evaluelinethickness[1] = self.E2thicknessSpinBox.value()
        if val == 2:
            aw.qmc.Evaluelinethickness[2] = self.E3thicknessSpinBox.value()
        if val == 3:
            aw.qmc.Evaluelinethickness[3] = self.E4thicknessSpinBox.value()
        self.E1thicknessSpinBox.setDisabled(False)
        self.E2thicknessSpinBox.setDisabled(False)
        self.E3thicknessSpinBox.setDisabled(False)
        self.E4thicknessSpinBox.setDisabled(False)
        aw.qmc.redraw()

    def setEmarkersize(self,_,val):
        self.E1sizeSpinBox.setDisabled(True)
        self.E2sizeSpinBox.setDisabled(True)
        self.E3sizeSpinBox.setDisabled(True)
        self.E4sizeSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.EvalueMarkerSize[0] = self.E1sizeSpinBox.value()
        if val == 1:
            aw.qmc.EvalueMarkerSize[1] = self.E2sizeSpinBox.value()
        if val == 2:
            aw.qmc.EvalueMarkerSize[2] = self.E3sizeSpinBox.value()
        if val == 3:
            aw.qmc.EvalueMarkerSize[3] = self.E4sizeSpinBox.value()
        self.E1sizeSpinBox.setDisabled(False)
        self.E2sizeSpinBox.setDisabled(False)
        self.E3sizeSpinBox.setDisabled(False)
        self.E4sizeSpinBox.setDisabled(False)
        aw.qmc.redraw()

    def setElinealpha(self,_,val):
        self.E1alphaSpinBox.setDisabled(True)
        self.E2alphaSpinBox.setDisabled(True)
        self.E3alphaSpinBox.setDisabled(True)
        self.E4alphaSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.Evaluealpha[0] = self.E1alphaSpinBox.value()
        if val == 1:
            aw.qmc.Evaluealpha[1] = self.E2alphaSpinBox.value()
        if val == 2:
            aw.qmc.Evaluealpha[2] = self.E3alphaSpinBox.value()
        if val == 3:
            aw.qmc.Evaluealpha[3] = self.E4alphaSpinBox.value()
        self.E1alphaSpinBox.setDisabled(False)
        self.E2alphaSpinBox.setDisabled(False)
        self.E3alphaSpinBox.setDisabled(False)
        self.E4alphaSpinBox.setDisabled(False)
        aw.qmc.redraw()

    def transferbuttonsto(self):
        pindex = self.transferpalettecombobox.currentIndex()
        aw.transferbuttonsto(pindex)

    def setbuttonsfrom(self):
        pindex = self.transferpalettecombobox.currentIndex()
        answer = aw.setbuttonsfrom(pindex)
        if answer:
            self.createEventbuttonTable()

    #applys a pattern of colors 
    def colorizebuttons(self,pattern=None):
        if self.changingcolorflag:
            n = self.colorSpinBox.value()
            self.colorSpinBox.setValue(n-1)
            return
        self.changingcolorflag = True
        if not pattern:
            pattern = self.colorSpinBox.value()
        ncolumns = aw.buttonlistmaxlen
        nbuttons = len(aw.buttonlist)
        initbuttons = ncolumns - 9
        nrows,extra = divmod((nbuttons-initbuttons),ncolumns)
        #button background colors (aw.extraeventbuttoncolor)
        bcolor = ["lightgrey"]*initbuttons
        step = pattern
        if extra:
            nrows += 1
        gap = int(-1*(230-50)/ncolumns)
        for i in range(nrows):
            for f in range(230,50,gap):
                color = QColor()    
                color.setHsv(step,255,f,255)
                bcolor.append(str(color.name()))
            step += pattern*2
        #text color (aw.extraeventbuttontextcolor)
        tcolor = ["yellow"]*nbuttons
        aw.extraeventbuttoncolor = bcolor[:nbuttons]
        aw.extraeventbuttontextcolor = tcolor[:]
        for i in range(nbuttons):
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[i],aw.extraeventbuttoncolor[i])
            aw.buttonlist[i].setStyleSheet(style)
        self.createEventbuttonTable()
        #check visibility
        if not aw.extraeventsbuttonsflag:
            self.extrabuttonsshowCheck.setChecked(True)
        self.changingcolorflag = False

    def seteventmarker(self,_,m):
        if m == 0 and self.marker1typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker1typeComboBox.currentIndex()])
        if m == 1 and self.marker2typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker2typeComboBox.currentIndex()])
        if m == 2 and self.marker3typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker3typeComboBox.currentIndex()])
        if m == 3 and self.marker4typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker4typeComboBox.currentIndex()])
        aw.qmc.redraw()

    def setcoloreventline(self,b):
        colorf = aw.colordialog(QColor(aw.qmc.EvalueColor[b]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.EvalueColor[b] = colorname
            aw.qmc.redraw()

    def realignbuttons(self):
        aw.buttonlistmaxlen = self.nbuttonsSpinBox.value()
        aw.realignbuttons()

    def createEventbuttonTable(self):
        self.nbuttonsSpinBox.setValue(aw.buttonlistmaxlen)
        self.eventbuttontable.clear()
        nbuttons = len(aw.extraeventstypes) 
        self.eventbuttontable.setRowCount(nbuttons)
        self.eventbuttontable.setColumnCount(10)
        self.eventbuttontable.setHorizontalHeaderLabels([QApplication.translate("Table","Label",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Description",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Type",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Value",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Action",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Documentation",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Visibility",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Color",None, QApplication.UnicodeUTF8),
                                                         QApplication.translate("Table","Text Color",None, QApplication.UnicodeUTF8),""])
        self.eventbuttontable.setAlternatingRowColors(True)
        self.eventbuttontable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.eventbuttontable.setSelectionBehavior(QTableWidget.SelectRows)
        self.eventbuttontable.setSelectionMode(QTableWidget.SingleSelection)
        self.eventbuttontable.setShowGrid(True)
        self.eventbuttontable.verticalHeader().setResizeMode(2)
        visibility = [QApplication.translate("ComboBox","OFF",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox","ON",None, QApplication.UnicodeUTF8)]
        for i in range(nbuttons):
            #label
            labeledit = QLineEdit(u(aw.extraeventslabels[i]))
            self.connect(labeledit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setlabeleventbutton(z,i))
            #description
            descriptionedit = QLineEdit(u(aw.extraeventsdescriptions[i]))
            self.connect(descriptionedit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setdescriptioneventbutton(z,i))
            #type
            typeComboBox = QComboBox()
            typeComboBox.addItems([self.etype0.text(),self.etype1.text(),self.etype2.text(),self.etype3.text(),"--"])
            typeComboBox.setCurrentIndex(aw.extraeventstypes[i])
            self.connect(typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,i=i:self.settypeeventbutton(z,i))
            #value
            valueEdit = QLineEdit()
            valueEdit.setValidator(QRegExpValidator(QRegExp(r"^100|\d?\d?$"),self))
            valueEdit.setText(aw.qmc.eventsvalues(aw.extraeventsvalues[i]))
            valueEdit.setAlignment(Qt.AlignRight)
            self.connect(valueEdit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setvalueeventbutton(z,i))
            #action
            actionComboBox = QComboBox()
            actionComboBox.addItems([QApplication.translate("ComboBox","None",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("ComboBox","Serial Command",None, QApplication.UnicodeUTF8),
                                     QApplication.translate("ComboBox","Call Program",None, QApplication.UnicodeUTF8),
                                     QApplication.translate("ComboBox","Multiple Event",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("ComboBox","Modbus Command",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("ComboBox","DTA Command",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("ComboBox","IO Command",None, QApplication.UnicodeUTF8)])
            actionComboBox.setCurrentIndex(aw.extraeventsactions[i])
            self.connect(actionComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,i=i:self.setactioneventbutton(z,i))
            #action description
            actiondescriptionedit = QLineEdit(u(aw.extraeventsactionstrings[i]))
            self.connect(actiondescriptionedit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setactiondescriptioneventbutton(z,i))
            #visibility
            visibilityComboBox =  QComboBox()
            visibilityComboBox.addItems(visibility)
            visibilityComboBox.setCurrentIndex(aw.extraeventsvisibility[i])
            self.connect(visibilityComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,i=i:self.setvisibilitytyeventbutton(z,i))
            #Color
            colorButton = QPushButton("Select")
            colorButton.setFocusPolicy(Qt.NoFocus)
            self.connect(colorButton, SIGNAL("clicked()"),lambda i=i: self.setbuttoncolor(i))
            #Text Color
            colorTextButton = QPushButton("Select")
            colorTextButton.setFocusPolicy(Qt.NoFocus)
            self.connect(colorTextButton, SIGNAL("clicked()"),lambda i=i: self.setbuttontextcolor(i))
            #Empty Cell
            emptyCell = QLabel("")
            #add widgets to the table
            self.eventbuttontable.setCellWidget(i,0,labeledit)
            self.eventbuttontable.setCellWidget(i,1,descriptionedit)
            self.eventbuttontable.setCellWidget(i,2,typeComboBox)
            self.eventbuttontable.setCellWidget(i,3,valueEdit)
            self.eventbuttontable.setCellWidget(i,4,actionComboBox)
            self.eventbuttontable.setCellWidget(i,5,actiondescriptionedit)
            self.eventbuttontable.setCellWidget(i,6,visibilityComboBox)
            self.eventbuttontable.setCellWidget(i,7,colorButton)
            self.eventbuttontable.setCellWidget(i,8,colorTextButton)
            self.eventbuttontable.setCellWidget(i,9,emptyCell)
        self.eventbuttontable.horizontalHeader().setStretchLastSection(False)
        self.eventbuttontable.resizeColumnsToContents()
        self.eventbuttontable.horizontalHeader().setStretchLastSection(True)
        self.eventbuttontable.setColumnWidth(0,70)
        self.eventbuttontable.setColumnWidth(1,80)
        self.eventbuttontable.setColumnWidth(3,50)
#        header = self.eventbuttontable.horizontalHeader()
#        header.setResizeMode(1, QHeaderView.Stretch)
#        header.setResizeMode(5, QHeaderView.Stretch)

    def setbuttoncolor(self,x):
        colorf = aw.colordialog(QColor(aw.extraeventbuttoncolor[x]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.extraeventbuttoncolor[x] = colorname
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[x],aw.extraeventbuttoncolor[x])
            aw.buttonlist[x].setStyleSheet(style)

    def setbuttontextcolor(self,x):
        colorf = aw.colordialog(QColor(aw.extraeventbuttontextcolor[x]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.extraeventbuttontextcolor[x] = colorname
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[x],aw.extraeventbuttoncolor[x])
            aw.buttonlist[x].setStyleSheet(style)

    def savetableextraeventbutton(self):
        for i in range(len(aw.extraeventstypes)):
            labeledit = self.eventbuttontable.cellWidget(i,0)
            label = u(labeledit.text())
            if "\\n" in label:              #make multiple line text if "\n" found in label string
                parts = label.split("\\n")
                label = chr(10).join(parts)
            aw.extraeventslabels[i] = label
            aw.buttonlist[i].setText(aw.extraeventslabels[i])
            descriptionedit = self.eventbuttontable.cellWidget(i,1)
            aw.extraeventsdescriptions[i] = u(descriptionedit.text())
            typecombobox = self.eventbuttontable.cellWidget(i,2)
            aw.extraeventstypes[i] = typecombobox.currentIndex()
            valueedit = self.eventbuttontable.cellWidget(i,3)
            aw.extraeventsvalues[i] = aw.qmc.str2eventsvalue(str(valueedit.text()))
            actioncombobox = self.eventbuttontable.cellWidget(i,4)
            aw.extraeventsactions[i] = actioncombobox.currentIndex()
            actiondescriptionedit = self.eventbuttontable.cellWidget(i,5)
            ades = u(actiondescriptionedit.text())
            aw.extraeventsactionstrings[i] = ades
            aw.update_extraeventbuttons_visibility()

    def setvisibilitytyeventbutton(self,_,i):
        actioncombobox = self.eventbuttontable.cellWidget(i,6)
        aw.extraeventsvisibility[i] = actioncombobox.currentIndex()
        aw.update_extraeventbuttons_visibility()

    def setlabeleventbutton(self,_,i):
        labeledit = self.eventbuttontable.cellWidget(i,0)
        aw.extraeventslabels[i] = u(labeledit.text())
        aw.settooltip()

    def setdescriptioneventbutton(self,_,i):
        descriptionedit = self.eventbuttontable.cellWidget(i,1)
        aw.extraeventsdescriptions[i] = u(descriptionedit.text())
        aw.settooltip()

    def setactiondescriptioneventbutton(self,_,i):
        actiondescriptionedit = self.eventbuttontable.cellWidget(i,5)
        aw.extraeventsactionstrings[i] = u(actiondescriptionedit.text())
        aw.settooltip()

    def setactioneventbutton(self,_,i):
        actioncombobox = self.eventbuttontable.cellWidget(i,4)
        aw.extraeventsactions[i] = actioncombobox.currentIndex()
        aw.settooltip()

    def setvalueeventbutton(self,_,i):
        valueedit = self.eventbuttontable.cellWidget(i,3)
        aw.extraeventsvalues[i] = aw.qmc.str2eventsvalue(str(valueedit.text()))
        part2 = ""
        if aw.extraeventsvalues[i] >= 0:
            part2 = str(aw.qmc.eventsvalues(aw.extraeventsvalues[i]))
        aw.buttonlist[i].setText(u(aw.qmc.etypesf(aw.extraeventstypes[i])[0])+part2)
        aw.settooltip()

    def settypeeventbutton(self,_,i):
        typecombobox = self.eventbuttontable.cellWidget(i,2)
        aw.extraeventstypes[i] = typecombobox.currentIndex()
        etype_char = ""
        if aw.extraeventstypes[i] < 4:
            etype_char = str(aw.qmc.etypesf(aw.extraeventstypes[i])[0])
        aw.buttonlist[i].setText(etype_char+str(aw.qmc.eventsvalues(aw.extraeventsvalues[i])))
        aw.settooltip()

    def delextraeventbutton(self):
        bindex = len(aw.extraeventstypes)-1
        selected = self.eventbuttontable.selectedRanges()
        if len(selected) > 0:
            bindex = selected[0].topRow()
        if bindex >= 0:
            aw.extraeventslabels.pop(bindex)
            aw.extraeventsdescriptions.pop(bindex)
            aw.extraeventstypes.pop(bindex)
            aw.extraeventsvalues.pop(bindex)
            aw.extraeventsactions.pop(bindex)
            aw.extraeventsactionstrings.pop(bindex)
            aw.extraeventsvisibility.pop(bindex)
            aw.extraeventbuttoncolor.pop(bindex)
            aw.extraeventbuttontextcolor.pop(bindex)
            self.createEventbuttonTable()  #update table
            if len(aw.e4buttondialog.buttons()):
                aw.e4buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e4buttondialog.buttons()):
                    aw.e4buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.e3buttondialog.buttons()):
                aw.e3buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e3buttondialog.buttons()):
                    aw.e3buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.e2buttondialog.buttons()):
                aw.e2buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e2buttondialog.buttons()):
                    aw.e2buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.e1buttondialog.buttons()):
                aw.e1buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e1buttondialog.buttons()):
                    aw.e1buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.lowerbuttondialog.buttons()):
                aw.lowerbuttondialog.removeButton(aw.buttonlist[bindex])
            aw.buttonlist.pop(bindex)
        aw.update_extraeventbuttons_visibility()

    def insertextraeventbutton(self):
        self.savetableextraeventbutton() #save previous changes
        if len(aw.e4buttondialog.buttons()) >= aw.buttonlistmaxlen:
            return
        aw.extraeventsdescriptions.append("")
        aw.extraeventstypes.append(0)
        aw.extraeventsvalues.append(0)
        aw.extraeventsactions.append(0)
        aw.extraeventsactionstrings.append("")
        aw.extraeventsvisibility.append(1)
        aw.extraeventbuttoncolor.append("yellow")
        aw.extraeventbuttontextcolor.append("black")
        initialtext = u(aw.qmc.etypesf(aw.extraeventstypes[-1])[0])+str(aw.qmc.eventsvalues(aw.extraeventsvalues[-1]))
        aw.extraeventslabels.append(initialtext)
        self.createEventbuttonTable() 
        aw.buttonlist.append(QPushButton())
        bindex = len(aw.buttonlist)-1
        aw.buttonlist[bindex].setFocusPolicy(Qt.NoFocus)
        aw.buttonlist[bindex].setStyleSheet("font-size: 10pt; font-weight: bold; color: black; background-color: yellow ")
        aw.buttonlist[bindex].setMaximumSize(90, 50)
        aw.buttonlist[bindex].setMinimumHeight(50)
        aw.buttonlist[bindex].setText(initialtext)
        aw.connect(aw.buttonlist[bindex], SIGNAL("clicked()"), lambda ee=bindex:aw.recordextraevent(ee))
#       #add button to row
#        lowerbuttonvisiblebuttons = len(aw.lowerbuttondialog.buttons())
#        for i in range(len(aw.qmc.buttonvisibility)):
#            # remove the invisible ones
#            if not aw.qmc.buttonvisibility[i]:
#                lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
#        if not self.eventsbuttonflag: # remove another count if EVENT button is invisible
#            lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
        if False: # lowerbuttonvisiblebuttons < aw.buttonlistmaxlen:
            aw.lowerbuttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
        elif len(aw.e1buttondialog.buttons()) < aw.buttonlistmaxlen:
            aw.e1buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
        elif len(aw.e2buttondialog.buttons()) < aw.buttonlistmaxlen:
            aw.e2buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
        elif len(aw.e3buttondialog.buttons()) < aw.buttonlistmaxlen:
            aw.e3buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
        else:
            aw.e4buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
        aw.update_extraeventbuttons_visibility()
        aw.settooltip()

    def eventsbuttonflagChanged(self):
        if self.eventsbuttonflag.isChecked():
            aw.button_11.setVisible(True)
            aw.eventsbuttonflag = 1
        else:
            aw.button_11.setVisible(False)
            aw.eventsbuttonflag = 0

    def eventsshowflagChanged(self):
        if self.eventsshowflagbox.isChecked():
            aw.qmc.eventsshowflag = 1
        else:
            aw.qmc.eventsshowflag = 0
        aw.qmc.redraw(recomputeAllDeltas=False)

    def minieventsflagChanged(self):
        if self.minieventsflag.isChecked():
            aw.minieventsflag = 1
        else:
            aw.minieventsflag = 0
        if aw.qmc.flagon:
            aw.update_minieventline_visibility()

    def eventsGraphTypeflagChanged(self):
        aw.qmc.eventsGraphflag = self.bartypeComboBox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def saveSliderSettings(self):
        aw.eventslidervisibilities[0] = int(self.E1visibility.isChecked())
        aw.eventslidervisibilities[1] = int(self.E2visibility.isChecked())
        aw.eventslidervisibilities[2] = int(self.E3visibility.isChecked())
        aw.eventslidervisibilities[3] = int(self.E4visibility.isChecked())
        aw.eventslideractions[0] = int(self.E1action.currentIndex())
        aw.eventslideractions[1] = int(self.E2action.currentIndex())
        aw.eventslideractions[2] = int(self.E3action.currentIndex())
        aw.eventslideractions[3] = int(self.E4action.currentIndex())
        aw.eventslidercommands[0] = str(self.E1command.text())
        aw.eventslidercommands[1] = str(self.E2command.text())
        aw.eventslidercommands[2] = str(self.E3command.text())
        aw.eventslidercommands[3] = str(self.E4command.text())
        aw.eventslideroffsets[0] = int(self.E1offset.value())
        aw.eventslideroffsets[1] = int(self.E2offset.value())
        aw.eventslideroffsets[2] = int(self.E3offset.value())
        aw.eventslideroffsets[3] = int(self.E4offset.value())
        aw.eventsliderfactors[0] = float(self.E1factor.value())
        aw.eventsliderfactors[1] = float(self.E2factor.value())
        aw.eventsliderfactors[2] = float(self.E3factor.value())
        aw.eventsliderfactors[3] = float(self.E4factor.value())

    def saveQuantifierSettings(self):
        aw.eventquantifieractive[0] = int(self.E1active.isChecked())
        aw.eventquantifieractive[1] = int(self.E2active.isChecked())
        aw.eventquantifieractive[2] = int(self.E3active.isChecked())
        aw.eventquantifieractive[3] = int(self.E4active.isChecked())
        aw.eventquantifiercoarse[0] = int(self.E1coarse.isChecked())
        aw.eventquantifiercoarse[1] = int(self.E2coarse.isChecked())
        aw.eventquantifiercoarse[2] = int(self.E3coarse.isChecked())
        aw.eventquantifiercoarse[3] = int(self.E4coarse.isChecked())
        aw.eventquantifiersource[0] = int(self.E1SourceComboBox.currentIndex())
        aw.eventquantifiersource[1] = int(self.E2SourceComboBox.currentIndex())
        aw.eventquantifiersource[2] = int(self.E3SourceComboBox.currentIndex())
        aw.eventquantifiersource[3] = int(self.E4SourceComboBox.currentIndex())
        aw.eventquantifiermin[0] = int(self.E1min.value())
        aw.eventquantifiermin[1] = int(self.E2min.value())
        aw.eventquantifiermin[2] = int(self.E3min.value())
        aw.eventquantifiermin[3] = int(self.E4min.value())
        aw.eventquantifiermax[0] = int(self.E1max.value())
        aw.eventquantifiermax[1] = int(self.E2max.value())
        aw.eventquantifiermax[2] = int(self.E3max.value())
        aw.eventquantifiermax[3] = int(self.E4max.value())
        aw.computeLinespaces()

    #the inverse to restoreState
    def storeState(self):
        # event configurations
        self.eventsbuttonflagstored = aw.eventsbuttonflag
        self.eventsshowflagstored = aw.qmc.eventsshowflag
        self.minieventsflagstored = aw.minieventsflag
        self.eventsGraphflagstored = aw.qmc.eventsGraphflag
        self.etypesstored = aw.qmc.etypes
        self.etypeComboBoxstored = aw.etypeComboBox
        self.autoChargeFlagstored = aw.qmc.autoChargeFlag
        self.autoDropFlagstored = aw.qmc.autoDropFlag
        self.markTPFlagstored = aw.qmc.markTPflag
        # buttons
        self.extraeventslabels = aw.extraeventslabels
        self.extraeventsdescriptions = aw.extraeventsdescriptions
        self.extraeventstypes = aw.extraeventstypes
        self.extraeventsvalues = aw.extraeventsvalues
        self.extraeventsactions = aw.extraeventsactions
        self.extraeventsactionstrings = aw.extraeventsactionstrings
        self.extraeventsvisibility = aw.extraeventsvisibility
        self.extraeventbuttoncolor = aw.extraeventbuttoncolor
        self.extraeventbuttontextcolor = aw.extraeventbuttontextcolor
        self.buttonlistmaxlen = aw.buttonlistmaxlen
        # sliders
        self.eventslidervisibilities = aw.eventslidervisibilities
        self.eventslideractions = aw.eventslideractions
        self.eventslidercommands = aw.eventslidercommands
        self.eventslideroffsets = aw.eventslideroffsets
        self.eventsliderfactors = aw.eventsliderfactors
        # palettes
        self.buttonpalette = aw.buttonpalette
        # styles
        self.EvalueColor = aw.qmc.EvalueColor
        self.EvalueMarker = aw.qmc.EvalueMarker
        self.Evaluelinethickness = aw.qmc.Evaluelinethickness
        self.Evaluealpha = aw.qmc.Evaluealpha
        self.EvalueMarkerSize = aw.qmc.EvalueMarkerSize

    #called from Cancel button
    def restoreState(self):
        # event configurations
        aw.eventsbuttonflag = self.eventsbuttonflagstored
        aw.qmc.eventsshowflag = self.eventsshowflagstored
        aw.minieventsflag = self.minieventsflagstored
        aw.qmc.eventsGraphflag = self.eventsGraphflagstored
        aw.qmc.etypes = self.etypesstored
        aw.etypeComboBox = self.etypeComboBoxstored
        aw.qmc.autoChargeFlag = self.autoChargeFlagstored
        aw.qmc.autoDropFlag = self.autoDropFlagstored
        aw.qmc.markTPflag = self.markTPFlagstored
        # buttons
        aw.extraeventslabels = self.extraeventslabels
        aw.extraeventsdescriptions = self.extraeventsdescriptions
        aw.extraeventstypes = self.extraeventstypes
        aw.extraeventsvalues = self.extraeventsvalues
        aw.extraeventsactions = self.extraeventsactions
        aw.extraeventsactionstrings = self.extraeventsactionstrings
        aw.extraeventsvisibility = self.extraeventsvisibility
        aw.extraeventbuttoncolor = self.extraeventbuttoncolor
        aw.extraeventbuttontextcolor = self.extraeventbuttontextcolor
        aw.buttonlistmaxlen = self.buttonlistmaxlen
        # sliders
        aw.eventslidervisibilities = self.eventslidervisibilities
        aw.eventslideractions = self.eventslideractions
        aw.eventslidercommands = self.eventslidercommands
        aw.eventslideroffsets = self.eventslideroffsets
        aw.eventsliderfactors = self.eventsliderfactors
        # palettes
        aw.buttonpalette = self.buttonpalette
        # styles
        aw.qmc.EvalueColor = self.EvalueColor
        aw.qmc.EvalueMarker = self.EvalueMarker
        aw.qmc.Evaluelinethickness = self.Evaluelinethickness
        aw.qmc.Evaluealpha = self.Evaluealpha
        aw.qmc.EvalueMarkerSize = self.EvalueMarkerSize
        self.accept()

    #called from OK button
    def updatetypes(self):
        try:
            self.savetableextraeventbutton()
            #save default buttons
            aw.qmc.buttonvisibility[0] = self.CHARGEbutton.isChecked()
            aw.button_8.setVisible(bool(aw.qmc.buttonvisibility[0]))
            aw.qmc.buttonvisibility[1] = self.DRYbutton.isChecked()
            aw.button_19.setVisible(bool(aw.qmc.buttonvisibility[1]))
            aw.qmc.buttonvisibility[2] = self.FCSbutton.isChecked()
            aw.button_3.setVisible(bool(aw.qmc.buttonvisibility[2]))
            aw.qmc.buttonvisibility[3] = self.FCEbutton.isChecked()
            aw.button_4.setVisible(bool(aw.qmc.buttonvisibility[3]))
            aw.qmc.buttonvisibility[4] = self.SCSbutton.isChecked()
            aw.button_5.setVisible(bool(aw.qmc.buttonvisibility[4]))
            aw.qmc.buttonvisibility[5] = self.SCEbutton.isChecked()
            aw.button_6.setVisible(bool(aw.qmc.buttonvisibility[5]))
            aw.qmc.buttonvisibility[6] = self.DROPbutton.isChecked()
            aw.button_9.setVisible(bool(aw.qmc.buttonvisibility[6]))
            aw.qmc.buttonvisibility[7] = self.COOLbutton.isChecked()
            aw.button_20.setVisible(bool(aw.qmc.buttonvisibility[7]))
            #save sliders   
            self.saveSliderSettings()
            self.saveQuantifierSettings()
            #save quantifiers
            aw.updateSlidersProperties() # set visibility and event names on slider widgets
            aw.qmc.buttonactions[0] = self.CHARGEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[1] = self.DRYbuttonActionType.currentIndex()
            aw.qmc.buttonactions[2] = self.FCSbuttonActionType.currentIndex()
            aw.qmc.buttonactions[3] = self.FCEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[4] = self.SCSbuttonActionType.currentIndex()
            aw.qmc.buttonactions[5] = self.SCEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[6] = self.DROPbuttonActionType.currentIndex()
            aw.qmc.buttonactions[7] = self.COOLbuttonActionType.currentIndex()
            aw.qmc.extrabuttonactions[0] = self.ONbuttonActionType.currentIndex()
            aw.qmc.extrabuttonactions[1] = self.OFFbuttonActionType.currentIndex()
            aw.qmc.extrabuttonactions[2] = self.SAMPLINGbuttonActionType.currentIndex()
            aw.qmc.buttonactionstrings[0] = u(self.CHARGEbuttonActionString.text())
            aw.qmc.buttonactionstrings[1] = u(self.DRYbuttonActionString.text())
            aw.qmc.buttonactionstrings[2] = u(self.FCSbuttonActionString.text())
            aw.qmc.buttonactionstrings[3] = u(self.FCEbuttonActionString.text())
            aw.qmc.buttonactionstrings[4] = u(self.SCSbuttonActionString.text())
            aw.qmc.buttonactionstrings[5] = u(self.SCEbuttonActionString.text())
            aw.qmc.buttonactionstrings[6] = u(self.DROPbuttonActionString.text())
            aw.qmc.buttonactionstrings[7] = u(self.COOLbuttonActionString.text())
            aw.qmc.extrabuttonactionstrings[0] = u(self.ONbuttonActionString.text())
            aw.qmc.extrabuttonactionstrings[1] = u(self.OFFbuttonActionString.text())
            aw.qmc.extrabuttonactionstrings[2] = u(self.SAMPLINGbuttonActionString.text())
            #save etypes
            if len(u(self.etype0.text())) and len(u(self.etype1.text())) and len(u(self.etype2.text())) and len(u(self.etype3.text())):
                aw.qmc.etypes[0] = u(self.etype0.text())
                aw.qmc.etypes[1] = u(self.etype1.text())
                aw.qmc.etypes[2] = u(self.etype2.text())
                aw.qmc.etypes[3] = u(self.etype3.text())
                # update minieditor event type ComboBox
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(aw.qmc.etypes)
                #update mini editor
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(aw.qmc.etypes)
                #update autoCharge/Drop flag
                aw.qmc.autoChargeFlag = self.autoCharge.isChecked()
                aw.qmc.autoDropFlag = self.autoDrop.isChecked()
                aw.qmc.markTPflag = self.markTP.isChecked()
                self.savetableextraeventbutton()
                aw.realignbuttons()
                aw.qmc.redraw(recomputeAllDeltas=False)
                aw.sendmessage(QApplication.translate("Message","Event configuration saved", None, QApplication.UnicodeUTF8))
                self.close()
            else:
                aw.sendmessage(QApplication.translate("Message","Found empty event type box", None, QApplication.UnicodeUTF8))
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " updatetypes(): %1").arg(str(e)),exc_tb.tb_lineno)

    def settypedefault(self):
        aw.qmc.etypes = aw.qmc.etypesdefault
        self.etype0.setText(aw.qmc.etypesdefault[0])
        self.etype0.setCursorPosition(0)
        self.etype1.setText(aw.qmc.etypesdefault[1])
        self.etype1.setCursorPosition(0)
        self.etype2.setText(aw.qmc.etypesdefault[2])
        self.etype2.setCursorPosition(0)
        self.etype3.setText(aw.qmc.etypesdefault[3])
        self.etype3.setCursorPosition(0)
        aw.settooltip()

    def showEventbuttonhelp(self):
        string = u(QApplication.translate("Message", "<b>Button Label</b> Enter \\n to create labels with multiple lines.",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Event Description</b> Description of the Event to be recorded.",None, QApplication.UnicodeUTF8)) + "<br>"  
        string += u(QApplication.translate("Message", "<b>Event type</b> Type of event to be recorded.",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Event value</b> Value of event (1-100) to be recorded",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Action</b> Perform an action at the time of the event",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Documentation</b> depends on the action type ('{}' is replaced by the event value):",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Serial Command: ASCII serial command or binary a2b_uu(serial command)",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Call Program: A program/script path (absolute or relative)",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Multiple Event: Adds events of other button numbers separated by a comma: 1,2,3, etc.",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Modbus Command: write([slaveId,register,value],..,[slaveId,register,value]) or wcoils(slaveId,register,[&lt;bool&gt;,..,&lt;bool&gt;]) writes values to the registers in slaves specified by the given ids",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "DTA Command: Insert Data address : value, ex. 4701:1000 and sv is 100. always multiply with 10 if value Unit: 0.1 / ex. 4719:0 stops heating",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "IO Command: set(n,0), set(n,1), toggle(n) to set Phidget IO digital output n",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Button Visibility</b> Hides/shows individual button",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Keyboard Shorcut: </b> [b] Hides/shows Extra Button Rows",None, QApplication.UnicodeUTF8)) + "<br>"
        QMessageBox.information(self,QApplication.translate("Message", "Event custom buttons",None, QApplication.UnicodeUTF8),string)

##########################################################################
#####################  PHASES GRAPH EDIT DLG  ############################
##########################################################################

class phasesGraphDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(phasesGraphDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Phases",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        self.phases = list(aw.qmc.phases)
        dryLabel = QLabel(QApplication.translate("Label", "Drying",None, QApplication.UnicodeUTF8))
        midLabel = QLabel(QApplication.translate("Label", "Maillard",None, QApplication.UnicodeUTF8))
        finishLabel = QLabel(QApplication.translate("Label", "Development",None, QApplication.UnicodeUTF8))
        minf = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxf = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))
        self.startdry = QSpinBox()
        self.startdry.setAlignment(Qt.AlignRight)
        self.startdry.setMinimumWidth(80)
        self.enddry = QSpinBox()
        self.enddry.setAlignment(Qt.AlignRight)
        self.enddry.setMinimumWidth(80)
        self.startmid = QSpinBox()
        self.startmid.setAlignment(Qt.AlignRight)
        self.startmid.setMinimumWidth(80)
        self.endmid = QSpinBox()
        self.endmid.setAlignment(Qt.AlignRight)
        self.endmid.setMinimumWidth(80)
        self.startfinish = QSpinBox()
        self.startfinish.setAlignment(Qt.AlignRight)
        self.startfinish.setMinimumWidth(80)
        self.endfinish = QSpinBox()
        self.endfinish.setAlignment(Qt.AlignRight)
        self.endfinish.setMinimumWidth(80)        
        self.events2phases()
        if aw.qmc.mode == "F":
            self.startdry.setSuffix(" F")
            self.enddry.setSuffix(" F")
            self.startmid.setSuffix(" F")
            self.endmid.setSuffix(" F")
            self.startfinish.setSuffix(" F")
            self.endfinish.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.startdry.setSuffix(" C")
            self.enddry.setSuffix(" C")
            self.startmid.setSuffix(" C")
            self.endmid.setSuffix(" C")
            self.startfinish.setSuffix(" C")
            self.endfinish.setSuffix(" C")
        self.startdry.setRange(0,1000)    #(min,max)
        self.enddry.setRange(0,1000)
        self.startmid.setRange(0,1000)
        self.endmid.setRange(0,1000)
        self.startfinish.setRange(0,1000)
        self.endfinish.setRange(0,1000)
        self.connect(self.enddry,SIGNAL("valueChanged(int)"),self.startmid.setValue)
        self.connect(self.startmid,SIGNAL("valueChanged(int)"),self.enddry.setValue)
        self.connect(self.endmid,SIGNAL("valueChanged(int)"),self.startfinish.setValue)
        self.connect(self.startfinish,SIGNAL("valueChanged(int)"),self.endmid.setValue)
        self.pushbuttonflag = QCheckBox(QApplication.translate("CheckBox","Auto Adjusted",None, QApplication.UnicodeUTF8))
        self.pushbuttonflag.setChecked(bool(aw.qmc.phasesbuttonflag))
        self.connect(self.pushbuttonflag,SIGNAL("stateChanged(int)"),self.pushbuttonflagChanged)
        self.watermarksflag = QCheckBox(QApplication.translate("CheckBox","Watermarks",None, QApplication.UnicodeUTF8))
        self.watermarksflag.setChecked(bool(aw.qmc.watermarksflag))
        self.phasesLCDflag = QCheckBox(QApplication.translate("CheckBox","Phases LCDs",None, QApplication.UnicodeUTF8))
        self.phasesLCDflag.setChecked(bool(aw.qmc.phasesLCDflag))
        self.autoDRYflag = QCheckBox(QApplication.translate("CheckBox","Auto DRY",None, QApplication.UnicodeUTF8))
        self.autoDRYflag.setChecked(bool(aw.qmc.autoDRYflag))
        self.autoFCsFlag = QCheckBox(QApplication.translate("CheckBox","Auto FCs",None, QApplication.UnicodeUTF8))
        self.autoFCsFlag.setChecked(bool(aw.qmc.autoFCsFlag))
        self.connect(self.watermarksflag,SIGNAL("stateChanged(int)"),self.watermarksflagChanged)
        self.connect(self.phasesLCDflag,SIGNAL("stateChanged(int)"),self.phasesLCDsflagChanged)
        self.connect(self.autoDRYflag,SIGNAL("stateChanged(int)"),self.autoDRYflagChanged)
        self.connect(self.autoFCsFlag,SIGNAL("stateChanged(int)"),self.autoFCsFlagChanged)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        setDefaultButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        setDefaultButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.cancel)
        self.connect(okButton,SIGNAL("clicked()"),self.updatephases)
        self.connect(setDefaultButton,SIGNAL("clicked()"),self.setdefault)
        
        phaseLayout = QGridLayout()
        phaseLayout.addWidget(minf,0,1,Qt.AlignCenter)
        phaseLayout.addWidget(maxf,0,2,Qt.AlignCenter)
        phaseLayout.addWidget(dryLabel,1,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startdry,1,1)
        phaseLayout.addWidget(self.enddry,1,2)
        phaseLayout.addWidget(midLabel,2,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startmid,2,1)
        phaseLayout.addWidget(self.endmid,2,2)
        phaseLayout.addWidget(finishLabel,3,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startfinish,3,1)
        phaseLayout.addWidget(self.endfinish,3,2)

        dryEspressoLabel = QLabel(QApplication.translate("Label", "Drying",None, QApplication.UnicodeUTF8))
        midEspressoLabel = QLabel(QApplication.translate("Label", "Maillard",None, QApplication.UnicodeUTF8))
        finishEspressoLabel = QLabel(QApplication.translate("Label", "Development",None, QApplication.UnicodeUTF8))
        minfEspresso = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxfEspresso = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))

        self.startdryEspresso = QSpinBox()
        self.startdryEspresso.setAlignment(Qt.AlignRight)
        self.startdryEspresso.setMinimumWidth(80)
        self.enddryEspresso = QSpinBox()
        self.enddryEspresso.setAlignment(Qt.AlignRight)
        self.enddryEspresso.setMinimumWidth(80)
        self.startmidEspresso = QSpinBox()
        self.startmidEspresso.setAlignment(Qt.AlignRight)
        self.startmidEspresso.setMinimumWidth(80)
        self.endmidEspresso = QSpinBox()
        self.endmidEspresso.setAlignment(Qt.AlignRight)
        self.endmidEspresso.setMinimumWidth(80)
        self.startfinishEspresso = QSpinBox()
        self.startfinishEspresso.setAlignment(Qt.AlignRight)
        self.startfinishEspresso.setMinimumWidth(80)
        self.endfinishEspresso = QSpinBox()
        self.endfinishEspresso.setAlignment(Qt.AlignRight)
        self.endfinishEspresso.setMinimumWidth(80)
        self.startdryEspresso.setRange(0,1000)    #(min,max)
        self.enddryEspresso.setRange(0,1000)
        self.startmidEspresso.setRange(0,1000)
        self.endmidEspresso.setRange(0,1000)
        self.startfinishEspresso.setRange(0,1000)
        self.endfinishEspresso.setRange(0,1000)
        self.connect(self.enddryEspresso,SIGNAL("valueChanged(int)"),self.startmidEspresso.setValue)
        self.connect(self.startmidEspresso,SIGNAL("valueChanged(int)"),self.enddryEspresso.setValue)
        self.connect(self.endmidEspresso,SIGNAL("valueChanged(int)"),self.startfinishEspresso.setValue)
        self.connect(self.startfinishEspresso,SIGNAL("valueChanged(int)"),self.endmidEspresso.setValue)
        
        if aw.qmc.mode == "F":
            self.startdryEspresso.setSuffix(" F")
            self.enddryEspresso.setSuffix(" F")
            self.startmidEspresso.setSuffix(" F")
            self.endmidEspresso.setSuffix(" F")
            self.startfinishEspresso.setSuffix(" F")
            self.endfinishEspresso.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.startdryEspresso.setSuffix(" C")
            self.enddryEspresso.setSuffix(" C")
            self.startmidEspresso.setSuffix(" C")
            self.endmidEspresso.setSuffix(" C")
            self.startfinishEspresso.setSuffix(" C")
            self.endfinishEspresso.setSuffix(" C")
            
        self.getphases()

        phaseEspressoLayout = QGridLayout()
        phaseEspressoLayout.addWidget(minfEspresso,0,1,Qt.AlignCenter)
        phaseEspressoLayout.addWidget(maxfEspresso,0,2,Qt.AlignCenter)
        phaseEspressoLayout.addWidget(dryEspressoLabel,1,0,Qt.AlignRight)
        phaseEspressoLayout.addWidget(self.startdryEspresso,1,1)
        phaseEspressoLayout.addWidget(self.enddryEspresso,1,2)
        phaseEspressoLayout.addWidget(midEspressoLabel,2,0,Qt.AlignRight)
        phaseEspressoLayout.addWidget(self.startmidEspresso,2,1)
        phaseEspressoLayout.addWidget(self.endmidEspresso,2,2)
        phaseEspressoLayout.addWidget(finishEspressoLabel,3,0,Qt.AlignRight)
        phaseEspressoLayout.addWidget(self.startfinishEspresso,3,1)
        phaseEspressoLayout.addWidget(self.endfinishEspresso,3,2)        
        
        self.phasesTabs = QTabWidget()
        # filter phases tab
        FilterWidget = QWidget()
        FilterWidget.setLayout(phaseLayout)
        self.phasesTabs.addTab(FilterWidget,QApplication.translate("Tab","Filter",None, QApplication.UnicodeUTF8))
        # filter phases tab
        EspressoWidget = QWidget()
        EspressoWidget.setLayout(phaseEspressoLayout)
        self.phasesTabs.addTab(EspressoWidget,QApplication.translate("Tab","Espresso",None, QApplication.UnicodeUTF8))
        
        self.phasesTabs.setCurrentIndex(aw.qmc.phases_mode)
        
        boxedPhaseLayout = QHBoxLayout()
        boxedPhaseLayout.addStretch()
        boxedPhaseLayout.addWidget(self.phasesTabs)
        boxedPhaseLayout.addStretch()
        boxedPhaseFlagGrid = QGridLayout()
        boxedPhaseFlagGrid.addWidget(self.pushbuttonflag,0,0)
        boxedPhaseFlagGrid.addWidget(self.autoDRYflag,1,0)
        boxedPhaseFlagGrid.addWidget(self.autoFCsFlag,1,1)
        boxedPhaseFlagGrid.addWidget(self.watermarksflag,2,0)
        boxedPhaseFlagGrid.addWidget(self.phasesLCDflag,2,1)
        boxedPhaseFlagLayout = QHBoxLayout()
        boxedPhaseFlagLayout.addStretch()
        boxedPhaseFlagLayout.addLayout(boxedPhaseFlagGrid)
        boxedPhaseFlagLayout.addStretch()
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(setDefaultButton)
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(cancelButton)
        buttonsLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(boxedPhaseLayout)
        mainLayout.addLayout(boxedPhaseFlagLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonsLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)
        aw.qmc.redraw(recomputeAllDeltas=False)

    def savePhasesSettings(self):
        if not aw.qmc.phasesbuttonflag:
            settings = QSettings()
            #save phases
            settings.setValue("Phases",aw.qmc.phases)

    def events2phases(self):
        if aw.qmc.phasesbuttonflag:
            # adjust phases by DryEnd and FCs events
            if aw.qmc.timeindex[1]:
                aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                self.enddry.setDisabled(True)
                self.startmid.setDisabled(True)
            if aw.qmc.timeindex[2]:
                aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
                self.endmid.setDisabled(True)
                self.startfinish.setDisabled(True)

    def watermarksflagChanged(self,_):
        aw.qmc.watermarksflag = not aw.qmc.watermarksflag
        aw.qmc.redraw(recomputeAllDeltas=False)

    def phasesLCDsflagChanged(self,_):
        aw.qmc.phasesLCDflag = not aw.qmc.phasesLCDflag
        if aw.qmc.flagstart:
            if aw.qmc.phasesLCDflag:
                aw.ntb.hide()
                aw.phasesLCDs.show()
            else:
                aw.phasesLCDs.hide()
                aw.ntb.show()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def autoDRYflagChanged(self,_):
        aw.qmc.autoDRYflag = not aw.qmc.autoDRYflag
        if aw.qmc.autoDRYflag:
            self.pushbuttonflag.setChecked(False)
        
    def autoFCsFlagChanged(self,_):
        aw.qmc.autoFCsFlag = not aw.qmc.autoFCsFlag
        if aw.qmc.autoFCsFlag:
            self.pushbuttonflag.setChecked(False)

    def pushbuttonflagChanged(self,i):
        if i:
            aw.qmc.phasesbuttonflag = True
            self.events2phases()
            self.getphases()
            aw.qmc.redraw(recomputeAllDeltas=False)
        else:
            aw.qmc.phasesbuttonflag = False
            self.enddry.setEnabled(True)
            self.startmid.setEnabled(True)
            self.endmid.setEnabled(True)
            self.startfinish.setEnabled(True)
        if aw.qmc.phasesbuttonflag:
            self.autoDRYflag.setChecked(False)
            self.autoFCsFlag.setChecked(False)

    def updatephases(self):
        aw.qmc.phases_filter[0] = self.startdry.value()
        aw.qmc.phases_filter[1] = self.enddry.value()
        aw.qmc.phases_filter[2] = self.endmid.value()
        aw.qmc.phases_filter[3] = self.endfinish.value()
        
        aw.qmc.phases_espresso[0] = self.startdryEspresso.value()
        aw.qmc.phases_espresso[1] = self.enddryEspresso.value()
        aw.qmc.phases_espresso[2] = self.endmidEspresso.value()
        aw.qmc.phases_espresso[3] = self.endfinishEspresso.value()
        
        aw.qmc.phases_mode = self.phasesTabs.currentIndex()
        
        if aw.qmc.phases_mode:
            # espresso mode
            aw.qmc.phases = aw.qmc.phases_espresso
        else:
            # filter mode
            aw.qmc.phases = aw.qmc.phases_filter

        if self.pushbuttonflag.isChecked():
            aw.qmc.phasesbuttonflag = True
        else:
            aw.qmc.phasesbuttonflag = False
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.savePhasesSettings()
        self.close()

    def cancel(self):
        aw.qmc.phases = list(self.phases)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.savePhasesSettings()
        self.close()

    def getphases(self):
        if aw.qmc.phases_mode:
            # espresso mode
            aw.qmc.phases_espresso = aw.qmc.phases          
        else:
            # filter mode
            aw.qmc.phases_filter = aw.qmc.phases

        self.startdry.setValue(aw.qmc.phases_filter[0])
        self.enddry.setValue(aw.qmc.phases_filter[1])
        self.endmid.setValue(aw.qmc.phases_filter[2])
        self.endfinish.setValue(aw.qmc.phases_filter[3])
        
        self.startdryEspresso.setValue(aw.qmc.phases_espresso[0])
        self.enddryEspresso.setValue(aw.qmc.phases_espresso[1])
        self.endmidEspresso.setValue(aw.qmc.phases_espresso[2])
        self.endfinishEspresso.setValue(aw.qmc.phases_espresso[3])
        
    def setdefault(self):
        aw.qmc.phases_mode = self.phasesTabs.currentIndex()
        if aw.qmc.mode == "F":
            aw.qmc.phases = list(aw.qmc.phases_fahrenheit_defaults)
        elif aw.qmc.mode == "C":
            aw.qmc.phases = list(aw.qmc.phases_celsius_defaults)
        self.events2phases()
        self.getphases()
        aw.sendmessage(QApplication.translate("Message","Phases changed to %1 default: %2",None, QApplication.UnicodeUTF8).arg(aw.qmc.mode).arg(str(aw.qmc.phases)))
        aw.qmc.redraw(recomputeAllDeltas=False)

############################################################################
#####################   FLAVOR STAR PROPERTIES DIALOG   ####################
############################################################################

class flavorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(flavorDlg,self).__init__(parent)
        self.setModal(True)
        rcParams['path.effects'] = []
        #avoid questionm mark context help
        flags = self.windowFlags()
        helpFlag = Qt.WindowContextHelpButtonHint
        flags = flags & (~helpFlag)
        self.setWindowFlags(flags)
        self.setWindowTitle(QApplication.translate("Form Caption","Cup Profile",None, QApplication.UnicodeUTF8))
        defaultlabel = QLabel(QApplication.translate("Label","Default",None, QApplication.UnicodeUTF8))
        self.defaultcombobox = QComboBox()
        self.defaultcombobox.addItems(["","Artisan","SCCA","CQI","SweetMarias","C","E","CoffeeGeek","Intelligentsia","IIAC","*CUSTOM*"])
        self.defaultcombobox.setCurrentIndex(0)
        self.lastcomboboxIndex = 0
        self.connect(self.defaultcombobox, SIGNAL("currentIndexChanged(int)"),self.setdefault)
        self.flavortable = QTableWidget()
        self.flavortable.setTabKeyNavigation(True)
        self.createFlavorTable()
        leftButton = QPushButton("<")
        leftButton.setFocusPolicy(Qt.NoFocus)
        self.connect(leftButton, SIGNAL("clicked()"),lambda x=0:self.move(x))
        rightButton = QPushButton(">")
        rightButton.setFocusPolicy(Qt.NoFocus)
        self.connect(rightButton, SIGNAL("clicked()"),lambda x=1:self.move(x))
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        addButton.setFocusPolicy(Qt.NoFocus)
        self.connect(addButton, SIGNAL("clicked()"),self.addlabel)
        delButton = QPushButton(QApplication.translate("Button","Del",None, QApplication.UnicodeUTF8))
        delButton.setFocusPolicy(Qt.NoFocus)
        self.connect(delButton, SIGNAL("clicked()"),self.poplabel)
        saveImgButton = QPushButton(QApplication.translate("Button","Save Image",None, QApplication.UnicodeUTF8))
        saveImgButton.setFocusPolicy(Qt.NoFocus)
        self.connect(saveImgButton, SIGNAL("clicked()"),lambda x=0,i=1:aw.resize(x,i))
        backButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        self.connect(backButton,SIGNAL("clicked()"),self.close)
        self.backgroundCheck = QCheckBox(QApplication.translate("CheckBox","Background", None, QApplication.UnicodeUTF8))
        if aw.qmc.flavorbackgroundflag:
            self.backgroundCheck.setChecked(True)
        self.connect(self.backgroundCheck, SIGNAL("clicked()"),self.showbackground)
        aspectlabel = QLabel(QApplication.translate("Label","Aspect Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox = QDoubleSpinBox()
        self.aspectSpinBox.setToolTip(QApplication.translate("Tooltip","Aspect Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox.setRange(0.,2.)
        self.aspectSpinBox.setSingleStep(.1)
        self.aspectSpinBox.setValue(aw.qmc.flavoraspect)
        self.connect(self.aspectSpinBox, SIGNAL("valueChanged(double)"),self.setaspect)
        flavorLayout = QHBoxLayout()
        flavorLayout.addWidget(self.flavortable)
        comboLayout = QHBoxLayout()
        comboLayout.addWidget(defaultlabel)
        comboLayout.addWidget(self.defaultcombobox)
        comboLayout.addStretch()
        aspectLayout = QHBoxLayout()
        aspectLayout.addWidget(self.backgroundCheck)
        aspectLayout.addWidget(aspectlabel)
        aspectLayout.addWidget(self.aspectSpinBox)
        aspectLayout.addStretch()
        blayout1 = QHBoxLayout()
        blayout1.addStretch()
        blayout1.addWidget(addButton)
        blayout1.addWidget(delButton)  
        blayout1.addStretch()
        extralayout = QVBoxLayout()
        extralayout.addLayout(comboLayout)
        extralayout.addLayout(aspectLayout)
        extraGroupLayout = QGroupBox()
        extraGroupLayout.setLayout(extralayout)
        blayout = QHBoxLayout()
        blayout.addStretch()
        blayout.addWidget(leftButton)
        blayout.addWidget(rightButton)
        blayout.addStretch()
        mainButtonsLayout = QHBoxLayout()
        mainButtonsLayout.addWidget(saveImgButton)
        mainButtonsLayout.addStretch()
        mainButtonsLayout.addWidget(backButton)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(flavorLayout)
        mainLayout.addLayout(blayout1)
        mainLayout.addWidget(extraGroupLayout)
        mainLayout.addLayout(blayout)
        mainLayout.addStretch()
        mainLayout.addLayout(mainButtonsLayout)
        self.setLayout(mainLayout)
        aw.qmc.flavorchart()

    def setaspect(self):
        aw.qmc.flavoraspect = self.aspectSpinBox.value()
        aw.qmc.flavorchart()

    def createFlavorTable(self):
        self.flavortable.clear()
        nflavors = len(aw.qmc.flavorlabels)
        if nflavors:
            self.flavortable.setRowCount(nflavors)
            self.flavortable.setColumnCount(2)
            self.flavortable.setHorizontalHeaderLabels([QApplication.translate("Table", "Label",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Value",None, QApplication.UnicodeUTF8)])
            self.flavortable.setAlternatingRowColors(True)
            self.flavortable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.flavortable.setSelectionBehavior(QTableWidget.SelectRows)
            self.flavortable.setSelectionMode(QTableWidget.SingleSelection)
            self.flavortable.setShowGrid(True)
            self.flavortable.verticalHeader().setResizeMode(2)
            #populate table
            for i in range(nflavors):
                labeledit = QLineEdit(u(aw.qmc.flavorlabels[i]))
                self.connect(labeledit, SIGNAL("textChanged(QString)"),lambda z=1,x=i: self.setlabel(x))
                valueSpinBox = QDoubleSpinBox()
                valueSpinBox.setRange(0.,10.)
                valueSpinBox.setAlignment(Qt.AlignRight)
                val = aw.qmc.flavors[i]
                if aw.qmc.flavors[0] < 1. and aw.qmc.flavors[-1] < 1.: # < 0.5.0 version style compatibility
                    val *= 10.
                valueSpinBox.setValue(val)
                self.connect(valueSpinBox, SIGNAL("valueChanged(double)"),lambda z=1,x=i: self.setvalue(z,x))
                #add widgets to the table
                self.flavortable.setCellWidget(i,0,labeledit)
                self.flavortable.setCellWidget(i,1,valueSpinBox)
            self.flavortable.resizeColumnsToContents()
            header = self.flavortable.horizontalHeader()
            header.setResizeMode(0, QHeaderView.Stretch)

    def showbackground(self):
        if self.backgroundCheck.isChecked():
            if not aw.qmc.background:
                message = QApplication.translate("Message","Background profile not found", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
                self.backgroundCheck.setChecked(False)
            else:
                if len(aw.qmc.backgroundFlavors) != len(aw.qmc.flavors):
                    message = QApplication.translate("Message","Background does not match number of labels", None, QApplication.UnicodeUTF8)
                    aw.sendmessage(message)
                    self.backgroundCheck.setChecked(False)
                else:
                    aw.qmc.flavorbackgroundflag = True
                    aw.qmc.flavorchart()
        else:
            aw.qmc.flavorbackgroundflag = False
            aw.qmc.flavorchart()

    def move(self,x):
        if x == 0:
            aw.qmc.flavorstartangle += 5
        else:
            aw.qmc.flavorstartangle -= 5
        aw.qmc.flavorchart()

    def savetable(self):
        for i in range(len(aw.qmc.flavorlabels)):
            labeledit = self.flavortable.cellWidget(i,0)
            valueSpinBox = self.flavortable.cellWidget(i,1)
            label = u(labeledit.text())
            if "\\n" in label:              #make multiple line text if "\n" found in label string
                parts = label.split("\\n")
                label = chr(10).join(parts)
            aw.qmc.flavorlabels[i] = label
            aw.qmc.flavors[i] = valueSpinBox.value()
        if self.lastcomboboxIndex == 10:
            # store the current labels as *CUSTOM*
            aw.qmc.customflavorlabels = aw.qmc.flavorlabels

    def setlabel(self,x):
        labeledit = self.flavortable.cellWidget(x,0)
        aw.qmc.flavorlabels[x] = labeledit.text()
        aw.qmc.flavorchart()

    def setvalue(self,_,x):
        valueSpinBox = self.flavortable.cellWidget(x,1)
        aw.qmc.flavors[x] = valueSpinBox.value()
        aw.qmc.flavorchart()

    def setdefault(self):
        if self.lastcomboboxIndex == 10:
            # store the current labels as *CUSTOM*
            aw.qmc.customflavorlabels = aw.qmc.flavorlabels
        dindex =  self.defaultcombobox.currentIndex()
        #["","Artisan","SCCA","CQI","SweetMarias","C","E",coffeegeek,Intelligentsia]
        if dindex > 0 or dindex < 11:
            aw.qmc.flavorstartangle = 90
        if dindex == 1:
            aw.qmc.flavorlabels = list(aw.qmc.artisanflavordefaultlabels)
        elif dindex == 2:
            aw.qmc.flavorlabels = list(aw.qmc.SCCAflavordefaultlabels)
        elif dindex == 3:
            aw.qmc.flavorlabels = list(aw.qmc.CQIflavordefaultlabels)
        elif dindex == 4:
            aw.qmc.flavorlabels = list(aw.qmc.SweetMariasflavordefaultlabels)
        elif dindex == 5:
            aw.qmc.flavorlabels = list(aw.qmc.Cflavordefaultlabels)
        elif dindex == 6:
            aw.qmc.flavorlabels = list(aw.qmc.Eflavordefaultlabels)
        elif dindex == 7:
            aw.qmc.flavorlabels = list(aw.qmc.coffeegeekflavordefaultlabels)
        elif dindex == 8:
            aw.qmc.flavorlabels = list(aw.qmc.Intelligentsiaflavordefaultlabels)
        elif dindex == 9:
            aw.qmc.flavorlabels = list(aw.qmc.IstitutoInternazionaleAssaggiatoriCaffe)
        elif dindex == 10:
            aw.qmc.flavorlabels = list(aw.qmc.customflavorlabels)
        else:
            return
        aw.qmc.flavors = [5.]*len(aw.qmc.flavorlabels)
        self.createFlavorTable()
        aw.qmc.flavorchart()
        self.lastcomboboxIndex = dindex

    def addlabel(self):
        aw.qmc.flavorlabels.append("???")
        aw.qmc.flavors.append(5.)
        self.createFlavorTable()
        aw.qmc.flavorchart()

    def poplabel(self):
        fn = len(aw.qmc.flavors)
        aw.qmc.flavors = aw.qmc.flavors[:(fn-1)]
        aw.qmc.flavorlabels = aw.qmc.flavorlabels[:(fn -1)]
        self.createFlavorTable()
        aw.qmc.flavorchart()

    def closeEvent(self,_):
        self.savetable()
        aw.qmc.safesaveflag = True
        self.accept()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def close(self):
        self.closeEvent(None)

#################################################################
#################### BACKGROUND DIALOG  #########################
#################################################################

class backgroundDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(backgroundDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Profile Background", None, QApplication.UnicodeUTF8))
        self.setModal(True)
        #TAB 1
        self.pathedit = QLineEdit(aw.qmc.backgroundpath)
        self.pathedit.setStyleSheet("background-color:'lightgrey';")
        self.pathedit.setReadOnly(True)
        self.filename = ""
        self.backgroundCheck = QCheckBox(QApplication.translate("CheckBox","Show", None, QApplication.UnicodeUTF8))
        self.backgroundDetails = QCheckBox(QApplication.translate("CheckBox","Text", None, QApplication.UnicodeUTF8))
        self.backgroundeventsflag = QCheckBox(QApplication.translate("CheckBox","Events", None, QApplication.UnicodeUTF8))
        self.backgroundDeltaETflag = QCheckBox(QApplication.translate("CheckBox","DeltaET", None, QApplication.UnicodeUTF8))
        self.backgroundDeltaBTflag = QCheckBox(QApplication.translate("CheckBox","DeltaBT", None, QApplication.UnicodeUTF8))
        self.backgroundAlignFCsflag = QCheckBox(QApplication.translate("CheckBox","Align FCs", None, QApplication.UnicodeUTF8))
        self.backgroundCheck.setChecked(aw.qmc.background)
        self.backgroundDetails.setChecked(aw.qmc.backgroundDetails)
        self.backgroundeventsflag.setChecked(aw.qmc.backgroundeventsflag)
        self.backgroundDeltaETflag.setChecked(aw.qmc.DeltaETBflag)
        self.backgroundDeltaBTflag.setChecked(aw.qmc.DeltaBTBflag)
        self.backgroundAlignFCsflag.setChecked(aw.qmc.flagalignFCs)
        loadButton = QPushButton(QApplication.translate("Button","Load", None, QApplication.UnicodeUTF8))
        loadButton.setFocusPolicy(Qt.NoFocus)
        delButton = QPushButton(QApplication.translate("Button","Delete", None, QApplication.UnicodeUTF8))
        delButton.setFocusPolicy(Qt.NoFocus)
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))
        alignButton = QPushButton(QApplication.translate("Button","Align", None, QApplication.UnicodeUTF8))
        alignButton.setFocusPolicy(Qt.NoFocus)
        self.connect(loadButton, SIGNAL("clicked()"),self.load)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(alignButton, SIGNAL("clicked()"), lambda : aw.qmc.timealign(FCs=aw.qmc.flagalignFCs))
        self.speedSpinBox = QSpinBox()
        self.speedSpinBox.setRange(1,90)
        self.speedSpinBox.setSingleStep(5)
        self.speedSpinBox.setValue(30)
        intensitylabel =QLabel(QApplication.translate("Label", "Opaqueness",None, QApplication.UnicodeUTF8))
        intensitylabel.setAlignment(Qt.AlignRight)
        self.intensitySpinBox = QSpinBox()
        self.intensitySpinBox.setAlignment(Qt.AlignRight)
        self.intensitySpinBox.setRange(1,9)
        self.intensitySpinBox.setSingleStep(1)
        self.intensitySpinBox.setValue(aw.qmc.backgroundalpha * 10)
        self.colors = []
        for key in cnames:
            self.colors.append(str(key))
        self.colors.sort()
        self.defaultcolors = ["ET","BT","DeltaET","DeltaBT"]
        self.defaultcolorsmapped = [aw.qmc.palette["et"],aw.qmc.palette["bt"],aw.qmc.palette["deltaet"],aw.qmc.palette["deltabt"]]
        metcolorlabel = QLabel(QApplication.translate("Label", "ET Color",None, QApplication.UnicodeUTF8))
        metcolorlabel.setAlignment(Qt.AlignRight)
        self.metcolorComboBox = QComboBox()
        self.metcolorComboBox.addItems(self.defaultcolors)
        self.metcolorComboBox.insertSeparator(4)
        self.metcolorComboBox.addItems(self.colors)
        self.metcolorComboBox.setCurrentIndex(self.getColorIdx(aw.qmc.backgroundmetcolor))
        btcolorlabel = QLabel(QApplication.translate("Label", "BT Color",None, QApplication.UnicodeUTF8))
        btcolorlabel.setAlignment(Qt.AlignRight)
        self.btcolorComboBox = QComboBox()
        self.btcolorComboBox.addItems(self.defaultcolors)
        self.btcolorComboBox.insertSeparator(4)
        self.btcolorComboBox.addItems(self.colors)
        self.btcolorComboBox.setCurrentIndex(self.getColorIdx(aw.qmc.backgroundbtcolor))
        deltaetcolorlabel = QLabel(QApplication.translate("Label", "DeltaET Color",None, QApplication.UnicodeUTF8))
        deltaetcolorlabel.setAlignment(Qt.AlignRight)
        self.deltaetcolorComboBox = QComboBox()
        self.deltaetcolorComboBox.addItems(self.defaultcolors)
        self.deltaetcolorComboBox.insertSeparator(4)
        self.deltaetcolorComboBox.addItems(self.colors)
        self.deltaetcolorComboBox.setCurrentIndex(self.getColorIdx(aw.qmc.backgrounddeltaetcolor))
        deltabtcolorlabel = QLabel(QApplication.translate("Label", "DeltaBT Color",None, QApplication.UnicodeUTF8))
        deltabtcolorlabel.setAlignment(Qt.AlignRight)
        self.deltabtcolorComboBox = QComboBox()
        self.deltabtcolorComboBox.addItems(self.defaultcolors)
        self.deltabtcolorComboBox.insertSeparator(4)
        self.deltabtcolorComboBox.addItems(self.colors)
        self.deltabtcolorComboBox.setCurrentIndex(self.getColorIdx(aw.qmc.backgrounddeltabtcolor))
        self.upButton = QPushButton(QApplication.translate("Button","Up",None, QApplication.UnicodeUTF8))
        self.upButton.setFocusPolicy(Qt.NoFocus)
        self.downButton = QPushButton(QApplication.translate("Button","Down",None, QApplication.UnicodeUTF8))
        self.downButton.setFocusPolicy(Qt.NoFocus)
        self.leftButton = QPushButton(QApplication.translate("Button","Left",None, QApplication.UnicodeUTF8))
        self.leftButton.setFocusPolicy(Qt.NoFocus)
        self.rightButton = QPushButton(QApplication.translate("Button","Right",None, QApplication.UnicodeUTF8))
        self.rightButton.setFocusPolicy(Qt.NoFocus)
        self.connect(self.backgroundCheck, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundDetails, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundeventsflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundDeltaETflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundDeltaBTflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundAlignFCsflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(delButton, SIGNAL("clicked()"),self.delete)
        self.connect(self.upButton, SIGNAL("clicked()"), lambda m= "up": self.move(m))
        self.connect(self.downButton, SIGNAL("clicked()"), lambda m="down": self.move(m))
        self.connect(self.leftButton, SIGNAL("clicked()"), lambda m="left": self.move(m))
        self.connect(self.rightButton, SIGNAL("clicked()"),lambda m="right": self.move(m))
        self.connect(self.intensitySpinBox, SIGNAL("valueChanged(int)"),self.adjustintensity)
        self.connect(self.btcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color="", curve = "bt": self.adjustcolor(color,curve))
        self.connect(self.metcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color= "", curve = "et": self.adjustcolor(color,curve))
        self.connect(self.deltabtcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color="", curve = "deltabt": self.adjustcolor(color,curve))
        self.connect(self.deltaetcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color= "", curve = "deltaet": self.adjustcolor(color,curve))
        #TAB 2 EVENTS
        #table for showing events
        self.eventtable = QTableWidget()
        self.eventtable.setTabKeyNavigation(True)
        self.createEventTable()
        #TAB 3 DATA
        #table for showing data
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        self.createDataTable()
        #TAB 4
        self.backgroundReproduce = QCheckBox(QApplication.translate("CheckBox","Playback Aid",None, QApplication.UnicodeUTF8))
        self.backgroundReproduce.setChecked(aw.qmc.backgroundReproduce)
        self.backgroundReproduce.setFocusPolicy(Qt.NoFocus)
        self.connect(self.backgroundReproduce, SIGNAL("stateChanged(int)"),self.setreproduce)
        etimelabel =QLabel(QApplication.translate("Label", "Text Warning",None, QApplication.UnicodeUTF8))
        etimeunit =QLabel(QApplication.translate("Label", "sec",None, QApplication.UnicodeUTF8))
        self.etimeSpinBox = QSpinBox()
        self.etimeSpinBox.setRange(1,60)
        self.etimeSpinBox.setValue(aw.qmc.detectBackgroundEventTime)
        self.connect(self.etimeSpinBox, SIGNAL("valueChanged(int)"),self.setreproduce)
        #LAYOUT MANAGERS
        movelayout = QGridLayout()
        movelayout.addWidget(self.upButton,0,1)
        movelayout.addWidget(self.leftButton,1,0)
        movelayout.addWidget(self.speedSpinBox,1,1)
        movelayout.addWidget(self.rightButton,1,2)
        movelayout.addWidget(self.downButton,2,1)
        checkslayout = QHBoxLayout()
        checkslayout.addWidget(self.backgroundCheck)
        checkslayout.addWidget(self.backgroundDetails)
        checkslayout.addWidget(self.backgroundeventsflag)
        checkslayout.addWidget(self.backgroundDeltaETflag)
        checkslayout.addWidget(self.backgroundDeltaBTflag)
        checkslayout.addWidget(self.backgroundAlignFCsflag)
        layout = QGridLayout()
        layout.addWidget(intensitylabel,0,0)
        layout.addWidget(self.intensitySpinBox,0,1)
        layout.addWidget(metcolorlabel,1,0)
        layout.addWidget(self.metcolorComboBox,1,1)
        layout.addWidget(btcolorlabel,2,0)
        layout.addWidget(self.btcolorComboBox,2,1)
        layout.addWidget(deltaetcolorlabel,3,0)
        layout.addWidget(self.deltaetcolorComboBox,3,1)
        layout.addWidget(deltabtcolorlabel,4,0)
        layout.addWidget(self.deltabtcolorComboBox,4,1)        
        hlayout = QHBoxLayout()
        hlayout.addStretch()
        hlayout.addLayout(layout)
        upperlayout = QVBoxLayout()
        upperlayout.addLayout(movelayout)
        upperlayout.addLayout(checkslayout)
        upperlayout.addLayout(hlayout)
        layoutBoxed = QHBoxLayout()
        layoutBoxed.addStretch()
        layoutBoxed.addLayout(upperlayout)
        layoutBoxed.addStretch()
        alignButtonBoxed = QHBoxLayout()
        alignButtonBoxed.addWidget(loadButton)
        alignButtonBoxed.addWidget(delButton)
        alignButtonBoxed.addStretch()
        alignButtonBoxed.addWidget(alignButton)
        tab4content = QHBoxLayout()
        tab4content.addWidget(self.backgroundReproduce)
        tab4content.addStretch()
        tab4content.addWidget(etimelabel)
        tab4content.addWidget(self.etimeSpinBox)
        tab4content.addWidget(etimeunit)
        tab1layout = QVBoxLayout()
        tab1layout.addLayout(layoutBoxed)
        tab1layout.addStretch()
        tab1layout.addLayout(alignButtonBoxed)
        tab1layout.addWidget(self.pathedit)
        tab1layout.addLayout(tab4content)
        tab1layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab1layout.setMargin(0)
        tab2layout = QVBoxLayout()
        tab2layout.addWidget(self.eventtable)
        tab2layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab2layout.setMargin(0)
        tab3layout = QVBoxLayout()
        tab3layout.addWidget(self.datatable)
        tab3layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab3layout.setMargin(0)
        #tab layout
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","Config",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Events",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Data",None, QApplication.UnicodeUTF8))
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(TabWidget) 
        mainLayout.addLayout(buttonLayout)
        mainLayout.setContentsMargins(5, 15, 5, 10) # left, top, right, bottom 
        self.setLayout(mainLayout)
        
    def getColorIdx(self,c):
        try:
            return self.defaultcolorsmapped.index(c)
        except:
            try:
                return self.colors.index(c) + 5
            except: 
                return 0       

    def setreproduce(self):
        if aw.qmc.background:
            aw.qmc.detectBackgroundEventTime = self.etimeSpinBox.value()
            if self.backgroundReproduce.isChecked():
                aw.qmc.backgroundReproduce = True
                msg = QApplication.translate("Message","Playback Aid set ON at %1 secs",None, QApplication.UnicodeUTF8).arg(str(aw.qmc.detectBackgroundEventTime))
            else:
                aw.qmc.backgroundReproduce = False
                msg = QApplication.translate("StatusBar","Playback Aid set OFF",None, QApplication.UnicodeUTF8)
                aw.messagelabel.setStyleSheet("background-color:'transparent';")
            aw.sendmessage(msg)
        else:
            self.backgroundReproduce.setChecked(False)
            aw.sendmessage(QApplication.translate("Message","No profile background found",None, QApplication.UnicodeUTF8))

    def adjustcolor(self,color,curve):
        color = str(color)
        self.btcolorComboBox.setDisabled(True)
        self.metcolorComboBox.setDisabled(True)
        self.deltabtcolorComboBox.setDisabled(True)
        self.deltaetcolorComboBox.setDisabled(True)
        if color == "ET":
            c = aw.qmc.palette["et"]
        elif color == "BT":
            c = aw.qmc.palette["bt"]
        elif color == "DeltaET":
            c = aw.qmc.palette["deltaet"]
        elif color == "DeltaBT":
            c = aw.qmc.palette["deltabt"]
        else:
            c = color
        if c != "":
            if curve == "et":
                aw.qmc.backgroundmetcolor = c
            elif curve == "bt":
                aw.qmc.backgroundbtcolor = c
            elif curve == "deltaet":
                aw.qmc.backgrounddeltaetcolor = c
            elif curve == "deltabt":
                aw.qmc.backgrounddeltabtcolor = c
            aw.qmc.redraw(recomputeAllDeltas=False)
        self.btcolorComboBox.setDisabled(False)
        self.metcolorComboBox.setDisabled(False)
        self.deltabtcolorComboBox.setDisabled(False)
        self.deltaetcolorComboBox.setDisabled(False)

    def adjustintensity(self):
        #block button
        self.intensitySpinBox.setDisabled(True)
        aw.qmc.backgroundalpha = self.intensitySpinBox.value()/10.
        aw.qmc.redraw(recomputeAllDeltas=False)
        #reactivate button
        self.intensitySpinBox.setDisabled(False)

    def delete(self):
        self.pathedit.setText("")
# we should not overwrite the users app settings here, right:
#        aw.qmc.backgroundeventsflag = False
#        self.backgroundDetails.setChecked(False)
#        self.backgroundeventsflag.setChecked(False)
#        aw.qmc.backgroundDetails = False
# but we have to deactivate the show flag
        self.backgroundCheck.setChecked(False)
        aw.qmc.background = False
        aw.deleteBackground()
        self.eventtable.clear()
        self.datatable.clear()
        aw.qmc.resetlinecountcaches()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def move(self,m):
        #block button
        if m == "up":
            self.upButton.setDisabled(True)
        elif m == "down":
            self.downButton.setDisabled(True)
        elif m == "left":
            self.leftButton.setDisabled(True)
        elif m == "right":
            self.rightButton.setDisabled(True)
        step = self.speedSpinBox.value()
        aw.qmc.movebackground(m,step)
        self.createEventTable()
        self.createDataTable()
        aw.qmc.redraw(recomputeAllDeltas=False)
        #activate button
        if m == "up":
            self.upButton.setDisabled(False)
        elif m == "down":
            self.downButton.setDisabled(False)
        elif m == "left":
            self.leftButton.setDisabled(False)
        elif m == "right":
            self.rightButton.setDisabled(False)

    def readChecks(self):
        aw.qmc.background = bool(self.backgroundCheck.isChecked())
        aw.qmc.backgroundDetails = bool(self.backgroundDetails.isChecked())
        aw.qmc.backgroundeventsflag = bool(self.backgroundeventsflag.isChecked())
        aw.qmc.DeltaETBflag = bool(self.backgroundDeltaETflag.isChecked())
        aw.qmc.DeltaBTBflag = bool(self.backgroundDeltaBTflag.isChecked())
        aw.qmc.flagalignFCs = bool(self.backgroundAlignFCsflag.isChecked())
        aw.qmc.redraw(recomputeAllDeltas=False)

    def load(self):
        self.filename = aw.ArtisanOpenFileDialog()
        if len(u(self.filename)) == 0:
            return
        aw.sendmessage(QApplication.translate("Message","Reading background profile...",None, QApplication.UnicodeUTF8))
        aw.qmc.resetlinecountcaches()
        aw.loadbackground(u(self.filename))
        self.pathedit.setText(u(self.filename))
        self.backgroundCheck.setChecked(True)
        self.readChecks()
        self.createEventTable()
        self.createDataTable()
        aw.qmc.timealign(redraw=True)
        aw.qmc.safesaveflag = True

    def createEventTable(self):
        self.eventtable.clear()
        ndata = len(aw.qmc.backgroundEvents)
        if ndata:
            self.eventtable.setRowCount(ndata)
            self.eventtable.setColumnCount(4)
            self.eventtable.setHorizontalHeaderLabels([QApplication.translate("Table","Time",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Description",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Type",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Value",None, QApplication.UnicodeUTF8)])
            self.eventtable.setAlternatingRowColors(True)
            self.eventtable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.eventtable.setSelectionBehavior(QTableWidget.SelectRows)
            self.eventtable.setSelectionMode(QTableWidget.SingleSelection)
            self.eventtable.setShowGrid(True)
            self.eventtable.verticalHeader().setResizeMode(2)
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            for i in range(ndata):
                timez = QTableWidgetItem(aw.qmc.stringfromseconds(int(aw.qmc.timeB[aw.qmc.backgroundEvents[i]]-start)))
                timez.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                description = QTableWidgetItem(aw.qmc.backgroundEStrings[i])
                etype = QTableWidgetItem(aw.qmc.Betypesf(aw.qmc.backgroundEtypes[i]))
                evalue = QTableWidgetItem(aw.qmc.eventsvalues(aw.qmc.backgroundEvalues[i]))
                evalue.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                #add widgets to the table
                self.eventtable.setItem(i,0,timez)
                self.eventtable.setItem(i,1,description)
                self.eventtable.setItem(i,2,etype)
                self.eventtable.setItem(i,3,evalue)
            self.eventtable.resizeColumnsToContents()
            # improve width of Time column
            self.eventtable.setColumnWidth(1,175)

    def createDataTable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.timeB)
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        if ndata:
            self.datatable.setRowCount(ndata)
            self.datatable.setColumnCount(6)
            self.datatable.setHorizontalHeaderLabels([QApplication.translate("Table","Time",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","ET",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","BT",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","DeltaBT",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","DeltaET",None, QApplication.UnicodeUTF8),
                                                      ""], # dummy column that stretches
                                                      )
            self.datatable.setAlternatingRowColors(True)
            self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
            self.datatable.setSelectionMode(QTableWidget.SingleSelection)
            self.datatable.setShowGrid(True)
            self.datatable.verticalHeader().setResizeMode(2)
            for i in range(ndata):
                Rtime = QTableWidgetItem(aw.qmc.stringfromseconds(int(round(aw.qmc.timeB[i]-start))))
                Rtime.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                ET = QTableWidgetItem("%.0f"%aw.qmc.temp1B[i])
                BT = QTableWidgetItem("%.0f"%aw.qmc.temp2B[i])
                ET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                BT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                if i:
                    d = (aw.qmc.timeB[i]-aw.qmc.timeB[i-1])
                    if d == 0:
                        dET = 0.
                        dBT = 0.
                    else:
                        dET = (60*(aw.qmc.temp1B[i]-aw.qmc.temp1B[i-1])/d)
                        dBT = (60*(aw.qmc.temp2B[i]-aw.qmc.temp2B[i-1])/d)
                    deltaET = QTableWidgetItem("%.1f"%dET)
                    deltaBT = QTableWidgetItem("%.1f"%dBT)
                else:
                    deltaET = QTableWidgetItem("--")
                    deltaBT = QTableWidgetItem("--")
                deltaET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                deltaBT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                if i:
                    #identify by color and add notation
                    if i == aw.qmc.timeindexB[0] != -1:
                        Rtime.setBackgroundColor(QColor('#f07800'))
                        text = QApplication.translate("Table", "CHARGE",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[1]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "DRY END",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[2]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "FC START",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[3]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "FC END",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[4]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "SC START",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[5]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "SC END",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[6]:
                        Rtime.setBackgroundColor(QColor('#f07800'))
                        text = QApplication.translate("Table", "DROP",None, QApplication.UnicodeUTF8)
                    elif i == aw.qmc.timeindexB[7]:
                        Rtime.setBackgroundColor(QColor('#f07800'))
                        text = QApplication.translate("Table", "COOL",None, QApplication.UnicodeUTF8)
                    elif i in aw.qmc.backgroundEvents:
                        Rtime.setBackgroundColor(QColor('yellow'))
                        index = aw.qmc.backgroundEvents.index(i)
                        text = QApplication.translate("Table", "EVENT #%1 %2%3",None, QApplication.UnicodeUTF8).arg(str(index+1)).arg(aw.qmc.Betypesf(aw.qmc.backgroundEtypes[index])[0]).arg(str(aw.qmc.backgroundEvalues[index]-1))
                    else:
                        text = u("")
                    Rtime.setText(text + u(" " + Rtime.text()))
                self.datatable.setItem(i,0,Rtime)
                self.datatable.setItem(i,1,ET)
                self.datatable.setItem(i,2,BT)
                self.datatable.setItem(i,3,deltaBT)
                self.datatable.setItem(i,4,deltaET)
            header = self.datatable.horizontalHeader()
            header.setResizeMode(0, QHeaderView.Fixed)
            header.setResizeMode(1, QHeaderView.Fixed)
            header.setResizeMode(2, QHeaderView.Fixed)
            header.setResizeMode(3, QHeaderView.Fixed)
            header.setResizeMode(4, QHeaderView.Fixed)
            header.setResizeMode(5, QHeaderView.Stretch)
            self.datatable.resizeColumnsToContents()

#############################################################################
################  Statistics DIALOG ########################
#############################################################################

class StatisticsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(StatisticsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Statistics",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.timez = QCheckBox(QApplication.translate("CheckBox","Time",None, QApplication.UnicodeUTF8))
        self.bar = QCheckBox(QApplication.translate("CheckBox","Bar",None, QApplication.UnicodeUTF8))
        self.ror = QCheckBox(aw.qmc.mode + QApplication.translate("CheckBox","/min",None, QApplication.UnicodeUTF8))
        self.ts = QCheckBox(QApplication.translate("CheckBox","ETBTa",None, QApplication.UnicodeUTF8))
        self.flavor = QCheckBox(QApplication.translate("CheckBox","Evaluation",None, QApplication.UnicodeUTF8))
        self.area = QCheckBox(QApplication.translate("CheckBox","Characteristics",None, QApplication.UnicodeUTF8))
        self.mindryedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[0]))
        self.mindryedit.setAlignment(Qt.AlignRight)
        self.mindryedit.setMinimumWidth(60)
        self.mindryedit.setMaximumWidth(60)
        self.maxdryedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[1]))
        self.maxdryedit.setAlignment(Qt.AlignRight)
        self.maxdryedit.setMinimumWidth(60)
        self.maxdryedit.setMaximumWidth(60)
        self.minmidedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[2]))
        self.minmidedit.setAlignment(Qt.AlignRight)
        self.minmidedit.setMinimumWidth(60)
        self.minmidedit.setMaximumWidth(60)
        self.maxmidedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[3]))
        self.maxmidedit.setAlignment(Qt.AlignRight)
        self.maxmidedit.setMinimumWidth(60)
        self.maxmidedit.setMaximumWidth(60)
        self.minfinishedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[4]))
        self.minfinishedit.setAlignment(Qt.AlignRight)
        self.minfinishedit.setMinimumWidth(60)
        self.minfinishedit.setMaximumWidth(60)
        self.maxfinishedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[5]))
        self.maxfinishedit.setAlignment(Qt.AlignRight)
        self.maxfinishedit.setMinimumWidth(60)
        self.maxfinishedit.setMaximumWidth(60)
        self.mincooledit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[6]))
        self.mincooledit.setAlignment(Qt.AlignRight)
        self.mincooledit.setMinimumWidth(60)
        self.mincooledit.setMaximumWidth(60)
        self.maxcooledit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[7]))
        self.maxcooledit.setAlignment(Qt.AlignRight)
        self.maxcooledit.setMinimumWidth(60)
        self.maxcooledit.setMaximumWidth(60)
        self.mindryedit.setValidator(QRegExpValidator(regextime,self))
        self.maxdryedit.setValidator(QRegExpValidator(regextime,self))
        self.minmidedit.setValidator(QRegExpValidator(regextime,self))
        self.maxmidedit.setValidator(QRegExpValidator(regextime,self))
        self.minfinishedit.setValidator(QRegExpValidator(regextime,self))
        self.maxfinishedit.setValidator(QRegExpValidator(regextime,self))
        self.mincooledit.setValidator(QRegExpValidator(regextime,self))
        self.maxcooledit.setValidator(QRegExpValidator(regextime,self))
        drylabel =QLabel(QApplication.translate("Label", "Drying",None, QApplication.UnicodeUTF8))
        midlabel =QLabel(QApplication.translate("Label", "Maillard",None, QApplication.UnicodeUTF8))
        finishlabel =QLabel(QApplication.translate("Label", "Development",None, QApplication.UnicodeUTF8))
        coollabel =QLabel(QApplication.translate("Label", "Cooling",None, QApplication.UnicodeUTF8))
        minf = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxf = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))
        #temp fix for possible bug aw.qmc.statisticsflags=[] > empty list out of range
        if aw.qmc.statisticsflags:
            if aw.qmc.statisticsflags[0]:
                self.timez.setChecked(True)
            if aw.qmc.statisticsflags[1]:
                self.bar.setChecked(True)
            if aw.qmc.statisticsflags[2]:
                self.flavor.setChecked(True)
            if aw.qmc.statisticsflags[3]:
                self.area.setChecked(True)
            if aw.qmc.statisticsflags[4]:
                self.ror.setChecked(True)
            if aw.qmc.statisticsflags[5]:
#                if aw.qmc.statisticsflags[4]:
#                    self.ts.setChecked(False)
#                else:
#                    self.ts.setChecked(True)
                self.ts.setChecked(True)
        else:
            aw.qmc.statisticsflags = [1,1,0,1,1,0]
            self.timez.setChecked(True)
            self.bar.setChecked(True)
            self.flavor.setChecked(False)
            self.area.setChecked(True)
            self.ror.setChecked(True)
            self.ts.setChecked(False)
        self.connect(self.timez,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,0))
        self.connect(self.bar,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,1))
        self.connect(self.flavor,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,2))
        self.connect(self.area,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,3))
        self.connect(self.ror,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,4))
        self.connect(self.ts,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,5))
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        resetButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(resetButton, SIGNAL("clicked()"),self.initialsettings)
        flagsLayout = QGridLayout()
        flagsLayout.addWidget(self.timez,0,0)
        flagsLayout.addWidget(self.bar,0,1)
        flagsLayout.addWidget(self.ror,0,2)
        flagsLayout.addWidget(self.ts,0,3)
        flagsLayout.addWidget(self.flavor,0,4)
        flagsLayout.addWidget(self.area,0,5)
        layout = QGridLayout()
        layout.addWidget(minf,0,1,Qt.AlignCenter)
        layout.addWidget(maxf,0,2,Qt.AlignCenter)
        layout.addWidget(drylabel,1,0,Qt.AlignRight)
        layout.addWidget(self.mindryedit,1,1)
        layout.addWidget(self.maxdryedit,1,2)
        layout.addWidget(midlabel,2,0,Qt.AlignRight)
        layout.addWidget(self.minmidedit,2,1)
        layout.addWidget(self.maxmidedit,2,2)
        layout.addWidget(finishlabel,3,0,Qt.AlignRight)
        layout.addWidget(self.minfinishedit,3,1)
        layout.addWidget(self.maxfinishedit,3,2)
        layout.addWidget(coollabel,4,0,Qt.AlignRight)
        layout.addWidget(self.mincooledit,4,1)
        layout.addWidget(self.maxcooledit,4,2)
        resetButton.setFocusPolicy(Qt.NoFocus)
        layoutHorizontal = QHBoxLayout()
        layoutHorizontal.addLayout(layout)
        layoutHorizontal.addStretch()
        eventsGroupLayout = QGroupBox(QApplication.translate("GroupBox","Evaluation",None, QApplication.UnicodeUTF8))
        eventsGroupLayout.setLayout(layoutHorizontal)
        displayGroupLayout = QGroupBox(QApplication.translate("GroupBox","Display",None, QApplication.UnicodeUTF8))
        displayGroupLayout.setLayout(flagsLayout)
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(resetButton)
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(displayGroupLayout)
        mainLayout.addWidget(eventsGroupLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonsLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)

    def changeStatisticsflag(self,value,i):
        aw.qmc.statisticsflags[i] = value
        aw.qmc.redraw(recomputeAllDeltas=False)

    def initialsettings(self):
        aw.qmc.statisticsconditions = aw.qmc.defaultstatisticsconditions
        self.close()
        aw.showstatistics()

    def accept(self):
        mindry = aw.qmc.stringtoseconds(str(self.mindryedit.text()))
        maxdry = aw.qmc.stringtoseconds(str(self.maxdryedit.text()))
        minmid = aw.qmc.stringtoseconds(str(self.minmidedit.text()))
        maxmid = aw.qmc.stringtoseconds(str(self.maxmidedit.text()))
        minfinish = aw.qmc.stringtoseconds(str(self.minfinishedit.text()))
        maxfinish = aw.qmc.stringtoseconds(str(self.maxfinishedit.text()))
        mincool = aw.qmc.stringtoseconds(str(self.mincooledit.text()))
        maxcool = aw.qmc.stringtoseconds(str(self.maxcooledit.text()))
        if mindry != -1 and maxdry != -1 and minmid != -1 and maxmid != -1 and minfinish != -1 and maxfinish != -1 and mincool != -1 and maxcool != -1:
            aw.qmc.statisticsconditions[0] = mindry
            aw.qmc.statisticsconditions[1] = maxdry
            aw.qmc.statisticsconditions[2] = minmid
            aw.qmc.statisticsconditions[3] = maxmid
            aw.qmc.statisticsconditions[4] = minfinish
            aw.qmc.statisticsconditions[5] = maxfinish
            aw.qmc.statisticsconditions[6] = mincool
            aw.qmc.statisticsconditions[7] = maxcool
            if self.timez.isChecked(): 
                aw.qmc.statisticsflags[0] = 1
            else:
                aw.qmc.statisticsflags[0] = 0
                
            if self.bar.isChecked(): 
                aw.qmc.statisticsflags[1] = 1
            else:
                aw.qmc.statisticsflags[1] = 0
                
            if self.flavor.isChecked(): 
                aw.qmc.statisticsflags[2] = 1
            else:
                aw.qmc.statisticsflags[2] = 0
                
            if self.area.isChecked(): 
                aw.qmc.statisticsflags[3] = 1
            else:
                aw.qmc.statisticsflags[3] = 0
                
            if self.ror.isChecked(): 
                aw.qmc.statisticsflags[4] = 1
            else:
                aw.qmc.statisticsflags[4] = 0
                
            if self.ts.isChecked(): 
                aw.qmc.statisticsflags[5] = 1
            else:
                aw.qmc.statisticsflags[5] = 0
            aw.qmc.redraw(recomputeAllDeltas=False)
            self.close()

###########################################################################################
##################### MODBUS PORT #########################################################
###########################################################################################

# modbus_tk variant
#class modbusport(object):
#    """ this class handles the communications with all the modbus devices"""
#    
#    def __init__(self):
#        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
#        self.comport = "COM5"      #NOTE: this string should not be translated. 
#        self.baudrate = 115200
#        self.bytesize = 8
#        self.parity= 'N'
#        self.stopbits = 1
#        self.timeout=1.0
#        self.master = None
#        
#    def isConnected(self):
#        return (self.master == None)
#        
#    def connect(self):
#        if self.master == None:
#            try:
#                ser = serial.Serial()
#                ser.setPort(self.comport)
#                ser.setBaudrate(self.baudrate)
#                ser.setByteSize(self.bytesize)
#                ser.setParity(self.parity)
#                ser.setStopbits(self.stopbits)
#                ser.setTimeout(self.timeout)
#                self.master = modbus_rtu.RtuMaster(ser)
#                self.master.set_timeout(1.0)
#                self.master.set_verbose(False)
#            except Exception as e:
#                aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(e))) 
#           
#    def writeSingleRegister(self,slave,register,value):
#        try:
#            self.connect()
#            resp = self.master.execute(int(slave),cst.WRITE_SINGLE_REGISTER,int(register),output_value=int(value))
#        except modbus_tk.modbus_rtu.ModbusInvalidResponseError as e:
#            self.master.close()
#        except Exception as e:
#            pass

# minimalmodbus v0.6 version
#class modbusport(object):
#    """ this class handles the communications with all the modbus devices"""
#    def __init__(self):
#        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
#        self.comport = "COM5"      #NOTE: this string should not be translated.
#        self.baudrate = 115200
#        self.bytesize = 8
#        self.parity= 'N'
#        self.stopbits = 1
#        self.timeout = 1
#        self.input1slave = 0
#        self.input1register = 0
#        self.input1float = False
#        self.input1code = 3
#        self.input1mode = "C"
#        self.input2slave = 0
#        self.input2register = 0
#        self.input2float = False
#        self.input2code = 3
#        self.input2mode = "C"
#        self.input3slave = 0
#        self.input3register = 0
#        self.input3float = False
#        self.input3code = 3
#        self.input3mode = "C"
#        self.input4slave = 0
#        self.input4register = 0
#        self.input4float = False
#        self.input4code = 3
#        self.input4mode = "C"
#        self.littleEndianFloats = False
#        self.master = None
#        self.COMsemaphore = QSemaphore(1)
#
#    def address2register(self,addr,code=3):
#        if code == 3 or code == 6:
#            return addr - 40001
#        else:
#            return addr - 30001
#
#    def isConnected(self):
#        return not (self.master == None) and self.master.serial.isOpen()
#        
#    def disconnect(self):
#        if self.isConnected():
#            try:
#                self.master.serial.close()
#                self.master = None
#            except:
#                pass
#        
#    def connect(self):
#        if self.master and not self.master.serial.isOpen():
#            self.master = None
#        if self.master == None:
#            try:
#                # as in the following the port is None, no port is opened on creation of the (py)serial object
#                self.master = minimalmodbus.Instrument(None, 1) # port, slaveaddress
#                # configure serial port:
#                self.master.serial.setPort(self.comport)
#                self.master.serial.setBaudrate(self.baudrate)
#                self.master.serial.setByteSize(self.bytesize)
#                self.master.serial.setParity(self.parity)
#                self.master.serial.setStopbits(self.stopbits)
#                # timeout seems to delay sequential requests in minimalmodbus (used lib internal for Modbus timing requirements) so keep the default for now
#                #self.master.serial.setTimeout(self.timeout) 
#                # configure Instrument:
#                self.master.debug = False
#                # open port
#                if not self.master.close_port_after_each_call:
#                    self.master.serial.open()
#                    libtime.sleep(.3) # avoid possible hickups on startup
#            except Exception as ex:
#                _, _, exc_tb = sys.exc_info()
#                aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(ex)),exc_tb.tb_lineno)
#
#    # write value to register on slave
#    # value can be one of string (containing an int or float), an int or a float
#    def writeRegister(self,slave,register,value):
#        if stringp(value):
#            if "." in value:
#                self.writeWord(slave,register,value)
#            else:
#                self.writeSingleRegister(slave,register,value)
#        elif isinstance(value, int):
#            self.writeSingleRegister(slave,register,value)
#        elif isinstance(value, float):
#            self.writeWord(slave,register,value)
#
#    def writeSingleRegister(self,slave,register,value):
#        try:
#            #### lock shared resources #####
#            self.COMsemaphore.acquire(1)
#            self.connect()
#            self.master.address = int(slave)
#            self.master.write_register(int(register),int(value),0,6)
#        except Exception as ex:
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeSingleRegister() %1").arg(str(ex)),exc_tb.tb_lineno)
#        finally:
#            if self.COMsemaphore.available() < 1:
#                self.COMsemaphore.release(1)
#
#    # value=int or float
#    # writes a single precision 32bit float (2-registers)
#    def writeWord(self,slave,register,value):
#        try:
#            #### lock shared resources #####
#            self.COMsemaphore.acquire(1)
#            self.connect()
#            self.master.address = int(slave)
#            self.master.write_float(int(register),float(value),2)
#        except Exception as ex:
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeWord() %1").arg(str(ex)),exc_tb.tb_lineno)
#        finally:
#            if self.COMsemaphore.available() < 1:
#                self.COMsemaphore.release(1)
#
#    def readFloat(self,slave,register,code=3):
#        try:
#            #### lock shared resources #####
#            self.COMsemaphore.acquire(1)
#            self.connect()
#            self.master.address = int(slave)
#            r = self.master.read_float(int(register),int(code),2)
#            return r
#        except Exception as ex:
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " readFloat() %1").arg(str(ex)),exc_tb.tb_lineno)
#        finally:
#            if self.COMsemaphore.available() < 1:
#                self.COMsemaphore.release(1)
#            #note: logged chars should be unicode not binary
#            if aw.seriallogflag:
#                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
#                aw.addserial("MODBUS readFloat :" + settings + " || Slave = " + str(slave) + " || Register = " + str(register) + " || Code = " + str(code) + " || Rx = " + str(r))
#
#    def readSingleRegister(self,slave,register,code=3):
#        try:
#            #### lock shared resources #####
#            self.COMsemaphore.acquire(1)
#            self.connect()
#            self.master.address = int(slave)
#            r = self.master.read_register(int(register),0,int(code))
#            return r
#        except Exception as ex:
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " readSingleRegister() %1").arg(str(ex)),exc_tb.tb_lineno)
#        finally:
#            if self.COMsemaphore.available() < 1:
#                self.COMsemaphore.release(1)
#            #note: logged chars should be unicode not binary
#            if aw.seriallogflag:
#                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
#                aw.addserial("MODBUS readSingleRegister :" + settings + " || Slave = " + str(slave) + " || Register = " + str(register) + " || Code = " + str(code) + " || Rx = " + str(r))



# hack to allow retry count and timeout to be configured on pymodbus UDP, without it blocks on connection failures
class ArtisanModbusUdpClient(ModbusUdpClient):
    ''' Adds timeout to UDP client
    '''
    def __init__(self, host='127.0.0.1', port=Defaults.Port,
        framer=ModbusSocketFramer, **kwargs):
        ''' Initialize a client instance

        :param host: The host to connect to (default 127.0.0.1)
        :param port: The modbus port to connect to (default 502)
        :param framer: The modbus framer to use (default ModbusSocketFramer)
        '''
        self.host = host
        self.port = port
        self.socket = None
        self.timeout  = kwargs.get('timeout',  Defaults.Timeout)
        BaseModbusClient.__init__(self, framer(ClientDecoder()),**kwargs)
    
    def connect(self):
        ''' Connect to the modbus tcp server

        :returns: True if connection succeeded, False otherwise
        '''
        if self.socket: return True
        try:
            family = ModbusUdpClient._get_address_family(self.host)
            self.socket = socket.socket(family, socket.SOCK_DGRAM)
            self.socket.settimeout(self.timeout)
        except socket.error:
            self.close()
        return self.socket != None


# pymodbus version
class modbusport(object):
    """ this class handles the communications with all the modbus devices"""
    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "COM5"      #NOTE: this string should not be translated.
        self.baudrate = 115200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 1
        self.input1slave = 0
        self.input1register = 0
        self.input1float = False
        self.input1code = 3
        self.input1mode = "C"
        self.input2slave = 0
        self.input2register = 0
        self.input2float = False
        self.input2code = 3
        self.input2mode = "C"
        self.input3slave = 0
        self.input3register = 0
        self.input3float = False
        self.input3code = 3
        self.input3mode = "C"
        self.input4slave = 0
        self.input4register = 0
        self.input4float = False
        self.input4code = 3
        self.input4mode = "C"
        self.littleEndianFloats = False
        self.master = None
        self.COMsemaphore = QSemaphore(1)
        self.host = '127.0.0.1' # the TCP/UDP host
        self.port = 502 # the TCP/UDP port
        self.type = 0
        # type =
        #    0: Serial RTU
        #    1: Serial ASCII
        #    2: Serial Binary
        #    3: TCP
        #    4: UDP
        self.lastReadResult = 0 # this is set by eventaction following some custom button/slider Modbus actions with "read" command
    
    def address2register(self,addr,code=3):
        if code == 3 or code == 6:
            return addr - 40001
        else:
            return addr - 30001      

    def isConnected(self):
        return not (self.master == None) and self.master.socket
        
    def disconnect(self):
        if self.isConnected():
            try:
                self.master.close()
                self.master = None
            except:
                pass

    def connect(self):
        if self.master and not self.master.socket:
            self.master = None
        if self.master == None:
            try:
                # as in the following the port is None, no port is opened on creation of the (py)serial object
                if self.type == 1: # Serial ASCII
                    self.master = ModbusSerialClient(
                        method='ascii',
                        port=self.comport,
                        baudrate=self.baudrate,
                        bytesize=self.bytesize,
                        parity=self.parity,
                        stopbits=self.stopbits,
                        timeout=self.timeout)
                elif self.type == 2: # Serial Binary
                    self.master = ModbusSerialClient(
                        method='binary',
                        port=self.comport,
                        baudrate=self.baudrate,
                        bytesize=self.bytesize,
                        parity=self.parity,
                        stopbits=self.stopbits,
                        timeout=self.timeout)  
                elif self.type == 3: # TCP
                    self.master = ModbusTcpClient(
                        host=self.host, 
                        port=self.port)
                elif self.type == 4: # UDP
                    self.master = ArtisanModbusUdpClient(
                        host=self.host, 
                        port=self.port,
                        retry_on_empty=False,
                        retries=1,
                        timeout=0.5, #self.timeout
                        )
                else: # Serial RTU
                    self.master = ModbusSerialClient(
                        method='rtu',
                        port=self.comport,
                        baudrate=self.baudrate,
                        bytesize=self.bytesize,
                        parity=self.parity,
                        stopbits=self.stopbits,
                        timeout=self.timeout)                    
                self.master.connect()
                libtime.sleep(.3) # avoid possible hickups on startup
            except Exception as ex:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(ex)),exc_tb.tb_lineno)

    # write multiple coils on slave
    def writeCoils(self,slave,register,values):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            self.connect()
            self.master.write_coils(int(register),list(values),unit=int(slave))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeCoils() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)    
                
    # write single coil on slave (function 5)
    def writeCoil(self,slave,register,value):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            self.connect()
            self.master.write_coil(int(register),value,unit=int(slave))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeCoil() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
        
    # write value to register on slave (function 6)
    # value can be one of string (containing an int or float), an int or a float
    def writeRegister(self,slave,register,value):
        if stringp(value):
            if "." in value:
                self.writeWord(slave,register,value)
            else:
                self.writeSingleRegister(slave,register,value)
        elif isinstance(value, int):
            self.writeSingleRegister(slave,register,value)
        elif isinstance(value, float):
            self.writeWord(slave,register,value)

    def writeSingleRegister(self,slave,register,value):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            self.connect()
            self.master.write_register(int(register),int(value),unit=int(slave))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeSingleRegister() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)

    # value=int or float
    # writes a single precision 32bit float (2-registers)
    def writeWord(self,slave,register,value):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            self.connect()
            if self.littleEndianFloats:
                builder = BinaryPayloadBuilder(endian=Endian.Little)
            else:
                builder = BinaryPayloadBuilder(endian=Endian.Big)
            builder.add_32bit_float(float(value))
            payload = builder.build() # .tolist()
            self.master.write_registers(int(register),payload,unit=int(slave),skip_encode=True)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeWord() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)

    def readFloat(self,slave,register,code=3):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            self.connect()
            if code==3:
                res = self.master.read_holding_registers(int(register),2,unit=int(slave))
            else:
                res = self.master.read_input_registers(int(register),2,unit=int(slave))
            if res == None or isinstance(res,ExceptionResponse):
                raise Exception("Exception response")
            if self.littleEndianFloats:
                decoder = BinaryPayloadDecoder.fromRegisters(res.registers, endian=Endian.Little)
            else:
                decoder = BinaryPayloadDecoder.fromRegisters(res.registers, endian=Endian.Big)
            r = decoder.decode_32bit_float()
            return r
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " readFloat() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("MODBUS readFloat :" + settings + " || Slave = " + str(slave) + " || Register = " + str(register) + " || Code = " + str(code) + " || Rx = " + str(r))

    def readSingleRegister(self,slave,register,code=3):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            self.connect()            
            if code==3:
                res = self.master.read_holding_registers(int(register),1,unit=int(slave))
            else:
                res = self.master.read_input_registers(int(register),1,unit=int(slave))
            if res == None or isinstance(res,ExceptionResponse):
                raise Exception("Exception response")          
            decoder = BinaryPayloadDecoder.fromRegisters(res.registers, endian=Endian.Big)
            r = decoder.decode_16bit_uint()
            return r
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " readSingleRegister() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("MODBUS readSingleRegister :" + settings + " || Slave = " + str(slave) + " || Register = " + str(register) + " || Code = " + str(code) + " || Rx = " + str(r))


class extraserialport(object):
    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 19200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 1
        self.devicefunctionlist = {}
        self.device = None
        self.SP = None

    def confport(self):
        self.SP.setPort(self.comport)
        self.SP.setBaudrate(self.baudrate)
        self.SP.setByteSize(self.bytesize)
        self.SP.setParity(self.parity)
        self.SP.setStopbits(self.stopbits)
        self.SP.setTimeout(self.timeout)

    def openport(self):
        try:
            self.confport()
            #open port
            if not self.SP.isOpen():
                self.SP.open()
        except serial.SerialException:
            self.SP.close()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8)
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error + " Unable to open serial port",exc_tb.tb_lineno)

    def closeport(self):
        if self.SP == None:
            self.SP.close()

    def connect(self):
        if self.SP == None:
            try:
                self.SP = serial.Serial()
                self.openport()
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(e)),exc_tb.tb_lineno)


class scaleport(extraserialport):
    """ this class handles the communications with the scale"""
    def __init__(self):
        super(scaleport, self).__init__()
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 19200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 1
        self.devicefunctionlist = {
            "None" : None,
            "KERN NDE" : self.readKERN_NDE,
            "acaia" : self.readAcaia,
        }

    def closeport(self):
        if u(self.device) == "acaia":
            # disconnect from acaia scale
            try:
                if self.SP.isOpen():
                    self.SP.write(str2cmd('￼BTDS\r\n'))
            except Exception:
                pass
        super(scaleport, self).closeport()
        
    # returns weight as int in g or -1 if something went wrong
    def readWeight(self):
        if self.device != None and self.device != "None" and self.device != "":
            return aw.float2float(self.devicefunctionlist[u(self.device)]())
        else:
            return -1
            
    def readLine(self):
        return str(self.SP.readline().decode('ascii'))

    def readAcaia(self):
        try:
            if not self.SP:
                # connect serial port if not yet connected                
                self.connect()
            if self.SP:
                if not self.SP.isOpen():
                    # open serial port if not yet open
                    self.openport()
                if self.SP.isOpen(): 
                    self.SP.write(str2cmd('￼BTST\r\n')) # request connection state
                    v = self.readLine()
                    if v.startswith('status=DISCONNECTED'):
                        # connect to scale if not yet connected
                        self.SP.write(str2cmd('￼BTLS\r\n')) # scan for scales
                        # read reply until "SCAN_STOP"
                        v = self.readLine()
                        while not v.startswith(' SCAN_STOP'):                        
                            v = str(self.SP.readline().decode('ascii'))
                        self.SP.write(str2cmd('￼BTCN1\r\n')) # connect to scale 1
                        # read until non-empty reply
                        v = self.readLine()
                        while v == "": # read until non-empty line
                            v = self.readLine()
                        if v.startswith('status=connected'):
                            # we read another line after the "connected" message
                            v = self.readLine()
                    # request weight
                    self.SP.write(str2cmd('￼GWT1,1,1\r\n'))
                    self.readLine() # first line of the reply contains reading number
                    v = self.readLine() # the second line of the reply contains the reading
                    res = v.strip().split(' ')
                    n = float(res[0])
                    # if res[1] = ' ' and res[2] = v.strip().split(' ') then weight in g
                    # if res[1] = 'oz' then weight in oz
                    if res[1] == 'oz':
                        return n * 28.3495231
                    else:
                        return n
        except Exception:
            return -1

    def readKERN_NDE(self):
        try:
            if not self.SP:
                self.connect()
            if self.SP:
                if not self.SP.isOpen():
                    self.openport()
                if self.SP.isOpen():
                    #self.SP.write(str2cmd('s')) # only stable
                    self.SP.write(str2cmd('w')) # any weight
                    v = self.SP.readline()
                    sa = v.decode('ascii').split('g')
                    if len(sa) == 2:
                        return int(sa[0])
                    else:
                        return -1 
        except Exception:
            return -1


class colorport(extraserialport):
    """ this class handles the communications with the color meter"""
    def __init__(self):
        super(colorport, self).__init__()
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 115200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 3
        self.devicefunctionlist = {
            "None" : None,
            "Tonino" : self.readTonino
        }

    # returns color as int or -1 if something went wrong
    def readColor(self):
        if self.device != None and self.device != "None" and self.device != "":
            return self.devicefunctionlist[u(self.device)]()
        else:
            return -1

    def readTonino(self):
        try:
            if not self.SP:
                self.connect()
                libtime.sleep(3)
                # put Tonino into PC mode on first connect
                self.SP.write(str2cmd('\nTONINO\n'))
                #self.SP.flush()
                libtime.sleep(.1)
                self.SP.readline()
            if self.SP:
                if not self.SP.isOpen():
                    self.openport()
                if self.SP.isOpen():
                    self.SP.flushInput()
                    self.SP.flushOutput()
                    self.SP.write(str2cmd('\nSCAN\n'))
                    #self.SP.flush()
                    libtime.sleep(.1)
                    libtime.sleep(1.0)
                    v = self.SP.readline()
                    n = int(v.decode('ascii').split(":")[1]) # response should have format "SCAN:128"
                    return n
        except:
            return -1


###########################################################################################
##################### SERIAL PORT #########################################################
###########################################################################################

class serialport(object):
    """ this class handles the communications with all the devices"""

    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "COM4"      #NOTE: this string should not be translated. It is an argument for lib Pyserial
        self.baudrate = 9600
        self.bytesize = 8
        self.parity= 'O'
        self.stopbits = 1
        self.timeout=1
        #serial port for ET/BT
        self.SP = serial.Serial()
        #semaphore (used by TC4 communication)
        self.COMsemaphore = QSemaphore(1) 
        #list of comm ports available after Scan
        self.commavailable = []
        ##### SPECIAL METER FLAGS ########
        self.PhidgetManager = None
        #stores the Phidget 1048 TemperatureSensor object (None if not initialized)
        self.PhidgetTemperatureSensor = None
        self.PhidgetTemperatureSensorAttached = False
        self.Phidget1048values = [-1]*4 # the values gathered by registered change triggers
        #stores the Phidget 1045 TemperatureSensor object (None if not initialized)
        self.PhidgetIRSensor = None
        self.PhidgetIRSensorSensorAttached = False
        self.Phidget1045value = -1
        #stores the Phidget BridgeSensor object (None if not initialized)
        self.PhidgetBridgeSensor = None
        self.PhidgetBridgeSensorAttached = False
        self.Phidget1046values = [-1]*4 # the values gathered by registered change triggers
        #stores the Phidget IO object (None if not initialized)
        self.PhidgetIO = None
        self.PhidgetIOAttached = False
        self.PhidgetIOvalues = [-1]*8 # the values gathered by registered change triggers
        #Yoctopuce channels
        self.YOCTOsensor = None
        self.YOCTOchan1 = None
        self.YOCTOchan2 = None
        #stores the id of the meter HH506RA as a string
        self.HH506RAid = "X"
        #select PID type that controls the roaster.
        # Reads/Controls ET
        self.controlETpid = [0,1]        # index0: type of pid: 0 = FujiPXG, 1 = FujiPXR3, 2 = DTA 
#                                        # index1: RS485 unitID: Can be changed in device menu.
        # Reads BT
        self.readBTpid = [1,2]           # index 0: type: FujiPXG, 1 = FujiPXR3, 2 = None, 3 = DTA 
#                                        # index 1: RS485 unitID. Can be changed in device menu. 
        # Reuse Modbus-meter port
        self.useModbusPort = False
        #Initialization for ARDUINO and TC4 meter
        self.arduinoETChannel = "1"
        self.arduinoBTChannel = "2"
        self.arduinoATChannel = "None" # the channel the Ambient Temperature of the Arduino TC4 is reported as (this value will overwrite the corresponding real channel)
        self.ArduinoIsInitialized = 0
        self.ArduinoFILT = [10,10,10,10] # Arduino Filter settings per channel in %
        self.HH806Winitflag = 0
        #list of functions calls to read temperature for devices.
        # device 0 (with index 0 bellow) is Fuji Pid
        # device 1 (with index 1 bellow) is Omega HH806
        # device 2 (with index 2 bellow) is omega HH506
        # etc
        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
        # - add to self.devicefunctionlist
        self.devicefunctionlist = [self.fujitemperature,    #0
                                   self.HH806AU,            #1
                                   self.HH506RA,            #2
                                   self.CENTER309,          #3
                                   self.CENTER306,          #4
                                   self.CENTER305,          #5
                                   self.CENTER304,          #6
                                   self.CENTER303,          #7
                                   self.CENTER302,          #8
                                   self.CENTER301,          #9
                                   self.CENTER300,          #10
                                   self.VOLTCRAFTK204,      #11
                                   self.VOLTCRAFTK202,      #12
                                   self.VOLTCRAFT300K,      #13
                                   self.VOLTCRAFT302KJ,     #14
                                   self.EXTECH421509,       #15
                                   self.HH802U,             #16
                                   self.HH309,              #17
                                   self.NONE,               #18
                                   self.ARDUINOTC4,         #19
                                   self.TEVA18B,            #20
                                   self.CENTER309_34,       #21
                                   self.fujidutycycle,      #22
                                   self.HHM28,              #23
                                   self.K204_34,            #24
                                   self.virtual,            #25
                                   self.DTAtemperature,     #26
                                   self.callprogram,        #27
                                   self.ARDUINOTC4_34,      #28
                                   self.MODBUS,             #29
                                   self.VOLTCRAFTK201,      #30
                                   self.AmprobeTMD56,       #31
                                   self.ARDUINOTC4_56,      #32
                                   self.MODBUS_34,          #33
                                   self.PHIDGET1048,        #34
                                   self.PHIDGET1048_34,     #35
                                   self.PHIDGET1048_AT,     #36
                                   self.PHIDGET1046,        #37
                                   self.PHIDGET1046_34,     #38
                                   self.MastechMS6514,      #39
                                   self.PHIDGET1018,        #40
                                   self.PHIDGET1018_34,     #41
                                   self.PHIDGET1018_56,     #42
                                   self.PHIDGET1018_78,     #43
                                   self.ARDUINOTC4_78,      #44
                                   self.YOCTO_thermo,       #45
                                   self.YOCTO_pt100,        #46
                                   self.PHIDGET1045,        #47
                                   self.callprogram_34,     #48
                                   self.callprogram_56,     #49
                                   self.DUMMY,              #50
                                   self.CENTER304_34,       #51
                                   self.HH806W              #52
                                   ]
        #used only in devices that also control the roaster like PIDs or arduino (possible to recieve asynchrous comands from GUI commands and thread sample()). 
        self.COMsemaphore = QSemaphore(1)
        #string with the name of the program for device #27
        self.externalprogram = "test.py"

#####################  FUNCTIONS  ############################
    ######### functions used by Fuji PIDs
    def sendFUJIcommand(self,binstring,nbytes):
        try:
            ###  lock resources ##
            self.COMsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(binstring)
                #self.SP.flush()
                libtime.sleep(.1)
                r = self.SP.read(nbytes)
                #serTX.close()
                libtime.sleep(0.035)                     #this garantees a minimum of 35 miliseconds between readings (for all Fujis)
                lenstring = len(r)
                if lenstring:
                    # CHECK FOR RECEIVED ERROR CODES
                    if ord(r[1]) == 128:
                        if ord(r[2]) == 1:
                            errorcode = QApplication.translate("Error Message","F80h Error",None, QApplication.UnicodeUTF8) + QString(" 1: A nonexistent function code was specified. Please check the function code.")
                            errorcode += (QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + QString(" SendFUJIcommand() 1: Illegal Function in unit %1")).arg(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                        if ord(r[2]) == 2:
                            errorcode = QApplication.translate("Error Message","F80h Error",None, QApplication.UnicodeUTF8) + QString(" 2: Faulty address for coil or resistor: The specified relative address for the coil number or resistor\n number cannot be used by the specified function code.")
                            errorcode += (QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + QString(" SendFUJIcommand() 2 Illegal Address for unit %1")).arg(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                        if ord(r[2]) == 3:
                            errorcode = QApplication.translate("Error Message","F80h Error",None, QApplication.UnicodeUTF8) + QString(" 3: Faulty coil or resistor number: The specified number is too large and specifies a range that does not contain\n coil numbers or resistor numbers.")
                            errorcode += (QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + QString(" SendFUJIcommand() 3 Illegal Data Value for unit %1")).arg(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                    else:
                        #Check crc16
                        crcRx =  hex2int(r[-1],r[-2])
                        crcCal1 = aw.fujipid.fujiCrc16(r[:-2]) 
                        if crcCal1 == crcRx:
                            return r           #OK. Return r after it has been checked for errors
                        else:
                            aw.qmc.adderror(QApplication.translate("Error Message","CRC16 data corruption ERROR. TX does not match RX. Check wiring",None, QApplication.UnicodeUTF8))
                            return "0"
                else:
                    aw.qmc.adderror(QApplication.translate("Error Message","No RX data received",None, QApplication.UnicodeUTF8))
                    return "0"
            else:
                return "0"
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendFUJIcommand()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return "0"
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("Fuji :" + settings + " || Tx = " + cmd2str(binascii.hexlify(binstring)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    #finds time, ET and BT when using Fuji PID. Updates sv (set value) LCD. Finds power duty cycle
    def fujitemperature(self):
        #update ET SV LCD 6
        aw.qmc.currentpidsv = aw.fujipid.readcurrentsv()
        #get time of temperature reading in seconds from start; .elapsed() returns miliseconds
        tx = aw.qmc.timeclock.elapsed()/1000.
        # get the temperature for ET. aw.fujipid.gettemperature(unitID)
        t1 = aw.fujipid.gettemperature(self.controlETpid[1])/10.  #Need to divide by 10 beacuse using 1 decimal point in Fuji (ie. received 843 = 84.3)
        #if Fuji for BT is not None (0= PXG, 1 = PXR, 2 = None 3 = DTA)
        if self.readBTpid[0] < 2:                    
            t2 = aw.fujipid.gettemperature(self.readBTpid[1])/10.
        elif self.readBTpid[0] == 3:
            ### arguments to create command to READ TEMPERATURE
            unitID = self.readBTpid[1]
            function = 3
            address = aw.dtapid.dtamem["pv"][1]  #index 1; ascii string
            ndata = 1
            ### create command
            command = aw.dtapid.message2send(unitID,function,address,ndata)
            t2 = self.sendDTAcommand(command)
        else:
            t2 = -1
        #get current duty cycle and update LCD 7
        try:
            aw.qmc.dutycycle = aw.fujipid.readdutycycle()
            aw.qmc.dutycycleTX = aw.qmc.timeclock.elapsed()/1000.
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","",None, QApplication.UnicodeUTF8) + " fujitemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
        return tx,t1,t2

    #especial function that collects extra duty cycle % and ET minus BT while keeping compatibility
    def fujidutycycle(self):
        #return saved readings from device 0
        return aw.qmc.dutycycleTX, aw.qmc.dutycycle, aw.qmc.currentpidsv

    def DTAtemperature(self):
        ###########################################################
        ### create command
        command = aw.dtapid.message2send(self.controlETpid[1],3,aw.dtapid.dtamem["sv"][1],1)
        #read sv
        aw.qmc.currentpidsv = self.sendDTAcommand(command)
        #update SV value 
        aw.dtapid.dtamem["sv"][0] = aw.qmc.currentpidsv    #index 0
        #sv LCD is updated in qmc.updadegraphics()
        #give some time to rest
        libtime.sleep(.1)
        ##############################################################
        ### create command
        command = aw.dtapid.message2send(self.controlETpid[1],3,aw.dtapid.dtamem["pv"][1],1)
        #read
        t1 = self.sendDTAcommand(command)
        tx = aw.qmc.timeclock.elapsed()/1000.
        #if Fuji for BT is not None (0= PXG, 1 = PXR, 2 = None 3 = DTA)
        if self.readBTpid[0] < 2:                    
            t2 = aw.fujipid.gettemperature(self.readBTpid[1])/10.
        elif self.readBTpid[0] == 3:
            ### create command
            command = aw.dtapid.message2send(self.readBTpid[1],3,aw.dtapid.dtamem["pv"][1],1)
            t2 = self.sendDTAcommand(command)
        else:
            t2 = aw.qmc.currentpidsv  #return 
        ################################################################
        return tx,t1,t2

    def sendDTAcommand(self,command):
        try:
            ###  lock resources ##
            self.COMsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                nrxbytes = 15
                #clear
                self.SP.flushInput()
                self.SP.flushOutput()
                #SEND (tx)
                self.SP.write(str2cmd(command))
                #self.SP.flush()
                libtime.sleep(.1)
                #READ n bytes(rx)
                r = self.SP.read(nrxbytes).decode('utf-8')
##                command = ":010347000001B4"
##                r =       ":01030401900067"
                if len(r) == nrxbytes:
                    #READ and WRITE commands are different
                    #READ command
                    if command[4] == "3":
                        #CRCreceived = int(r[13:15],16)  #bytes 14&15
                        #CRCcalculated = aw.dtapid.DTACalcChecksum(r[1:11]) #bytes 1-10
                        #if CRCreceived == CRCcalculated:
                        t1 = float(int(r[7:11], 16))*0.1    #convert ascii string from bytes 8-11 (4 bytes) to a float
                        return t1
##                        else:
##                            aw.qmc.adderror(QApplication.translate("Error Message","DTAtemperature(): Data corruption. Check wiring",None, QApplication.UnicodeUTF8))            
##                            if len(aw.qmc.timex) > 2:
##                                return aw.qmc.temp1[-1]
##                            else:
##                                return 0.
                    #WRITE COMMAND. Under Test
##                    if command[4] == "4":
##                        #received  data is equal to sent command
##                        if r == command:
##                            aw.sendmessage("Write operation OK")
##                            return 1
##                        else:
##                            aw.sendmessage("Write operation BAD")
##                            return 0
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","DTAcommand(): %1 bytes received but 15 needed",None, QApplication.UnicodeUTF8).arg(nbytes))            
                    if len(aw.qmc.timex) > 2:
                        return aw.qmc.temp1[-1]
                    else:
                        return -1.
        except serial.SerialException:
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendDTAcommand()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds            
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("DElta DTA:" + settings + " || Tx = " + cmd2str(command) + " || Rx = " + str(r))

    def callprogram(self):
        try:
            output = os.popen(self.externalprogram,"r").readline()
            tx = aw.qmc.timeclock.elapsed()/1000.
            if "," in output:
                parts = output.split(",")
                if len(parts) > 2:
                    aw.qmc.program_t3 = float(parts[2])
                    if len(parts) > 3:
                        aw.qmc.program_t4 = float(parts[3])
                        if len(parts) > 4:
                            aw.qmc.program_t5 = float(parts[4])
                            if len(parts) > 5:
                                aw.qmc.program_t6 = float(parts[5])
                return tx,float(parts[0]),float(parts[1])
            else:
                return tx,0.,float(output)
        except Exception as e:
            tx = aw.qmc.timeclock.elapsed()/1000.
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " callprogram(): %1 ").arg(str(e)),exc_tb.tb_lineno)
            return tx,0.,0.
            
    def callprogram_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.program_t3
        t2 = aw.qmc.program_t4
        return tx,t2,t1

    def callprogram_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.program_t5
        t2 = aw.qmc.program_t6
        return tx,t2,t1

    def virtual(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        return tx,1.,1.

    def HH506RA(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH506RAtemperature()
        return tx,t2,t1

    def HH806AU(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1

    def AmprobeTMD56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1 

    def MastechMS6514(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.MS6514temperature()
        return tx,t2,t1 

    def HH806W(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806Wtemperature()
        return tx,t2,t1
    
    def DUMMY(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        return tx,0,0
        
    def PHIDGET1045(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t,a = self.PHIDGET1045temperature()
        return tx,a,t        

    def PHIDGET1048(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(0)
        return tx,t1,t2 # time, ET (chan2), BT (chan1)

    def PHIDGET1048_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(1)
        return tx,t1,t2

    def PHIDGET1048_AT(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(2)
        return tx,t1,t2

    def PHIDGET1046(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1046temperature(0)
        return tx,t1,t2

    def PHIDGET1046_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1046temperature(1)
        return tx,t1,t2
        
    def PHIDGET1018(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(0)
        return tx,v1,v2

    def PHIDGET1018_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(1)
        return tx,v1,v2

    def PHIDGET1018_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(2)
        return tx,v1,v2

    def PHIDGET1018_78(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(3)
        return tx,v1,v2

    def MODBUS(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.MODBUSread()
        return tx,t2,t1

    def MODBUS_34(self):
        return aw.qmc.extraMODBUStx,aw.qmc.extraMODBUSt4,aw.qmc.extraMODBUSt3

    def HH802U(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1

    def HH309(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    def CENTER309(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    #especial function that collects extra T3 and T4 from center 309 while keeping compatibility
    def CENTER309_34(self):
        #return saved readings collected at self.CENTER309temperature()
        return aw.qmc.extra309TX,aw.qmc.extra309T4,aw.qmc.extra309T3

    #especial function that collects extra T3 and T4 from center 309 while keeping compatibility
    def CENTER304_34(self):
        return self.CENTER309_34()

    def CENTER306(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def CENTER305(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def CENTER304(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    def CENTER303(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def CENTER302(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def CENTER301(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def CENTER300(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFTK204(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    #especial function that collects extra T3 and T4 from Vol K204 while keeping compatibility
    def K204_34(self):
        #return saved readings collected at self.CENTER309temperature()
        return aw.qmc.extra309TX,aw.qmc.extra309T4,aw.qmc.extra309T3

    def VOLTCRAFTK201(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFTK202(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def VOLTCRAFT300K(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFT302KJ(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def EXTECH421509(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH506RAtemperature()
        return tx,t2,t1

    def NONE(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.NONEtmp()
        return tx,t2,t1

    def ARDUINOTC4(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.ARDUINOTC4temperature()
        return tx,t2,t1

    def ARDUINOTC4_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT1
        t2 = aw.qmc.extraArduinoT2
        return tx,t2,t1

    def ARDUINOTC4_56(self): # heater / fan DUTY %
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT3
        t2 = aw.qmc.extraArduinoT4
        return tx,t2,t1

    def ARDUINOTC4_78(self): # PID SV / internal temp
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT5
        t2 = aw.qmc.extraArduinoT6
        return tx,t2,t1
        
    def YOCTO_thermo(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.YOCTOtemperatures(0)
        return tx,v1,v2

    def YOCTO_pt100(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.YOCTOtemperatures(1)
        return tx,v1,v2

    def TEVA18B(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.TEVA18Btemperature()
        return tx,t2,t1

    #multimeter
    def HHM28(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        val,symbols= self.HHM28multimeter()  #NOTE: val and symbols are type strings
        #temporary fix to display the output
        aw.sendmessage(val + symbols)
        if "L" in val:  #L = Out of Range
            return tx, 0., 0.
##        else:
##            #read quantifier symbols
##            if "n" in symbols:
##                val /= 1000000000.
##            elif "u" in symbols:
##                val /= 1000000.
##            elif "m" in symbols:
##                val /= 1000.
##            elif "k" in symbols:
##                val *= 1000.
##            elif "M" in symbols:
##                val *= 1000000.
            ### not finished
        else:
            return tx, 0., float(val)   #send a 0. as second reading because the meter only returns one reading

############################################################################
    def openport(self):
        try:
            self.confport()
            self.ArduinoIsInitialized = 0  # Assume the Arduino has to be reinitialized
            #open port
            if not self.SP.isOpen():
                self.SP.open()
                libtime.sleep(.5) # avoid possible hickups on startup
        except serial.SerialException:
            self.SP.close()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + QApplication.translate("Error Message","Unable to open serial port",None, QApplication.UnicodeUTF8)
            aw.qmc.adderror(error)

    #loads configuration to ports
    def confport(self):
        self.SP.setPort(self.comport)
        self.SP.setBaudrate(self.baudrate)
        self.SP.setByteSize(self.bytesize)
        self.SP.setParity(self.parity)
        self.SP.setStopbits(self.stopbits)
        self.SP.setTimeout(self.timeout)

    def closeport(self):
        try:
            if self.SP and self.SP.isOpen():
                self.SP.close()
        except:
            pass

    def closeEvent(self,_):
        try:
            self.closeport() 
        except serial.SerialException:
            pass

    def binary(self, n, digits=8):
        return "{0:0>{1}}".format(bin(n)[2:], digits)

    #similar to Omega HH806
    def MS6514temperature(self):
        try:
#            command = str2cmd("#0A0000NA2\r\n")  #"#0A0101NA4\r\n"
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
#                self.SP.flushOutput()
#                self.SP.write(command)
#                libtime.sleep(.1)
                r = self.SP.read(16)
                if len(r) == 16:
                    #convert to binary to hex string
                    s1 = hex2int(r[5],r[6])/10.
                    s2 = hex2int(r[7],r[8])/10.
                    #we convert the strings to integers. Divide by 10.0 (decimal position)
                    return s1,s2
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","MS6514temperature(): %1 bytes received but 16 needed",None, QApplication.UnicodeUTF8).arg(nbytes))
                    return -1,-1                                    #return something out of scope to avoid function error (expects two values)
            else:
                return -1,-1
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806AUtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.MS6514temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806 :" + settings + " || Rx = " + cmd2str(binascii.hexlify(r)))


    #t2 and t1 from Omega HH806 or HH802 meter 
    def HH806AUtemperature(self):
        #init command = "#0A0000RA6\r\n"
        try:
            command = str2cmd("#0A0000NA2\r\n")  #"#0A0101NA4\r\n"
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
#                self.SP.flush() # was added in 0.7.x but seems to produce problems on some Macs
                libtime.sleep(.1)
                r = self.SP.read(16)
                if len(r) == 16:
                    #convert to binary to hex string
                    s1 = hex2int(r[5],r[6])/10.
                    s2 = hex2int(r[10],r[11])/10.
                    #we convert the strings to integers. Divide by 10.0 (decimal position)
                    return s1,s2
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH806AUtemperature(): %1 bytes received but 16 needed",None, QApplication.UnicodeUTF8).arg(nbytes))
                    return -1,-1                                    #return something out of scope to avoid function error (expects two values)
            else:
                return -1,-1
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806AUtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806AUtemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def HH806Winit(self):
        try:
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(str2cmd("#0A0000RA6\r\n"))
                libtime.sleep(.3)
                self.SP.write(str2cmd("#0A0000RA6\r\n"))
                libtime.sleep(.3)
                self.SP.write(str2cmd("\x21\x05\x00\x58\x7E"))
                libtime.sleep(2.)
                self.HH806Winitflag = 1
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Winit()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Winit() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                command = "#0A0000RA6\r\n #0A0000RA6\r\n \x21\x05\x00\x58\x7E"
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806Winit :" + settings + " || Tx = " + command + " || Rx = ")

    #UNDER WORK 806 wireless meter
    def HH806Wtemperature(self):
        if self.HH806Winitflag == 0:
            self.HH806Winit()
            if self.HH806Winitflag == 0:
                aw.qmc.adderror(QApplication.translate("Error Message","HH806Wtemperature(): Unable to initiate device",None, QApplication.UnicodeUTF8))
                return -1,-1
        try:
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                for _ in range(27):
                    rcode = self.SP.read(1)
                    #locate first byte
                    if rcode == "\x3d":
                        r = self.SP.read(25)
                        if len(r) == 25:
                            r1 = hex2int(r[11],r[12])/10.
                            r2 = hex2int(r[19],r[20])/10.
                            #GOOD
                            return r1,r2
                #BAD
                return -1.,-1.
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Wtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Wtemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806Wtemperature: " + settings + " || Rx = " + binascii.hexlify(r))

    #returns v1,v2 from a connected MODBUS device
    def MODBUSread(self):
        # slave, register
        just_send = False
        if aw.modbus.input1slave:
            if aw.modbus.input1float:
                res1 = aw.modbus.readFloat(aw.modbus.input1slave,aw.modbus.input1register,aw.modbus.input1code)
            else:
                res1 = aw.modbus.readSingleRegister(aw.modbus.input1slave,aw.modbus.input1register,aw.modbus.input1code)
            if res1 is None:
                res1 = -1
            just_send = True
        else:
            res1 = -1
        if aw.modbus.input2slave:
            if just_send:
                libtime.sleep(0.30)   #this garantees a minimum of 30 miliseconds between readings (according to the Modbus spec)
            if aw.modbus.input2float:
                res2 = aw.modbus.readFloat(aw.modbus.input2slave,aw.modbus.input2register,aw.modbus.input2code)
            else:
                res2 = aw.modbus.readSingleRegister(aw.modbus.input2slave,aw.modbus.input2register,aw.modbus.input2code)
            if res2 is None:
                res2 = -1
            just_send = True
        else:
            res2 = -1
        if aw.modbus.input3slave:
            if just_send:
                libtime.sleep(0.30)   #this garantees a minimum of 30 miliseconds between readings (according to the Modbus spec)
            if aw.modbus.input3float:
                res3 = aw.modbus.readFloat(aw.modbus.input3slave,aw.modbus.input3register,aw.modbus.input3code)
            else:
                res3 = aw.modbus.readSingleRegister(aw.modbus.input3slave,aw.modbus.input3register,aw.modbus.input3code)
            if res3 is None:
                res3 = -1
            just_send = True
        else:
            res3 = -1
        if aw.modbus.input4slave:
            if just_send:
                libtime.sleep(0.30)   #this garantees a minimum of 30 miliseconds between readings (according to the Modbus spec)
            if aw.modbus.input4float:
                res4 = aw.modbus.readFloat(aw.modbus.input4slave,aw.modbus.input4register,aw.modbus.input4code)
            else:
                res4 = aw.modbus.readSingleRegister(aw.modbus.input4slave,aw.modbus.input4register,aw.modbus.input4code)
            if res4 is None:
                res4 = -1
            just_send = True
        else:
            res4 = -1
        aw.qmc.extraMODBUSt3 = res3
        aw.qmc.extraMODBUSt4 = res4
        aw.qmc.extraMODBUStx = aw.qmc.timeclock.elapsed()/1000.
        return res2, res1

    def NONEtmp(self):
        dialogx = nonedevDlg()
        if dialogx.exec_():
            try:
                ET = (int(str(dialogx.etEdit.text())) * 10)/10.
            except:
                ET = 0
            try:
                BT = (int(str(dialogx.btEdit.text())) * 10)/10.
            except:
                BT = 0
            return ET, BT
        else:
            return -1, -1

    #reads once the id of the HH506RA meter and stores it in the serial variable self.HH506RAid. Marko Luther.
    def HH506RAGetID(self):
        try:
            ID = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                sync = None
                while sync != b"Err\r\n":
                    self.SP.write(b"\r\n")
                    #self.SP.flush()
                    libtime.sleep(.1)
                    sync = self.SP.read(5)
                    libtime.sleep(1)
                self.SP.write(b"%000R")
                ID = self.SP.read(5)
                if len(ID) == 5:
                    self.HH506RAid = ID[0:3]               # Assign new id to self.HH506RAid
                else:
                    nbytes = len(ID)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH506RAGetID: %1 bytes received but 5 needed",None, QApplication.UnicodeUTF8).arg(nbytes))
        except serial.SerialException:
            self.closeport()
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAGetID()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAGetID() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H506 :" + settings + " || Rx = " + str(ID))

    #HH506RA Device
    #returns t1,t2 from Omega HH506 meter. By Marko Luther
    def HH506RAtemperature(self):
        #if initial id "X" has not changed then get a new one;
        if self.HH506RAid == "X":
            self.HH506RAGetID()                       # obtain new id one time; self.HH506RAid should not be "X" any more
            if self.HH506RAid == "X":                 # if self.HH506RAGetID() went wrong and self.HH506RAid is still "X"
                aw.qmc.adderror(QApplication.translate("Error Message","HH506RAtemperature(): Unable to get id from HH506RA device ",None, QApplication.UnicodeUTF8))
                return -1,-1
        try:
            command = b"#" + self.HH506RAid + b"N" # + "\r\n" this seems not to be needed
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                self.SP.flush()
                r = self.SP.read(14)
                if len(r) == 14:
                    #we convert the hex strings to integers. Divide by 10.0 (decimal position)
                    r = r.replace(str2cmd(' '),str2cmd('0'))
                    return int(r[1:5],16)/10., int(r[7:11],16)/10.
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH506RAtemperature(): %1 bytes received but 14 needed",None, QApplication.UnicodeUTF8).arg(nbytes))               
                    return -1,-1
            else:
                return -1,-1
        except serial.SerialException:
            #self.closeport()
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAtemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H506 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def CENTER302temperature(self):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                #self.SP.flush()
                libtime.sleep(.1)
                r = self.SP.read(7)                                   #NOTE: different
                if len(r) == 7:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(o(r[2]))              #bit"[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    return T1,0
                else:
                    nbytes = len(r)
                    error = QApplication.translate("Error Message","CENTER302temperature(): %1 bytes received but 7 needed",None, QApplication.UnicodeUTF8).arg(nbytes)
                    timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                    return -1,-1 
            else:
                return -1,-1 
        except serial.SerialException:
            #self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER302temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER302temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER302 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER303temperature(self):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                #self.SP.flush()
                libtime.sleep(.1)
                r = self.SP.read(8) #NOTE: different to CENTER306
                if len(r) == 8:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #if bit 5 of byte 3 = 1 then T2 = ####
                    #if bit 5 of byte 3 = 0 then T2 = ###.#
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(o(r[2]))              #bit"[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    bit5 = b3bin[2]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #extract T2
                    B56 = cmd2str(binascii.hexlify(r[5:7])) # select byte 5 and 6; NOTE: different to CENTER303
                    if B56[0].isdigit():
                        T2 = float(B56)
                    else:
                        T2 = float(B56[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    if bit5 == "0":
                        T2 /= 10.
                    return T1,T2
                else:
                    _, _, exc_tb = sys.exc_info()
                    nbytes = len(r)
                    error = QApplication.translate("Error Message","CENTER303temperature(): %1 bytes received but 8 needed",None, QApplication.UnicodeUTF8).arg(nbytes)
                    timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                    return -1,-1
            else:
                return -1,-1 
        except serial.SerialException:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER303temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER303temperature() %1").arg(str(ex)),exc_tb.tb_lineno)            
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER303 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER306temperature(self):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                #self.SP.flush()
                libtime.sleep(.1)
                r = self.SP.read(10) #NOTE: different to CENTER303
                if len(r) == 10:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #if bit 5 of byte 3 = 1 then T2 = ####
                    #if bit 5 of byte 3 = 0 then T2 = ###.#
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(o(r[2]))          #bits string order "[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    bit5 = b3bin[2]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #extract T2
                    B78 = cmd2str(binascii.hexlify(r[7:9])) # select byte 7 and 9; NOTE: different to CENTER303
                    if B78[0].isdigit():
                        T2 = float(B78)
                    else:
                        T2 = float(B78[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    if bit5 == "0":
                        T2 /= 10.
                    return T1,T2
                else:
                    nbytes = len(r)
                    error = QApplication.translate("Error Message","CENTER306temperature(): %1 bytes received but 10 needed",None, QApplication.UnicodeUTF8).arg(nbytes)
                    timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                    return -1,-1
            else:
                return -1,-1
        except serial.SerialException:
            #self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER306temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER306temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER306 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER309temperature(self):
        ##    command = "\x4B" returns 4 bytes . Model number.
        ##    command = "\x48" simulates HOLD button
        ##    command = "\x4D" simulates MAX/MIN button
        ##    command = "\x4E" simulates EXIT MAX/MIN button
        ##    command = "\x52" simulates TIME button
        ##    command = "\x43" simulates C/F button
        ##    command = "\x55" dump all memmory
        ##    command = "\x50" Load recorded data
        ##    command = "\x41" returns 45 bytes (8x5 + 5 = 45) as follows:
        ##    
        ##    "\x02\x80\xUU\xUU\xUU\xUU\xUU\xAA"  \x80 means "Celsi" (if \x00 then "Faren") UUs unknown
        ##    "\xAA\xBB\xBB\xCC\xCC\xDD\xDD\x00"  Temprerature T1 = AAAA, T2=BBBB, T3= CCCC, T4 = DDDD
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown (possible data containers but found empty)
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown
        ##    "\x00\x00\x00\x0E\x03"              The byte r[43] \x0E changes depending on what thermocouple(s) are connected.
        ##                                        If T1 thermocouple connected alone, then r[43]  = \x0E = 14
        ##                                        If T2 thermocouple connected alone, then r[43]  = \x0D = 13
        ##                                        If T1 + T2 thermocouples connected, then r[43]  = \x0C = 12
        ##                                        If T3 thermocouple connected alone, then r[43]  = \x0B = 11
        ##                                        If T4 thermocouple connected alone, then r[43]  = \x07 = 7
        ##                                        Note: Print r[43] if you want to find other connect-combinations
        ##                                        THIS ONLY WORKS WHEN TEMPERATURE < 200. If T >= 200 r[43] changes
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                #self.SP.flush()
                libtime.sleep(.1)
                r = self.SP.read(45)
                if len(r) == 45:
                    T1 = T2 = T3 = T3 = -1
                    try:
                        T1 = hex2int(r[7],r[8])/10.
                    except Exception:
                        pass
                    try:
                        T2 = hex2int(r[9],r[10])/10.
                    except Exception:
                        pass
                    try:
                        T3 = hex2int(r[11],r[12])/10.
                    except Exception:
                        pass
                    try:
                        T4 = hex2int(r[13],r[14])/10.
                    except Exception:
                        pass
                    #save these variables if using T3 and T4
                    aw.qmc.extra309T3 = T3
                    aw.qmc.extra309T4 = T4
                    aw.qmc.extra309TX = aw.qmc.timeclock.elapsed()/1000.
                    return T1,T2
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","CENTER309temperature(): %1 bytes received but 45 needed",None, QApplication.UnicodeUTF8).arg(nbytes))            
                    return -1,-1 
            else:
                return -1,-1
        except serial.SerialException:
            #self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER309temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER309temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER309 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def getFirstMatchingPhidgetsSerialNum(self,name):
        if self.PhidgetManager == None:
            self.PhidgetManager = PhidgetManager()
        if aw.qmc.phidgetRemoteFlag:
            libtime.sleep(.1)
            self.PhidgetManager.openRemote(aw.qmc.phidgetServerID,password=aw.qmc.phidgetPassword)
        else:
            self.PhidgetManager.openManager()
        devices = self.PhidgetManager.getAttachedDevices()
        res = -1
        if len(devices) == 0:
            libtime.sleep(.3)
            devices = self.PhidgetManager.getAttachedDevices()
            if len(devices) == 0:
                res = 0
        for d in devices:
            ser = d.getSerialNum()
            if d.getDeviceName() == name:
                # try if it can be opened (so not yet opened by another channel)
                try:
                    if not aw.qmc.phidgetRemoteFlag and name == 'Phidget Temperature Sensor IR': # only for the IR we support multiple devices
#                       d.openRemote(aw.qmc.phidgetServerID,serial=ser,password=aw.qmc.phidgetPassword)
                        d.openPhidget(serial=ser)
                        libtime.sleep(.4)
                        d.waitForAttach(800)
                        d.closePhidget()
                    res = ser
                    break                    
                except:
                    pass
            else:
                res = 0
        return res

    def phidget1045TemperatureChanged(self,e):
        if aw.qmc.phidget1045_async:
            self.Phidget1045value = (self.Phidget1045value + e.temperature)/2.0
            
    def phidget1045temp(self,temp,ambient):
        return (temp - ambient) * aw.qmc.phidget1045_emissivity + ambient

    def configure1045(self):
        self.Phidget1045value = -1
        if aw.qmc.phidget1045_async:
            self.PhidgetIRSensor.setTemperatureChangeTrigger(0,aw.qmc.phidget1045_changeTrigger)
        else:
            self.PhidgetIRSensor.setTemperatureChangeTrigger(0,0.5)
        if aw.qmc.phidget1045_async:
            self.PhidgetIRSensor.setOnTemperatureChangeHandler(lambda e=None:self.phidget1045TemperatureChanged(e))
        else:
            self.PhidgetIRSensor.setOnTemperatureChangeHandler(None)

    def phidget1045attached(self,e):
        self.configure1045()
        aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor IR attached",None, QApplication.UnicodeUTF8))
        self.PhidgetIRSensorSensorAttached = True
        
    def phidget1045detached(self,e):
        aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor IR detached",None, QApplication.UnicodeUTF8))
        self.PhidgetIRSensorSensorAttached = False

    def PHIDGET1045temperature(self):
        try:
            if self.PhidgetIRSensor == None:
                ser = self.getFirstMatchingPhidgetsSerialNum('Phidget Temperature Sensor IR')
                if ser:
                    self.PhidgetIRSensor = PhidgetTemperatureSensor()
                    try:
                        self.PhidgetIRSensor.setOnAttachHandler(self.phidget1045attached)
                        self.PhidgetIRSensor.setOnDetachHandler(self.phidget1045detached)
                        if aw.qmc.phidgetRemoteFlag:
                            self.PhidgetIRSensor.openRemote(aw.qmc.phidgetServerID,serial=ser,password=aw.qmc.phidgetPassword)
                        else:
                            self.PhidgetIRSensor.openPhidget(serial=ser)
                    except Exception as ex:
                        #_, _, exc_tb = sys.exc_info()
                        #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1045temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
                        try:
                            self.PhidgetIRSensor.closePhidget()
                        except:
                            pass
                        self.PhidgetIRSensor = None
            if self.PhidgetIRSensorSensorAttached:
                    res = -1
                    ambient = -1
                    try:
                        if aw.qmc.phidget1045_async:
                            if self.Phidget1045value == -1:
                                self.Phidget1045value = self.PhidgetIRSensor.getTemperature(0)
                            probe = self.Phidget1045value
                        else:
                            probe = self.PhidgetIRSensor.getTemperature(0)
                        if aw.qmc.mode == "F":
                            probe = aw.qmc.fromCtoF(probe)
                        res = probe
                    except:
                        pass
                    try:
                        ambient = self.PhidgetIRSensor.getAmbientTemperature()
                    except:
                        pass
                    return self.phidget1045temp(res,ambient),ambient
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                self.PhidgetIRSensor.closePhidget()
            except:
                pass
            self.PhidgetIRSensor = None
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1045temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    def phidget1048TemperatureChanged(self,e):
        if aw.qmc.phidget1048_async[e.index]:
            aw.ser.Phidget1048values[e.index] = (aw.ser.Phidget1048values[e.index] + e.temperature)/2.0

    def phidget1048getSensorReading(self,i):
        if aw.qmc.phidget1048_async[i]:
            if aw.ser.Phidget1048values[i] == -1:
                aw.ser.Phidget1048values[i] = aw.ser.PhidgetTemperatureSensor.getTemperature(i)                
            return aw.ser.Phidget1048values[i]
        else:
            return aw.ser.PhidgetTemperatureSensor.getTemperature(i)
    
    def configure1048(self):
        aw.ser.PhidgetTemperatureSensor.setThermocoupleType(0,aw.qmc.phidget1048_types[0])
        aw.ser.PhidgetTemperatureSensor.setThermocoupleType(1,aw.qmc.phidget1048_types[1])
        if 35 in aw.qmc.extradevices:
            aw.ser.PhidgetTemperatureSensor.setThermocoupleType(2,aw.qmc.phidget1048_types[2])
            aw.ser.PhidgetTemperatureSensor.setThermocoupleType(3,aw.qmc.phidget1048_types[3])
        aw.ser.Phidget1048values = [-1]*4
        changeTrigger = False
        for i in range(4):
            if i < 2 or (i < 4 and 35 in aw.qmc.extradevices):
                if aw.qmc.phidget1048_async[i]:
                    aw.ser.PhidgetTemperatureSensor.setTemperatureChangeTrigger(i,aw.qmc.phidget1048_changeTriggers[i])
                    changeTrigger = True
                else:
                    aw.ser.PhidgetTemperatureSensor.setTemperatureChangeTrigger(i,0.5)
        if changeTrigger:
            aw.ser.PhidgetTemperatureSensor.setOnTemperatureChangeHandler(lambda e=None:self.phidget1048TemperatureChanged(e))
        else:
            aw.ser.PhidgetTemperatureSensor.setOnTemperatureChangeHandler(None)

    def phidget1048attached(self,e):
        self.configure1048()
        aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor 4-input attached",None, QApplication.UnicodeUTF8))
        aw.ser.PhidgetTemperatureSensorAttached = True
        
    def phidget1048detached(self,e):
        aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor 4-input detached",None, QApplication.UnicodeUTF8))
        aw.ser.PhidgetTemperatureSensorAttached = False

    # mode = 0 for probe 1 and 2; mode = 1 for probe 3 and 4; mode 2 for Ambient Temperature
    def PHIDGET1048temperature(self,mode=0):
        try:
            if aw.ser.PhidgetTemperatureSensor == None:
                aw.ser.PhidgetTemperatureSensor = PhidgetTemperatureSensor()
                try:
                    aw.ser.PhidgetTemperatureSensor.setOnAttachHandler(self.phidget1048attached)
                    aw.ser.PhidgetTemperatureSensor.setOnDetachHandler(self.phidget1048detached)
                    if aw.qmc.phidgetRemoteFlag:
                        aw.ser.PhidgetTemperatureSensor.openRemote(aw.qmc.phidgetServerID,password=aw.qmc.phidgetPassword)
                    else:
                        aw.ser.PhidgetTemperatureSensor.openPhidget()
                except Exception as ex:
                    #_, _, exc_tb = sys.exc_info()
                    #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1048temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
                    aw.ser.PhidgetBridgeSensorAttached = False
                    try:
                        aw.ser.PhidgetTemperatureSensor.closePhidget()
                    except:
                        pass
                    aw.ser.PhidgetTemperatureSensor = None
            if aw.ser.PhidgetTemperatureSensorAttached:
                if mode == 0:
                    probe1 = probe2 = -1
                    try:
                        probe1 = self.phidget1048getSensorReading(0)
                        if aw.qmc.mode == "F":
                            probe1 = aw.qmc.fromCtoF(probe1)
                    except:
                        pass
                    try:
                        probe2 = self.phidget1048getSensorReading(1)
                        if aw.qmc.mode == "F":
                            probe2 = aw.qmc.fromCtoF(probe2)
                    except:
                        pass
                    return probe1, probe2
                elif mode == 1:
                    probe3 = probe4 = -1
                    try:
                        probe3 = self.phidget1048getSensorReading(2)
                        if aw.qmc.mode == "F":
                            probe3 = aw.qmc.fromCtoF(probe3)
                    except:
                        pass
                    try:
                        probe4 = self.phidget1048getSensorReading(3)
                        if aw.qmc.mode == "F":
                            probe4 = aw.qmc.fromCtoF(probe4)
                    except:
                        pass
                    return probe3, probe4
                elif mode == 2:
                    try:
                        at = aw.ser.PhidgetTemperatureSensor.getAmbientTemperature()
                        if aw.qmc.mode == "F":
                            at = aw.qmc.fromCtoF(at)
                        return at,-1
                    except:
                        return -1,-1
                else:
                    return -1,-1
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                aw.ser.PhidgetTemperatureSensor.closePhidget()
            except:
                pass
            aw.ser.PhidgetTemperatureSensor = None
            aw.ser.PhidgetBridgeSensorAttached = False
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1048temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    # takes a bridge value in mV/V and returns the resistance of the corresponding RTD, assuming the RTD is connected
    # via a Wheatstone Bridge build from 1K ohm resistors
    # http://en.wikipedia.org/wiki/Wheatstone_bridge
    # Note: the 1046 returns the bridge value in mV/V
    def R_RTD_WS(self,bv):
        return (1000 * (1000 - 2 * bv))/(1000 + 2 * bv)
    
    # takes a bridge value in mV/V and returns the resistance of the corresponding RTD, assuming the RTD is connected
    # via a Voltage Divider build from 1K ohm resistors
    # http://en.wikipedia.org/wiki/Voltage_divider
    # Note: the 1046 returns the bridge value in mV/V
    def R_RTD_DIV(self,bv):
        return (2000 * bv) / (1000 - bv)
        
    # this formula results from a direct mathematical linearization of the Callendar-Van Dusen equation
    # see Analog Devices Application Note AN-709 http://www.analog.com/static/imported-files/application_notes/AN709_0.pdf
    # Wikipedia http://en.wikipedia.org/wiki/Resistance_thermometer
    #  or http://www.abmh.de
    def rRTD2PT100temp(self,R_RTD):
        Z1 = -3.9083e-03
        Z2 = 1.76e-05
        Z3 = -2.31e-08
        Z4 = -1.155e-06
        try:
            return (Z1 + math.sqrt(abs(Z2 + (Z3 * R_RTD))))/Z4
        except:
            return -1

    # convert the BridgeValue given by the PhidgetBridge to a temperature value assuming a PT100 probe
    # see http://www.phidgets.com/docs/3175_User_Guide
    # this one is a simpler and less accurate approximation as above that directly gives the temperature for a given bridge value in mV/V,
    # that works only for the Voltage Divider case
#    def bridgeValue2PT100(self,bv):
#        bvf = bv / (1000 - bv)
#        return 4750.3 * bvf * bvf + 4615.6 * bvf - 242.615                

    def phidget1046TemperatureChanged(self,e):
        if aw.qmc.phidget1046_async[e.index]:
            temp = self.bridgeValue2Temperature(e.index,e.value)
            if aw.qmc.mode == "F":
                temp = aw.qmc.fromCtoF(temp)
            aw.ser.Phidget1046values[e.index] = (aw.ser.Phidget1046values[e.index] + temp)/2.0

    def bridgeValue2Temperature(self,i,bv):
        v = -1
        try:
            if aw.qmc.phidget1046_formula[i] == 0:
                v = self.rRTD2PT100temp(self.R_RTD_WS(abs(bv)))  # we add the abs() here to support inverted wirings
            elif aw.qmc.phidget1046_formula[i] == 1:
                v = self.rRTD2PT100temp(self.R_RTD_DIV(abs(bv)))  # we add the abs() here to support inverted wirings
            elif aw.qmc.phidget1046_formula[i] == 2:
                v = bv # no abs() for raw values
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " bridgeValue2Temperature(): %1").arg(str(e)),exc_tb.tb_lineno)            
        return v

    def phidget1046getTemperature(self,i):
        v = -1
        try:
            bv = aw.ser.PhidgetBridgeSensor.getBridgeValue(i)
            
# test values for the bridge value to temperature conversion
#            bv = 51.77844 # about room temperature for Voltage Divider wiring
#            bv = 400.2949 # about room temperature for Wheatstone Bridge

            v = self.bridgeValue2Temperature(i,bv)
            if aw.qmc.mode == "F" and aw.qmc.phidget1046_formula[i] != 2:
                v = aw.qmc.fromCtoF(v)
        except:
            v = -1
        return v
                        
    def phidget1046getSensorReading(self,i):
        if aw.qmc.phidget1046_async[i]:
            if aw.ser.Phidget1046values[i] == -1:
                aw.ser.Phidget1046values[i] = self.phidget1046getTemperature(i)               
            return aw.ser.Phidget1046values[i]
        else:
            return self.phidget1046getTemperature(i)
            
            
    def configure1046(self):
        # reset async values
        aw.ser.Phidget1046values = [-1]*4
        # set gain
        for i in range(4):
            try:
                aw.ser.PhidgetBridgeSensor.setGain(i, aw.qmc.phidget1046_gain[i])
            except:
                pass
        # set rate
        try:
            aw.ser.PhidgetBridgeSensor.setDataRate(aw.qmc.phidget1046_dataRate)
        except:
            pass
        try:
            aw.ser.PhidgetBridgeSensor.setEnabled(0, True)
            aw.ser.PhidgetBridgeSensor.setEnabled(1, True)
        except:
            pass
        try:
            if 38 in aw.qmc.extradevices:
                aw.ser.PhidgetBridgeSensor.setEnabled(2, True)
                aw.ser.PhidgetBridgeSensor.setEnabled(3, True)
        except:
            pass
        if aw.qmc.phidget1046_async[0] or aw.qmc.phidget1046_async[1] or (38 in aw.qmc.extradevices and (aw.qmc.phidget1046_async[2] or aw.qmc.phidget1046_async[3])):
            aw.ser.PhidgetBridgeSensor.setOnBridgeDataHandler(lambda e=None:self.phidget1046TemperatureChanged(e))
        else:
            aw.ser.PhidgetBridgeSensor.setOnBridgeDataHandler(None)

    def phidget1046attached(self,e):
        self.configure1046()
        aw.sendmessage(QApplication.translate("Message","Phidget Bridge 4-input attached",None, QApplication.UnicodeUTF8))
        aw.ser.PhidgetBridgeSensorAttached = True
        
    def phidget1046detached(self,e):
        aw.sendmessage(QApplication.translate("Message","Phidget Bridge 4-input detached",None, QApplication.UnicodeUTF8))
        aw.ser.PhidgetBridgeSensorAttached = False

    # mode = 0 for probe 1 and 2; mode = 1 for probe 3 and 4; mode 2 for Ambient Temperature
    def PHIDGET1046temperature(self,mode=0):
        try:
            if aw.ser.PhidgetBridgeSensor == None:
                aw.ser.PhidgetBridgeSensor = Phidget1046TemperatureSensor()
                try: 
                    aw.ser.PhidgetBridgeSensor.setOnAttachHandler(self.phidget1046attached)
                    aw.ser.PhidgetBridgeSensor.setOnDetachHandler(self.phidget1046detached)
                    if aw.qmc.phidgetRemoteFlag:
                        aw.ser.PhidgetBridgeSensor.openRemote(aw.qmc.phidgetServerID,password=aw.qmc.phidgetPassword)
                    else:
                        aw.ser.PhidgetBridgeSensor.openPhidget()
                except Exception as ex:
                    #_, _, exc_tb = sys.exc_info()
                    #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1046temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
                    aw.ser.PhidgetBridgeSensorAttached = False
                    try:
                        aw.ser.PhidgetBridgeSensor.closePhidget()
                    except:
                        pass
                    aw.ser.PhidgetBridgeSensor = None
            if aw.ser.PhidgetBridgeSensorAttached:
                if mode == 0:
                    probe1 = probe2 = -1
                    try:
                        probe1 = self.phidget1046getSensorReading(0)
                    except:
                        pass
                    try:
                        probe2 = self.phidget1046getSensorReading(1)
                    except:
                        pass
                    return probe1, probe2
                elif mode == 1:
                    probe3 = probe4 = -1
                    try:
                        probe3 = self.phidget1046getSensorReading(2)
                    except:
                        pass
                    try:
                        probe4 = self.phidget1046getSensorReading(3)
                    except:
                        pass
                    return probe3, probe4
                else:
                    return -1,-1
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                aw.ser.PhidgetBridgeSensor.closePhidget()
            except:
                pass
            aw.ser.Phidget1046values = [-1]*4
            aw.ser.PhidgetBridgeSensor = None
            aw.ser.PhidgetBridgeSensorAttached = False
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1046temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    def phidget1018SensorChanged(self,e):
        if aw.qmc.phidget1018_async[e.index]:
            aw.ser.PhidgetIOvalues[e.index] = (aw.ser.PhidgetIOvalues[e.index] + e.value)/2.0

    def phidget1018getSensorReading(self,i):
        if aw.qmc.phidget1018_raws[i]:
            return aw.ser.PhidgetIO.getSensorRawValue(i)
        else:
            if aw.qmc.phidget1018_async[i]:            
                if aw.ser.PhidgetIOvalues[i] == -1:
                    aw.ser.PhidgetIOvalues[i] = aw.ser.PhidgetIO.getSensorValue(i)
                return aw.ser.PhidgetIOvalues[i]
            else:
                return aw.ser.PhidgetIO.getSensorValue(i)
                
    def configure1018(self):
        # set data rates of all active inputs to 4ms
        aw.ser.PhidgetIOvalues = [-1]*8
        aw.ser.PhidgetIO.setRatiometric(aw.qmc.phidget1018Ratiometric)
        changeTrigger = False
        for i in range(max(3,aw.ser.PhidgetIO.getSensorCount())):
            try:
                # DataRate=8 => 8ms (the default and minimum for USB connections)
                # DataRate=16 => 16ms (the minimium over SBC/Wireless)
                # DataRate=512 => 0.5s
                # DataRate=1024 => 1s
                # DataRate=1504 => 1.5s
                aw.ser.PhidgetIO.setSensorChangeTrigger(i,1000) # "deactivate" triggers for non async channels
                if i < 2 or (i < 4 and 41 in aw.qmc.extradevices) or (i < 6 and 42 in aw.qmc.extradevices) or (i < 8 and 43 in aw.qmc.extradevices):
                    if not aw.qmc.phidget1018_raws[i] and aw.qmc.phidget1018_async[i]:
                        changeTrigger = True
                        aw.ser.PhidgetIO.setSensorChangeTrigger(i,aw.qmc.phidget1018_changeTriggers[i]) # force fixed data rate if 0 (default 10)
                        aw.ser.PhidgetIO.setDataRate(i, aw.qmc.phidget1018_dataRates[i])
            except:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                pass
        if changeTrigger:
            aw.ser.PhidgetIO.setOnSensorChangeHandler(lambda e=None:self.phidget1018SensorChanged(e))
        else:
            aw.ser.PhidgetIO.setOnSensorChangeHandler(None)
                
    def phidget1018attached(self,e):
        self.configure1018()
        aw.sendmessage(QApplication.translate("Message","Phidget 1018 IO attached",None, QApplication.UnicodeUTF8))
        aw.ser.PhidgetIOAttached = True
        
    def phidget1018detached(self,e):
        aw.sendmessage(QApplication.translate("Message","Phidget 1018 IO detached",None, QApplication.UnicodeUTF8))
        aw.ser.PhidgetIOAttached = False

    # mode = 0 for probe 1 and 2; mode = 1 for probe 3 and 4; mode 2 for probe 5 and 6; mode 3 for probe 7 and 8
    def PHIDGET1018values(self,mode=0):
        try:
            if aw.ser.PhidgetIO == None:
                aw.ser.PhidgetIO = Phidget1018IO()
                try: 
                    aw.ser.PhidgetIO.setOnAttachHandler(self.phidget1018attached)
                    aw.ser.PhidgetIO.setOnDetachHandler(self.phidget1018detached)
                    if aw.qmc.phidgetRemoteFlag:
                        aw.ser.PhidgetIO.openRemote(aw.qmc.phidgetServerID,password=aw.qmc.phidgetPassword)
                    else:
                        aw.ser.PhidgetIO.openPhidget()
                except Exception as ex:
                    #_, _, exc_tb = sys.exc_info()
                    #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1018values() %1").arg(str(ex)),exc_tb.tb_lineno)
                    aw.ser.PhidgetIOAttached = False
                    try:
                        aw.ser.PhidgetIO.closePhidget()
                    except:
                        pass
                    aw.ser.PhidgetIO = None
            if aw.ser.PhidgetIOAttached:
                sensorCount = aw.ser.PhidgetIO.getSensorCount()
                if mode == 0:
                    probe1 = probe2 = -1
                    try:
                        if sensorCount > 0:
                            probe1 = self.phidget1018getSensorReading(0)
                    except:
                        pass
                    try:
                        if sensorCount > 1:
                            probe2 = self.phidget1018getSensorReading(1)
                    except:
                        pass
                    return probe1, probe2
                elif mode == 1:
                    probe3 = probe4 = -1
                    try:
                        if sensorCount > 3:
                            probe3 = self.phidget1018getSensorReading(2)
                    except:
                        pass
                    try:
                        if sensorCount > 4:
                            probe4 = self.phidget1018getSensorReading(3)
                    except:
                        pass
                    return probe3, probe4
                elif mode == 2:
                    probe5 = probe6 = -1
                    try:
                        if sensorCount > 5:
                            probe5 = self.phidget1018getSensorReading(4)
                    except:
                        pass
                    try:
                        if sensorCount > 6:
                            probe6 = self.phidget1018getSensorReading(5)
                    except:
                        pass
                    return probe5, probe6
                elif mode == 3:
                    probe7 = probe8 = -1
                    try:
                        if sensorCount > 7:
                            probe7 = self.phidget1018getSensorReading(6)
                    except:
                        pass
                    try:
                        if sensorCount > 8:
                            probe8 = self.phidget1018getSensorReading(7)
                    except:
                        pass
                    return probe7, probe8
                else:
                    return -1,-1
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            aw.ser.PhidgetIOAttached = False
            try:
                aw.ser.PhidgetIO.closePhidget()
            except:
                pass
            aw.ser.PhidgetIO = None
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PHIDGET1018values() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    # mode = 0 for 2x thermocuple model; mode = 1 for 1x PT100 type probe
    def YOCTOtemperatures(self,mode=0):
        try: 
            if self.YOCTOsensor == None:
                errmsg=YRefParam()
                ## WINDOWS/Linux DLL HACK BEGIN
                if platf == 'Windows' and aw.appFrozen():
                    if platform.architecture()[0] == '32bit':
                        YAPI._yApiCLibFile = os.path.dirname(sys.executable) + "\\lib\\yapi.dll"
                    else:
                        YAPI._yApiCLibFile = os.path.dirname(sys.executable) + "\\lib\\yapi-amd64.dll"
                elif platf == "Linux" and aw.appFrozen():
                    if platform.architecture()[0] == '32bit':
                        YAPI._yApiCLibFile = u(QApplication.applicationDirPath() + "/libyapi-i386.so")
                    else:                    
                        YAPI._yApiCLibFile = u(QApplication.applicationDirPath() + "/libyapi-amd64.so")
                ## WINDOWS/Linux DLL HACK END
                # alt: PreregisterHub( )
                if YAPI.RegisterHub("usb", errmsg) == YAPI.SUCCESS:
                    self.YOCTOsensor = YTemperature.FirstTemperature()
                    if mode == 0 and self.YOCTOsensor != None and self.YOCTOsensor.isOnline():
                        serial=self.YOCTOsensor.get_module().get_serialNumber()
                        self.YOCTOchan1 = YTemperature.FindTemperature(serial + '.temperature1')
                        self.YOCTOchan2 = YTemperature.FindTemperature(serial + '.temperature2')
                        aw.sendmessage(QApplication.translate("Message","Yocto Thermocouple attached",None, QApplication.UnicodeUTF8))                       
                    elif mode == 1 and self.YOCTOsensor != None and self.YOCTOsensor.isOnline():
                        aw.sendmessage(QApplication.translate("Message","Yocto PT100 attached",None, QApplication.UnicodeUTF8))                       
            probe1 = -1
            probe2 = -1
            if mode == 0:
                try:
                    if self.YOCTOchan1 and self.YOCTOchan1.isOnline():
                        probe1 = self.YOCTOchan1.get_currentValue()
                except:
                    pass
                try:
                    if self.YOCTOchan2 and self.YOCTOchan2.isOnline():
                        probe2 = self.YOCTOchan2.get_currentValue()
                except:
                    pass
            elif mode == 1:
                try:
                    if self.YOCTOsensor and self.YOCTOsensor.isOnline():
                        probe1 = self.YOCTOsensor.get_currentValue()
                except:
                    pass
            return probe1, probe2
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                YAPI.UnregisterHub("usb")
            except:
                pass
            self.YOCTOsensor = None
            self.YOCTOchan1 = None
            self.YOCTOchan2 = None
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " YOCTOtemperatures() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1


    def ARDUINOTC4temperature(self):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            command = ""
            res = ""
            result = ""
            t1,t2 = 0.,0.
            if not self.SP.isOpen():
                self.openport()
                libtime.sleep(2)
                #Reinitialize Arduino in case communication was interupted
                self.ArduinoIsInitialized = 0
            if self.SP.isOpen():
                #INITIALIZE (ONLY ONCE)
                if not self.ArduinoIsInitialized:
                    self.SP.flushInput()
                    self.SP.flushOutput()
                    #build initialization command 
                    et_channel = self.arduinoETChannel
                    if et_channel == "None":
                        et_channel = "0"
                    bt_channel = self.arduinoBTChannel
                    if bt_channel == "None":
                        bt_channel = "0"
                    #If extra device +ArduinoTC4_XX present. read all 4 Ts
                    if 28 in aw.qmc.extradevices: # +ArduinoTC4_34
                        vals = ["1","2","3","4"]
                        vals.pop(vals.index(self.arduinoETChannel))
                        vals.pop(vals.index(self.arduinoBTChannel))
                        command = "CHAN;" + et_channel + bt_channel + vals[0] + vals[1]
                    else:
                    #no extra device +ArduinoTC4_XX present. reads ambient T, ET, BT
                        command = "CHAN;" + et_channel + bt_channel + "00"
#                    if aw.qmc.extradevices in [32,44]: # +ArduinoTC4_56 or +ArduinoTC4_78
#                        self.SP.write(str2cmd("PID;XON" + "\n"))       #activate extra PID OT1/OT2 channels
#                    else:
#                        self.SP.write(str2cmd("PID;XOFF" + "\n"))       #activate extra PID OT1/OT2 channels
                    #self.SP.flush()
                    libtime.sleep(0.3)
                    self.SP.write(str2cmd(command + "\n"))       #send command
                    #self.SP.flush()
                    libtime.sleep(.1)
                    result = self.SP.readline().decode('utf-8')[:-2]  #read
                    if (not len(result) == 0 and not result.startswith("#")):
                        raise Exception(QApplication.translate("Error Message","Arduino could not set channels",None, QApplication.UnicodeUTF8))
                    elif result.startswith("#"):
                        #OK. NOW SET UNITS
                        self.SP.flushInput()
                        self.SP.flushOutput()
                        command = "UNITS;" + aw.qmc.mode + "\n"   #Set units
                        self.SP.write(str2cmd(command))
                        #self.SP.flush()
                        libtime.sleep(.1)
                        result = self.SP.readline().decode('utf-8')[:-2]
                        if (not len(result) == 0 and not result.startswith("#")):
                            raise Exception(QApplication.translate("Error Message","Arduino could not set temperature unit",None, QApplication.UnicodeUTF8))
                        else:
                            #OK. NOW SET FILTER
                            self.SP.flushInput()
                            self.SP.flushOutput()
                            filt =  ",".join(map(str,aw.ser.ArduinoFILT))
                            command = "FILT;" + filt + "\n"   #Set filters
                            self.SP.write(str2cmd(command))
                            #self.SP.flush()
                            libtime.sleep(.1)
                            result = self.SP.readline().decode('utf-8')[:-2]
                            if (not len(result) == 0 and not result.startswith("#")):
                                raise Exception(QApplication.translate("Error Message","Arduino could not set filters",None, QApplication.UnicodeUTF8))
                            else:
                                ### EVERYTHING OK  ###
                                self.ArduinoIsInitialized = 1
                #READ TEMPERATURE
                command = "READ\n"  #Read command.
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(str2cmd(command))
                #self.SP.flush()
                libtime.sleep(.1)
                rl = self.SP.readline().decode('utf-8')[:-2]
                res = rl.rsplit(',')  #response: list ["t0","t1","t2"] with t0 = internal temp; t1 = ET; t2 = BT
                if self.arduinoETChannel == "None":
                    t1 = -1
                else:
                    t1 = float(res[1])
                if self.arduinoBTChannel == "None":
                    t2 = -1
                else:
                    t2 = float(res[2])
                #if extra device +ArduinoTC4_34 or +ArduinoTC4_56, but not both
                if 28 in aw.qmc.extradevices or (32 in aw.qmc.extradevices and not 28 in aw.qmc.extradevices):
                    #set the other values to extra temp variables
                    aw.qmc.extraArduinoT1 = float(res[3])
                    aw.qmc.extraArduinoT2 = float(res[4])
                if 28 in aw.qmc.extradevices and 32 in aw.qmc.extradevices: # +ArduinoTC4_34 and +ArduinoTC4_56
                    try:
                        aw.qmc.extraArduinoT3 = float(res[5])
                        aw.qmc.extraArduinoT4 = float(res[6])
                    except:
                        aw.qmc.extraArduinoT3 = 0
                        aw.qmc.extraArduinoT4 = 0
                else:
                    aw.qmc.extraArduinoT3 = aw.qmc.extraArduinoT4 = -1                
                if 44 in aw.qmc.extradevices: # +ArduinoTC4_78
                    # report SV as extraArduinoT5
                    try:
                        aw.qmc.extraArduinoT5 = float(res[7])
                    except:
                        aw.qmc.extraArduinoT5 = 0
                    # report Ambient Temperature as extraArduinoT6
                    try:
                        aw.qmc.extraArduinoT6 = float(res[0])
                    except:
                        aw.qmc.extraArduinoT6 = 0
                # overwrite temps by AT internal Ambient Temperature
                if aw.ser.arduinoATChannel != "None":
                    if aw.ser.arduinoATChannel == "T1":
                        t1 = float(res[0])
                    elif aw.ser.arduinoATChannel == "T2":
                        t2 = float(res[0])
                    elif (28 in aw.qmc.extradevices or (32 in aw.qmc.extradevices and not 28 in aw.qmc.extradevices)) and aw.ser.arduinoATChannel == "T3":
                        aw.qmc.extraArduinoT1 = float(res[0])
                    elif (28 in aw.qmc.extradevices or (32 in aw.qmc.extradevices and not 28 in aw.qmc.extradevices)) and aw.ser.arduinoATChannel == "T4":
                        aw.qmc.extraArduinoT2 = float(res[0])
                    elif (28 in aw.qmc.extradevices and 32 in aw.qmc.extradevices) and aw.ser.arduinoATChannel == "T5":
                        aw.qmc.extraArduinoT3 = float(res[0])
                    elif (28 in aw.qmc.extradevices and 32 in aw.qmc.extradevices) and aw.ser.arduinoATChannel == "T6":
                        aw.qmc.extraArduinoT4 = float(res[0])
                return t1, t2
        except serial.SerialException as e:
            #self.closeport() # closing the port on error is to serve as the Arduino needs time to restart and has to be reinitialized!
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.ARDUINOTC4temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error + " " + str(aw.qmc.samplingsemaphore.available()) + " " + str(e),exc_tb.tb_lineno)
            return -1.,-1.
        except Exception as e:
            # self.closeport() # closing the port on error is to serve as the Arduino needs time to restart and has to be reinitialized!
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " ser.ARDUINOTC4temperature(): %1").arg(str(e)),exc_tb.tb_lineno)
            return -1.,-1.
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("ArduinoTC4 :" + settings + " || Tx = " + str(command) + " || Rx = " + str(res) + "|| Ts= %.2f, %.2f, %.2f, %.2f, %.2f, %.2f"%(t1,t2,aw.qmc.extraArduinoT1,aw.qmc.extraArduinoT2,aw.qmc.extraArduinoT3,aw.qmc.extraArduinoT4))

    def TEVA18Bconvert(self, seg):
        if seg == 0x7D:
            return 0
        elif seg == 0x05:
            return 1
        elif seg == 0x5B:
            return 2
        elif seg == 0x1F:
            return 3
        elif seg == 0x27:
            return 4
        elif seg == 0x3E:
            return 5
        elif seg == 0x7E:
            return 6
        elif seg == 0x15:
            return 7
        elif seg == 0x7F:
            return 8
        elif seg == 0x3F:
            return 9
        else:
            return -1

    def TEVA18Btemperature(self):
        try:
            r = ""
            run = 1
            counter = 0
            while(run):
                
                #MaWa
                #really interesting:
                #need this sleep. without artisan hungs after 20 to 40 seconds.
                #seems like iam running the loop forever, forever .... with sleep it is ok
                #seen this sometimes in communication between threads in C or C++. --> volatile problem?
                if counter > 0:
                    libtime.sleep(1)
                counter = counter + 1
                if not self.SP.isOpen():
                    self.openport()    
                    libtime.sleep(2)
                if self.SP.isOpen():
                    self.SP.flushInput()
                    r = self.SP.read(14)
                    if len(r) != 14:
                        continue
#                    s200 = binascii.hexlify(r[0])
                    s201 = binascii.hexlify(r[1])
                    s202 = binascii.hexlify(r[2])
                    s203 = binascii.hexlify(r[3])
                    s204 = binascii.hexlify(r[4])
                    s205 = binascii.hexlify(r[5])
                    s206 = binascii.hexlify(r[6])
                    s207 = binascii.hexlify(r[7])
                    s208 = binascii.hexlify(r[8])
    #                s209 = binascii.hexlify(r[9])
    #                s210 = binascii.hexlify(r[10])
    #                s211 = binascii.hexlify(r[11])
    #                s212 = binascii.hexlify(r[12])
                    s213 = binascii.hexlify(r[13])
#                   t200 = int(s200,16)
                    t201 = int(s201,16)
                    t202 = int(s202,16)
                    t203 = int(s203,16)
                    t204 = int(s204,16)
                    t205 = int(s205,16)
                    t206 = int(s206,16)
                    t207 = int(s207,16)
                    t208 = int(s208,16)
    #                t209 = int(s209,16)
    #                t210 = int(s210,16)
    #                t211 = int(s211,16)
    #                t212 = int(s212,16)
                    t213 = int(s213,16)
                    # is meter in temp mode?
                    # first check byte order
                    if(((t213 & 0xf0) >> 4) != 14):
                        #ERROR try again .....
                        continue
                    elif(((t213 & 0x0f) & 0x02) != 2):
                        #ERROR
                        # device seems not to be in temp mode, break here
                        raise ValueError
                    # convert
                    bNegative = 0
                    iDivisor = 0
                    # first lets check the byte order
                    # seg1 bytes
                    if (((t201 & 0xf0) >> 4) == 2) and (((t202 & 0xf0) >> 4) == 3):
                        seg1 = ((t201 & 0x0f) << 4) + (t202 & 0x0f)
                    else:
                        continue
                    # seg2 bytes
                    if (((t203 & 0xf0) >> 4) == 4) and (((t204 & 0xf0) >> 4) == 5):
                        seg2 = ((t203 & 0x0f) << 4) + (t204 & 0x0f)
                    else:
                        continue
                    # seg3 bytes
                    if (((t205 & 0xf0) >> 4) == 6) and (((t206 & 0xf0) >> 4) == 7):
                        seg3 = ((t205 & 0x0f) << 4) + (t206 & 0x0f)
                    else:
                        continue
                    # seg4 bytes
                    if (((t207 & 0xf0) >> 4) == 8) and (((t208 & 0xf0) >> 4) == 9):
                        seg4 = ((t207 & 0x0f) << 4) + (t208 & 0x0f)
                    else:
                        continue
                    # is negative?
                    if (seg1 & 0x80):
                        bNegative = 1
                        seg1 = seg1 & ~0x80
                    # check divisor
                    if (seg2 & 0x80):
                        iDivisor = 1000.
                        seg2 = seg2 & ~0x80
                    elif (seg3 & 0x80):
                        iDivisor = 100.
                        seg3 = seg3 & ~0x80
                    elif (seg4 & 0x80):
                        iDivisor = 10.
                        seg4 = seg4 & ~0x80
                    iValue = 0
                    fReturn = 0
                    i = self.TEVA18Bconvert(seg1)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = i * 1000
                    i = self.TEVA18Bconvert(seg2)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + (i * 100)
                    i = self.TEVA18Bconvert(seg3)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + (i * 10)
                    i = self.TEVA18Bconvert(seg4)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + i
                    # what about the divisor?
                    if (iDivisor > 0):
                        fReturn = iValue / iDivisor
                    # is value negative?
                    if (fReturn):
                        if (bNegative):
                            fReturn = fReturn * (-1)
                    #ok seems we got valid value
                    # break loop here
                    run = 0
            #Since the meter reads only one temperature, send 0 as ET and fReturn as BT
            if fReturn:
                return 0.,fReturn    #  **** RETURN T HERE  ******
            else:
                raise ValueError
        except ValueError:
            #self.closeport()
            error = QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " ser.TEVA18Btemperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1 
        except serial.SerialException:
            #self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.TEVA18Btemperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1 
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.TEVA18Btemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("TEVA18B :" + settings + " || Tx = " + "No command" + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def HHM28multimeter(self):
        # This meter sends a continuos frame byte by byte. It only transmits data. It does not receive commands.
        # A frame is composed of 14 ordered bytes. A byte is represented bellow enclosed in "XX"
        # FRAME  = ["1A","2B","3C","4D","5E","6F","7G","8H","9I","10J","11K","12L","13M","14N"]
        # The first 4 bits of each byte are dedicated to identify the byte in the frame by using a number.
        # The last 4 bits of each byte are dedicated to carry Data. Depending on the byte number, the meaning of data changes.
        # Bytes 2,3,4,5,6,7,8,9 carry data bits that represent actual segments of the four LCD numbers of the meter display.
        # Bytes 1,10,11,12,13 carry data bits that represent other symbols like F (for Farad), u (for micro), M (for Mega), etc, of the meter display
        try:
            r, r2 = "",""
            frame = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
            #keep reading till the first byte of next frame (till we read an actual 1 in 1A )
            for i in range(28):  #any number > 14 will be OK
                r = self.SP.read(1)
                if r:
                    fb = (ord(r[0]) & 0xf0) >> 4
                    if fb == 1:
                        r2 = self.SP.read(13)   #read the remaining 13 bytes to get 14 bytes
                        break
                else:
                    raise ValueError(str("No Data received"))
##                if (ord(r[0]) & 0xf0) >> 4 == 1:
##                    r2 = self.SP.read(13)   #read the remaining 13 bytes to get 14 bytes
##                    break
            frame = r + r2
            #check bytes
            for i in range(14):
                number = fb = (ord(frame[i]) & 0xf0) >> 4
                if number != i+1:
                    #find device index
                    raise ValueError(str("Data corruption"))
            if len(frame) == 14:
                #extract data from frame in to a list containing the hex string values of the data
                data = []
                for i in range(14):
                    data.append(hex((ord(frame[i]) & 0x0f))[2:])
                #The four LCD digits are BC + DE + FG + HI   
                digits = [data[1]+data[2],data[3]+data[4],data[5]+data[6],data[7]+data[8]]
                #find sign 
                sign = ""   # +
                if (int(digits[0],16) & 0x80) >> 7:
                    sign = "-"
                #find location of decimal point
                for i in range(4):
                    if (int(digits[i],16) & 0x80) >> 7:
                        dec = i
                        digits[i] = hex(int(digits[i],16) & 0x7f)[2:]  #remove decimal point
                        if len(digits[i]) < 2:
                            digits[i] = "0" + digits[i]
                #find value from table
                table = {"00":" ","68":"L","7d":"0","05":"1","5b":"2","1f":"3",
                         "27":"4","3e":"5","7e":"6","15":"7","7f":"8","3f":"9"} 
                val = ""
                #some erros found in values: "38","5d",0A,etc
                for i in range(4):
                    if digits[i] in table:
                        val += table[digits[i]]
                    else:
                        raise ValueError(str("Data corruption"))
                number = ".".join((val[:dec],val[dec:]))  #add the decimal point
                #find symbols
                tablesymbols = [
                                ["AC","","",""],    #["AC","","Auto","RS232"]
                                ["u","n","k","diode"],
                                ["m","%","M","Beep"],
                                ["F","Ohm","Relative","Hold"],
                                ["A","V","Hz","Low Batt"]
                                ]
                masks = [0x08,0x04,0x02,0x01]
                nbytes = [0,9,10,11,12]
                symbols = ""
                for p in range(5):
                    for i in range(4):
                        if (int(data[nbytes[p]],16) & masks[i]):
                            symbols += " " + tablesymbols[p][i]
                return (sign + number), symbols
            else:
                raise ValueError(str("Needed 14 bytes but only received %i"%(len(frame))))
        except ValueError:
            #self.closeport()
            error  = QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " ser.HHM28multimeter()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            #find device index
            if aw.qmc.device == 23:
                if len(aw.qmc.temp1):
                    return str(aw.qmc.temp1[-1]),str(aw.qmc.temp2[-1])
                else:
                    return "0","0"
            else:
                index = aw.qmc.extradevices.index(23)
                if len(aw.qmc.extratemp1[i]):
                    return str(aw.qmc.extratemp1[index][-1]),str(aw.qmc.temp2[index][-1])
                else:
                    return "0","0"
        except serial.SerialException:
            #self.closeport()
            error  = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HHM28multimeter()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return "0",""
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HHM28multimeter() %1").arg(str(ex)),exc_tb.tb_lineno)
            return "0"""
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("HHM28multimeter :" + settings + " || Tx = " + "No command" + " || Rx = " + str(frame))

    #sends a command to the ET/BT device. (used by eventaction to send serial command to e.g. Arduino)
    def sendTXcommand(self,command):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
                libtime.sleep(2)
                #Reinitialize Arduino in case communication was interrupted
                if aw.qmc.device == 19:
                    self.ArduinoIsInitialized = 0
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                if (aw.qmc.device == 19 and not command.endswith("\n")):
                    command += "\n"
                self.SP.write(str2cmd(command))
                #self.SP.flush()
        except serial.SerialException as e:
            #self.closeport() # do not close the serial port as reopening might take too long
            error  = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXcommand()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error + " " + str(aw.qmc.samplingsemaphore.available()) + " " + str(e),exc_tb.tb_lineno)
        except Exception as ex:
            #self.closeport() # do not close the serial port as reopening might take too long
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXcommand() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)        
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("Serial Ccommand :" + settings + " || Tx = " + command + " || Rx = " + "No answer needed")

    #Example function
    #NOT USED YET, maybe FUTURE Arduino?
    #sends a command to the ET/BT device and receives data of length nbytes
#    def sendTXRXcommand(self,command,nbytes):
#        try:
#            self.SP.write(str2cmd(command))
#            r = self.SP.read(nbytes)
#            if len(r) == nbytes:
#                return r
#            else:
#                return "ERR"
#        except serial.SerialException:
#            self.closeport()
#            error  = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXRXcommand()"
#            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
#        except Exception as ex:
#            self.closeport()
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXRXcommand() %1").arg(str(ex)),exc_tb.tb_lineno)
#        finally:
#            #note: logged chars should not be binary
#            if aw.seriallogflag:
#                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
#                aw.addserial("FutureArduinocommand :" + settings + " || Tx = " + command + " || Rx = " + "No answer needed")

#########################################################################
#############  DESIGNER CONFIG DIALOG ###################################
#########################################################################

class designerconfigDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(designerconfigDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Designer Config",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        #landmarks
        charge = QLabel(QApplication.translate("Label", "CHARGE",None, QApplication.UnicodeUTF8))
        charge.setAlignment(Qt.AlignRight)
        charge.setStyleSheet("background-color: #f07800")
        self.dryend = QCheckBox(QApplication.translate("CheckBox","DRY END",None, QApplication.UnicodeUTF8))
        self.dryend.setStyleSheet("background-color: orange")
        self.fcs = QCheckBox(QApplication.translate("CheckBox","FC START",None, QApplication.UnicodeUTF8))
        self.fcs.setStyleSheet("background-color: orange")
        self.fce = QCheckBox(QApplication.translate("CheckBox","FC END",None, QApplication.UnicodeUTF8))
        self.fce.setStyleSheet("background-color: orange")
        self.scs = QCheckBox(QApplication.translate("CheckBox","SC START",None, QApplication.UnicodeUTF8))
        self.scs.setStyleSheet("background-color: orange")
        self.sce = QCheckBox(QApplication.translate("CheckBox","SC END",None, QApplication.UnicodeUTF8))
        self.sce.setStyleSheet("background-color: orange")
        drop = QLabel(QApplication.translate("Label", "DROP",None, QApplication.UnicodeUTF8))
        drop.setAlignment(Qt.AlignRight)
        drop.setStyleSheet("background-color: #f07800")
        self.loadconfigflags()
        self.connect(self.dryend, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,1))
        self.connect(self.fcs, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,2))
        self.connect(self.fce, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,3))
        self.connect(self.scs, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,4))
        self.connect(self.sce, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,5))
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        markersettinglabel = QLabel(QApplication.translate("Label", "Marker",None, QApplication.UnicodeUTF8))
        markersettinglabel.setAlignment(Qt.AlignCenter)
        timesettinglabel = QLabel(QApplication.translate("Label", "Time",None, QApplication.UnicodeUTF8))
        timesettinglabel.setAlignment(Qt.AlignCenter)
        btsettinglabel = QLabel(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8))
        btsettinglabel.setAlignment(Qt.AlignCenter)
        etsettinglabel = QLabel(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8))
        etsettinglabel.setAlignment(Qt.AlignCenter)
        self.Edit0 = QLineEdit(aw.qmc.stringfromseconds(0))
        self.Edit0.setEnabled(False)
        self.Edit0bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[0]])
        self.Edit0et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[0]])
        self.Edit0.setAlignment(Qt.AlignRight)
        self.Edit0bt.setAlignment(Qt.AlignRight)
        self.Edit0et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[1]:
            self.Edit1 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[1]] - start))
            self.Edit1bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[1]])
            self.Edit1et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[1]])
        else:
            self.Edit1 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit1bt = QLineEdit("0.0")
            self.Edit1et = QLineEdit("0.0")
        self.Edit1.setAlignment(Qt.AlignRight)
        self.Edit1bt.setAlignment(Qt.AlignRight)
        self.Edit1et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[2]:
            self.Edit2 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[2]] - start))
            self.Edit2bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[2]])
            self.Edit2et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[2]])
        else:
            self.Edit2 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit2bt = QLineEdit("0.0")
            self.Edit2et = QLineEdit("0.0")
        self.Edit2.setAlignment(Qt.AlignRight)
        self.Edit2bt.setAlignment(Qt.AlignRight)
        self.Edit2et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[3]:
            self.Edit3 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[3]] - start))
            self.Edit3bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[3]])
            self.Edit3et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[3]])
        else:
            self.Edit3 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit3bt = QLineEdit("0.0")
            self.Edit3et = QLineEdit("0.0")
        self.Edit3.setAlignment(Qt.AlignRight)
        self.Edit3bt.setAlignment(Qt.AlignRight)
        self.Edit3et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[4]:
            self.Edit4 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[4]] - start))
            self.Edit4bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[4]])
            self.Edit4et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[4]])
        else:
            self.Edit4 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit4bt = QLineEdit("0.0")
            self.Edit4et = QLineEdit("0.0")
        self.Edit4.setAlignment(Qt.AlignRight)
        self.Edit4bt.setAlignment(Qt.AlignRight)
        self.Edit4et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[5]:
            self.Edit5 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[5]] - start))
            self.Edit5bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[5]])
            self.Edit5et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[5]])
        else:
            self.Edit5 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit5bt = QLineEdit("0.0")
            self.Edit5et = QLineEdit("0.0")
        self.Edit5.setAlignment(Qt.AlignRight)
        self.Edit5bt.setAlignment(Qt.AlignRight)
        self.Edit5et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[6]:
            self.Edit6 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[6]] - start))
            self.Edit6bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[6]])
            self.Edit6et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[6]])
        else:
            self.Edit6 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit6bt = QLineEdit("0.0")
            self.Edit6et = QLineEdit("0.0")
        self.Edit6.setAlignment(Qt.AlignRight)
        self.Edit6bt.setAlignment(Qt.AlignRight)
        self.Edit6et.setAlignment(Qt.AlignRight)
        self.Edit0.setMaximumWidth(50)
        self.Edit1.setMaximumWidth(50)
        self.Edit2.setMaximumWidth(50)
        self.Edit3.setMaximumWidth(50)
        self.Edit4.setMaximumWidth(50)
        self.Edit5.setMaximumWidth(50)
        self.Edit6.setMaximumWidth(50)
        self.Edit0bt.setMaximumWidth(50)
        self.Edit1bt.setMaximumWidth(50)
        self.Edit2bt.setMaximumWidth(50)
        self.Edit3bt.setMaximumWidth(50)
        self.Edit4bt.setMaximumWidth(50)
        self.Edit5bt.setMaximumWidth(50)
        self.Edit6bt.setMaximumWidth(50)
        self.Edit0et.setMaximumWidth(50)
        self.Edit1et.setMaximumWidth(50)
        self.Edit2et.setMaximumWidth(50)
        self.Edit3et.setMaximumWidth(50)
        self.Edit4et.setMaximumWidth(50)
        self.Edit5et.setMaximumWidth(50)
        self.Edit6et.setMaximumWidth(50)
        self.Edit1copy = self.Edit1.text()
        self.Edit2copy = self.Edit2.text()
        self.Edit3copy = self.Edit3.text()
        self.Edit4copy = self.Edit4.text()
        self.Edit5copy = self.Edit5.text()
        self.Edit6copy = self.Edit6.text()
        self.Edit0btcopy = self.Edit0bt.text()
        self.Edit1btcopy = self.Edit1bt.text()
        self.Edit2btcopy = self.Edit2bt.text()
        self.Edit3btcopy = self.Edit3bt.text()
        self.Edit4btcopy = self.Edit4bt.text()
        self.Edit5btcopy = self.Edit5bt.text()
        self.Edit6btcopy = self.Edit6bt.text()
        self.Edit0etcopy = self.Edit0et.text()
        self.Edit1etcopy = self.Edit1et.text()
        self.Edit2etcopy = self.Edit2et.text()
        self.Edit3etcopy = self.Edit3et.text()
        self.Edit4etcopy = self.Edit4et.text()
        self.Edit5etcopy = self.Edit5et.text()
        self.Edit6etcopy = self.Edit6et.text()
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.Edit0.setValidator(QRegExpValidator(regextime,self))
        self.Edit1.setValidator(QRegExpValidator(regextime,self))
        self.Edit2.setValidator(QRegExpValidator(regextime,self))
        self.Edit3.setValidator(QRegExpValidator(regextime,self))
        self.Edit4.setValidator(QRegExpValidator(regextime,self))
        self.Edit5.setValidator(QRegExpValidator(regextime,self))
        self.Edit6.setValidator(QRegExpValidator(regextime,self))
        self.Edit0bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit0bt))
        self.Edit1bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit1bt))
        self.Edit2bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit2bt))
        self.Edit3bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit3bt))
        self.Edit4bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit4bt))
        self.Edit5bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit5bt))
        self.Edit6bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit6bt))
        self.Edit0et.setValidator(QDoubleValidator(0., 999., 1, self.Edit0et))
        self.Edit1et.setValidator(QDoubleValidator(0., 999., 1, self.Edit1et))
        self.Edit2et.setValidator(QDoubleValidator(0., 999., 1, self.Edit2et))
        self.Edit3et.setValidator(QDoubleValidator(0., 999., 1, self.Edit3et))
        self.Edit4et.setValidator(QDoubleValidator(0., 999., 1, self.Edit4et))
        self.Edit5et.setValidator(QDoubleValidator(0., 999., 1, self.Edit5et))
        self.Edit6et.setValidator(QDoubleValidator(0., 999., 1, self.Edit6et))
        curvinesslabel = QLabel(QApplication.translate("Label", "Curviness",None, QApplication.UnicodeUTF8))
        etcurviness = QLabel(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8))
        btcurviness = QLabel(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8))
        etcurviness.setAlignment(Qt.AlignRight)
        btcurviness.setAlignment(Qt.AlignRight)
        self.ETsplineComboBox = QComboBox()
        self.ETsplineComboBox.addItems(["1","2","3","4","5"])
        self.ETsplineComboBox.setCurrentIndex(aw.qmc.ETsplinedegree - 1)
        self.connect(self.ETsplineComboBox,SIGNAL("currentIndexChanged(int)"), self.redrawcurviness)
        self.BTsplineComboBox = QComboBox()
        self.BTsplineComboBox.addItems(["1","2","3","4","5"])
        self.BTsplineComboBox.setCurrentIndex(aw.qmc.BTsplinedegree - 1)
        self.connect(self.BTsplineComboBox,SIGNAL("currentIndexChanged(int)"), self.redrawcurviness)
        reproducelabel = QLabel(QApplication.translate("Label", "Events Playback",None, QApplication.UnicodeUTF8))
        self.reproduceComboBox = QComboBox()
        self.reproduceComboBox.addItems(["",
                                         QApplication.translate("ComboBox","DeltaBT",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","DeltaET",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","SV Commands",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","Ramp Commands",None, QApplication.UnicodeUTF8)])
        self.reproduceComboBox.setCurrentIndex(aw.qmc.reproducedesigner)
        self.connect(self.reproduceComboBox,SIGNAL("currentIndexChanged(int)"), self.changereproducemode)
        updateButton = QPushButton(QApplication.translate("Button","Update",None, QApplication.UnicodeUTF8))
        updateButton.setFocusPolicy(Qt.NoFocus)
        self.connect(updateButton, SIGNAL("clicked()"), self.settimes)
        updateButton.setMinimumWidth(100)
        defaultButton = QPushButton(QApplication.translate("Button","Reset",None, QApplication.UnicodeUTF8))
        defaultButton.setFocusPolicy(Qt.NoFocus)
        defaultButton.setMinimumWidth(100)
        self.connect(defaultButton, SIGNAL("clicked()"), self.reset)
        closeButton = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        closeButton.setFocusPolicy(Qt.NoFocus)
        self.connect(closeButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        convertButton = QPushButton(QApplication.translate("Button","Create",None, QApplication.UnicodeUTF8))
        self.connect(convertButton, SIGNAL("clicked()"),self.create)
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(closeButton)
        buttonLayout.addWidget(convertButton)
        marksLayout = QGridLayout()
        marksLayout.addWidget(markersettinglabel,0,0)
        marksLayout.addWidget(timesettinglabel,0,1)
        marksLayout.addWidget(btsettinglabel,0,2)
        marksLayout.addWidget(etsettinglabel,0,3)
        marksLayout.addWidget(charge,1,0)
        marksLayout.addWidget(self.Edit0,1,1)
        marksLayout.addWidget(self.Edit0bt,1,2)
        marksLayout.addWidget(self.Edit0et,1,3)
        marksLayout.addWidget(self.dryend,2,0)
        marksLayout.addWidget(self.Edit1,2,1)
        marksLayout.addWidget(self.Edit1bt,2,2)
        marksLayout.addWidget(self.Edit1et,2,3)
        marksLayout.addWidget(self.fcs,3,0)
        marksLayout.addWidget(self.Edit2,3,1)
        marksLayout.addWidget(self.Edit2bt,3,2)
        marksLayout.addWidget(self.Edit2et,3,3)
        marksLayout.addWidget(self.fce,4,0)
        marksLayout.addWidget(self.Edit3,4,1)
        marksLayout.addWidget(self.Edit3bt,4,2)
        marksLayout.addWidget(self.Edit3et,4,3)
        marksLayout.addWidget(self.scs,5,0)
        marksLayout.addWidget(self.Edit4,5,1)
        marksLayout.addWidget(self.Edit4bt,5,2)
        marksLayout.addWidget(self.Edit4et,5,3)
        marksLayout.addWidget(self.sce,6,0)
        marksLayout.addWidget(self.Edit5,6,1)
        marksLayout.addWidget(self.Edit5bt,6,2)
        marksLayout.addWidget(self.Edit5et,6,3)
        marksLayout.addWidget(drop,7,0)
        marksLayout.addWidget(self.Edit6,7,1)
        marksLayout.addWidget(self.Edit6bt,7,2)
        marksLayout.addWidget(self.Edit6et,7,3)
        updateLayout = QHBoxLayout()
        updateLayout.addWidget(defaultButton)
        updateLayout.addWidget(updateButton)
        settingsLayout = QVBoxLayout()
        settingsLayout.addLayout(marksLayout)
        settingsLayout.addLayout(updateLayout)
        curvinessLayout = QHBoxLayout()
        curvinessLayout.addWidget(curvinesslabel)
        curvinessLayout.addWidget(etcurviness)
        curvinessLayout.addWidget(self.ETsplineComboBox)
        curvinessLayout.addWidget(btcurviness)
        curvinessLayout.addWidget(self.BTsplineComboBox)
        reproduceLayout = QHBoxLayout()
        reproduceLayout.addWidget(reproducelabel)
        reproduceLayout.addWidget(self.reproduceComboBox)
        modLayout = QVBoxLayout()
        modLayout.addLayout(curvinessLayout)
        modLayout.addLayout(reproduceLayout)
        marksGroupLayout = QGroupBox(QApplication.translate("GroupBox","Initial Settings",None, QApplication.UnicodeUTF8))
        marksGroupLayout.setLayout(settingsLayout)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(marksGroupLayout)
        mainLayout.addLayout(modLayout)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def changereproducemode(self):
        aw.qmc.reproducedesigner = self.reproduceComboBox.currentIndex()

    def redrawcurviness(self):
        ETcurviness = int(str(self.ETsplineComboBox.currentText()))
        BTcurviness = int(str(self.BTsplineComboBox.currentText()))
        timepoints = len(aw.qmc.timex)
        if (timepoints - ETcurviness) >= 1:
            aw.qmc.ETsplinedegree = ETcurviness
        else:
            aw.qmc.ETsplinedegree = len(aw.qmc.timex)-1
            self.ETsplineComboBox.setCurrentIndex(aw.qmc.ETsplinedegree-1)
            ms = QApplication.translate("Message","Not enough time points for an ET curviness of %1. Set curviness to %2",None, QApplication.UnicodeUTF8).arg(ETcurviness).arg(aw.qmc.ETsplinedegree)
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),ms)
        if (timepoints - BTcurviness) >= 1:
            aw.qmc.BTsplinedegree = BTcurviness
        else:
            aw.qmc.BTsplinedegree = len(aw.qmc.timex)-1
            self.BTsplineComboBox.setCurrentIndex(aw.qmc.BTsplinedegree-1)
            ms = QApplication.translate("Message","Not enough time points for an BT curviness of %1. Set curviness to %2",None, QApplication.UnicodeUTF8).arg(BTcurviness).arg(aw.qmc.BTsplinedegree)
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),ms)
        aw.qmc.redrawdesigner()

    def settimes(self):
        #check input
        strings = [QApplication.translate("Message","CHARGE",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","DRY END",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","FC START",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","FC END",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","SC START",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","SC END",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","DROP",None, QApplication.UnicodeUTF8)]
        timecheck = self.validatetime()
        if timecheck != 1000:
            st = QApplication.translate("Message","Incorrect time format. Please recheck %1 time",None, QApplication.UnicodeUTF8).arg(strings[timecheck])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),st)
            return 1
        checkvalue = self.validatetimeorder()
        if checkvalue != 1000:
            st = QApplication.translate("Message","Times need to be in ascending order. Please recheck %1 time",None, QApplication.UnicodeUTF8).arg(strings[checkvalue+1])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),st)            
            return 1
        if self.Edit0bt.text() != self.Edit0btcopy:
            aw.qmc.temp2[aw.qmc.timeindex[0]] = float(str(self.Edit0bt.text()))
        if self.Edit0et.text() != self.Edit0etcopy:
            aw.qmc.temp1[aw.qmc.timeindex[0]] = float(str(self.Edit0et.text()))
        if self.dryend.isChecked():
            if self.Edit1.text() != self.Edit1copy:
                if aw.qmc.stringtoseconds(str(self.Edit1.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit1.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[1]] = timez
            if self.Edit1bt.text() != self.Edit1btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[1]] = float(str(self.Edit1bt.text()))
            if self.Edit1et.text() != self.Edit1etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[1]] = float(str(self.Edit1et.text()))
        if self.fcs.isChecked():
            if self.Edit2.text() != self.Edit2copy:
                if aw.qmc.stringtoseconds(str(self.Edit2.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit2.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[2]] = timez
            if self.Edit2bt.text() != self.Edit2btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[2]] = float(str(self.Edit2bt.text()))
            if self.Edit2et.text() != self.Edit2etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[2]] = float(str(self.Edit2et.text()))
        if self.fce.isChecked():
            if self.Edit3.text() != self.Edit3copy:
                if aw.qmc.stringtoseconds(str(self.Edit3.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit3.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[3]] = timez
            if self.Edit3bt.text() != self.Edit3btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[3]] = float(str(self.Edit3bt.text()))
            if self.Edit3et.text() != self.Edit3etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[3]] = float(str(self.Edit3et.text()))
        if self.scs.isChecked():
            if self.Edit4.text() != self.Edit4copy:
                if aw.qmc.stringtoseconds(str(self.Edit4.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit4.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[4]] = timez
            if self.Edit4bt.text() != self.Edit4btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[4]] = float(str(self.Edit4bt.text()))
            if self.Edit4et.text() != self.Edit4etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[4]] = float(str(self.Edit4et.text()))
        if self.sce.isChecked():
            if self.Edit5.text() != self.Edit5copy:
                if aw.qmc.stringtoseconds(str(self.Edit5.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit5.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[5]] = timez
            if self.Edit5bt.text() != self.Edit5btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[5]] = float(str(self.Edit5bt.text()))
            if self.Edit5et.text() != self.Edit5etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[5]] = float(str(self.Edit5et.text()))
        if self.Edit6.text() != self.Edit6copy:
            if aw.qmc.stringtoseconds(str(self.Edit6.text())):
                timez = aw.qmc.stringtoseconds(str(self.Edit6.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                aw.qmc.timex[aw.qmc.timeindex[6]] = timez
        if self.Edit6bt.text() != self.Edit6btcopy:
            aw.qmc.temp2[aw.qmc.timeindex[6]] = float(str(self.Edit6bt.text()))
        if self.Edit6et.text() != self.Edit6etcopy:
            aw.qmc.temp1[aw.qmc.timeindex[6]] = float(str(self.Edit6et.text()))
        for i in range(1,6): #1-5
            aw.qmc.designertimeinit[i] = aw.qmc.timex[aw.qmc.timeindex[i]]
        aw.qmc.xaxistosm()
        aw.qmc.redrawdesigner()
        return 0

    #supporting function for settimes()
    def validatetimeorder(self):
        time = []
        checks = self.readchecks()
        time.append(aw.qmc.stringtoseconds(str(self.Edit0.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit1.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit2.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit3.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit4.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit5.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit6.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        for i in range(len(time)-1):
            if time[i+1] <= time[i] and checks[i+1] != 0:
                return i
        return 1000

    def validatetime(self):
        strings = []
        strings.append(self.Edit0.text())
        strings.append(self.Edit1.text())
        strings.append(self.Edit2.text())
        strings.append(self.Edit3.text())
        strings.append(self.Edit4.text())
        strings.append(self.Edit5.text())
        strings.append(self.Edit6.text())
        for i in range(len(strings)):
            if len(str(strings[i])) < 5:
                return i
        else:
            return 1000

    #supporting function for settimes()
    def readchecks(self):
        checks = [0,0,0,0,0,0,0]
        if self.dryend.isChecked(): 
            checks[1] = 1
        if self.fcs.isChecked():
            checks[2] = 1
        if self.fce.isChecked():
            checks[3] = 1
        if self.scs.isChecked():
            checks[4] = 1
        if self.sce.isChecked():
            checks[5] = 1
        return checks

    def create(self):
        self.close()
        aw.qmc.convert_designer()

    #reset
    def reset(self):
        self.dryend.setChecked(True)
        self.fcs.setChecked(True)
        self.fce.setChecked(True)
        self.scs.setChecked(True)
        self.sce.setChecked(True)
        #reset designer
        aw.qmc.reset_designer()
        #update editboxes
        self.Edit0.setText(aw.qmc.stringfromseconds(0))
        self.Edit1.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[1]))
        self.Edit2.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[2]))
        self.Edit3.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[3]))
        self.Edit4.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[4]))
        self.Edit5.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[5]))
        self.Edit6.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[6]))
        self.Edit0bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[0]])
        self.Edit1bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[1]])
        self.Edit2bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[2]])
        self.Edit3bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[3]])
        self.Edit4bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[4]])
        self.Edit5bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[5]])
        self.Edit6bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[6]])
        self.Edit0et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[0]])
        self.Edit1et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[1]])
        self.Edit2et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[2]])
        self.Edit3et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[3]])
        self.Edit4et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[4]])
        self.Edit5et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[5]])
        self.Edit6et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[6]])
        aw.sendmessage(QApplication.translate("Message","Designer has been reset",None, QApplication.UnicodeUTF8))

    def loadconfigflags(self):
        self.dryend.setChecked(aw.qmc.timeindex[1])
        self.fcs.setChecked(aw.qmc.timeindex[2])
        self.fce.setChecked(aw.qmc.timeindex[3])
        self.scs.setChecked(aw.qmc.timeindex[4])
        self.sce.setChecked(aw.qmc.timeindex[5])

    #adds deletes landmarks
    def changeflags(self,_,idi):
        if self.validatetimeorder() != 1000:
            if idi == 1:
                if self.dryend.isChecked():
                    self.dryend.setChecked(False)
            elif idi == 2:
                if self.fcs.isChecked():
                    self.fcs.setChecked(False)
            elif idi == 3:
                if self.fce.isChecked():
                    self.fes.setChecked(False)
            elif idi == 4:
                if self.scs.isChecked():
                    self.scs.setChecked(False)
            elif idi == 5:
                if self.sce.isChecked():
                    self.sce.setChecked(False)
            #ERROR time from edit boxes is not in ascending order
            strings = [QApplication.translate("Message","CHARGE",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","DRY END",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","FC START",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","FC END",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","SC START",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","SC END",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","DROP",None, QApplication.UnicodeUTF8)]
            st = QApplication.translate("Message","Times need to be in ascending order. Please recheck %1 time",None, QApplication.UnicodeUTF8).arg(strings[idi])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),st)
            return
        #idi = id index
        if aw.qmc.timeindex[idi]:
            #ERASE mark point
            aw.qmc.currentx = aw.qmc.timex[aw.qmc.timeindex[idi]]
            aw.qmc.currenty = aw.qmc.temp2[aw.qmc.timeindex[idi]]
            aw.qmc.removepoint()
        else:
            #ADD mark point
            if idi == 1:
                timez = aw.qmc.stringtoseconds(str(self.Edit1.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit1bt.text()))
                et = float(str(self.Edit1et.text()))
            if idi == 2:
                timez = aw.qmc.stringtoseconds(str(self.Edit2.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit2bt.text()))
                et = float(str(self.Edit2et.text()))
            if idi == 3:
                timez = aw.qmc.stringtoseconds(str(self.Edit3.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit3bt.text()))
                et = float(str(self.Edit3et.text()))
            if idi == 4:
                timez = aw.qmc.stringtoseconds(str(self.Edit4.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit4bt.text()))
                et = float(str(self.Edit4et.text()))
            if idi == 5:
                timez = aw.qmc.stringtoseconds(str(self.Edit5.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit5bt.text()))
                et = float(str(self.Edit5et.text()))
            aw.qmc.currentx = timez 
            aw.qmc.currenty = bt
            newindex = aw.qmc.addpoint()
            aw.qmc.timeindex[idi] = newindex
            aw.qmc.temp2[aw.qmc.timeindex[idi]] = bt
            aw.qmc.temp1[aw.qmc.timeindex[idi]] = et
            aw.qmc.xaxistosm()
            aw.qmc.redrawdesigner()

#########################################################################
#############  NONE DEVICE DIALOG #######################################
#########################################################################

#inputs temperature
class nonedevDlg(QDialog):
    def __init__(self, parent = None):
        super(nonedevDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Manual Temperature Logger",None, QApplication.UnicodeUTF8))
        if len(aw.qmc.timex):
            if aw.qmc.manuallogETflag:
                etval = str(int(aw.qmc.temp1[-1]))
            else:
                etval = "0"
            btval = str(int(aw.qmc.temp2[-1])) 
        else:
            etval = "0"
            btval = "0"
        self.etEdit = QLineEdit(etval)
        btlabel = QLabel(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8))
        self.btEdit = QLineEdit(btval)
        self.etEdit.setValidator(QIntValidator(0, 1000, self.etEdit))
        self.btEdit.setValidator(QIntValidator(0, 1000, self.btEdit))
        self.btEdit.setFocus()
        self.ETbox = QCheckBox(QApplication.translate("CheckBox","ET",None, QApplication.UnicodeUTF8))
        if aw.qmc.manuallogETflag == True:
            self.ETbox.setChecked(True)
        else:
            self.ETbox.setChecked(False)
            self.etEdit.setVisible(False)
        self.connect(self.ETbox,SIGNAL("stateChanged(int)"),self.changemanuallogETflag)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        grid = QGridLayout()
        grid.addWidget(self.ETbox,0,0)
        grid.addWidget(self.etEdit,0,1)
        grid.addWidget(btlabel,1,0)
        grid.addWidget(self.btEdit,1,1)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(grid)
        mainLayout.addStretch()  
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def changemanuallogETflag(self):
        if self.ETbox.isChecked():
            aw.qmc.manuallogETflag = 1
            self.etEdit.setVisible(True)
            self.etEdit.setFocus()
        else:
            aw.qmc.manuallogETflag = 0
            self.etEdit.setVisible(False)
            self.btEdit.setFocus()

#########################################################################
#############  SERIAL PORT CONFIGURATION DIALOG #########################
#########################################################################


class PortComboBox(QComboBox):
    def __init__(self, parent = None, selection = None):
        super(PortComboBox, self).__init__(parent)
        self.installEventFilter(self)
        self.selection = u(selection) # just the port name (first element of one of the triples in self.ports)
        # a list of triples as returned by serial.tools.list_ports
        self.ports = []
        self.updateMenu()
        self.edited = None
        self.connect(self, SIGNAL("editTextChanged(QString)"),lambda txt="":self.textEdited(txt)) 
        self.setEditable(True)

    def textEdited(self,txt):
        self.edited = txt

    def getSelection(self):
        return self.edited or self.selection

    def setSelection(self,i):
        if i >= 0:
            try:
#                self.blockSignals(True)
                #self.clear()
                #self.addItems(list([p[0] for p in self.ports]))
                
#                for p, item in enumerate(self.ports):
#                    self.setItemText(p,item[0])
#                try:
#                    self.setCurrentIndex(i)
#                except:
#                    pass
                self.selection = u(self.ports[i][0])
                self.edited = None # reset the user text editing
            except:
                pass
#            finally:
#                self.blockSignals(False)

    def eventFilter(self, obj, event):
# the next prevents correct setSelection on Windows
#        if event.type() == QEvent.FocusIn:
#            self.setSelection(self.currentIndex())
        if event.type() == QEvent.MouseButtonPress:
            self.updateMenu()
        return False

    def updateMenu(self):
        self.blockSignals(True)
        if platf == 'Darwin':
            self.ports = list([p for p in serial.tools.list_ports.comports() if not(p[0] in ['/dev/cu.Bluetooth-PDA-Sync','/dev/cu.Bluetooth-Modem','/dev/tty.Bluetooth-PDA-Sync','/dev/tty.Bluetooth-Modem'])])
        else:
            self.ports = list(serial.tools.list_ports.comports())
        if self.selection not in [p[0] for p in self.ports]:
            self.ports.append([self.selection,"",""])
        self.ports = sorted(self.ports,key=lambda p: p[0])
        self.clear()
        self.addItems([(p[1] if p[1] else p[0]) for p in self.ports])
        try:
            pos = [p[0] for p in self.ports].index(self.selection)
            self.setCurrentIndex(pos)
        except:
            pass
        self.blockSignals(False)


class comportDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(comportDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Serial Ports Configuration",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        ##########################    TAB 1 WIDGETS
        comportlabel =QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.comportEdit = PortComboBox(selection = aw.ser.comport)
        self.connect(self.comportEdit, SIGNAL("activated(int)"),lambda i=0:self.portComboBoxIndexChanged(self.comportEdit,i)) 
        comportlabel.setBuddy(self.comportEdit)
        baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.baudrateComboBox = QComboBox()
        baudratelabel.setBuddy(self.baudrateComboBox)
        self.bauds = ["2400","9600","19200","38400","57600","115200"]
        self.baudrateComboBox.addItems(self.bauds)
        self.baudrateComboBox.setCurrentIndex(self.bauds.index(str(aw.ser.baudrate)))
        bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.bytesizeComboBox = QComboBox()
        bytesizelabel.setBuddy(self.bytesizeComboBox)
        self.bytesizes = ["7","8"]
        self.bytesizeComboBox.addItems(self.bytesizes)
        self.bytesizeComboBox.setCurrentIndex(self.bytesizes.index(str(aw.ser.bytesize)))
        paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.parityComboBox = QComboBox()
        paritylabel.setBuddy(self.parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.parity = ["O","E","N"]
        self.parityComboBox.addItems(self.parity)
        self.parityComboBox.setCurrentIndex(self.parity.index(aw.ser.parity))
        stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.stopbitsComboBox = QComboBox()
        stopbitslabel.setBuddy(self.stopbitsComboBox)
        self.stopbits = ["0","1","2"]
        self.stopbitsComboBox.addItems(self.stopbits)
        self.stopbitsComboBox.setCurrentIndex(aw.ser.stopbits)
        timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.timeoutEdit = QLineEdit(str(aw.ser.timeout))
        self.timeoutEdit.setValidator(QIntValidator(0,5,self.timeoutEdit))
        etbt_help_label = QLabel(QApplication.translate("Label", "Settings for non-Modbus devices",None, QApplication.UnicodeUTF8) + "<br>")
        ##########################    TAB 2  WIDGETS   EXTRA DEVICES
        self.serialtable = QTableWidget()
        self.serialtable.setTabKeyNavigation(True)
        self.createserialTable()
        ##########################    TAB 3 WIDGETS   MODBUS
        modbus_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.modbus_comportEdit = PortComboBox(selection = aw.modbus.comport)
        self.connect(self.modbus_comportEdit, SIGNAL("activated(int)"),lambda i=0:self.portComboBoxIndexChanged(self.modbus_comportEdit,i)) 
        modbus_comportlabel.setBuddy(self.modbus_comportEdit)
        modbus_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.modbus_baudrateComboBox = QComboBox()
        modbus_baudratelabel.setBuddy(self.modbus_baudrateComboBox)
        self.modbus_bauds = ["2400","9600","19200","38400","57600","115200"]
        self.modbus_baudrateComboBox.addItems(self.modbus_bauds)
        self.modbus_baudrateComboBox.setCurrentIndex(self.modbus_bauds.index(str(aw.modbus.baudrate)))
        modbus_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.modbus_bytesizeComboBox = QComboBox()
        modbus_bytesizelabel.setBuddy(self.modbus_bytesizeComboBox)
        self.modbus_bytesizes = ["7","8"]
        self.modbus_bytesizeComboBox.addItems(self.modbus_bytesizes)
        self.modbus_bytesizeComboBox.setCurrentIndex(self.modbus_bytesizes.index(str(aw.modbus.bytesize)))
        modbus_paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.modbus_parityComboBox = QComboBox()
        modbus_paritylabel.setBuddy(self.modbus_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.modbus_parity = ["O","E","N"]
        self.modbus_parityComboBox.addItems(self.modbus_parity)
        self.modbus_parityComboBox.setCurrentIndex(self.modbus_parity.index(aw.modbus.parity))
        modbus_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.modbus_stopbitsComboBox = QComboBox()
        modbus_stopbitslabel.setBuddy(self.modbus_stopbitsComboBox)
        self.modbus_stopbits = ["0","1","2"]
        self.modbus_stopbitsComboBox.addItems(self.stopbits)
        self.modbus_stopbitsComboBox.setCurrentIndex(aw.modbus.stopbits)
        modbus_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.modbus_timeoutEdit = QLineEdit(str(aw.modbus.timeout))
        self.modbus_timeoutEdit.setValidator(QIntValidator(1,5,self.modbus_timeoutEdit))
        modbus_input1slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input1slaveEdit = QLineEdit(str(aw.modbus.input1slave))
        self.modbus_input1slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input1slaveEdit))
        self.modbus_input1slaveEdit.setFixedWidth(50)
        self.modbus_input1slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input1registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input1registerEdit = QLineEdit(str(aw.modbus.input1register))
        self.modbus_input1registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input1registerEdit))
        self.modbus_input1registerEdit.setFixedWidth(50)
        self.modbus_input1registerEdit.setAlignment(Qt.AlignRight)
        modbus_function_codes = ["3","4"]
        modbus_modes = ["", "C","F"]
        modbus_input1floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input1codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input1float = QCheckBox()
        self.modbus_input1float.setChecked(aw.modbus.input1float)
        self.modbus_input1float.setFocusPolicy(Qt.NoFocus) 
#        self.connect(self.modbus_input1float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())  
        self.modbus_input1code = QComboBox()
        self.modbus_input1code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input1code.addItems(modbus_function_codes)
        self.modbus_input1code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input1code)))
        self.modbus_input1code.setFixedWidth(50)
        modbus_input1modelabel = QLabel(QApplication.translate("Label", "Mode",None, QApplication.UnicodeUTF8))
        self.modbus_input1mode = QComboBox()
        self.modbus_input1mode.setFocusPolicy(Qt.NoFocus)
        self.modbus_input1mode.addItems(modbus_modes)
        self.modbus_input1mode.setCurrentIndex(modbus_modes.index(str(aw.modbus.input1mode)))
        self.modbus_input1mode.setFixedWidth(50)
        modbus_input2slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input2slaveEdit = QLineEdit(str(aw.modbus.input2slave))
        self.modbus_input2slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input2slaveEdit))
        self.modbus_input2slaveEdit.setFixedWidth(50)
        self.modbus_input2slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input2registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input2registerEdit = QLineEdit(str(aw.modbus.input2register))
        self.modbus_input2registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input2registerEdit))
        self.modbus_input2registerEdit.setFixedWidth(50)
        self.modbus_input2registerEdit.setAlignment(Qt.AlignRight)
        modbus_input2floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input2codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input2float = QCheckBox()
        self.modbus_input2float.setChecked(aw.modbus.input2float)
        self.modbus_input2float.setFocusPolicy(Qt.NoFocus)  
#        self.connect(self.modbus_input2float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())      
        self.modbus_input2code = QComboBox()
        self.modbus_input2code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input2code.addItems(modbus_function_codes)
        self.modbus_input2code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input2code)))
        self.modbus_input2code.setFixedWidth(50)
        modbus_input2modelabel = QLabel(QApplication.translate("Label", "Mode",None, QApplication.UnicodeUTF8))
        self.modbus_input2mode = QComboBox()
        self.modbus_input2mode.setFocusPolicy(Qt.NoFocus)
        self.modbus_input2mode.addItems(modbus_modes)
        self.modbus_input2mode.setCurrentIndex(modbus_modes.index(str(aw.modbus.input2mode)))
        self.modbus_input2mode.setFixedWidth(50)
        modbus_input3slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input3slaveEdit = QLineEdit(str(aw.modbus.input3slave))
        self.modbus_input3slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input3slaveEdit))
        self.modbus_input3slaveEdit.setFixedWidth(50)
        self.modbus_input3slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input3registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input3registerEdit = QLineEdit(str(aw.modbus.input3register))
        self.modbus_input3registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input3registerEdit))
        self.modbus_input3registerEdit.setFixedWidth(50)
        self.modbus_input3registerEdit.setAlignment(Qt.AlignRight)
        modbus_input3floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input3codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input3float = QCheckBox()
        self.modbus_input3float.setChecked(aw.modbus.input3float)
        self.modbus_input3float.setFocusPolicy(Qt.NoFocus) 
#        self.connect(self.modbus_input3float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())
        self.modbus_input3code = QComboBox()
        self.modbus_input3code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input3code.addItems(modbus_function_codes)
        self.modbus_input3code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input3code)))
        self.modbus_input3code.setFixedWidth(50)
        modbus_input3modelabel = QLabel(QApplication.translate("Label", "Mode",None, QApplication.UnicodeUTF8))
        self.modbus_input3mode = QComboBox()
        self.modbus_input3mode.setFocusPolicy(Qt.NoFocus)
        self.modbus_input3mode.addItems(modbus_modes)
        self.modbus_input3mode.setCurrentIndex(modbus_modes.index(str(aw.modbus.input3mode)))
        self.modbus_input3mode.setFixedWidth(50)
        modbus_input4slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input4slaveEdit = QLineEdit(str(aw.modbus.input4slave))
        self.modbus_input4slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input4slaveEdit))
        self.modbus_input4slaveEdit.setFixedWidth(50)
        self.modbus_input4slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input4registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input4registerEdit = QLineEdit(str(aw.modbus.input4register))
        self.modbus_input4registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input4registerEdit))
        self.modbus_input4registerEdit.setFixedWidth(50)
        self.modbus_input4registerEdit.setAlignment(Qt.AlignRight)
        modbus_input4floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input4codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input4float = QCheckBox()
        self.modbus_input4float.setChecked(aw.modbus.input4float)
        self.modbus_input4float.setFocusPolicy(Qt.NoFocus)
#        self.connect(self.modbus_input4float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())
        self.modbus_input4code = QComboBox()
        self.modbus_input4code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input4code.addItems(modbus_function_codes)
        self.modbus_input4code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input4code)))
        self.modbus_input4code.setFixedWidth(50)
        modbus_input4modelabel = QLabel(QApplication.translate("Label", "Mode",None, QApplication.UnicodeUTF8))
        self.modbus_input4mode = QComboBox()
        self.modbus_input4mode.setFocusPolicy(Qt.NoFocus)
        self.modbus_input4mode.addItems(modbus_modes)
        self.modbus_input4mode.setCurrentIndex(modbus_modes.index(str(aw.modbus.input4mode)))
        self.modbus_input4mode.setFixedWidth(50)
        self.modbus_littleEndianFloats = QCheckBox(QApplication.translate("ComboBox","little-endian",None, QApplication.UnicodeUTF8))
        self.modbus_littleEndianFloats.setChecked(aw.modbus.littleEndianFloats)
        self.modbus_littleEndianFloats.setFocusPolicy(Qt.NoFocus)
# always enabled, because also MODBUS write commands now support floats and respect little vs big endian mode
#        if self.modbus_input1float.isChecked() or self.modbus_input2float.isChecked() or self.modbus_input3float.isChecked() or self.modbus_input4float.isChecked():
#            self.modbus_littleEndianFloats.setEnabled(True)
#        else:
#            self.modbus_littleEndianFloats.setEnabled(False)
        # type
        self.modbus_type = QComboBox()
        modbus_typelabel = QLabel(QApplication.translate("Label", "Type",None, QApplication.UnicodeUTF8))
        modbus_typelabel.setBuddy(self.modbus_type)
        self.modbus_type.setFocusPolicy(Qt.NoFocus)
        self.modbus_type.addItems(["Serial RTU", "Serial ASCII", "Serial Binary", "TCP", "UDP"])
        self.modbus_type.setCurrentIndex(aw.modbus.type)
        # host (IP or hostname)
        modbus_hostlabel = QLabel(QApplication.translate("Label", "Host",None, QApplication.UnicodeUTF8))
        self.modbus_hostEdit = QLineEdit(str(aw.modbus.host))
        self.modbus_hostEdit.setFixedWidth(120)
        self.modbus_hostEdit.setAlignment(Qt.AlignRight)
        # port (default 502)
        modbus_portlabel = QLabel(QApplication.translate("Label", "Port",None, QApplication.UnicodeUTF8))
        self.modbus_portEdit = QLineEdit(str(aw.modbus.port))
        self.modbus_portEdit.setValidator(QIntValidator(1,65535,self.modbus_input4slaveEdit))        
        self.modbus_portEdit.setFixedWidth(60)
        self.modbus_portEdit.setAlignment(Qt.AlignRight)
        # modbus help dialog text
#        modbus_help_text = QApplication.translate("Message", "These serial settings are used for all Modbus communication.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text = QApplication.translate("Message", "The MODBUS device corresponds to input channels",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "1 and 2.. The MODBUS_34 extra device adds",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "input channels 3 and 4. Inputs with slave",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "id set to 0 are turned off. Modbus function 3",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "'read holding register' is the standard.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Modbus function 4 triggers the use of 'read ",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "input register'. Input registers (fct 4) usually",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", " are from 30000-39999. Most devices hold data in",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "2 byte integer registers. A temperature of 145.2C",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "is often sent as 1452. In that case you have to",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "use the symbolic assignment 'x/10'. Few devices",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "hold data as 4 byte floats in two registers.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Tick the Float flag in this case.",None, QApplication.UnicodeUTF8)
        modbus_help_label = QLabel(modbus_help_text)
        fnt = modbus_help_label.font()
        if platf == 'Darwin':
            fnt.setPointSize(fnt.pointSize() - 2)
        else:
            fnt.setPointSize(fnt.pointSize() - 1)
        modbus_help_label.setFont(fnt)
        ##########################    TAB 4 WIDGETS   SCALE
        scale_devicelabel = QLabel(QApplication.translate("Label", "Device", None, QApplication.UnicodeUTF8))
        self.scale_deviceEdit = QComboBox()
        supported_scales = list(aw.scale.devicefunctionlist.keys())
        self.scale_deviceEdit.addItems(supported_scales)
        try:
            self.scale_deviceEdit.setCurrentIndex(supported_scales.index(aw.scale.device))
        except:
            self.scale_deviceEdit.setCurrentIndex(0)
        self.scale_deviceEdit.setEditable(False)
        scale_devicelabel.setBuddy(self.scale_deviceEdit)
        scale_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.scale_comportEdit = PortComboBox(selection = aw.scale.comport)
        self.connect(self.scale_comportEdit, SIGNAL("activated(int)"),lambda i=0:self.portComboBoxIndexChanged(self.scale_comportEdit,i))
        scale_comportlabel.setBuddy(self.scale_comportEdit)
        scale_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.scale_baudrateComboBox = QComboBox()
        scale_baudratelabel.setBuddy(self.scale_baudrateComboBox)
        self.scale_bauds = ["1200","2400","4800","9600","19200","38400","57600","115200"]
        self.scale_baudrateComboBox.addItems(self.scale_bauds)
        self.scale_baudrateComboBox.setCurrentIndex(self.scale_bauds.index(str(aw.scale.baudrate)))
        scale_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.scale_bytesizeComboBox = QComboBox()
        scale_bytesizelabel.setBuddy(self.scale_bytesizeComboBox)
        self.scale_bytesizes = ["7","8"]
        self.scale_bytesizeComboBox.addItems(self.scale_bytesizes)
        self.scale_bytesizeComboBox.setCurrentIndex(self.scale_bytesizes.index(str(aw.scale.bytesize)))
        scale_paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.scale_parityComboBox = QComboBox()
        scale_paritylabel.setBuddy(self.scale_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.scale_parity = ["O","E","N"]
        self.scale_parityComboBox.addItems(self.scale_parity)
        self.scale_parityComboBox.setCurrentIndex(self.scale_parity.index(aw.scale.parity))
        scale_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.scale_stopbitsComboBox = QComboBox()
        scale_stopbitslabel.setBuddy(self.scale_stopbitsComboBox)
        self.scale_stopbits = ["0","1","2"]
        self.scale_stopbitsComboBox.addItems(self.stopbits)
        self.scale_stopbitsComboBox.setCurrentIndex(aw.scale.stopbits)
        scale_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.scale_timeoutEdit = QLineEdit(str(aw.scale.timeout))
        self.scale_timeoutEdit.setValidator(QIntValidator(1,5,self.scale_timeoutEdit))
        ##########################    TAB 5 WIDGETS   COLOR
        color_devicelabel = QLabel(QApplication.translate("Label", "Device", None, QApplication.UnicodeUTF8))
        self.color_deviceEdit = QComboBox()
        supported_color_meters = list(aw.color.devicefunctionlist.keys())
        self.color_deviceEdit.addItems(supported_color_meters)
        try:
            self.color_deviceEdit.setCurrentIndex(supported_color_meters.index(aw.color.device))
        except:
            self.color_deviceEdit.setCurrentIndex(0)
        self.color_deviceEdit.setEditable(False)
        color_devicelabel.setBuddy(self.color_deviceEdit)
        color_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.color_comportEdit = PortComboBox(selection = aw.color.comport)
        self.connect(self.color_comportEdit, SIGNAL("activated(int)"),lambda i=0:self.portComboBoxIndexChanged(self.color_comportEdit,i))
        color_comportlabel.setBuddy(self.color_comportEdit)
        color_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.color_baudrateComboBox = QComboBox()
        color_baudratelabel.setBuddy(self.color_baudrateComboBox)
        self.color_bauds = ["1200","2400","4800","9600","19200","38400","57600","115200"]
        self.color_baudrateComboBox.addItems(self.color_bauds)
        self.color_baudrateComboBox.setCurrentIndex(self.color_bauds.index(str(aw.color.baudrate)))
        color_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.color_bytesizeComboBox = QComboBox()
        color_bytesizelabel.setBuddy(self.color_bytesizeComboBox)
        self.color_bytesizes = ["7","8"]
        self.color_bytesizeComboBox.addItems(self.color_bytesizes)
        self.color_bytesizeComboBox.setCurrentIndex(self.color_bytesizes.index(str(aw.color.bytesize)))
        color_paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.color_parityComboBox = QComboBox()
        color_paritylabel.setBuddy(self.color_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.color_parity = ["O","E","N"]
        self.color_parityComboBox.addItems(self.color_parity)
        self.color_parityComboBox.setCurrentIndex(self.color_parity.index(aw.color.parity))
        color_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.color_stopbitsComboBox = QComboBox()
        color_stopbitslabel.setBuddy(self.color_stopbitsComboBox)
        self.color_stopbits = ["0","1","2"]
        self.color_stopbitsComboBox.addItems(self.stopbits)
        self.color_stopbitsComboBox.setCurrentIndex(aw.color.stopbits)
        color_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.color_timeoutEdit = QLineEdit(str(aw.color.timeout))
        self.color_timeoutEdit.setValidator(QIntValidator(1,5,self.color_timeoutEdit))
        #### dialog buttons
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
#        scanButton = QPushButton(QApplication.translate("Button","Scan for Ports",None, QApplication.UnicodeUTF8))
#        scanButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
#        self.connect(scanButton, SIGNAL("clicked()"), self.scanforport)
        #button layout
        buttonLayout = QHBoxLayout()
#        buttonLayout.addWidget(scanButton)
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        #LAYOUT TAB 1
        grid = QGridLayout()
        grid.addWidget(comportlabel,0,0,Qt.AlignRight)
        grid.addWidget(self.comportEdit,0,1)
        grid.addWidget(baudratelabel,1,0,Qt.AlignRight)
        grid.addWidget(self.baudrateComboBox,1,1)
        grid.addWidget(bytesizelabel,2,0,Qt.AlignRight)
        grid.addWidget(self.bytesizeComboBox,2,1)
        grid.addWidget(paritylabel,3,0,Qt.AlignRight)
        grid.addWidget(self.parityComboBox,3,1)
        grid.addWidget(stopbitslabel,4,0,Qt.AlignRight)
        grid.addWidget(self.stopbitsComboBox,4,1)
        grid.addWidget(timeoutlabel,5,0,Qt.AlignRight)
        grid.addWidget(self.timeoutEdit,5,1)
        gridBoxLayout = QHBoxLayout()
        gridBoxLayout.addLayout(grid)
        gridBoxLayout.addStretch()
        tab1Layout = QVBoxLayout()
        tab1Layout.addWidget(etbt_help_label)
        devid = aw.qmc.device
        # "ADD DEVICE:"
        if not(devid in [27,29,33,34,37,40,41,45,46,47,48,49,50,51]) and not(devid == 0 and aw.ser.useModbusPort): # hide serial confs for MODBUS, Phidget and Yocto devices
            tab1Layout.addLayout(gridBoxLayout)
        tab1Layout.addStretch()
        #LAYOUT TAB 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.serialtable)
        #LAYOUT TAB 3
        modbus_grid = QGridLayout()
        modbus_grid.addWidget(modbus_comportlabel,0,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_comportEdit,0,1)
        modbus_grid.addWidget(modbus_baudratelabel,1,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_baudrateComboBox,1,1)
        modbus_grid.addWidget(modbus_bytesizelabel,2,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_bytesizeComboBox,2,1)
        modbus_grid.addWidget(modbus_paritylabel,3,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_parityComboBox,3,1)
        modbus_grid.addWidget(modbus_stopbitslabel,4,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_stopbitsComboBox,4,1)
        modbus_grid.addWidget(modbus_timeoutlabel,5,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_timeoutEdit,5,1)
        modbus_grid.setMargin(5)
        modbus_grid.setSpacing(7)
        modbus_gridV = QVBoxLayout()
        modbus_gridV.addStretch()
        modbus_gridV.addLayout(modbus_grid)
        modbus_gridV.addStretch()
        modbus_input1 = QGridLayout()
        modbus_input1.addWidget(modbus_input1slavelabel,0,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1slaveEdit,0,1)
        modbus_input1.addWidget(modbus_input1registerlabel,1,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1registerEdit,1,1)
        modbus_input1.addWidget(modbus_input1codelabel,2,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1code,2,1)
        modbus_input1.addWidget(modbus_input1modelabel,3,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1mode,3,1)
        modbus_input1.addWidget(modbus_input1floatlabel,4,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1float,4,1)
        modbus_input1group = QGroupBox(QApplication.translate("GroupBox", "Input 1",None, QApplication.UnicodeUTF8))
        modbus_input1group.setLayout(modbus_input1)

        modbus_input2 = QGridLayout()
        modbus_input2.addWidget(modbus_input2slavelabel,0,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2slaveEdit,0,1)
        modbus_input2.addWidget(modbus_input2registerlabel,1,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2registerEdit,1,1)
        modbus_input2.addWidget(modbus_input2codelabel,2,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2code,2,1)
        modbus_input2.addWidget(modbus_input2modelabel,3,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2mode,3,1)
        modbus_input2.addWidget(modbus_input2floatlabel,4,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2float,4,1)
        modbus_input2group = QGroupBox(QApplication.translate("GroupBox", "Input 2",None, QApplication.UnicodeUTF8))
        modbus_input2group.setLayout(modbus_input2)
        modbus_input3 = QGridLayout()
        modbus_input3.addWidget(modbus_input3slavelabel,0,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3slaveEdit,0,1)
        modbus_input3.addWidget(modbus_input3registerlabel,1,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3registerEdit,1,1)
        modbus_input3.addWidget(modbus_input3codelabel,2,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3code,2,1)
        modbus_input3.addWidget(modbus_input3modelabel,3,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3mode,3,1)
        modbus_input3.addWidget(modbus_input3floatlabel,4,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3float,4,1)
        modbus_input3group = QGroupBox(QApplication.translate("GroupBox", "Input 3",None, QApplication.UnicodeUTF8))
        modbus_input3group.setLayout(modbus_input3)
        modbus_input4 = QGridLayout()
        modbus_input4.addWidget(modbus_input4slavelabel,0,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4slaveEdit,0,1)
        modbus_input4.addWidget(modbus_input4registerlabel,1,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4registerEdit,1,1)
        modbus_input4.addWidget(modbus_input4codelabel,2,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4code,2,1)
        modbus_input4.addWidget(modbus_input4modelabel,3,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4mode,3,1)
        modbus_input4.addWidget(modbus_input4floatlabel,4,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4float,4,1)
        modbus_input4group = QGroupBox(QApplication.translate("GroupBox", "Input 4",None, QApplication.UnicodeUTF8))
        modbus_input4group.setLayout(modbus_input4)
        modbus_inputV = QHBoxLayout()
        modbus_inputV.setMargin(0)
#        modbus_inputV.setSpacing(2)
        modbus_inputV.addWidget(modbus_input1group)
        modbus_inputV.addStretch()
        modbus_inputV.addWidget(modbus_input2group)
        modbus_inputV.addStretch()
        modbus_inputV.addWidget(modbus_input3group)
        modbus_inputV.addStretch()
        modbus_inputV.addWidget(modbus_input4group)
        modbus_inputV.addStretch()
        modbus_gridVLayout = QHBoxLayout()
        modbus_gridVLayout.addLayout(modbus_gridV)
        modbus_gridVLayout.addWidget(modbus_help_label)
        modbus_gridVLayout.addStretch()
        modbus_setup = QHBoxLayout()
        modbus_setup.addWidget(self.modbus_littleEndianFloats)
        modbus_setup.addStretch()
        modbus_setup.addWidget(modbus_typelabel)
        modbus_setup.addWidget(self.modbus_type)
        modbus_setup.addStretch()
        modbus_setup.addWidget(modbus_hostlabel)
        modbus_setup.addWidget(self.modbus_hostEdit)
        modbus_setup.addSpacing(7)
        modbus_setup.addWidget(modbus_portlabel)
        modbus_setup.addWidget(self.modbus_portEdit)
        tab3Layout = QVBoxLayout()
        tab3Layout.addLayout(modbus_gridVLayout)
        tab3Layout.addLayout(modbus_inputV)
        tab3Layout.addLayout(modbus_setup)
        tab3Layout.addStretch()
        tab3Layout.setMargin(0)
        tab3Layout.setSpacing(5)
        #LAYOUT TAB 4
        scale_grid = QGridLayout()
        scale_grid.addWidget(scale_devicelabel,0,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_deviceEdit,0,1)
        scale_grid.addWidget(scale_comportlabel,1,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_comportEdit,1,1)
        scale_grid.addWidget(scale_baudratelabel,2,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_baudrateComboBox,2,1)
        scale_grid.addWidget(scale_bytesizelabel,3,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_bytesizeComboBox,3,1)
        scale_grid.addWidget(scale_paritylabel,4,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_parityComboBox,4,1)
        scale_grid.addWidget(scale_stopbitslabel,5,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_stopbitsComboBox,5,1)
        scale_grid.addWidget(scale_timeoutlabel,6,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_timeoutEdit,6,1)
        scaleH = QHBoxLayout()
        scaleH.addLayout(scale_grid)
        scaleH.addStretch()
        tab4Layout = QVBoxLayout()
        tab4Layout.addLayout(scaleH)
        tab4Layout.addStretch()
        #LAYOUT TAB 5
        color_grid = QGridLayout()
        color_grid.addWidget(color_devicelabel,0,0,Qt.AlignRight)
        color_grid.addWidget(self.color_deviceEdit,0,1)
        color_grid.addWidget(color_comportlabel,1,0,Qt.AlignRight)
        color_grid.addWidget(self.color_comportEdit,1,1)
        color_grid.addWidget(color_baudratelabel,2,0,Qt.AlignRight)
        color_grid.addWidget(self.color_baudrateComboBox,2,1)
        color_grid.addWidget(color_bytesizelabel,3,0,Qt.AlignRight)
        color_grid.addWidget(self.color_bytesizeComboBox,3,1)
        color_grid.addWidget(color_paritylabel,4,0,Qt.AlignRight)
        color_grid.addWidget(self.color_parityComboBox,4,1)
        color_grid.addWidget(color_stopbitslabel,5,0,Qt.AlignRight)
        color_grid.addWidget(self.color_stopbitsComboBox,5,1)
        color_grid.addWidget(color_timeoutlabel,6,0,Qt.AlignRight)
        color_grid.addWidget(self.color_timeoutEdit,6,1)
        colorH = QHBoxLayout()
        colorH.addLayout(color_grid)
        colorH.addStretch()
        tab5Layout = QVBoxLayout()
        tab5Layout.addLayout(colorH)
        tab5Layout.addStretch()
        #tab widget
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","ET/BT",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Extra",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Modbus",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Scale",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Color",None, QApplication.UnicodeUTF8))
        if devid == 29: # switch to MODBUS tab if MODBUS device was selected as main device
            TabWidget.setCurrentIndex(2)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(buttonLayout)
        self.setLayout(Mlayout)

    def portComboBoxIndexChanged(self,portComboBox,i):
        portComboBox.setSelection(i)

#    def changeEndianVisibility(self):
#        if self.modbus_input1float.isChecked() or self.modbus_input2float.isChecked() or self.modbus_input3float.isChecked() or self.modbus_input4float.isChecked():
#            self.modbus_littleEndianFloats.setEnabled(True)
#        else:
#            self.modbus_littleEndianFloats.setEnabled(False)

    def createserialTable(self):
        try:
            self.serialtable.clear()
            nssdevices = len(aw.extracomport)
            if nssdevices:
                self.serialtable.setRowCount(nssdevices)
                self.serialtable.setColumnCount(7)
                self.serialtable.setHorizontalHeaderLabels([QApplication.translate("Table","Device",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Comm Port",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Baud Rate",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Byte Size",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Parity",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Stopbits",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Timeout",None, QApplication.UnicodeUTF8)])
                self.serialtable.setAlternatingRowColors(True)
                self.serialtable.setEditTriggers(QTableWidget.NoEditTriggers)
                self.serialtable.setSelectionBehavior(QTableWidget.SelectRows)
                self.serialtable.setSelectionMode(QTableWidget.SingleSelection)
                self.serialtable.setShowGrid(True)
                self.serialtable.verticalHeader().setResizeMode(2)
                for i in range(nssdevices):
                    devid = aw.qmc.extradevices[i]
                    devicename = aw.qmc.devices[devid-1]
                    if devicename[0] == "+":
                        devname = devicename[1:]
                    else:
                        devname = devicename
                    device = QTableWidgetItem(devname)    #type identification of the device. Non editable
                    self.serialtable.setItem(i,0,device)
                    # "ADD DEVICE:"
                    if not (devid in [27,29,33,34,37,40,41,45,46,47,48,49,50,51]) and devicename[0] != "+": # hide serial confs for MODBUS, Phidgets and "+X" extra devices
                        comportComboBox = PortComboBox(selection = aw.extracomport[i])
                        self.connect(comportComboBox, SIGNAL("activated(int)"),lambda i=0:self.portComboBoxIndexChanged(comportComboBox,i))
                        comportComboBox.setFixedWidth(200)
                        baudComboBox =  QComboBox()
                        baudComboBox.addItems(self.bauds)
                        if str(aw.extrabaudrate[i]) in self.bauds:
                            baudComboBox.setCurrentIndex(self.bauds.index(str(aw.extrabaudrate[i])))
                        byteComboBox =  QComboBox()
                        byteComboBox.addItems(self.bytesizes)
                        if str(aw.extrabytesize[i]) in self.bytesizes:
                            byteComboBox.setCurrentIndex(self.bytesizes.index(str(aw.extrabytesize[i])))
                        parityComboBox =  QComboBox()
                        parityComboBox.addItems(self.parity)
                        if aw.extraparity[i] in self.parity:
                            parityComboBox.setCurrentIndex(self.parity.index(aw.extraparity[i]))
                        #self.connect(baudComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,x=i:self.setextradevice(z,x))
                        stopbitsComboBox = QComboBox()
                        stopbitsComboBox.addItems(self.stopbits)
                        if str(aw.extrastopbits[i]) in self.stopbits:
                            stopbitsComboBox.setCurrentIndex(self.stopbits.index(str(aw.extrastopbits[i])))
                        timeoutEdit = QLineEdit(str(aw.extratimeout[i]))
                        timeoutEdit.setValidator(QIntValidator(1,5,timeoutEdit))
                        timeoutEdit.setFixedWidth(65)
                        timeoutEdit.setAlignment(Qt.AlignRight)
                        #add widgets to the table
                        self.serialtable.setCellWidget(i,1,comportComboBox)
                        self.serialtable.setCellWidget(i,2,baudComboBox)
                        self.serialtable.setCellWidget(i,3,byteComboBox)
                        self.serialtable.setCellWidget(i,4,parityComboBox)
                        self.serialtable.setCellWidget(i,5,stopbitsComboBox)
                        self.serialtable.setCellWidget(i,6,timeoutEdit)
                self.serialtable.resizeColumnsToContents()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " createserialTable(): %1").arg(str(e)),exc_tb.tb_lineno)

    def saveserialtable(self):
        try:
            #aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            ser_ports = len(aw.extracomport)
            self.closeserialports()
            for i in range(ser_ports):
                devid = aw.qmc.extradevices[i]
                devicename = aw.qmc.devices[devid-1]    #type identification of the device. Non editable
                if devid != 29 and devid != 33 and devicename[0] != "+": # hide serial confs for MODBUS and "+XX" extra devices
                    comportComboBox =  self.serialtable.cellWidget(i,1)
                    if comportComboBox:
                        aw.extracomport[i] = str(comportComboBox.getSelection())
                    baudComboBox =  self.serialtable.cellWidget(i,2)
                    if baudComboBox:
                        aw.extrabaudrate[i] = int(str(baudComboBox.currentText()))
                    byteComboBox =  self.serialtable.cellWidget(i,3)
                    if byteComboBox:
                        aw.extrabytesize[i] = int(str(byteComboBox.currentText()))
                    parityComboBox =  self.serialtable.cellWidget(i,4)
                    if parityComboBox:
                        aw.extraparity[i] = str(parityComboBox.currentText())
                    stopbitsComboBox =  self.serialtable.cellWidget(i,5)
                    if stopbitsComboBox:
                        aw.extrastopbits[i] = int(str(stopbitsComboBox.currentText()))
                    timeoutEdit = self.serialtable.cellWidget(i,6)
                    if timeoutEdit:
                        aw.extratimeout[i] = int(str(timeoutEdit.text()))
            #create serial ports for each extra device
            aw.extraser = [None]*ser_ports
            #load the settings for the extra serial ports found
            for i in range(ser_ports):
                aw.extraser[i] = serialport()
                aw.extraser[i].comport = str(aw.extracomport[i])
                aw.extraser[i].baudrate = aw.extrabaudrate[i]
                aw.extraser[i].bytesize = aw.extrabytesize[i]
                aw.extraser[i].parity = str(aw.extraparity[i])
                aw.extraser[i].stopbits = aw.extrastopbits[i]
                aw.extraser[i].timeout = aw.extratimeout[i]
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " saveserialtable(): %1").arg(str(e)),exc_tb.tb_lineno)

    def accept(self):
        #validate serial parameter against input errors
        class comportError(Exception): pass
#        class baudrateError(Exception): pass
#        class bytesizeError(Exception): pass
#        class parityError(Exception): pass
#        class stopbitsError(Exception): pass
        class timeoutError(Exception): pass
#        comport = str(self.comportEdit.currentText())
        comport = str(self.comportEdit.getSelection())
        baudrate = str(self.baudrateComboBox.currentText())
        bytesize = str(self.bytesizeComboBox.currentText())
        parity = str(self.parityComboBox.currentText())
        stopbits = str(self.stopbitsComboBox.currentText())
        timeout = str(self.timeoutEdit.text())
        #save extra serial ports by reading the serial extra table
        self.saveserialtable()
        # "ADD DEVICE:"
        if not(aw.qmc.device in [27,29,33,34,37,40,41,45,46,47,48,49,50,51]) and not(aw.qmc.device == 0 and aw.ser.useModbusPort): # only if serial conf is not hidden
            try:
                #check here comport errors
                if not comport:
                    raise comportError
                if not timeout:
                    raise timeoutError
                #add more checks here
                aw.sendmessage(QApplication.translate("Message","Serial Port Settings: %1, %2, %3, %4, %5, %6", None, QApplication.UnicodeUTF8).arg(comport).arg(baudrate).arg(bytesize).arg(parity).arg(stopbits).arg(timeout))
            except comportError:
                aw.qmc.adderror(QApplication.translate("Error Message","Serial Exception: invalid comm port", None, QApplication.UnicodeUTF8))
                self.comportEdit.selectAll()
                self.comportEdit.setFocus()
                return
            except timeoutError:
                aw.qmc.adderror(QApplication.translate("Error Message","Serial Exception: timeout", None, QApplication.UnicodeUTF8))
                self.timeoutEdit.selectAll()
                self.timeoutEdit.setFocus()
                return
        QDialog.accept(self)

#    # returns a list of strings indicating available serial ports
#    def serialports(self):
#        available = []
#        if platf in ('Windows', 'Microsoft'):
#            #scans serial ports in Windows computer
#            for i in range(100):
#                try:
#                    s = serial.Serial(i)
#                    available.append(s.portstr)
#                    s.close()
#                except serial.SerialException:
#                    pass
#        elif platf == 'Darwin':
#            if float(serial.VERSION[:3]) < 2.6:
#                #scans serial ports in Mac computer
#                for name in glob.glob("/dev/cu.*"):
#                    if name.upper().rfind("MODEM") < 0:
#                        try:  
#                            f = open(name, "r+")
#                            f.close()
#                            available.append(name)
#                        except Exception:
#                            pass
#            else:
#                from serial.tools import list_ports
#                available = list([port[0] for port in list_ports.comports() if not(port[0] in ['/dev/tty.Bluetooth-PDA-Sync','/dev/tty.Bluetooth-Modem'])])
#        elif platf == 'Linux':
#            if float(serial.VERSION[:3]) < 2.6:
#                maxnum=9
#                for prefix in ["/dev/ttyS", "/dev/cua", "/dev/ttyUSB","/dev/usb/ttyUSB", "/dev/usb/tts/"]:
#                    for num in range(maxnum+1):
#                        name=prefix+repr(num)
#                        if not os.path.exists(name):
#                            continue
#                        try:
#                            f = open(name, "r+")
#                            f.close()
#                            available.append(name)
#                        except Exception:
#                            pass
#            else:
#                from serial.tools import list_ports
#                available = list([port[0] for port in list_ports.comports()])
#        else:
#            self.sendmessage(QApplication.translate("Message","Port scan on this platform not yet supported", None, QApplication.UnicodeUTF8))
#        return available
#

#    def scanforport(self):
#        try:
#            available = self.serialports()
#            aw.ser.closeport()            #set comboBoxes
#            self.comportEdit.clear()
#            self.comportEdit.addItems(available)
#            self.modbus_comportEdit.clear()
#            self.modbus_comportEdit.addItems(available)
#            if len(available):
#                if aw.ser.comport in available:
#                    self.comportEdit.setCurrentIndex(available.index(aw.ser.comport))
#                else:
#                    self.comportEdit.setCurrentIndex(len(available)-1)
#                aw.ser.commavailable = available[:]
#                for i in range(len(aw.qmc.extradevices)):
#                    comportComboBox =  self.serialtable.cellWidget(i,1)
#                    if comportComboBox != None:
#                        comportComboBox.clear()
#                        comportComboBox.addItems(aw.ser.commavailable)
#                        if aw.extracomport[i] in aw.ser.commavailable:
#                            comportComboBox.setCurrentIndex(aw.ser.commavailable.index(aw.extracomport[i]))
#                        else:
#                            comportComboBox.setCurrentIndex(len(aw.ser.commavailable)-1)
#        except Exception as e:
#            _, _, exc_tb = sys.exc_info()
#            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " scanforport(): %1").arg(str(e)),exc_tb.tb_lineno)

    def closeserialports(self):
        aw.closeserialports()


#################################################################################
##################   Device assignments DIALOG for reading temperature   ########
#################################################################################

class DeviceAssignmentDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(DeviceAssignmentDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Device Assignment", None, QApplication.UnicodeUTF8))
        self.setModal(True)
        ################ TAB 1   WIDGETS
        #ETcurve
        self.ETcurve = QCheckBox(QApplication.translate("CheckBox", "ET",None, QApplication.UnicodeUTF8))
        self.ETcurve.setChecked(aw.qmc.ETcurve)
        #BTcurve
        self.BTcurve = QCheckBox(QApplication.translate("CheckBox", "BT",None, QApplication.UnicodeUTF8))
        self.BTcurve.setChecked(aw.qmc.BTcurve)
        #ETlcd
        self.ETlcd = QCheckBox(QApplication.translate("CheckBox", "ET",None, QApplication.UnicodeUTF8))
        self.ETlcd.setChecked(aw.qmc.ETlcd)
        #BTlcd
        self.BTlcd = QCheckBox(QApplication.translate("CheckBox", "BT",None, QApplication.UnicodeUTF8))
        self.BTlcd.setChecked(aw.qmc.BTlcd)
        self.curveHBox = QHBoxLayout()
        self.curveHBox.setContentsMargins(10,5,10,5)
        self.curveHBox.setSpacing(5)
        self.curveHBox.addWidget(self.ETcurve)
        self.curveHBox.addSpacing(10)
        self.curveHBox.addWidget(self.BTcurve)
        self.curveHBox.addStretch()
        self.curves = QGroupBox(QApplication.translate("GroupBox","Curves",None, QApplication.UnicodeUTF8))
        self.curves.setLayout(self.curveHBox)
        self.lcdHBox = QHBoxLayout()
        self.lcdHBox.setContentsMargins(30,5,30,5)
        self.lcdHBox.setSpacing(5)
        self.lcdHBox.addWidget(self.ETlcd)
        self.lcdHBox.addSpacing(10)
        self.lcdHBox.addWidget(self.BTlcd)
        self.lcdHBox.addStretch()
        self.lcds = QGroupBox(QApplication.translate("GroupBox","LCDs",None, QApplication.UnicodeUTF8))
        self.lcds.setLayout(self.lcdHBox)
        self.curveBox = QHBoxLayout()
        self.curveBox.addWidget(self.curves)
        self.curveBox.addWidget(self.lcds)
        self.nonpidButton = QRadioButton(QApplication.translate("Radio Button","Meter", None, QApplication.UnicodeUTF8))
        self.pidButton = QRadioButton(QApplication.translate("Radio Button","PID", None, QApplication.UnicodeUTF8))
        self.arduinoButton = QRadioButton(QApplication.translate("Radio Button","TC4", None, QApplication.UnicodeUTF8))
        self.programButton = QRadioButton(QApplication.translate("Radio Button","Program", None, QApplication.UnicodeUTF8))
        #As a main device, don't show the devices that start with a "+"
        # devices with a first letter "+" are extra devices an depend on another device
        # each device provides 2 curves
        #don't show devices with a "-". Devices with a - at front are either a pid, arduino, or an external program
        dev = aw.qmc.devices[:]             #deep copy
        limit = len(dev)
        for _ in range(limit):
            for i in range(len(dev)):
                if dev[i][0] == "+" or dev[i][0] == "-":
                    dev.pop(i)              #note: pop() makes the list smaller that's why there are 2 FOR statements
                    break 
        self.sorted_devices = sorted(dev)        
#        self.sorted_devices = sorted(dev, key=lambda x: (x[1:] if x.startswith("+") else x)) # +Devices are anyhow not this the dev list
        self.devicetypeComboBox = QComboBox()
        self.devicetypeComboBox.addItems(self.sorted_devices)
        self.programedit = QLineEdit(aw.ser.externalprogram)
        selectprogrambutton =  QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
        selectprogrambutton.setFocusPolicy(Qt.NoFocus)
        self.connect(selectprogrambutton, SIGNAL("clicked()"),self.loadprogramname)
        helpprogrambutton =  QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpprogrambutton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpprogrambutton, SIGNAL("clicked()"),self.showhelpprogram)
        ###################################################
        # PID
        controllabel =QLabel(QApplication.translate("Label", "Control ET",None, QApplication.UnicodeUTF8))
        self.controlpidtypeComboBox = QComboBox()
        self.controlpidtypeComboBox.addItems(["Fuji PXG","Fuji PXR","Delta DTA"])
        self.controlpidtypeComboBox.setCurrentIndex(aw.ser.controlETpid[0])  #pid type is index 0
        btlabel =QLabel(QApplication.translate("Label", "Read BT",None, QApplication.UnicodeUTF8))
        self.btpidtypeComboBox = QComboBox()
        self.btpidtypeComboBox.addItems(["Fuji PXG","Fuji PXR","None","Delta DTA"])
        self.btpidtypeComboBox.setCurrentIndex(aw.ser.readBTpid[0]) #pid type is index 0
        label1 = QLabel(QApplication.translate("Label", "Type",None, QApplication.UnicodeUTF8))
        label2 = QLabel(QApplication.translate("Label", "RS485 Unit ID",None, QApplication.UnicodeUTF8))
        #rs485 possible unit IDs (1-32); unit 0 is master (computer)
        unitids = list(map(str,list(range(1,33))))
        self.controlpidunitidComboBox = QComboBox()
        self.controlpidunitidComboBox.addItems(unitids)
        self.btpidunitidComboBox = QComboBox()
        self.btpidunitidComboBox.addItems(unitids)
        # index 1 = unitID of the rs485 network
        self.controlpidunitidComboBox.setCurrentIndex(unitids.index(str(aw.ser.controlETpid[1])))
        self.btpidunitidComboBox.setCurrentIndex(unitids.index(str(aw.ser.readBTpid[1])))
        #Reuse Modbus port
        self.useModbusPort = QCheckBox(QApplication.translate("CheckBox", "Modbus Port",None, QApplication.UnicodeUTF8))
        self.useModbusPort.setChecked(aw.ser.useModbusPort)
        ####################################################
        #Arduino TC4 channel config
        arduinoChannels = ["None","1","2","3","4"]
        arduinoETLabel =QLabel(QApplication.translate("Label", "ET Channel",None, QApplication.UnicodeUTF8))
        self.arduinoETComboBox = QComboBox()
        self.arduinoETComboBox.addItems(arduinoChannels)
        arduinoBTLabel =QLabel(QApplication.translate("Label", "BT Channel",None, QApplication.UnicodeUTF8))
        self.arduinoBTComboBox = QComboBox()
        self.arduinoBTComboBox.addItems(arduinoChannels)
        #check previous settings for radio button
        if aw.qmc.device == 0 or aw.qmc.device == 26:   #if Fuji pid or Delta DTA pid
            self.pidButton.setChecked(True)
        elif aw.qmc.device == 19:                       #if arduino
            self.arduinoButton.setChecked(True)
        elif aw.qmc.device == 27:                       #if program
            self.programButton.setChecked(True)
        else:
            self.nonpidButton.setChecked(True)          #else
            selected_device_index = 0
            try:
                selected_device_index = self.sorted_devices.index(aw.qmc.devices[aw.qmc.device - 1])
            except Exception:
                pass
            self.devicetypeComboBox.setCurrentIndex(selected_device_index)
        self.arduinoETComboBox.setCurrentIndex(arduinoChannels.index(aw.ser.arduinoETChannel))
        self.arduinoBTComboBox.setCurrentIndex(arduinoChannels.index(aw.ser.arduinoBTChannel))
        arduinoATLabel =QLabel(QApplication.translate("Label", "AT Channel",None, QApplication.UnicodeUTF8))
        arduinoTemperatures = ["None","T1","T2","T3","T4","T5","T6"]
        self.arduinoATComboBox = QComboBox()        
        self.arduinoATComboBox.addItems(arduinoTemperatures)
        self.arduinoATComboBox.setCurrentIndex(arduinoTemperatures.index(aw.ser.arduinoATChannel))
        self.showControlButton = QCheckBox(QApplication.translate("CheckBox", "Control Button",None, QApplication.UnicodeUTF8))
        self.showControlButton.setChecked(aw.qmc.PIDbuttonflag)
        self.connect(self.showControlButton,SIGNAL("stateChanged(int)"),lambda i=0:self.showControlbuttonToggle(i))
        FILTLabel =QLabel(QApplication.translate("Label", "Filter",None, QApplication.UnicodeUTF8))
        self.FILTspinBoxes = []
        for i in range(4):
            spinBox = QSpinBox()
            spinBox.setAlignment(Qt.AlignRight)
            spinBox.setRange(0,99)
            spinBox.setSingleStep(5)
            spinBox.setSuffix(" %")
            spinBox.setValue(aw.ser.ArduinoFILT[i])
            self.FILTspinBoxes.append(spinBox)
        ####################################################
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton, SIGNAL("clicked()"),self.okEvent)
        self.connect(cancelButton, SIGNAL("clicked()"),self.cancelEvent)
        labelETadvanced = QLabel(QApplication.translate("Label", "ET Y(x)",None, QApplication.UnicodeUTF8))
        labelBTadvanced = QLabel(QApplication.translate("Label", "BT Y(x)",None, QApplication.UnicodeUTF8))
        self.ETfunctionedit = QLineEdit(str(aw.qmc.ETfunction))
        self.BTfunctionedit = QLineEdit(str(aw.qmc.BTfunction))
        symbolicHelpButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        symbolicHelpButton.setMaximumSize(symbolicHelpButton.sizeHint())
        symbolicHelpButton.setMinimumSize(symbolicHelpButton.minimumSizeHint())
        symbolicHelpButton.setFocusPolicy(Qt.NoFocus)
        self.connect(symbolicHelpButton, SIGNAL("clicked()"),aw.showSymbolicHelp)
        ##########################    TAB 2  WIDGETS   "EXTRA DEVICES"
        #table for showing data
        self.devicetable = QTableWidget()
        self.devicetable.setTabKeyNavigation(True)
        self.createDeviceTable()
        self.addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        self.addButton.setFocusPolicy(Qt.NoFocus)
        self.addButton.setMinimumWidth(100)
        self.addButton.setMaximumWidth(100)
        self.connect(self.addButton, SIGNAL("clicked()"),self.adddevice)
        resetButton = QPushButton(QApplication.translate("Button","Reset",None, QApplication.UnicodeUTF8))
        resetButton.setFocusPolicy(Qt.NoFocus)
        resetButton.setMinimumWidth(100)
        self.connect(resetButton, SIGNAL("clicked()"),self.resetextradevices)
        self.delButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
        self.delButton.setFocusPolicy(Qt.NoFocus)
        self.delButton.setMinimumWidth(100)
        self.delButton.setMaximumWidth(100)
        self.connect(self.delButton, SIGNAL("clicked()"),self.deldevice) 
        self.enableDisableAddDeleteButtons()
        ##########     LAYOUTS
        # create Phidget box
        phidgetProbeTypeItems = ["K", "J", "E", "T"]
        phidgetBox1048 = QGridLayout()
        self.asyncCheckBoxes1048 = []
        self.changeTriggerCombos1048 = []
        self.probeTypeCombos = []
        for i in range(1,5):
            changeTriggersCombo = QComboBox()
            changeTriggersCombo.setFocusPolicy(Qt.NoFocus)
            model = changeTriggersCombo.model()
            changeTriggerItems = self.createItems(aw.qmc.phidget1048_changeTriggersStrings)
            for item in changeTriggerItems:
                model.appendRow(item)
            try:
                changeTriggersCombo.setCurrentIndex(aw.qmc.phidget1048_changeTriggersValues.index(aw.qmc.phidget1048_changeTriggers[i-1]))
            except:
                pass
            changeTriggersCombo.setMaximumSize(65,100)
            self.changeTriggerCombos1048.append(changeTriggersCombo)
            phidgetBox1048.addWidget(changeTriggersCombo,3,i)
            asyncFlag = QCheckBox()
            asyncFlag.setFocusPolicy(Qt.NoFocus)
            asyncFlag.setChecked(True)
            self.connect(asyncFlag,SIGNAL("stateChanged(int)"),lambda x,y=i-1 :self.asyncFlagStateChanged1048(y,x))
            asyncFlag.setChecked(aw.qmc.phidget1048_async[i-1])
            self.asyncCheckBoxes1048.append(asyncFlag)
            phidgetBox1048.addWidget(asyncFlag,2,i)
            probeTypeCombo = QComboBox()
            probeTypeCombo.setFocusPolicy(Qt.NoFocus)
            model = probeTypeCombo.model()
            probeTypeItems = self.createItems(phidgetProbeTypeItems)
            for item in probeTypeItems:
                model.appendRow(item)
            try:
                probeTypeCombo.setCurrentIndex(aw.qmc.phidget1048_types[i-1]-1)
            except:
                pass
            probeTypeCombo.setMaximumSize(65,100)
            self.probeTypeCombos.append(probeTypeCombo)
            phidgetBox1048.addWidget(probeTypeCombo,1,i)            
            rowLabel = QLabel(str(i))
            phidgetBox1048.addWidget(rowLabel,0,i)
        typeLabel = QLabel(QApplication.translate("Label","Type", None, QApplication.UnicodeUTF8))
        asyncLabel = QLabel(QApplication.translate("Label","Async", None, QApplication.UnicodeUTF8))
        changeTriggerLabel = QLabel(QApplication.translate("Label","Change", None, QApplication.UnicodeUTF8))
        phidgetBox1048.addWidget(typeLabel,1,0,Qt.AlignRight)
        phidgetBox1048.addWidget(asyncLabel,2,0,Qt.AlignRight)
        phidgetBox1048.addWidget(changeTriggerLabel,3,0,Qt.AlignRight)
        phidget1048HBox = QHBoxLayout()
        phidget1048HBox.addStretch()
        phidget1048HBox.addLayout(phidgetBox1048)
        phidget1048HBox.addStretch()
        phidget1048VBox = QVBoxLayout()
        phidget1048VBox.addLayout(phidget1048HBox)
        phidget1048VBox.addStretch()
        phidget1048GroupBox = QGroupBox(QApplication.translate("GroupBox","Phidgets 1048",None, QApplication.UnicodeUTF8))
        phidget1048GroupBox.setLayout(phidget1048VBox)
        phidget1048HBox.setContentsMargins(0,0,0,0)
        
        # Phidget IR
        phidgetBox1045 = QGridLayout()
        self.changeTriggerCombos1045 = QComboBox()
        self.changeTriggerCombos1045.setFocusPolicy(Qt.NoFocus)
        model = self.changeTriggerCombos1045.model()
        changeTriggerItems = self.createItems(aw.qmc.phidget1045_changeTriggersStrings)
        for item in changeTriggerItems:
            model.appendRow(item)
        try:
            self.changeTriggerCombos1045.setCurrentIndex(aw.qmc.phidget1045_changeTriggersValues.index(aw.qmc.phidget1045_changeTrigger))
        except:
            pass
        self.changeTriggerCombos1045.setMaximumSize(65,100)
        phidgetBox1045.addWidget(self.changeTriggerCombos1045,3,1)
        self.asyncCheckBoxe1045 = QCheckBox()
        self.asyncCheckBoxe1045.setFocusPolicy(Qt.NoFocus)
        self.asyncCheckBoxe1045.setChecked(True)
        self.connect(self.asyncCheckBoxe1045,SIGNAL("stateChanged(int)"),lambda x,y=i-1 :self.asyncFlagStateChanged1045(y,x))
        self.asyncCheckBoxe1045.setChecked(aw.qmc.phidget1045_async)
        phidgetBox1045.addWidget(self.asyncCheckBoxe1045,2,1)
        asyncLabel = QLabel(QApplication.translate("Label","Async", None, QApplication.UnicodeUTF8))
        changeTriggerLabel = QLabel(QApplication.translate("Label","Change", None, QApplication.UnicodeUTF8))
        EmissivityLabel = QLabel(QApplication.translate("Label","Emissivity", None, QApplication.UnicodeUTF8))
        self.emissivitySpinBox = QDoubleSpinBox()
        self.emissivitySpinBox.setAlignment(Qt.AlignRight)
        self.emissivitySpinBox.setRange(0.,1.)
        self.emissivitySpinBox.setSingleStep(.1)
        self.emissivitySpinBox.setValue(aw.qmc.phidget1045_emissivity)
        phidgetBox1045.addWidget(asyncLabel,2,0,Qt.AlignRight)
        phidgetBox1045.addWidget(changeTriggerLabel,3,0,Qt.AlignRight)
        phidgetBox1045.addWidget(EmissivityLabel,4,0,Qt.AlignRight)
        phidgetBox1045.addWidget(self.emissivitySpinBox,4,1)
        phidget1045VBox = QVBoxLayout()
        phidget1045VBox.addStretch()
        phidget1045VBox.addLayout(phidgetBox1045)
        phidget1045VBox.addStretch()
        phidget1045VBox.addStretch()
        phidget1045GroupBox = QGroupBox(QApplication.translate("GroupBox","Phidgets 1045",None, QApplication.UnicodeUTF8))
        phidget1045GroupBox.setLayout(phidget1045VBox)
        phidget1045VBox.setContentsMargins(0,0,0,0)           

        # 1046 RTD
        phidgetBox1046 = QGridLayout()
        self.gainCombos1046 = []
        self.formulaCombos1046 = []
        self.asyncCheckBoxes1046 = []        
        for i in range(1,5):
            gainCombo = QComboBox()
            gainCombo.setFocusPolicy(Qt.NoFocus)
            model = gainCombo.model()
            gainItems = self.createItems(aw.qmc.phidget1046_gainValues)
            for item in gainItems:
                model.appendRow(item)
            try:
                gainCombo.setCurrentIndex(aw.qmc.phidget1046_gain[i-1] - 1)
            except:
                pass
            gainCombo.setMaximumSize(60,100)
            self.gainCombos1046.append(gainCombo)
            phidgetBox1046.addWidget(gainCombo,1,i)
            
            formulaCombo = QComboBox()
            formulaCombo.setFocusPolicy(Qt.NoFocus)
            model = formulaCombo.model()
            formulaItems = self.createItems(aw.qmc.phidget1046_formulaValues)
            for item in formulaItems:
                model.appendRow(item)
            try:
                formulaCombo.setCurrentIndex(aw.qmc.phidget1046_formula[i-1])
            except:
                pass
            formulaCombo.setMaximumSize(60,100)
            self.formulaCombos1046.append(formulaCombo)
            phidgetBox1046.addWidget(formulaCombo,2,i)

            asyncFlag = QCheckBox()
            asyncFlag.setFocusPolicy(Qt.NoFocus)
            asyncFlag.setChecked(True)
            asyncFlag.setChecked(aw.qmc.phidget1046_async[i-1])
            self.asyncCheckBoxes1046.append(asyncFlag)
            phidgetBox1046.addWidget(asyncFlag,3,i)        
            rowLabel = QLabel(str(i))
            phidgetBox1046.addWidget(rowLabel,0,i)
            
        self.dataRateCombo1046 = QComboBox()
        self.dataRateCombo1046.setFocusPolicy(Qt.NoFocus)
        model = self.dataRateCombo1046.model()
        dataRateItems = self.createItems(aw.qmc.phidget_dataRatesStrings)
        for item in dataRateItems:
            model.appendRow(item)
        try:
            self.dataRateCombo1046.setCurrentIndex(aw.qmc.phidget_dataRatesValues.index(aw.qmc.phidget1046_dataRate))
        except:
            pass
        self.dataRateCombo1046.setMaximumSize(70,100)
        phidgetBox1046.addWidget(self.dataRateCombo1046,4,1)
     
        gainLabel = QLabel(QApplication.translate("Label","Gain", None, QApplication.UnicodeUTF8))
        formulaLabel = QLabel(QApplication.translate("Label","Wiring", None, QApplication.UnicodeUTF8))
        asyncLabel = QLabel(QApplication.translate("Label","Async", None, QApplication.UnicodeUTF8))
        rateLabel = QLabel(QApplication.translate("Label","Rate", None, QApplication.UnicodeUTF8))
        phidgetBox1046.addWidget(gainLabel,1,0,Qt.AlignRight)
        phidgetBox1046.addWidget(formulaLabel,2,0,Qt.AlignRight)
        phidgetBox1046.addWidget(asyncLabel,3,0,Qt.AlignRight)
        phidgetBox1046.addWidget(rateLabel,4,0,Qt.AlignRight)
        phidget1046HBox = QHBoxLayout()
        phidget1046HBox.addStretch()
        phidget1046HBox.addLayout(phidgetBox1046)
        phidget1046HBox.addStretch()
        phidget1046VBox = QVBoxLayout()
        phidget1046VBox.addLayout(phidget1046HBox)
        phidget1046VBox.addStretch()
        phidget1046GroupBox = QGroupBox(QApplication.translate("GroupBox","Phidgets 1046 RTD",None, QApplication.UnicodeUTF8))
        phidget1046GroupBox.setLayout(phidget1046VBox)
        phidget1046HBox.setContentsMargins(0,0,0,0)

        phdget10481045GroupBoxHBox = QHBoxLayout()
        phdget10481045GroupBoxHBox.addWidget(phidget1048GroupBox)
        phdget10481045GroupBoxHBox.addStretch()
        phdget10481045GroupBoxHBox.addWidget(phidget1046GroupBox) 

        # Phidget IO 1018
        # ratiometric flag
        self.phidgetBoxRatiometricFlag = QCheckBox(QApplication.translate("CheckBox","Ratiometric",None, QApplication.UnicodeUTF8))
        self.phidgetBoxRatiometricFlag.setFocusPolicy(Qt.NoFocus)
        self.phidgetBoxRatiometricFlag.setChecked(aw.qmc.phidget1018Ratiometric)
        # per each of the 8-channels: raw flag / data rate popup / change trigger popup
        phidgetBox1018 = QGridLayout()
        self.asyncCheckBoxes = []
        self.rawCheckBoxes = []
        self.dataRateCombos = []
        self.changeTriggerCombos = []
        for i in range(1,9):
            dataRatesCombo = QComboBox()
            dataRatesCombo.setFocusPolicy(Qt.NoFocus)
            model = dataRatesCombo.model()
            dataRateItems = self.createItems(aw.qmc.phidget_dataRatesStrings)
            for item in dataRateItems:
                model.appendRow(item)
            try:
                dataRatesCombo.setCurrentIndex(aw.qmc.phidget_dataRatesValues.index(aw.qmc.phidget1018_dataRates[i-1]))
            except:
                pass
            dataRatesCombo.setMaximumSize(55,100)
            self.dataRateCombos.append(dataRatesCombo)
            phidgetBox1018.addWidget(dataRatesCombo,4,i)
            changeTriggersCombo = QComboBox()
            changeTriggersCombo.setFocusPolicy(Qt.NoFocus)
            model = changeTriggersCombo.model()
            changeTriggerItems = self.createItems(aw.qmc.phidget1018_changeTriggersStrings)
            for item in changeTriggerItems:
                model.appendRow(item)
            self.connect(changeTriggersCombo,SIGNAL("currentIndexChanged(int)"),lambda x,y=i-1 :self.changeTriggerIndexChanged(y,x))
            try:
                changeTriggersCombo.setCurrentIndex((aw.qmc.phidget1018_changeTriggersValues.index(aw.qmc.phidget1018_changeTriggers[i-1])))
            except:
                pass
            changeTriggersCombo.setMaximumSize(55,100)
            self.changeTriggerCombos.append(changeTriggersCombo)
            phidgetBox1018.addWidget(changeTriggersCombo,3,i)
            asyncFlag = QCheckBox()
            asyncFlag.setFocusPolicy(Qt.NoFocus)
            asyncFlag.setChecked(True)
            self.connect(asyncFlag,SIGNAL("stateChanged(int)"),lambda x,y=i-1 :self.asyncFlagStateChanged(y,x))
            asyncFlag.setChecked(aw.qmc.phidget1018_async[i-1])
            self.asyncCheckBoxes.append(asyncFlag)
            phidgetBox1018.addWidget(asyncFlag,2,i)
            rawFlag = QCheckBox()
            rawFlag.setFocusPolicy(Qt.NoFocus)
            rawFlag.setChecked(False)
            self.connect(rawFlag,SIGNAL("stateChanged(int)"),lambda x,y=i-1 :self.rawFlagStateChanged(y,x))
            rawFlag.setChecked(aw.qmc.phidget1018_raws[i-1])
            self.rawCheckBoxes.append(rawFlag)
            phidgetBox1018.addWidget(rawFlag,1,i)
            rowLabel = QLabel(str(i))
            phidgetBox1018.addWidget(rowLabel,0,i)
        asyncLabel = QLabel(QApplication.translate("Label","Async", None, QApplication.UnicodeUTF8))
        rawLabel = QLabel(QApplication.translate("Label","Raw", None, QApplication.UnicodeUTF8))
        dataRateLabel = QLabel(QApplication.translate("Label","Rate", None, QApplication.UnicodeUTF8))
        changeTriggerLabel = QLabel(QApplication.translate("Label","Change", None, QApplication.UnicodeUTF8))
        phidgetBox1018.addWidget(rawLabel,1,0,Qt.AlignRight)
        phidgetBox1018.addWidget(asyncLabel,2,0,Qt.AlignRight)
        phidgetBox1018.addWidget(changeTriggerLabel,3,0,Qt.AlignRight)
        phidgetBox1018.addWidget(dataRateLabel,4,0,Qt.AlignRight)
        ratiometricBox = QHBoxLayout()
        ratiometricBox.addStretch()
        ratiometricBox.addWidget(self.phidgetBoxRatiometricFlag)
        phidget1018HBox = QVBoxLayout()
        phidget1018HBox.addLayout(phidgetBox1018)
        phidget1018HBox.addLayout(ratiometricBox)
        phidget1018GroupBox = QGroupBox(QApplication.translate("GroupBox","Phidget IO",None, QApplication.UnicodeUTF8))
        phidget1018GroupBox.setLayout(phidget1018HBox)
        phidget1018HBox.setContentsMargins(0,0,0,0)
        self.phidgetBoxRemoteFlag = QCheckBox()
        self.phidgetBoxRemoteFlag.setFocusPolicy(Qt.NoFocus)
        self.phidgetBoxRemoteFlag.setChecked(aw.qmc.phidgetRemoteFlag)
        phidgetServerIdLabel = QLabel(QApplication.translate("Label","ServerId:", None, QApplication.UnicodeUTF8))
        self.phidgetServerId = QLineEdit(aw.qmc.phidgetServerID)
        phidgetPasswordLabel = QLabel(QApplication.translate("Label","Password:", None, QApplication.UnicodeUTF8))
        self.phidgetPassword = QLineEdit(aw.qmc.phidgetPassword)
        self.phidgetPassword.setEchoMode(3)
        phidgetServerBox = QHBoxLayout()
        phidgetServerBox.addWidget(phidgetServerIdLabel)
        phidgetServerBox.addWidget(self.phidgetServerId)
        phidgetServerBox.setContentsMargins(0,0,0,0)
        phidgetServerBox.setSpacing(3)
        phidgetPasswordBox = QHBoxLayout()
        phidgetPasswordBox.addWidget(phidgetPasswordLabel)
        phidgetPasswordBox.addWidget(self.phidgetPassword)
        phidgetPasswordBox.setContentsMargins(0,0,0,0)
        phidgetPasswordBox.setSpacing(3)
        phidgetNetworkGrid = QGridLayout()
        phidgetNetworkGrid.addWidget(self.phidgetBoxRemoteFlag,0,0)
        phidgetNetworkGrid.addLayout(phidgetServerBox,0,1)
        phidgetNetworkGrid.addLayout(phidgetPasswordBox,0,2)
        phidgetNetworkGrid.setContentsMargins(0,0,0,0)
        phidgetNetworkGrid.setSpacing(20)
        phidgetNetworkGroupBox = QGroupBox(QApplication.translate("GroupBox","Network",None, QApplication.UnicodeUTF8))
        phidgetNetworkGroupBox.setLayout(phidgetNetworkGrid)
        phidget10451018HBox = QHBoxLayout()
        phidget10451018HBox.addWidget(phidget1045GroupBox)
        phidget10451018HBox.addWidget(phidget1018GroupBox)
        phidgetVBox = QVBoxLayout()
        phidgetVBox.addLayout(phdget10481045GroupBoxHBox)
        phidgetVBox.addLayout(phidget10451018HBox)
        phidgetVBox.addWidget(phidgetNetworkGroupBox)
        phidgetVBox.setSpacing(5)
        phidgetVBox.setContentsMargins(0,0,0,0)
        # create pid box
        PIDgrid = QGridLayout()
        PIDgrid.addWidget(label1,0,1)
        PIDgrid.addWidget(label2,0,2)
        PIDgrid.addWidget(controllabel,1,0)
        PIDgrid.addWidget(self.controlpidtypeComboBox,1,1)
        PIDgrid.addWidget(self.controlpidunitidComboBox,1,2)
        PIDgrid.addWidget(btlabel,2,0,Qt.AlignRight)
        PIDgrid.addWidget(self.btpidtypeComboBox,2,1)
        PIDgrid.addWidget(self.btpidunitidComboBox,2,2)
        PIDgrid.addWidget(self.useModbusPort,2,3)
        PIDBox = QHBoxLayout()
        PIDBox.addLayout(PIDgrid)
        PIDBox.addStretch()
        PIDBox.setContentsMargins(5,0,5,5)
        PIDGroupBox = QGroupBox(QApplication.translate("GroupBox","PID",None, QApplication.UnicodeUTF8))
        PIDGroupBox.setLayout(PIDBox)
        # create arduino box
        filtgrid = QGridLayout()
        filtgrid.addWidget(FILTLabel,1,0)
        for i in range(4):
            filtgrid.addWidget(self.FILTspinBoxes[i],1,i+2)
        filtgridBox = QHBoxLayout()
        filtgridBox.addLayout(filtgrid)
        filtgridBox.addStretch()
        filtgridBox.setContentsMargins(5,5,5,5)
        arduinogrid = QGridLayout()
        arduinogrid.addWidget(arduinoETLabel,1,0,Qt.AlignRight)
        arduinogrid.addWidget(self.arduinoETComboBox,1,1)
        arduinogrid.addWidget(arduinoBTLabel,2,0,Qt.AlignRight)
        arduinogrid.addWidget(self.arduinoBTComboBox,2,1)
        arduinogrid.addWidget(self.arduinoATComboBox,2,3)
        arduinogrid.addWidget(arduinoATLabel,2,4)
        arduinogrid.addWidget(self.showControlButton,2,5)
        arduinogridBox = QHBoxLayout()
        arduinogridBox.addLayout(arduinogrid)
        arduinogridBox.addStretch()
        arduinogridBox.setContentsMargins(5,5,5,5)
        arduinoBox = QVBoxLayout()
        arduinoBox.addLayout(arduinogridBox)
        arduinoBox.addLayout(filtgridBox)
        arduinoBox.setContentsMargins(5,5,5,5)
        arduinoGroupBox = QGroupBox(QApplication.translate("GroupBox","Arduino TC4",None, QApplication.UnicodeUTF8))
        arduinoGroupBox.setLayout(arduinoBox)
        #create program Box
        programlayout = QHBoxLayout()
        programlayout.addWidget(helpprogrambutton)
        programlayout.addWidget(selectprogrambutton)
        programlayout.addWidget(self.programedit)
        programGroupBox = QGroupBox(QApplication.translate("GroupBox","External Program",None, QApplication.UnicodeUTF8))
        programGroupBox.setLayout(programlayout)
        #ET BT symbolic adjustments/assignments Box
        adjustmentHelp = QHBoxLayout()
        adjustmentHelp.addStretch()
        adjustmentHelp.addWidget(symbolicHelpButton)
        adjustmentGroupBox = QGroupBox(QApplication.translate("GroupBox","Symbolic Assignments",None, QApplication.UnicodeUTF8))
        adjustmentsLayout = QVBoxLayout()
        adjustmentsLayout.addWidget(labelETadvanced)
        adjustmentsLayout.addWidget(self.ETfunctionedit)
        adjustmentsLayout.addWidget(labelBTadvanced)
        adjustmentsLayout.addWidget(self.BTfunctionedit)
        adjustmentsLayout.addStretch()
        adjustmentsLayout.addLayout(adjustmentHelp)
        adjustmentGroupBox.setLayout(adjustmentsLayout)
        #LAYOUT TAB 1
        deviceSelector = QHBoxLayout()
        deviceSelector.addWidget(self.devicetypeComboBox)
        deviceSelector.addStretch()
        grid = QGridLayout()
        grid.addLayout(self.curveBox,0,1)
        grid.addWidget(self.nonpidButton,2,0)
        grid.addLayout(deviceSelector,2,1)
        grid.addWidget(self.pidButton,3,0)
        grid.addWidget(PIDGroupBox,3,1)
        grid.addWidget(self.arduinoButton,4,0)
        grid.addWidget(arduinoGroupBox,4,1)
        grid.addWidget(self.programButton,5,0)
        grid.addWidget(programGroupBox,5,1)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        tab1Layout = QVBoxLayout()
        tab1Layout.addLayout(grid)
        tab1Layout.setContentsMargins(5,5,0,5)
        tab1Layout.addStretch()
        bLayout = QHBoxLayout()
        bLayout.addWidget(self.addButton)
        bLayout.addWidget(self.delButton)
        bLayout.addStretch()
        bLayout.addSpacing(10)
        bLayout.addWidget(resetButton)
        #LAYOUT TAB 2 (Extra Devices)
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.devicetable)
        tab2Layout.setSpacing(5)
        tab2Layout.setContentsMargins(0,10,0,5)
        tab2Layout.addLayout(bLayout)
        #LAYOUT TAB 3 (Symb ET/BT)
        tab3Layout = QVBoxLayout()
        tab3Layout.addWidget(adjustmentGroupBox)
        #LAYOUT TAB 4 (Phidgets)
        tab4Layout = QVBoxLayout()
        tab4Layout.addLayout(phidgetVBox)        
        tab4Layout.setContentsMargins(0,0,0,0)
        #main tab widget
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","ET/BT",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Extra Devices",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Symb ET/BT",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Phidgets",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(buttonLayout)
        Mlayout.setMargin(10)
        self.setLayout(Mlayout)

    def asyncFlagStateChanged1048(self,i,x):
        if x == 0:
            # disable ChangeTrigger selection
            self.changeTriggerCombos1048[i].setEnabled(False)
        else:
            # enable ChangeTrigger selection
            self.changeTriggerCombos1048[i].setEnabled(True)

    def asyncFlagStateChanged1045(self,i,x):
        if x == 0:
            # disable ChangeTrigger selection
            self.changeTriggerCombos1045.setEnabled(False)
        else:
            # enable ChangeTrigger selection
            self.changeTriggerCombos1045.setEnabled(True)
        
    def changeTriggerIndexChanged(self,i,x):
        if x == 0:
            # enable DataRate selection
            self.dataRateCombos[i].setEnabled(True)
        else:
            # disable DataRate selection
            self.dataRateCombos[i].setEnabled(False)
        
    def rawFlagStateChanged(self,i,x):
        if x == 0:
            # enable ChangeTrigger and if that is 0 also DataRate selection
            self.asyncCheckBoxes[i].setEnabled(True)
            if self.asyncCheckBoxes[i].isChecked():
                self.changeTriggerCombos[i].setEnabled(True)
                if self.changeTriggerCombos[i].currentIndex() == 0:
                    self.dataRateCombos[i].setEnabled(True)
                else:
                    self.dataRateCombos[i].setEnabled(False)
        else:
            # disable DataRate selection
            self.asyncCheckBoxes[i].setEnabled(False)
            self.changeTriggerCombos[i].setEnabled(False)
            self.dataRateCombos[i].setEnabled(False)
            
    def asyncFlagStateChanged(self,i,x):
        if x == 0:
            # disable DataRate selection
            self.changeTriggerCombos[i].setEnabled(False)
            self.dataRateCombos[i].setEnabled(False)
        else:
            # enable ChangeTrigger and if that is 0 also DataRate selection
            self.changeTriggerCombos[i].setEnabled(True)
            if self.changeTriggerCombos[i].currentIndex() == 0:
                self.dataRateCombos[i].setEnabled(True)
            else:
                self.dataRateCombos[i].setEnabled(False)

    def createItems(self,strs):
        items = []
        for i in range(len(strs)):
            item = QStandardItem(strs[i])
            items.append(item)
        return items

    def showControlbuttonToggle(self,i):
        if i:
            aw.qmc.PIDbuttonflag = True
            if aw.qmc.device in [0,19,26]: # FUJI, DTA, ARDUINOTC4
                aw.button_10.setVisible(True)
        else:
            aw.qmc.PIDbuttonflag = False
            aw.button_10.setVisible(False)
        
    def createDeviceTable(self):
        try:
            self.devicetable.clear()
            nddevices = len(aw.qmc.extradevices)
            self.devicetable.setRowCount(nddevices)
            self.devicetable.setColumnCount(11)
            self.devicetable.setHorizontalHeaderLabels([QApplication.translate("Table", "Device",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Color 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Color 2",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Label 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Label 2",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "y1(x)",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "y2(x)",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "LCD 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "LCD 2",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Curve 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Curve 2",None, QApplication.UnicodeUTF8)])
            self.devicetable.setAlternatingRowColors(True)
            self.devicetable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.devicetable.setSelectionBehavior(QTableWidget.SelectRows)
            self.devicetable.setSelectionMode(QTableWidget.SingleSelection)
            self.devicetable.setShowGrid(True)
            self.devicetable.verticalHeader().setResizeMode(2)
            if nddevices:
                dev = aw.qmc.devices[:]             #deep copy
                limit = len(dev)
                for _ in range(limit):
                    for i in range(len(dev)):
                        if dev[i][0] == "-" or dev[i] == "NONE": # non manual device or deactivated device in extra device list
                            dev.pop(i)              #note: pop() makes the list smaller 
                            break 
                devices = sorted(map(lambda x:(x[1:] if x.startswith("+") else x),dev), key=lambda x: (x[1:] if x.startswith("+") else x))
                for i in range(nddevices):
                    typeComboBox =  QComboBox()
                    typeComboBox.addItems(devices[:])
                    try:
                        dev_name = aw.qmc.devices[aw.qmc.extradevices[i]-1]
                        if dev_name[0] == "+":
                            dev_name = dev_name[1:]
                        typeComboBox.setCurrentIndex(devices.index(dev_name))
                    except:
                        pass
                    color1Button = QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
                    color1Button.setFocusPolicy(Qt.NoFocus)
                    self.connect(color1Button, SIGNAL("clicked()"),lambda l = 1, c = i: self.setextracolor(l,c))
                    color2Button = QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
                    color2Button.setFocusPolicy(Qt.NoFocus)
                    self.connect(color2Button, SIGNAL("clicked()"),lambda l = 2, c = i: self.setextracolor(l,c))
                    name1edit = QLineEdit(u(aw.qmc.extraname1[i]))
                    name2edit = QLineEdit(u(aw.qmc.extraname2[i]))
                    mexpr1edit = QLineEdit(u(aw.qmc.extramathexpression1[i]))
                    mexpr2edit = QLineEdit(u(aw.qmc.extramathexpression2[i]))
                    mexpr1edit.setToolTip(QApplication.translate("Tooltip","Example: 100 + 2*x",None, QApplication.UnicodeUTF8))
                    mexpr2edit.setToolTip(QApplication.translate("Tooltip","Example: 100 + x",None, QApplication.UnicodeUTF8))
                    LCD1visibilityComboBox =  QCheckBox()
                    if aw.extraLCDvisibility1[i]:
                        LCD1visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        LCD1visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(LCD1visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,lcd=1, ind=i: self.updateLCDvisibility(x,lcd,ind))
                    LCD2visibilityComboBox =  QCheckBox()
                    if aw.extraLCDvisibility2[i]:
                        LCD2visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        LCD2visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(LCD2visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,lcd=2, ind=i: self.updateLCDvisibility(x,lcd,ind))
                    Curve1visibilityComboBox =  QCheckBox()
                    if aw.extraCurveVisibility1[i]:
                        Curve1visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        Curve1visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(Curve1visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,curve=1, ind=i: self.updateCurveVisibility(bool(x),curve,ind))
                    Curve2visibilityComboBox =  QCheckBox()
                    if aw.extraCurveVisibility2[i]:
                        Curve2visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        Curve2visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(Curve2visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,curve=2, ind=i: self.updateCurveVisibility(bool(x),curve,ind))
                    #add widgets to the table
                    self.devicetable.setCellWidget(i,0,typeComboBox)
                    self.devicetable.setCellWidget(i,1,color1Button)
                    self.devicetable.setCellWidget(i,2,color2Button)
                    self.devicetable.setCellWidget(i,3,name1edit)
                    self.devicetable.setCellWidget(i,4,name2edit)
                    self.devicetable.setCellWidget(i,5,mexpr1edit)
                    self.devicetable.setCellWidget(i,6,mexpr2edit)
                    self.devicetable.setCellWidget(i,7,LCD1visibilityComboBox)
                    self.devicetable.setCellWidget(i,8,LCD2visibilityComboBox)
                    self.devicetable.setCellWidget(i,9,Curve1visibilityComboBox)
                    self.devicetable.setCellWidget(i,10,Curve2visibilityComboBox)
                self.devicetable.resizeColumnsToContents()
                header = self.devicetable.horizontalHeader()
                header.setStretchLastSection(True)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " createDeviceTable(): %1").arg(str(e)),exc_tb.tb_lineno)

    def showhelpprogram(self):
        string = "<b>Allows to link to external programs that print temperature when called</b><br><br>"
        string += "The output of the program must be to Stdout (like when using print statements)<br><br>"
        string += "this allows to connect meters that use any programming language <br><br>"
        string += "Example of output needed from program for single temperature (BT)<br><br> \"100.4\" (note: \"\" not needed) <br><br>"
        string += "Example of output needed from program for double temperature (ET,BT)<br><br> \"200.4,100.4\" (note: temperatures are separated by a comma \"ET,BT\")<br><br>"
        string += "Example of a file written in python language called test.py:<br>"
        string += "#comment: print a string with two numbers separated by a comma<br><br>"
        string += "#!/usr/bin/env python<br>"
        string += "print (\"237.1,100.4\")"
        translatedstring = QApplication.translate("Message",string,None, QApplication.UnicodeUTF8)
        QMessageBox.information(self,QApplication.translate("Message", "External program",None, QApplication.UnicodeUTF8),translatedstring)

    def loadprogramname(self):
        fileName = aw.ArtisanOpenFileDialog()
        if fileName:
            self.programedit.setText(fileName)

    def enableDisableAddDeleteButtons(self):
        if len(aw.qmc.extradevices) >= aw.nLCDS:
            self.addButton.setEnabled(False)
        else:
            self.addButton.setEnabled(True)
        if len(aw.qmc.extradevices) > 0:
            self.delButton.setEnabled(True)
        else:
            self.delButton.setEnabled(False)

    #adds extra device
    def adddevice(self):
        try:
            self.savedevicetable()
            #addDevice() is located in aw so that the same function can be used in init after dynamically loading settings
            aw.addDevice()
            self.createDeviceTable()
            self.enableDisableAddDeleteButtons()
            aw.qmc.resetlinecountcaches()
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " adddevice(): %1").arg(str(e)),exc_tb.tb_lineno)

    def deldevice(self):
        try:
            bindex = len(aw.qmc.extradevices)-1
            selected = self.devicetable.selectedRanges()
            if len(selected) > 0:
                bindex = selected[0].topRow()
            if bindex >= 0:
                self.delextradevice(bindex)
            aw.updateExtraLCDvisibility()
            aw.qmc.resetlinecountcaches()
            self.enableDisableAddDeleteButtons()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " deldevice(): %1").arg(str(e)),exc_tb.tb_lineno)

    def resetextradevices(self):
        try:
            aw.resetExtraDevices()
            #update table
            self.createDeviceTable()
            #enable/disable buttons
            self.enableDisableAddDeleteButtons()
            #redraw
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " resetextradevices(): %1").arg(str(e)),exc_tb.tb_lineno)

    def delextradevice(self,x):
        try:
            aw.qmc.extradevices.pop(x)
            aw.qmc.extradevicecolor1.pop(x)
            aw.qmc.extradevicecolor2.pop(x)
            aw.qmc.extratimex.pop(x)
            aw.qmc.extratemp1.pop(x)
            aw.qmc.extratemp2.pop(x)
            aw.qmc.extrastemp1.pop(x)
            aw.qmc.extrastemp2.pop(x)
            aw.qmc.extralinestyles1.pop(x)
            aw.qmc.extralinestyles2.pop(x)
            aw.qmc.extradrawstyles1.pop(x)
            aw.qmc.extradrawstyles2.pop(x)
            aw.qmc.extralinewidths1.pop(x)
            aw.qmc.extralinewidths2.pop(x)
            aw.qmc.extramarkers1.pop(x)
            aw.qmc.extramarkers2.pop(x)
            aw.qmc.extramarkersizes1.pop(x)
            aw.qmc.extramarkersizes2.pop(x)
            # visible courves before this one
            before1 = before2 = 0
            for j in range(x):
                if aw.extraCurveVisibility1[j]:
                    before1 = before1 + 1
                if aw.extraCurveVisibility2[j]:
                    before2 = before2 + 1
            if aw.extraCurveVisibility1[x]:
                aw.qmc.extratemp1lines.pop(before1)
            if aw.extraCurveVisibility2[x]:
                aw.qmc.extratemp2lines.pop(before2)
            aw.qmc.extraname1.pop(x)
            aw.qmc.extraname2.pop(x)
            aw.qmc.extramathexpression1.pop(x)
            aw.qmc.extramathexpression2.pop(x)
            aw.updateExtraLCDvisibility()
            #pop serial port settings
            if len(aw.extracomport) > x:
                aw.extracomport.pop(x)
            if len(aw.extrabaudrate) > x:
                aw.extrabaudrate.pop(x)
            if len(aw.extrabytesize) > x:
                aw.extrabytesize.pop(x)
            if len(aw.extraparity) > x:
                aw.extraparity.pop(x)
            if len(aw.extrastopbits) > x:
                aw.extrastopbits.pop(x)
            if len(aw.extratimeout) > x:
                aw.extratimeout.pop(x)
            if len(aw.extraser) > x:
                if aw.extraser[x].SP.isOpen():
                    aw.extraser[x].SP.close()
                aw.extraser.pop(x)
            self.createDeviceTable()
            aw.qmc.resetlinecountcaches()
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "delextradevice(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def savedevicetable(self):
        try:
            for i in range(len(aw.qmc.extradevices)):
                typecombobox = self.devicetable.cellWidget(i,0)
                #cellWidget(i,1) and cellWidget(i,2) are saved automatically when there is a change. No need to save here.
                name1edit = self.devicetable.cellWidget(i,3)
                name2edit = self.devicetable.cellWidget(i,4)
                mexpr1edit = self.devicetable.cellWidget(i,5)
                mexpr2edit = self.devicetable.cellWidget(i,6)
                try:
                    aw.qmc.extradevices[i] = aw.qmc.devices.index(str(typecombobox.currentText())) + 1
                except:
                    try: # might be a +device
                        aw.qmc.extradevices[i] = aw.qmc.devices.index("+" + str(typecombobox.currentText())) + 1
                    except:
                        aw.qmc.extradevices[i] = 0
                if name1edit:
                    aw.qmc.extraname1[i] = u(name1edit.text())
                else:
                    aw.qmc.extraname1[i] = u("")
                if name2edit:
                    aw.qmc.extraname2[i] = u(name2edit.text())
                else:
                    aw.qmc.extraname2[i] = u("")
                aw.extraLCDlabel1[i].setText("<b>" + aw.qmc.extraname1[i] + "</b>")
                aw.extraLCDlabel2[i].setText("<b>" + aw.qmc.extraname2[i] + "</b>")
                if mexpr2edit:
                    aw.qmc.extramathexpression1[i] = u(mexpr1edit.text())
                else:
                    aw.qmc.extramathexpression1[i] = u("")
                if mexpr2edit:
                    aw.qmc.extramathexpression2[i] = u(mexpr2edit.text())
                else:
                    aw.qmc.extramathexpression2[i] = u("")
            #update legend with new curves
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "savedevicetable(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def updateLCDvisibility(self,x,lcd,ind):
        if lcd == 1:
            aw.extraLCDvisibility1[ind] = bool(x)
            aw.extraLCDframe1[ind].setVisible(bool(x))
        elif lcd == 2:
            aw.extraLCDvisibility2[ind] = bool(x)
            aw.extraLCDframe2[ind].setVisible(bool(x))

    def updateCurveVisibility(self,x,curve,ind):
        aw.qmc.resetlinecountcaches()
        if curve == 1:
            aw.extraCurveVisibility1[ind] = bool(x)
        elif curve == 2:
            aw.extraCurveVisibility2[ind] = bool(x)

    def setextracolor(self,l,i):
        try:
            #line 1
            if l == 1:
                # use native no buttons dialog on Mac OS X, blocks otherwise
                colorf = aw.colordialog(QColor(aw.qmc.extradevicecolor1[i]),True,self)
                if colorf.isValid():
                    colorname = str(colorf.name())
                    aw.qmc.extradevicecolor1[i] = colorname
                    # set LCD label color
                    aw.setLabelColor(aw.extraLCDlabel1[i],QColor(colorname))
            #line 2
            elif l == 2:
                # use native no buttons dialog on Mac OS X, blocks otherwise
                colorf = aw.colordialog(QColor(aw.qmc.extradevicecolor2[i]),True,self)
                if colorf.isValid():
                    colorname = str(colorf.name())
                    aw.qmc.extradevicecolor2[i] = colorname
                    # set LCD label color
                    aw.setLabelColor(aw.extraLCDlabel2[i],QColor(colorname))
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setextracolor(): %1").arg(str(e)),exc_tb.tb_lineno)

    
    def cancelEvent(self):
        #self.close()
        self.accept()

    def okEvent(self):
        try:
            #save any extra devices here
            self.savedevicetable()
            message = QApplication.translate("Message","Device not set", None, QApplication.UnicodeUTF8)
            # by default switch PID buttons/LCDs off
            aw.button_10.setVisible(False)
#            aw.label6.setVisible(False)
#            aw.lcd6.setVisible(False)
#            aw.label7.setVisible(False)
#            aw.lcd7.setVisible(False)
            aw.LCD6frame.setVisible(False)
            aw.LCD7frame.setVisible(False)
            aw.qmc.resetlinecountcaches()
            aw.ser.arduinoETChannel = str(self.arduinoETComboBox.currentText())
            aw.ser.arduinoBTChannel = str(self.arduinoBTComboBox.currentText())
            aw.ser.arduinoATChannel = str(self.arduinoATComboBox.currentText())
            aw.ser.ArduinoFILT = [sb.value() for sb in self.FILTspinBoxes]
            if self.pidButton.isChecked():
                #type index[0]: 0 = PXG, 1 = PXR, 2 = DTA
                if str(self.controlpidtypeComboBox.currentText()) == "Fuji PXG":
                    aw.ser.controlETpid[0] = 0
                    str1 = "Fuji PXG"
                elif str(self.controlpidtypeComboBox.currentText()) == "Fuji PXR":
                    aw.ser.controlETpid[0] = 1
                    str1 = "Fuji PXR"
                elif str(self.controlpidtypeComboBox.currentText()) == "Delta DTA":
                    aw.ser.controlETpid[0] = 2
                    str1 = "Delta DTA"
                aw.ser.controlETpid[1] =  int(str(self.controlpidunitidComboBox.currentText()))
                if str(self.btpidtypeComboBox.currentText()) == "Fuji PXG":
                    aw.ser.readBTpid[0] = 0
                    str2 = "Fuji PXG"
                elif str(self.btpidtypeComboBox.currentText()) == "Fuji PXR":
                    aw.ser.readBTpid[0] = 1
                    str2 = "Fuji PXR"
                elif str(self.btpidtypeComboBox.currentText()) == "None":
                    aw.ser.readBTpid[0] = 2
                    str2 = "None"
                elif str(self.btpidtypeComboBox.currentText()) == "Delta DTA":
                    aw.ser.readBTpid[0] = 3
                    str2 = "Delta DTA"
                aw.ser.readBTpid[1] =  int(str(self.btpidunitidComboBox.currentText()))
                if self.useModbusPort.isChecked():
                    aw.ser.useModbusPort = True
                else:
                    aw.ser.useModbusPort = False
                #If fuji pid
                if str1 != "Delta DTA":
                    aw.qmc.device = 0
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'O'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                #else if DTA pid
                else:
                    aw.qmc.device = 26
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                message = QApplication.translate("Message","PID to control ET set to %1 %2" + \
                                                 " ; PID to read BT set to %3 %4", None, QApplication.UnicodeUTF8).arg(str1).arg(str(aw.ser.controlETpid[1])).arg(str2).arg(str(aw.ser.readBTpid[1]))
                aw.button_10.setVisible(True)
#                aw.label6.setVisible(True)
#                aw.lcd6.setVisible(True)
#                aw.label7.setVisible(True)
#                aw.lcd7.setVisible(True)
                aw.LCD6frame.setVisible(True)
                aw.LCD7frame.setVisible(True)
            elif self.arduinoButton.isChecked():
                meter = "Arduino (TC4)"
                aw.qmc.device = 19
                aw.ser.baudrate = 115200
                aw.ser.bytesize = 8
                aw.ser.parity= 'N'
                aw.ser.stopbits = 1
                aw.ser.timeout = 1
                aw.ser.ArduinoIsInitialized = 0 # ensure the Arduino gets reinitalized if settings changed
                message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
                if aw.qmc.PIDbuttonflag:
                    aw.button_10.setVisible(True)
            elif self.programButton.isChecked():
                meter = str(self.programedit.text())
                aw.ser.externalprogram = meter
                aw.qmc.device = 27
                message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
            elif self.nonpidButton.isChecked():
                meter = str(self.devicetypeComboBox.currentText())
                if meter == "Omega HH806AU":
                    aw.qmc.device = 1
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Omega HH506RA":
                    aw.qmc.device = 2
                    #aw.ser.comport = "/dev/tty.usbserial-A2001Epn"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 7
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    aw.ser.HH506RAid = "X" # ensure the HH506RA gets reinitalized if settings changed
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 309":
                    aw.qmc.device = 3
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 306":
                    aw.qmc.device = 4
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 305":
                    aw.qmc.device = 5
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to CENTER 305, which is equivalent to CENTER 306. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 304":
                    aw.qmc.device = 6
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 309. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 303":
                    aw.qmc.device = 7
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 302":
                    aw.qmc.device = 8
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 301":
                    aw.qmc.device = 9
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 300":
                    aw.qmc.device = 10
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT K204":
                    aw.qmc.device = 11
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 309. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT K202":
                    aw.qmc.device = 12
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 306. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT 300K":
                    aw.qmc.device = 13
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT 302KJ":
                    aw.qmc.device = 14
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "EXTECH 421509":
                    aw.qmc.device = 15
                    #aw.ser.comport = "/dev/tty.usbserial-A2001Epn"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 7
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to Omega HH506RA. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Omega HH802U":
                    aw.qmc.device = 16
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to Omega HH806AU. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Omega HH309":
                    aw.qmc.device = 17
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                #special device manual mode. No serial settings.
                elif meter == "NONE":
                    aw.qmc.device = 18
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                    st = ""
                    if aw.qmc.delay != aw.qmc.min_delay:
                        aw.qmc.delay = aw.qmc.min_delay
                        st += ". Sampling rate changed to 1 second"
                    # ensure that events button is shown
                    aw.eventsbuttonflag = 1
                    aw.button_11.setVisible(True)
                    message = QApplication.translate("Message","Device set to %1%2", None, QApplication.UnicodeUTF8).arg(meter).arg(st)
                ##########################
                ####  DEVICE 19 is the Arduino/TC4
                ##########################
                elif meter == "TE VA18B":
                    aw.qmc.device = 20
                    #aw.ser.comport = "COM7"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 21 is +309_34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 22 is +FUJI DUTY% but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Omega HHM28[6]":
                    aw.qmc.device = 23
                    #aw.ser.comport = "COM1"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
# +DEVICEs cannot be set as main device
                ##########################
                ####  DEVICE 24 is +VOLTCRAFT 204_34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 25 is +Virtual but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 26 is DTA pid
                ##########################
                ##########################
                ####  DEVICE 27 is an external program
                ##########################
                ##########################
                ####  DEVICE 28 is +ArduinoTC4_34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "MODBUS":
                    aw.qmc.device = 29
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 115200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose Modbus serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT K201":
                    aw.qmc.device = 30
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 302. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Amprobe TMD-56":
                    aw.qmc.device = 31
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to Omega HH806AU. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 32 is +ArduinoTC4_56 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 33 is +MODBUS_34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Phidget 1048":
                    aw.qmc.device = 34
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 35 is +Phidget 1048_34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 36 is +Phidget 1048_AT but +DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "Phidget 1046 RTD":
                    aw.qmc.device = 37
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 38 is +Phidget 1046_34 RTD but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Mastech MS6514":
                    aw.qmc.device = 39
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Phidget IO 12":
                    aw.qmc.device = 40
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 41 is +Phidget IO 34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 42 is +Phidget IO 56 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 43 is +Phidget IO 78 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 44 is +ARDUINOTC4_78 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "Yocto Thermocouple":
                    aw.qmc.device = 45
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                elif meter == "Yocto PT100":
                    aw.qmc.device = 46
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                elif meter == "Phidget 1045 IR":
                    aw.qmc.device = 47
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 48 is an external program _34
                ##########################
                ##########################
                ####  DEVICE 49 is an external program _56
                ##########################
                elif meter == "DUMMY":
                    aw.qmc.device = 50
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 51 is +304_34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Omega HH806W":
                    aw.qmc.device = 52
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 38400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                # ensure that by selecting a real device, the initial sampling rate is set to 3s
                if meter != "NONE":
                    aw.qmc.delay = max(aw.qmc.delay,aw.qmc.min_delay)
    # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
    # - add an elif entry above to specify the default serial settings
            #extra devices serial config
            #set of different serial settings modes options
            ssettings = [[9600,8,'O',1,1],[19200,8,'E',1,1],[2400,7,'E',1,1],[9600,8,'N',1,1],
                         [19200,8,'N',1,1],[2400,8,'N',1,1],[9600,8,'E',1,1],[38400,8,'E',1,1],[115200,8,'N',1,1]]
            #map device index to a setting mode (chose the one that matches the device)
    # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
    # - add an entry to devsettings below (and potentially to ssettings above)
            devssettings = [
                0, # 0
                1, # 1
                2, # 2
                3, # 3
                3, # 4
                3, # 5
                3, # 6
                3, # 7
                3, # 8
                3, # 9
                3, # 10
                3, # 11
                3, # 12
                3, # 13
                3, # 14
                2, # 15
                1, # 16
                3, # 17
                0, # 18
                4, # 19
                5, # 20
                3, # 21
                6, # 22
                5, # 23
                3, # 24
                3, # 25
                6, # 26
                3, # 27
                4, # 28
                8, # 29
                3, # 30
                1, # 31
                4, # 32
                7, # 33
                1, # 34
                1, # 35
                1, # 36
                1, # 37
                1, # 38
                3, # 39
                1, # 40
                1, # 41
                1, # 42
                1, # 43
                4, # 44
                1, # 45
                1, # 46
                1, # 47
                3, # 48
                3, # 49
                3, # 50
                3, # 51
                8] # 52
            #init serial settings of extra devices
            for i in range(len(aw.qmc.extradevices)):
                if aw.qmc.extradevices[i] < len(devssettings) and devssettings[aw.qmc.extradevices[i]] < len(ssettings):
                    dsettings = ssettings[devssettings[aw.qmc.extradevices[i]]]
                    if i < len(aw.extrabaudrate):
                        aw.extrabaudrate[i] = dsettings[0]
                    else:
                        aw.extrabaudrate.append(dsettings[0])
                    if i < len(aw.extrabytesize):
                        aw.extrabytesize[i] = dsettings[1]
                    else:
                        aw.extrabytesize.append(dsettings[1])
                    if i < len(aw.extraparity): 
                        aw.extraparity[i] = dsettings[2]
                    else:
                        aw.extraparity.append(dsettings[2])
                    if i < len(aw.extrastopbits):
                        aw.extrastopbits[i] = dsettings[3]
                    else:
                        aw.extrastopbits.append(dsettings[3])
                    if i < len(aw.extratimeout):
                        aw.extratimeout[i] = dsettings[4]
                    else:
                        aw.extratimeout.append(dsettings[4])
            if self.nonpidButton.isChecked():
                aw.button_10.setVisible(False)
                aw.button_12.setVisible(False)
                aw.button_13.setVisible(False)
                aw.button_14.setVisible(False)
                aw.button_15.setVisible(False)
                aw.button_16.setVisible(False)
                aw.button_17.setVisible(False)
#                aw.label6.setVisible(False)
#                aw.lcd6.setVisible(False)
#                aw.label7.setVisible(False)
#                aw.lcd7.setVisible(False)
                aw.LCD6frame.setVisible(False)
                aw.LCD7frame.setVisible(False)
            aw.qmc.ETfunction = str(self.ETfunctionedit.text())
            aw.qmc.BTfunction = str(self.BTfunctionedit.text())
            aw.qmc.ETcurve = self.ETcurve.isChecked()
            aw.qmc.BTcurve = self.BTcurve.isChecked()
            aw.qmc.ETlcd = self.ETlcd.isChecked()
            aw.qmc.BTlcd = self.BTlcd.isChecked()
            # Phidget configurations
            for i in range(4):
                aw.qmc.phidget1048_types[i] = self.probeTypeCombos[i].currentIndex()+1
                aw.qmc.phidget1048_async[i] = self.asyncCheckBoxes1048[i].isChecked()
                aw.qmc.phidget1048_changeTriggers[i] = aw.qmc.phidget1048_changeTriggersValues[self.changeTriggerCombos1048[i].currentIndex()]
                aw.qmc.phidget1046_gain[i] = self.gainCombos1046[i].currentIndex()+1
                aw.qmc.phidget1046_formula[i] = self.formulaCombos1046[i].currentIndex()
                aw.qmc.phidget1046_async[i] = self.asyncCheckBoxes1046[i].isChecked()
            aw.qmc.phidget1046_dataRate = aw.qmc.phidget_dataRatesValues[self.dataRateCombo1046.currentIndex()]
            if aw.ser.PhidgetBridgeSensor:
                aw.ser.PhidgetBridgeSensorAttached = False
                try:
                    aw.ser.PhidgetBridgeSensor.closePhidget()
                except:
                    pass
                aw.ser.PhidgetBridgeSensor = None
            if aw.ser.PhidgetTemperatureSensor:
                aw.ser.PhidgetTemperatureSensorAttached = False
                try:
                    aw.ser.PhidgetTemperatureSensor.closePhidget()
                except:
                    pass
                aw.ser.PhidgetTemperatureSensor = None                
            aw.qmc.phidget1045_async = self.asyncCheckBoxe1045.isChecked()
            aw.qmc.phidget1045_changeTrigger = aw.qmc.phidget1045_changeTriggersValues[self.changeTriggerCombos1045.currentIndex()]
            aw.qmc.phidget1045_emissivity = self.emissivitySpinBox.value()            
            if aw.qmc.phidget1045_async:
                aw.ser.PhidgetIRSensorSensorAttached = False
                try:
                    aw.ser.PhidgetIRSensor.closePhidget()
                except:
                    pass
                aw.ser.PhidgetIRSensor = None
            aw.qmc.phidgetRemoteFlag = self.phidgetBoxRemoteFlag.isChecked()
            aw.qmc.phidgetServerID = u(self.phidgetServerId.text())
            aw.qmc.phidgetPassword = u(self.phidgetPassword.text())
            asyncMode = False
            for i in range(8):
                aw.qmc.phidget1018_async[i] = self.asyncCheckBoxes[i].isChecked()
                if aw.qmc.phidget1018_async[i] and (i < 2 or (i < 4 and 41 in aw.qmc.extradevices) or (i < 6 and 42 in aw.qmc.extradevices) or (i < 8 and 43 in aw.qmc.extradevices)):
                    asyncMode = True
                aw.qmc.phidget1018_raws[i] = self.rawCheckBoxes[i].isChecked()
                aw.qmc.phidget1018_dataRates[i] = aw.qmc.phidget_dataRatesValues[self.dataRateCombos[i].currentIndex()]
                aw.qmc.phidget1018_changeTriggers[i] = aw.qmc.phidget1018_changeTriggersValues[self.changeTriggerCombos[i].currentIndex()]
            aw.qmc.phidget1018Ratiometric = self.phidgetBoxRatiometricFlag.isChecked()
            try:
                if aw.ser.PhidgetIO and aw.ser.PhidgetIO.isAttached():
                    # set also the raw, changeTrigger and rate things
                    try:
                        for i in range(max(3,aw.ser.PhidgetIO.getSensorCount())):
                            aw.ser.PhidgetIO.setSensorChangeTrigger(i,1000) # "deactivate" triggers for non async channels
                            if i < 2 or (i < 4 and 41 in aw.qmc.extradevices) or (i < 6 and 42 in aw.qmc.extradevices) or (i < 8 and 43 in aw.qmc.extradevices):
                                if not aw.qmc.phidget1018_raws[i] and aw.qmc.phidget1018_async[i]:
                                    aw.ser.PhidgetIO.setSensorChangeTrigger(i,aw.qmc.phidget1018_changeTriggers[i]) # force fixed data rate if 0 (default 10)
                                    aw.ser.PhidgetIO.setDataRate(i, aw.qmc.phidget1018_dataRates[i])
                    except:
                        pass
                    if asyncMode:
                        aw.ser.PhidgetIO.setOnSensorChangeHandler(lambda e=None:aw.ser.phidget1018SensorChanged(e))
                    else:
                        aw.ser.PhidgetIO.setOnSensorChangeHandler(None)
            except:
                pass
            # LCD visibility
            aw.LCD2frame.setVisible(aw.qmc.ETlcd)
            aw.LCD3frame.setVisible(aw.qmc.BTlcd)
            if aw.largeLCDs_dialog:
                try:
                    aw.largeLCDs_dialog.lcd2.setVisible(aw.qmc.ETlcd)
                    aw.largeLCDs_dialog.lcd3.setVisible(aw.qmc.BTlcd)
                except:
                    pass
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.sendmessage(message)
            #open serial conf Dialog
            #if device is not None or not external-program (don't need serial settings config)
            # "ADD DEVICE:"
            if not(aw.qmc.device in [18,27,34,37,40,41,45,46,47,48,49,50,51]):
                aw.setcommport()
            #self.close()
            self.accept()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " device accept(): %1").arg(str(e)),exc_tb.tb_lineno)

############################################################
#######################  CUSTOM COLOR DIALOG  ##############
############################################################

class graphColorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(graphColorDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Colors", None, QApplication.UnicodeUTF8))
        frameStyle = QFrame.Sunken | QFrame.Panel
        #TAB1
        self.backgroundLabel = QLabel(aw.qmc.palette["background"])
        self.backgroundLabel.setPalette(QPalette(QColor(aw.qmc.palette["background"])))
        self.backgroundLabel.setAutoFillBackground(True)
        self.backgroundButton = QPushButton(QApplication.translate("Button","Background", None, QApplication.UnicodeUTF8))
        self.backgroundButton.setFocusPolicy(Qt.NoFocus)
        self.backgroundLabel.setFrameStyle(frameStyle)
        self.connect(self.backgroundButton, SIGNAL("clicked()"), lambda var=self.backgroundLabel,color="background": self.setColor("Background",var,color))
        self.gridLabel =QLabel(aw.qmc.palette["grid"])
        self.gridLabel.setPalette(QPalette(QColor(aw.qmc.palette["grid"])))
        self.gridLabel.setAutoFillBackground(True)
        self.gridButton = QPushButton(QApplication.translate("Button","Grid", None, QApplication.UnicodeUTF8))
        self.gridButton.setFocusPolicy(Qt.NoFocus)
        self.gridLabel.setFrameStyle(frameStyle)
        self.connect(self.gridButton, SIGNAL("clicked()"), lambda var=self.gridLabel, color= "grid": self.setColor("Grid",var,color))
        self.titleLabel =QLabel(aw.qmc.palette["title"])
        self.titleLabel.setPalette(QPalette(QColor(aw.qmc.palette["title"])))
        self.titleLabel.setAutoFillBackground(True)
        self.titleButton = QPushButton(QApplication.translate("Button","Title", None, QApplication.UnicodeUTF8))
        self.titleButton.setFocusPolicy(Qt.NoFocus)
        self.titleLabel.setFrameStyle(frameStyle)
        self.connect(self.titleButton, SIGNAL("clicked()"), lambda var=self.titleLabel,color="title": self.setColor("Title",var,color))
        self.yLabel =QLabel(aw.qmc.palette["ylabel"])
        self.yLabel.setPalette(QPalette(QColor(aw.qmc.palette["ylabel"])))
        self.yLabel.setAutoFillBackground(True)
        self.yButton = QPushButton(QApplication.translate("Button","Y Label", None, QApplication.UnicodeUTF8))
        self.yButton.setFocusPolicy(Qt.NoFocus)
        self.yLabel.setFrameStyle(frameStyle)
        self.connect(self.yButton, SIGNAL("clicked()"), lambda var=self.yLabel,color="ylabel": self.setColor("Y Label",var,color))
        self.xLabel =QLabel(aw.qmc.palette["xlabel"])
        self.xLabel.setPalette(QPalette(QColor(aw.qmc.palette["xlabel"])))
        self.xLabel.setAutoFillBackground(True)
        self.xButton = QPushButton(QApplication.translate("Button","X Label", None, QApplication.UnicodeUTF8))
        self.xButton.setFocusPolicy(Qt.NoFocus)
        self.xLabel.setFrameStyle(frameStyle)
        self.connect(self.xButton, SIGNAL("clicked()"), lambda var=self.xLabel,color="xlabel": self.setColor("X Label",var,color))
        self.rect1Label =QLabel(aw.qmc.palette["rect1"])
        self.rect1Label.setPalette(QPalette(QColor(aw.qmc.palette["rect1"])))
        self.rect1Label.setAutoFillBackground(True)
        self.rect1Button = QPushButton(QApplication.translate("Button","Drying Phase", None, QApplication.UnicodeUTF8))
        self.rect1Button.setFocusPolicy(Qt.NoFocus)
        self.rect1Label.setFrameStyle(frameStyle)
        self.connect(self.rect1Button, SIGNAL("clicked()"), lambda var=self.rect1Label,color="rect1": self.setColor("Drying Phase",var,color))
        self.rect2Label =QLabel(aw.qmc.palette["rect2"])
        self.rect2Label.setPalette(QPalette(QColor(aw.qmc.palette["rect2"])))
        self.rect2Label.setAutoFillBackground(True)
        self.rect2Button = QPushButton(QApplication.translate("Button","Maillard Phase", None, QApplication.UnicodeUTF8))
        self.rect2Button.setFocusPolicy(Qt.NoFocus)
        self.rect2Label.setFrameStyle(frameStyle)
        self.connect(self.rect2Button, SIGNAL("clicked()"), lambda var=self.rect2Label,color="rect2": self.setColor("Maillard Phase",var,color))
        self.rect3Label =QLabel(aw.qmc.palette["rect3"])
        self.rect3Label.setPalette(QPalette(QColor(aw.qmc.palette["rect3"])))
        self.rect3Label.setAutoFillBackground(True)
        self.rect3Button = QPushButton(QApplication.translate("Button","Development Phase", None, QApplication.UnicodeUTF8))
        self.rect3Button.setFocusPolicy(Qt.NoFocus)
        self.rect3Label.setFrameStyle(frameStyle)
        self.connect(self.rect3Button, SIGNAL("clicked()"), lambda var=self.rect3Label,color="rect3": self.setColor("Development Phase",var,color))
        self.rect4Label =QLabel(aw.qmc.palette["rect4"])
        self.rect4Label.setPalette(QPalette(QColor(aw.qmc.palette["rect4"])))
        self.rect4Label.setAutoFillBackground(True)
        self.rect4Button = QPushButton(QApplication.translate("Button","Cooling Phase", None, QApplication.UnicodeUTF8))
        self.rect4Button.setFocusPolicy(Qt.NoFocus)
        self.rect4Label.setFrameStyle(frameStyle)
        self.connect(self.rect4Button, SIGNAL("clicked()"), lambda var=self.rect4Label,color="rect4": self.setColor("Cooling Phase",var,color))
        self.metLabel =QLabel(aw.qmc.palette["et"])
        self.metLabel.setPalette(QPalette(QColor(aw.qmc.palette["et"])))
        self.metLabel.setAutoFillBackground(True)
        self.metButton = QPushButton(QApplication.translate("Button","ET", None, QApplication.UnicodeUTF8))
        self.metButton.setFocusPolicy(Qt.NoFocus)
        self.metLabel.setFrameStyle(frameStyle)
        self.connect(self.metButton, SIGNAL("clicked()"), lambda var=self.metLabel,color="et": self.setColor("ET",var,color))
        self.btLabel =QLabel(aw.qmc.palette["bt"])
        self.btLabel.setPalette(QPalette(QColor(aw.qmc.palette["bt"])))
        self.btLabel.setAutoFillBackground(True)
        self.btButton = QPushButton(QApplication.translate("Button","BT", None, QApplication.UnicodeUTF8))
        self.btButton.setFocusPolicy(Qt.NoFocus)
        self.btLabel.setFrameStyle(frameStyle)
        self.connect(self.btButton, SIGNAL("clicked()"), lambda var=self.btLabel,color="bt": self.setColor("BT",var,color))
        self.deltametLabel =QLabel(aw.qmc.palette["deltaet"])
        self.deltametLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltaet"])))
        self.deltametLabel.setAutoFillBackground(True)
        self.deltametButton = QPushButton(QApplication.translate("Button","DeltaET", None, QApplication.UnicodeUTF8))
        self.deltametButton.setFocusPolicy(Qt.NoFocus)
        self.deltametLabel.setFrameStyle(frameStyle)
        self.connect(self.deltametButton, SIGNAL("clicked()"), lambda var=self.deltametLabel,color="deltaet": self.setColor("DeltaET",var,color))
        self.deltabtLabel =QLabel(aw.qmc.palette["deltabt"])
        self.deltabtLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltabt"])))
        self.deltabtLabel.setAutoFillBackground(True)
        self.deltabtButton = QPushButton(QApplication.translate("Button","DeltaBT", None, QApplication.UnicodeUTF8))
        self.deltabtButton.setFocusPolicy(Qt.NoFocus)
        self.deltabtLabel.setFrameStyle(frameStyle)
        self.connect(self.deltabtButton, SIGNAL("clicked()"), lambda var=self.deltabtLabel,color="deltabt": self.setColor("DeltaBT",var,color))
        self.markersLabel =QLabel(aw.qmc.palette["markers"])
        self.markersLabel.setPalette(QPalette(QColor(aw.qmc.palette["markers"])))
        self.markersLabel.setAutoFillBackground(True)
        self.markersButton = QPushButton(QApplication.translate("Button","Markers", None, QApplication.UnicodeUTF8))
        self.markersButton.setFocusPolicy(Qt.NoFocus)
        self.markersLabel.setFrameStyle(frameStyle)
        self.connect(self.markersButton, SIGNAL("clicked()"), lambda var=self.markersLabel,color="markers": self.setColor("Markers",var,color))
        self.textLabel =QLabel(aw.qmc.palette["text"])
        self.textLabel.setPalette(QPalette(QColor(aw.qmc.palette["text"])))
        self.textLabel.setAutoFillBackground(True)
        self.textButton = QPushButton(QApplication.translate("Button","Text", None, QApplication.UnicodeUTF8))
        self.textButton.setFocusPolicy(Qt.NoFocus)
        self.textLabel.setFrameStyle(frameStyle)
        self.connect(self.textButton, SIGNAL("clicked()"), lambda var=self.textLabel,color="text": self.setColor("Text",var,color))
        self.watermarksLabel =QLabel(aw.qmc.palette["watermarks"])
        self.watermarksLabel.setPalette(QPalette(QColor(aw.qmc.palette["watermarks"])))
        self.watermarksLabel.setAutoFillBackground(True)
        self.watermarksButton = QPushButton(QApplication.translate("Button","Watermarks", None, QApplication.UnicodeUTF8))
        self.watermarksButton.setFocusPolicy(Qt.NoFocus)
        self.watermarksLabel.setFrameStyle(frameStyle)
        self.connect(self.watermarksButton, SIGNAL("clicked()"), lambda var=self.watermarksLabel,color="watermarks": self.setColor("Watermarks",var,color))
        self.ClineLabel =QLabel(aw.qmc.palette["Cline"])
        self.ClineLabel.setPalette(QPalette(QColor(aw.qmc.palette["Cline"])))
        self.ClineLabel.setAutoFillBackground(True)
        self.ClineButton = QPushButton(QApplication.translate("Button","C Lines", None, QApplication.UnicodeUTF8))
        self.ClineButton.setFocusPolicy(Qt.NoFocus)
        self.ClineLabel.setFrameStyle(frameStyle)
        self.connect(self.ClineButton, SIGNAL("clicked()"), lambda var=self.ClineLabel,color="Cline": self.setColor("C Lines",var,color))
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        defaultsButton = QPushButton(QApplication.translate("Button","Defaults", None, QApplication.UnicodeUTF8))
        defaultsButton.setFocusPolicy(Qt.NoFocus)
        self.connect(defaultsButton, SIGNAL("clicked()"),lambda x=1:self.recolor(x))
        greyButton = QPushButton(QApplication.translate("Button","Grey", None, QApplication.UnicodeUTF8))
        greyButton.setFocusPolicy(Qt.NoFocus)
        self.connect(greyButton, SIGNAL("clicked()"),lambda x=2:self.recolor(x))
        #TAB 2
        #use indexes to translate
        self.lcdcolors = ["","grey","darkGrey","slateGrey","lightGray","black","white","transparent"]     #this one is not to be translated as arguments need to be in English
        lcdcolorstranslate = ["",
                              QApplication.translate("ComboBox","grey",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Dark Grey",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Slate Grey",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Light Gray",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Black",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","White",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Transparent",None, QApplication.UnicodeUTF8)]  # translated
        self.lcd1colorComboBox =  QComboBox()
        self.lcd1colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd1colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd1colorComboBox.currentText(),flag = 2,x=1:self.paintlcds(text,flag,x))
        self.lcd2colorComboBox =  QComboBox()
        self.lcd2colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd2colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd2colorComboBox.currentText(),flag = 2,x=2:self.paintlcds(text,flag,x))
        self.lcd3colorComboBox =  QComboBox()
        self.lcd3colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd3colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd3colorComboBox.currentText(),flag = 2,x=3:self.paintlcds(text,flag,x))
        self.lcd4colorComboBox =  QComboBox()
        self.lcd4colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd4colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd4colorComboBox.currentText(),flag = 2,x=4:self.paintlcds(text,flag,x))
        self.lcd5colorComboBox =  QComboBox()
        self.lcd5colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd5colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd5colorComboBox.currentText(),flag = 2,x=5:self.paintlcds(text,flag,x))
        self.lcd6colorComboBox =  QComboBox()
        self.lcd6colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd6colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd6colorComboBox.currentText(),flag = 2,x=6:self.paintlcds(text,flag,x))
        lcd1backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd1backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=1:self.paintlcds(text,flag,x))
        lcd2backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd2backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=2:self.paintlcds(text,flag,x))
        lcd3backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd3backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=3:self.paintlcds(text,flag,x))
        lcd4backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd4backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=4:self.paintlcds(text,flag,x))
        lcd5backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd5backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=5:self.paintlcds(text,flag,x))
        lcd6backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd6backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=6:self.paintlcds(text,flag,x))
        lcd1LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd1LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=1:self.paintlcds(text,flag,x))
        lcd2LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd2LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=2:self.paintlcds(text,flag,x))
        lcd3LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd3LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=3:self.paintlcds(text,flag,x))
        lcd4LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd4LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=4:self.paintlcds(text,flag,x))
        lcd5LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd5LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=5:self.paintlcds(text,flag,x))
        lcd6LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd6LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=6:self.paintlcds(text,flag,x))
        self.lcd1spinbox = QSpinBox()
        self.lcd1spinbox.setSingleStep(10)
        self.lcd1spinbox.setMaximum(359)
        self.lcd1spinbox.setWrapping(True)
        self.connect(self.lcd1spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd1spinbox.value(),lcd=1:self.setLED(val,lcd))
        self.lcd2spinbox = QSpinBox()
        self.lcd2spinbox.setSingleStep(10)
        self.lcd2spinbox.setWrapping(True)
        self.lcd2spinbox.setMaximum(359)
        self.connect(self.lcd2spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd2spinbox.value(),lcd=2:self.setLED(val,lcd))
        self.lcd3spinbox = QSpinBox()
        self.lcd3spinbox.setSingleStep(10)
        self.lcd3spinbox.setWrapping(True)
        self.lcd3spinbox.setMaximum(359)
        self.connect(self.lcd3spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd3spinbox.value(),lcd=3:self.setLED(val,lcd))
        self.lcd4spinbox = QSpinBox()
        self.lcd4spinbox.setSingleStep(10)
        self.lcd4spinbox.setWrapping(True)
        self.lcd4spinbox.setMaximum(359)
        self.connect(self.lcd4spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd4spinbox.value(),lcd=4:self.setLED(val,lcd))
        self.lcd5spinbox = QSpinBox()
        self.lcd5spinbox.setSingleStep(10)
        self.lcd5spinbox.setWrapping(True)
        self.lcd5spinbox.setMaximum(359)
        self.connect(self.lcd5spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd5spinbox.value(),lcd=5:self.setLED(val,lcd))
        self.lcd6spinbox = QSpinBox()
        self.lcd6spinbox.setSingleStep(10)
        self.lcd6spinbox.setWrapping(True)
        self.lcd6spinbox.setMaximum(359)
        self.connect(self.lcd6spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd6spinbox.value(),lcd=6:self.setLED(val,lcd))
        LCDdefaultButton = QPushButton(QApplication.translate("Button","B/W",None, QApplication.UnicodeUTF8))
        self.connect(LCDdefaultButton, SIGNAL("clicked()"),self.setLCDdefaults)
        #LAYOUTS
        #tab1 layout
        grid = QGridLayout()
        grid.setColumnStretch(1,10)
        grid.setVerticalSpacing(1)
        grid.setColumnMinimumWidth(1,200)
        grid.addWidget(self.backgroundButton,0,0)
        grid.addWidget(self.backgroundLabel,0,1)
        grid.addWidget(self.titleButton,1,0)
        grid.addWidget(self.titleLabel,1,1)
        grid.addWidget(self.gridButton,2,0)
        grid.addWidget(self.gridLabel,2,1)
        grid.addWidget(self.metButton,3,0)
        grid.addWidget(self.metLabel,3,1)
        grid.addWidget(self.btButton,4,0)
        grid.addWidget(self.btLabel,4,1)
        grid.addWidget(self.deltametButton,5,0)
        grid.addWidget(self.deltametLabel,5,1)
        grid.addWidget(self.deltabtButton,6,0)
        grid.addWidget(self.deltabtLabel,6,1)
        grid.addWidget(self.yButton,7,0)
        grid.addWidget(self.yLabel,7,1)
        grid.addWidget(self.xButton,8,0)
        grid.addWidget(self.xLabel,8,1)
        grid.addWidget(self.rect1Button,9,0)
        grid.addWidget(self.rect1Label,9,1)
        grid.addWidget(self.rect2Button,10,0)
        grid.addWidget(self.rect2Label,10,1)
        grid.addWidget(self.rect3Button,11,0)
        grid.addWidget(self.rect3Label,11,1)
        grid.addWidget(self.rect4Button,12,0)
        grid.addWidget(self.rect4Label,12,1)
        grid.addWidget(self.markersButton,13,0)
        grid.addWidget(self.markersLabel,13,1)
        grid.addWidget(self.textButton,14,0)
        grid.addWidget(self.textLabel,14,1)
        grid.addWidget(self.watermarksButton,15,0)
        grid.addWidget(self.watermarksLabel,15,1)
        grid.addWidget(self.ClineButton,16,0)
        grid.addWidget(self.ClineLabel,16,1)
        defaultsLayout = QHBoxLayout()
        defaultsLayout.addStretch()
        defaultsLayout.addWidget(greyButton)
        defaultsLayout.addWidget(defaultsButton)
        defaultsLayout.addWidget(okButton)
        grid.addLayout(defaultsLayout,17,1)
        graphLayout = QVBoxLayout()
        graphLayout.addLayout(grid)
        #tab 2
        lcdlayout = QVBoxLayout()
        lcd1layout = QHBoxLayout()
        lcd1layout.addWidget(lcd1backButton,0)
        lcd1layout.addWidget(self.lcd1colorComboBox,1)
        lcd1layout.addWidget(lcd1LEDButton,2)
        lcd1layout.addWidget(self.lcd1spinbox,3)
        lcd2layout = QHBoxLayout()
        lcd2layout.addWidget(lcd2backButton,0)
        lcd2layout.addWidget(self.lcd2colorComboBox,1)
        lcd2layout.addWidget(lcd2LEDButton,2)
        lcd2layout.addWidget(self.lcd2spinbox,3)
        lcd3layout = QHBoxLayout()
        lcd3layout.addWidget(lcd3backButton,0)
        lcd3layout.addWidget(self.lcd3colorComboBox,1)
        lcd3layout.addWidget(lcd3LEDButton,2)
        lcd3layout.addWidget(self.lcd3spinbox,3)
        lcd4layout = QHBoxLayout()
        lcd4layout.addWidget(lcd4backButton,0)
        lcd4layout.addWidget(self.lcd4colorComboBox,1)
        lcd4layout.addWidget(lcd4LEDButton,2)
        lcd4layout.addWidget(self.lcd4spinbox,3)
        lcd5layout = QHBoxLayout()
        lcd5layout.addWidget(lcd5backButton,0)
        lcd5layout.addWidget(self.lcd5colorComboBox,1)
        lcd5layout.addWidget(lcd5LEDButton,2)
        lcd5layout.addWidget(self.lcd5spinbox,3)
        lcd6layout = QHBoxLayout()
        lcd6layout.addWidget(lcd6backButton,0)
        lcd6layout.addWidget(self.lcd6colorComboBox,1)
        lcd6layout.addWidget(lcd6LEDButton,2)
        lcd6layout.addWidget(self.lcd6spinbox,3)
        LCD1GroupLayout = QGroupBox(QApplication.translate("GroupBox","Timer LCD",None, QApplication.UnicodeUTF8))
        LCD1GroupLayout.setLayout(lcd1layout)
        lcd1layout.setMargin(0)
        LCD2GroupLayout = QGroupBox(QApplication.translate("GroupBox","ET LCD",None, QApplication.UnicodeUTF8))
        LCD2GroupLayout.setLayout(lcd2layout)
        lcd2layout.setMargin(0)
        LCD3GroupLayout = QGroupBox(QApplication.translate("GroupBox","BT LCD",None, QApplication.UnicodeUTF8))
        LCD3GroupLayout.setLayout(lcd3layout)
        lcd3layout.setMargin(0)
        LCD4GroupLayout = QGroupBox(QApplication.translate("GroupBox","DeltaET LCD",None, QApplication.UnicodeUTF8))
        LCD4GroupLayout.setLayout(lcd4layout)
        lcd4layout.setMargin(0)
        LCD5GroupLayout = QGroupBox(QApplication.translate("GroupBox","DeltaBT LCD",None, QApplication.UnicodeUTF8))
        LCD5GroupLayout.setLayout(lcd5layout)
        lcd5layout.setMargin(0)
        LCD6GroupLayout = QGroupBox(QApplication.translate("GroupBox","Extra Devices / PID SV LCD",None, QApplication.UnicodeUTF8))
        LCD6GroupLayout.setLayout(lcd6layout)
        lcd6layout.setMargin(0)
        buttonlayout  = QHBoxLayout()
        buttonlayout.addStretch()
        buttonlayout.addWidget(LCDdefaultButton)
        buttonlayout.setMargin(0)
        buttonlayout.setSpacing(0)
        lcdlayout.addWidget(LCD1GroupLayout)
        lcdlayout.addWidget(LCD2GroupLayout)
        lcdlayout.addWidget(LCD3GroupLayout)
        lcdlayout.addWidget(LCD4GroupLayout)
        lcdlayout.addWidget(LCD5GroupLayout)
        lcdlayout.addWidget(LCD6GroupLayout)
        lcdlayout.addLayout(buttonlayout)
        lcdlayout.setMargin(0)
        lcdlayout.setSpacing(0)
        ###################################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(graphLayout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","Graph",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(lcdlayout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","LCDs",None, QApplication.UnicodeUTF8))
        okLayout = QHBoxLayout()
        okLayout.addStretch()
        okLayout.addWidget(okButton)
        okLayout.setMargin(0)
        okLayout.setContentsMargins(0, 0, 0, 0)
        TabWidget.setContentsMargins(0, 0, 0, 0)
        C1Widget.setContentsMargins(0, 0, 0, 0)
        C2Widget.setContentsMargins(0, 0, 0, 0)
        graphLayout.setMargin(0)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(okLayout)
        Mlayout.setMargin(10)
        Mlayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(Mlayout)

    def setLCDdefaults(self):
        aw.lcdpaletteB["timer"] = "black"
        aw.lcdpaletteF["timer"] = "white"
        aw.lcdpaletteB["et"] = "black"
        aw.lcdpaletteF["et"] = "white"
        aw.lcdpaletteB["bt"] = "black"
        aw.lcdpaletteF["bt"] = "white"
        aw.lcdpaletteB["deltaet"] = "black"
        aw.lcdpaletteF["deltaet"] = "white"
        aw.lcdpaletteB["deltabt"] = "black"
        aw.lcdpaletteF["deltabt"] = "white"
        aw.lcdpaletteB["sv"] = "black"
        aw.lcdpaletteF["sv"] = "white"
        aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        aw.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        aw.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        aw.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        aw.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        aw.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        aw.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        aw.updateExtraLCDvisibility()

    def setLED(self,hue,lcd):
        if lcd == 1:
            color = QColor(aw.lcdpaletteF["timer"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["timer"] = str(color.name())
            aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        elif lcd == 2:
            color = QColor(aw.lcdpaletteF["et"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["et"] = str(color.name())
            aw.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        elif lcd == 3:
            color = QColor(aw.lcdpaletteF["bt"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["bt"] = str(color.name())
            aw.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        elif lcd == 4:
            color = QColor(aw.lcdpaletteF["deltaet"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["deltaet"] = str(color.name())
            aw.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        elif lcd == 5:
            color = QColor(aw.lcdpaletteF["deltabt"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["deltabt"] = str(color.name())
            aw.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        elif lcd == 6:
            color = QColor(aw.lcdpaletteF["sv"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["sv"] = str(color.name())
            aw.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))

    def paintlcds(self,text,flag,lcdnumber):
        if lcdnumber ==1:
            if flag == 0:
                aw.lcdpaletteB["timer"] = str((aw.colordialog(QColor(aw.lcdpaletteB["timer"]))).name())
            elif flag == 1:
                aw.lcdpaletteF["timer"] = str((aw.colordialog(QColor(aw.lcdpaletteF["timer"]))).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["timer"] = self.lcdcolors[self.lcd1colorComboBox.currentIndex()]
            aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        if lcdnumber ==2:
            if flag == 0:
                aw.lcdpaletteB["et"] = str((aw.colordialog(QColor(aw.lcdpaletteB["et"]))).name())
            elif flag == 1:
                aw.lcdpaletteF["et"] = str((aw.colordialog(QColor(aw.lcdpaletteF["et"]))).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["et"] = self.lcdcolors[self.lcd2colorComboBox.currentIndex()]
            aw.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        if lcdnumber ==3:
            if flag == 0:
                aw.lcdpaletteB["bt"] = str((aw.colordialog(QColor(aw.lcdpaletteB["bt"]))).name())
            elif flag == 1:
                aw.lcdpaletteF["bt"] = str((aw.colordialog(QColor(aw.lcdpaletteF["bt"]))).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["bt"] = self.lcdcolors[self.lcd3colorComboBox.currentIndex()]
            aw.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        if lcdnumber ==4:
            if flag == 0:
                aw.lcdpaletteB["deltaet"] = str((aw.colordialog(QColor(aw.lcdpaletteB["deltaet"]))).name())
            elif flag == 1:
                aw.lcdpaletteF["deltaet"] = str((aw.colordialog(QColor(aw.lcdpaletteF["deltaet"]))).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["deltaet"] = self.lcdcolors[self.lcd4colorComboBox.currentIndex()]
            aw.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        if lcdnumber ==5:
            if flag == 0:
                aw.lcdpaletteB["deltabt"] = str((aw.colordialog(QColor(aw.lcdpaletteB["deltabt"]))).name())
            elif flag == 1:
                aw.lcdpaletteF["deltabt"] = str((aw.colordialog(QColor(aw.lcdpaletteF["deltabt"]))).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["deltabt"] = self.lcdcolors[self.lcd5colorComboBox.currentIndex()]
            aw.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        if lcdnumber ==6:
            if flag == 0:
                aw.lcdpaletteB["sv"] = str((aw.colordialog(QColor(aw.lcdpaletteB["sv"]))).name())
            elif flag == 1:
                aw.lcdpaletteF["sv"] = str((aw.colordialog(QColor(aw.lcdpaletteF["sv"]))).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["sv"] = self.lcdcolors[self.lcd6colorComboBox.currentIndex()]
            aw.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.updateExtraLCDvisibility()

    # adds a new event to the Dlg
    def recolor(self, x):
        aw.qmc.changeGColor(x)
        self.gridLabel.setText(aw.qmc.palette["grid"])
        self.gridLabel.setPalette(QPalette(QColor(aw.qmc.palette["grid"])))
        self.backgroundLabel.setText(aw.qmc.palette["background"])
        self.backgroundLabel.setPalette(QPalette(QColor(aw.qmc.palette["background"])))
        self.titleLabel.setText(aw.qmc.palette["title"])
        self.titleLabel.setPalette(QPalette(QColor(aw.qmc.palette["title"])))
        self.yLabel.setText(aw.qmc.palette["ylabel"])
        self.yLabel.setPalette(QPalette(QColor(aw.qmc.palette["ylabel"])))
        self.xLabel.setText(aw.qmc.palette["xlabel"])
        self.xLabel.setPalette(QPalette(QColor(aw.qmc.palette["xlabel"])))
        self.rect1Label.setText(aw.qmc.palette["rect1"])
        self.rect1Label.setPalette(QPalette(QColor(aw.qmc.palette["rect1"])))
        self.rect2Label.setText(aw.qmc.palette["rect2"])
        self.rect2Label.setPalette(QPalette(QColor(aw.qmc.palette["rect2"])))
        self.rect3Label.setText(aw.qmc.palette["rect3"])
        self.rect3Label.setPalette(QPalette(QColor(aw.qmc.palette["rect3"])))
        self.rect4Label.setText(aw.qmc.palette["rect4"])
        self.rect4Label.setPalette(QPalette(QColor(aw.qmc.palette["rect4"])))
        self.metLabel.setText(aw.qmc.palette["et"])
        self.metLabel.setPalette(QPalette(QColor(aw.qmc.palette["et"])))
        self.btLabel.setText(aw.qmc.palette["bt"])
        self.btLabel.setPalette(QPalette(QColor(aw.qmc.palette["bt"])))
        self.deltametLabel.setText(aw.qmc.palette["deltaet"])
        self.deltametLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltaet"])))
        self.deltabtLabel.setText(aw.qmc.palette["deltabt"])
        self.deltabtLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltabt"])))
        self.markersLabel.setText(aw.qmc.palette["markers"])
        self.markersLabel.setPalette(QPalette(QColor(aw.qmc.palette["markers"])))
        self.textLabel.setText(aw.qmc.palette["text"])
        self.textLabel.setPalette(QPalette(QColor(aw.qmc.palette["text"])))
        self.watermarksLabel.setText(aw.qmc.palette["watermarks"])
        self.watermarksLabel.setPalette(QPalette(QColor(aw.qmc.palette["watermarks"])))
        self.ClineLabel.setText(aw.qmc.palette["Cline"])
        self.ClineLabel.setPalette(QPalette(QColor(aw.qmc.palette["Cline"])))

    def setColor(self,title,var,color):
        labelcolor = QColor(aw.qmc.palette[color])
        colorf = aw.colordialog(labelcolor)
        if colorf.isValid():
            aw.qmc.palette[color] = str(colorf.name())
            var.setText(colorf.name())
            var.setPalette(QPalette(colorf))
            var.setAutoFillBackground(True)
            aw.qmc.fig.canvas.redraw(recomputeAllDeltas=False)
            if title == "ET":
                aw.setLabelColor(aw.label2,QColor(aw.qmc.palette[color]))
            elif title == "BT":
                aw.setLabelColor(aw.label3,QColor(aw.qmc.palette[color]))
            elif title == "DeltaET":
                aw.setLabelColor(aw.label4,QColor(aw.qmc.palette[color]))
            elif title == "DeltaBT":
                aw.setLabelColor(aw.label5,QColor(aw.qmc.palette[color]))
            aw.sendmessage(QApplication.translate("Message","Color of %1 set to %2", None, QApplication.UnicodeUTF8).arg(title).arg(str(aw.qmc.palette[color])))

############################################################
#######################  LARGE LCDs DIALOG  ################
############################################################

class LargeLCDs(ArtisanDialog):
    def __init__(self, parent = None):
        super(LargeLCDs,self).__init__(parent)
        self.lcd1 = None # Timer
        self.lcd2 = None # ET
        self.lcd3 = None # BT
        settings = QSettings()
        if settings.contains("LCDGeometry"):
            self.restoreGeometry(settings.value("LCDGeometry").toByteArray())
        self.resized = False # prevent first resizing event handling
        self.layoutNr = -1 # 0: landscape, 1: landscape tight, 2: portrait         
        self.chooseLayout(self.width(),self.height())
        
        self.resizeEvent = self.resizeDialog
        
    def makeLCD(self,s,tight=False):    
        lcd = QLCDNumber() # Temperature BT
        lcd.setSegmentStyle(2)
        lcd.setFrameStyle(QFrame.Plain)        
        if s == "timer":
            lcd.setDigitCount(5)
            lcd.display("00:00")
        else:
            lcd.setSmallDecimalPoint(True)
            if aw.qmc.LCDdecimalplaces:
                if tight:
                    lcd.setDigitCount(4)
                    lcd.display("  -.-")
                else:
                    lcd.setDigitCount(5)
                    lcd.display("   -.-")
            else:
                if tight:
                    lcd.setDigitCount(3)
                    lcd.display(" --")
                else:
                    lcd.setDigitCount(4)
                    lcd.display("  --")
            if s == "et":
                lcd.setVisible(aw.qmc.ETlcd)
            elif s == "bt":
                lcd.setVisible(aw.qmc.BTlcd)
        lcd.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
        return lcd
        
    # tight 0: leading space on lcd2 and lcd 1, 1: leading space on lcd3, 2: no leading spaces
    def makeLCDs(self,tight=False):
        # time LCD
        self.lcd1 = self.makeLCD("timer",False) # time
        # ET
        self.lcd2 = self.makeLCD("et",tight) # Temperature ET
        # BT
        self.lcd3 = self.makeLCD("bt",tight) # Temperature BT
        
    def landscapeLayout(self):
        self.makeLCDs()
        templayout = QHBoxLayout()
        templayout.addWidget(self.lcd2)
        templayout.addWidget(self.lcd3)
        landscapelayout = QVBoxLayout()
        landscapelayout.addWidget(self.lcd1)
        landscapelayout.addLayout(templayout)
        landscapelayout.setSpacing(0)
        landscapelayout.setContentsMargins(0, 0, 0, 0)
        return landscapelayout
        
    def landscapeTightLayout(self):
        self.makeLCDs()
        landscapetightlayout = QHBoxLayout()
        landscapetightlayout.addWidget(self.lcd1)
        landscapetightlayout.addWidget(self.lcd2)
        landscapetightlayout.addWidget(self.lcd3)
        landscapetightlayout.setSpacing(0)
        landscapetightlayout.setContentsMargins(0, 0, 0, 0)
        return landscapetightlayout
        
    def portraitLayout(self):
        self.makeLCDs(tight=True)
        portraitlayout = QVBoxLayout()
        portraitlayout.addWidget(self.lcd1)
        portraitlayout.addWidget(self.lcd2)
        portraitlayout.addWidget(self.lcd3)
        portraitlayout.setSpacing(0)
        portraitlayout.setContentsMargins(0, 0, 0, 0)
        return portraitlayout
                
    # n the number of layout to be set (0: landscape, 1: landscape tight, 2: portrait)
    def reLayout(self,n):
        if self.layoutNr != n:
            # release old layout
            if self.layout():
                QWidget().setLayout(self.layout())
            # install the new layout
            if n == 0:
                self.setLayout(self.landscapeLayout())
            elif n == 1:
                self.setLayout(self.landscapeTightLayout())
            elif n == 2:
                self.setLayout(self.portraitLayout())
        self.layoutNr = n
    
    def chooseLayout(self,w,h):
        if w > h:
            if w > 3*h:
                self.reLayout(1)
            else:
                self.reLayout(0)
        else:
            self.reLayout(2)
        
    def resizeDialog(self,event):
        if self.resized:
            w = event.size().width()
            h = event.size().height()
            self.chooseLayout(w,h)
        else:
            self.resized = True
        
    def closeEvent(self, event):
        settings = QSettings()
        #save window geometry
        settings.setValue("LCDGeometry",QVariant(self.saveGeometry()))
        aw.largeLCDs_dialog = None
        aw.LargeLCDs = False

############################################################
#######################  WHEEL GRAPH CONFIG DIALOG  ########
############################################################

class WheelDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(WheelDlg,self).__init__(parent)
        
        rcParams['path.effects'] = []
            
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Wheel Graph Editor",None, QApplication.UnicodeUTF8))
        self.viewmodeflag = False
        #table for alarms
        self.datatable = QTableWidget()
        self.createdatatable()
        #table for labels
        self.labeltable = QTableWidget()
        self.labelCloseButton = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        self.connect(self.labelCloseButton, SIGNAL("clicked()"),self.closelabels)
        self.labelResetButton = QPushButton(QApplication.translate("Button","Reset Parents",None, QApplication.UnicodeUTF8))
        self.labelResetButton.setToolTip(QApplication.translate("Tooltip","Erases wheel parent hierarchy",None, QApplication.UnicodeUTF8))
        self.connect(self.labelResetButton, SIGNAL("clicked()"),self.resetlabelparents)
        self.labelwheelx = 0   #index of wheel being edited on labeltable
        self.hierarchyButton = QPushButton(QApplication.translate("Button","Reverse Hierarchy",None, QApplication.UnicodeUTF8))
        self.hierarchyButton.setToolTip(QApplication.translate("Tooltip","Sets graph hierarchy child->parent instead of parent->child",None, QApplication.UnicodeUTF8))
        self.connect(self.hierarchyButton, SIGNAL("clicked()"),aw.qmc.setWheelHierarchy)
        self.labeltable.setVisible(False)
        self.labelCloseButton.setVisible(False)
        self.labelResetButton.setVisible(False)
        aspectlabel = QLabel(QApplication.translate("Label","Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox = QDoubleSpinBox()
        self.aspectSpinBox.setToolTip(QApplication.translate("Tooltip","Aspect Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox.setRange(0.,2.)
        self.aspectSpinBox.setSingleStep(.1)
        self.aspectSpinBox.setValue(aw.qmc.wheelaspect)
        self.connect(self.aspectSpinBox, SIGNAL("valueChanged(double)"),self.setaspect)
        txtlabel = QLabel(QApplication.translate("Label","Text",None, QApplication.UnicodeUTF8))
        txtButtonplus = QPushButton(QApplication.translate("Button","+",None, QApplication.UnicodeUTF8))
        txtButtonplus.setToolTip(QApplication.translate("Tooltip","Increase size of text in all the graph",None, QApplication.UnicodeUTF8))
        self.connect(txtButtonplus, SIGNAL("clicked()"),lambda x = 1: self.changetext(x))
        txtButtonminus = QPushButton(QApplication.translate("Button","-",None, QApplication.UnicodeUTF8))
        txtButtonminus.setToolTip(QApplication.translate("Tooltip","Decrease size of text in all the graph",None, QApplication.UnicodeUTF8))
        self.connect(txtButtonminus, SIGNAL("clicked()"),lambda x = 0: self.changetext(x))
        edgelabel = QLabel(QApplication.translate("Label","Edge",None, QApplication.UnicodeUTF8))
        self.edgeSpinBox = QSpinBox()
        self.edgeSpinBox.setToolTip(QApplication.translate("Tooltip","Decorative edge beween wheels",None, QApplication.UnicodeUTF8))
        self.edgeSpinBox.setRange(0,5)
        self.edgeSpinBox.setValue(int(aw.qmc.wheeledge*100))
        self.connect(self.edgeSpinBox, SIGNAL("valueChanged(int)"),self.setedge)
        linewidthlabel = QLabel(QApplication.translate("Label","Line",None, QApplication.UnicodeUTF8))
        self.linewidthSpinBox = QSpinBox()
        self.linewidthSpinBox.setToolTip(QApplication.translate("Tooltip","Line thickness",None, QApplication.UnicodeUTF8))
        self.linewidthSpinBox.setRange(0,20)
        self.linewidthSpinBox.setValue(aw.qmc.wheellinewidth)
        self.connect(self.linewidthSpinBox, SIGNAL("valueChanged(int)"),self.setlinewidth)
        linecolor = QPushButton(QApplication.translate("Button","Line Color",None, QApplication.UnicodeUTF8))
        linecolor.setToolTip(QApplication.translate("Tooltip","Line color",None, QApplication.UnicodeUTF8))
        self.connect(linecolor, SIGNAL("clicked()"),self.setlinecolor)
        colorlabel = QLabel(QApplication.translate("Label","Color pattern",None, QApplication.UnicodeUTF8))
        self.colorSpinBox = QSpinBox()
        self.colorSpinBox.setToolTip(QApplication.translate("Tooltip","Apply color pattern to whole graph",None, QApplication.UnicodeUTF8))
        self.colorSpinBox.setRange(0,255)
        self.colorSpinBox.setValue(aw.qmc.wheelcolorpattern)
        self.colorSpinBox.setWrapping(True)
        self.connect(self.colorSpinBox, SIGNAL("valueChanged(int)"),self.setcolorpattern)
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        addButton.setToolTip(QApplication.translate("Tooltip","Add new wheel",None, QApplication.UnicodeUTF8))
        self.connect(addButton, SIGNAL("clicked()"),self.insertwheel)
        rotateLeftButton = QPushButton(QApplication.translate("Button","<",None, QApplication.UnicodeUTF8))
        rotateLeftButton.setToolTip(QApplication.translate("Tooltip","Rotate graph 1 degree counter clockwise",None, QApplication.UnicodeUTF8))
        self.connect(rotateLeftButton, SIGNAL("clicked()"),lambda x = 1: self.rotatewheels(x))
        rotateRightButton = QPushButton(QApplication.translate("Button",">",None, QApplication.UnicodeUTF8))
        rotateRightButton.setToolTip(QApplication.translate("Tooltip","Rotate graph 1 degree clockwise",None, QApplication.UnicodeUTF8))
        self.connect(rotateRightButton, SIGNAL("clicked()"),lambda x = 0: self.rotatewheels(x))
        saveButton = QPushButton(QApplication.translate("Button","Save File",None, QApplication.UnicodeUTF8))
        self.connect(saveButton, SIGNAL("clicked()"),self.fileSave)
        saveButton.setToolTip(QApplication.translate("Tooltip","Save graph to a text file.wg",None, QApplication.UnicodeUTF8))
        saveImgButton = QPushButton(QApplication.translate("Button","Save Img",None, QApplication.UnicodeUTF8))
        saveImgButton.setToolTip(QApplication.translate("Tooltip","Save image using current graph size to a png format",None, QApplication.UnicodeUTF8))
        self.connect(saveImgButton, SIGNAL("clicked()"),lambda x=0,i=1:aw.resize(x,i))
        viewModeButton = QPushButton(QApplication.translate("Button","View Mode",None, QApplication.UnicodeUTF8))
        viewModeButton.setToolTip(QApplication.translate("Tooltip","Sets Wheel graph to view mode",None, QApplication.UnicodeUTF8))
        self.connect(viewModeButton, SIGNAL("clicked()"),self.viewmode)
        openButton = QPushButton(QApplication.translate("Button","Open",None, QApplication.UnicodeUTF8))
        openButton.setToolTip(QApplication.translate("Tooltip","open graph file.wg",None, QApplication.UnicodeUTF8))
        self.connect(openButton, SIGNAL("clicked()"),self.loadWheel)
        closeButton = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        closeButton.setToolTip(QApplication.translate("Tooltip","Close wheel graph editor",None, QApplication.UnicodeUTF8))
        self.connect(closeButton, SIGNAL("clicked()"),self.close)
        aw.qmc.drawWheel()
        label1layout = QVBoxLayout()
        label2layout = QHBoxLayout()
        label1layout.addWidget(self.labeltable)
        label2layout.addWidget(self.labelCloseButton)
        label2layout.addWidget(self.labelResetButton)
        label1layout.addLayout(label2layout)
        self.labelGroupLayout = QGroupBox(QApplication.translate("GroupBox","Label Properties",None, QApplication.UnicodeUTF8))
        self.labelGroupLayout.setLayout(label1layout)
        self.labelGroupLayout.setVisible(False)
        buttonlayout = QHBoxLayout()
        buttonlayout.addWidget(openButton)
        buttonlayout.addWidget(saveButton)
        buttonlayout.addWidget(saveImgButton)
        buttonlayout.addWidget(viewModeButton)
        buttonlayout.addWidget(closeButton)
        configlayout =  QHBoxLayout()
        configlayout.addWidget(colorlabel)
        configlayout.addWidget(self.colorSpinBox)
        configlayout.addWidget(aspectlabel)
        configlayout.addWidget(self.aspectSpinBox)
        configlayout.addWidget(edgelabel)
        configlayout.addWidget(self.edgeSpinBox)
        configlayout.addWidget(linewidthlabel)
        configlayout.addWidget(self.linewidthSpinBox)
        configlayout.addWidget(linecolor)
        configlayout.addWidget(txtlabel)
        configlayout.addWidget(txtButtonplus)
        configlayout.addWidget(txtButtonminus)
        controlLayout = QHBoxLayout()
        controlLayout.addWidget(addButton)
        controlLayout.addWidget(rotateLeftButton)
        controlLayout.addWidget(rotateRightButton)
        controlLayout.addWidget(self.hierarchyButton)
        mainlayout = QVBoxLayout()
        mainlayout.addWidget(self.datatable)
        mainlayout.addWidget(self.labelGroupLayout)
        mainlayout.addLayout(controlLayout)
        mainlayout.addLayout(configlayout)
        mainlayout.addLayout(buttonlayout)
        self.setLayout(mainlayout)

    #creates config table for wheel with index x
    def createlabeltable(self,x):
        self.labelwheelx = x                    #wheel being edited
        self.labelGroupLayout.setVisible(True)
        self.labeltable.setVisible(True)
        self.labelCloseButton.setVisible(True)
        self.labelResetButton.setVisible(True)
        self.labeltable.clear()
        nlabels = len(aw.qmc.wheelnames[x])
        if nlabels:
            self.labeltable.setRowCount(nlabels)
            self.labeltable.setColumnCount(5)
            self.labeltable.setHorizontalHeaderLabels([QApplication.translate("Table","Label",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Parent",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Width",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Color",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Opaqueness",None, QApplication.UnicodeUTF8)])
            self.labeltable.setAlternatingRowColors(True)
            self.labeltable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.labeltable.setSelectionBehavior(QTableWidget.SelectRows)
            self.labeltable.setSelectionMode(QTableWidget.SingleSelection)
            self.labeltable.setShowGrid(True)
            self.labeltable.verticalHeader().setResizeMode(2)
            #populate table
            for i in range(nlabels):
                label = QTableWidgetItem(aw.qmc.wheelnames[x][i])
                parentComboBox =  QComboBox()
                if x > 0:
                    items = aw.qmc.wheelnames[x-1][:]
                    items.insert(0,"")
                    parentComboBox.addItems(items)
                    if aw.qmc.wheellabelparent[x][i]:
                        parentComboBox.setCurrentIndex(aw.qmc.wheellabelparent[x][i])
                else:
                    parentComboBox.addItems([])
                self.connect(parentComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,x=x,i=i:self.setwheelchild(z,x,i))
                labelwidthSpinBox = QDoubleSpinBox()
                labelwidthSpinBox.setRange(1.,100.)
                labelwidthSpinBox.setValue(aw.qmc.segmentlengths[x][i])
                labelwidthSpinBox.setSuffix("%")
                self.connect(labelwidthSpinBox, SIGNAL("valueChanged(double)"),lambda z=1,x=x,u=i: self.setlabelwidth(z,x,u))
                colorButton = QPushButton("Set Color")
                self.connect(colorButton, SIGNAL("clicked()"),lambda x =x,i=i: self.setsegmentcolor(x,i))
                alphaSpinBox = QSpinBox()
                alphaSpinBox.setRange(0,10)
                alphaSpinBox.setValue(int(aw.qmc.segmentsalpha[x][i]*10))
                self.connect(alphaSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=x,u=i: self.setsegmentalpha(z,x,u))
                #add widgets to the table
                self.labeltable.setItem(i,0,label)
                self.labeltable.setCellWidget(i,1,parentComboBox)
                self.labeltable.setCellWidget(i,2,labelwidthSpinBox)
                self.labeltable.setCellWidget(i,3,colorButton)
                self.labeltable.setCellWidget(i,4,alphaSpinBox)

    def setsegmentcolor(self,x,i):
        colorf = aw.colordialog(QColor(aw.qmc.wheelcolor[x][i]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.wheelcolor[x][i] = colorname      #add new color to label
            self.createdatatable()                           #update main table with label names (label::color)
            aw.qmc.drawWheel()

    #sets a uniform color in wheel
    def setwheelcolor(self,x):
        colorf = aw.colordialog(QColor(aw.qmc.wheelcolor[x][0]))
        if colorf.isValid():
            colorname = str(colorf.name())
            for i in range(len(aw.qmc.wheelcolor[x])):
                aw.qmc.wheelcolor[x][i] =  colorname
        self.createdatatable()
        aw.qmc.drawWheel()

    #sets color pattern (many colors) in wheel
    def setwheelcolorpattern(self,z,x):
        wsb =  self.datatable.cellWidget(x,9)
        wpattern = wsb.value()
        wlen = len(aw.qmc.wheelcolor[x])
        for i in range(wlen):
            color = QColor()
            color.setHsv((360/wlen)*i*wpattern,255,255,255)
            aw.qmc.wheelcolor[x][i] = str(color.name())
        aw.qmc.drawWheel()

    #sets color pattern (many colors) for whole graph
    def setcolorpattern(self):
        aw.qmc.wheelcolorpattern = self.colorSpinBox.value()
        if aw.qmc.wheelcolorpattern:
            for x in range(len(aw.qmc.wheelcolor)):
                wlen = len(aw.qmc.wheelcolor[x])
                for i in range(wlen):
                    color = QColor()
                    color.setHsv((360/wlen)*i*aw.qmc.wheelcolorpattern,255,255,255)
                    aw.qmc.wheelcolor[x][i] = str(color.name())
            aw.qmc.drawWheel()

    def setsegmentalpha(self,z,x,u):
        aw.qmc.segmentsalpha[x][u] = float(z/10.)
        aw.qmc.drawWheel()

    #rotate whole graph 
    def rotatewheels(self,x):
        if x == 1: #left,counterclockwise
            for i in range(len(aw.qmc.startangle)):
                aw.qmc.startangle[i] += 1
        elif x == 0: #right,clockwise
            for i in range(len(aw.qmc.startangle)):
                aw.qmc.startangle[i] -= 1
        aw.qmc.drawWheel()

    #z= new width%, x= wheel number index, u = index of segment in the wheel
    def setlabelwidth(self,z,x,u):
        newwidth = z
        oldwidth = aw.qmc.segmentlengths[x][u]
        diff = newwidth - oldwidth
        l = len(aw.qmc.segmentlengths[x])
        for i in range(l):
            if i != u:
                if diff > 0:
                    aw.qmc.segmentlengths[x][i] -= abs(float(diff))/(l-1)
                else:
                    aw.qmc.segmentlengths[x][i] += abs(float(diff))/(l-1)
        aw.qmc.segmentlengths[x][u] = newwidth
        aw.qmc.drawWheel()

    #input: z = index of parent in previus wheel; x = wheel number; i = index of element in wheel
    def setwheelchild(self,z,x,i):
        aw.qmc.setwheelchild(z,x,i)
        aw.qmc.drawWheel()
        self.createdatatable() #update data table

    #deletes parent-child relation in a wheel. It obtains the wheel index by self.labelwheelx
    def resetlabelparents(self):
        x = self.labelwheelx
        nsegments = len(aw.qmc.wheellabelparent[x])
        for i in range(nsegments):
            aw.qmc.wheellabelparent[x][i] = 0
            aw.qmc.segmentlengths[x][i] = 100./nsegments
        aw.qmc.drawWheel()
        self.createlabeltable(x)

    def setaspect(self):
        aw.qmc.wheelaspect = self.aspectSpinBox.value()
        aw.qmc.drawWheel()

    #adjust decorative edge between wheels
    def setedge(self):
        aw.qmc.wheeledge = float(self.edgeSpinBox.value())/100.
        aw.qmc.drawWheel()

    #adjusts line thickness
    def setlinewidth(self):
        aw.qmc.wheellinewidth = self.linewidthSpinBox.value()
        aw.qmc.drawWheel()

    #sets line color
    def setlinecolor(self):
        colorf = aw.colordialog(QColor(aw.qmc.wheellinecolor))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.wheellinecolor = colorname      #add new color to label
            aw.qmc.drawWheel()

    #makes not visible the wheel config table
    def closelabels(self):
        self.labelGroupLayout.setVisible(False)
        self.labeltable.setVisible(False)
        self.labelCloseButton.setVisible(False)
        self.labelResetButton.setVisible(False)

    #creates graph table
    def createdatatable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.wheelnames)
        if ndata:
            self.datatable.setRowCount(ndata)
            self.datatable.setColumnCount(10)
            self.datatable.setHorizontalHeaderLabels([QApplication.translate("Table","Delete Wheel",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Edit Labels",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Update Labels",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Properties",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Radius",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Starting angle",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Projection",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Text Size",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Color",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Color Pattern",None, QApplication.UnicodeUTF8)])
            self.datatable.setAlternatingRowColors(True)
            self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
            self.datatable.setSelectionMode(QTableWidget.SingleSelection)
            self.datatable.setShowGrid(True)
            self.datatable.verticalHeader().setResizeMode(2)
            #populate table
            for i in range(ndata):
                delButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
                self.connect(delButton, SIGNAL("clicked()"),lambda x = i: self.popwheel(x))
                labelsedit = QLineEdit(str(",".join(aw.qmc.wheelnames[i])))
                updateButton = QPushButton(QApplication.translate("Button","Update",None, QApplication.UnicodeUTF8))
                self.connect(updateButton, SIGNAL("clicked()"),lambda x = i: self.updatelabels(x))
                setButton = QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
                self.connect(setButton, SIGNAL("clicked()"),lambda x = i: self.createlabeltable(x))
                widthSpinBox = QDoubleSpinBox()
                widthSpinBox.setRange(1.,100.)
                widthSpinBox.setValue(aw.qmc.wradii[i])
                widthSpinBox.setSuffix("%")
                self.connect(widthSpinBox, SIGNAL("valueChanged(double)"),lambda z=1,x=i: self.setwidth(z,x))
                angleSpinBox = QSpinBox()
                angleSpinBox.setSuffix(QApplication.translate("Label"," dg",None, QApplication.UnicodeUTF8))
                angleSpinBox.setRange(0,359)
                angleSpinBox.setWrapping(True)
                angleSpinBox.setValue(aw.qmc.startangle[i])
                self.connect(angleSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=i: self.setangle(z,x))
                projectionComboBox =  QComboBox()
                projectionComboBox.addItems([QApplication.translate("ComboBox","Flat",None, QApplication.UnicodeUTF8),
                                             QApplication.translate("ComboBox","Perpendicular",None, QApplication.UnicodeUTF8),
                                             QApplication.translate("ComboBox","Radial",None, QApplication.UnicodeUTF8)])
                projectionComboBox.setCurrentIndex(aw.qmc.projection[i])
                self.connect(projectionComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,x=i:self.setprojection(z,x))
                txtSpinBox = QSpinBox()
                txtSpinBox.setRange(1,30)
                txtSpinBox.setValue(aw.qmc.wheeltextsize[i])
                self.connect(txtSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=i: self.setTextsizeX(z,x))
                colorButton = QPushButton(QApplication.translate("Button","Set Color",None, QApplication.UnicodeUTF8))
                self.connect(colorButton, SIGNAL("clicked()"),lambda x =i: self.setwheelcolor(x))
                colorSpinBox = QSpinBox()
                colorSpinBox.setRange(0,255)
                colorSpinBox.setWrapping(True)
                self.connect(colorSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=i,: self.setwheelcolorpattern(z,x))
                #add widgets to the table
                self.datatable.setCellWidget(i,0,delButton)
                self.datatable.setCellWidget(i,1,labelsedit)
                self.datatable.setCellWidget(i,2,updateButton)
                self.datatable.setCellWidget(i,3,setButton)
                self.datatable.setCellWidget(i,4,widthSpinBox)
                self.datatable.setCellWidget(i,5,angleSpinBox)
                self.datatable.setCellWidget(i,6,projectionComboBox)
                self.datatable.setCellWidget(i,7,txtSpinBox)
                self.datatable.setCellWidget(i,8,colorButton)
                self.datatable.setCellWidget(i,9,colorSpinBox)

    #reads label edit box for wheel with index x, and updates labels
    def updatelabels(self,x):
        labelsedit =  self.datatable.cellWidget(x,1)
        text  = str(labelsedit.text())
        if "\\n" in text:              #make multiple line text if "\n" found in label string
            parts = text.split("\\n")
            text = chr(10).join(parts)
        newwheellabels = text.strip().split(",")
        newnlabels = len(newwheellabels)
        oldnlabels = len(aw.qmc.wheelnames[x])
        #adjust segments len and alpha for each wheel if number of labels changed
        if oldnlabels != newnlabels:
            aw.qmc.segmentlengths[x] = [100./newnlabels]*newnlabels
            aw.qmc.segmentsalpha[x] = [.3]*newnlabels
            aw.qmc.wheellabelparent[x] = [0]*newnlabels
            aw.qmc.wheelcolor[x] = [aw.qmc.wheelcolor[x][0]]*newnlabels
        aw.qmc.wheelnames[x] = newwheellabels[:]
        aw.qmc.drawWheel()

    #sets radii for a wheel. z is a variable dummy with no meaning but passed by the Qt inner workings
    def setwidth(self,z,x):
        widthSpinBox = self.datatable.cellWidget(x,4)
        newwidth = widthSpinBox.value()
        oldwidth = aw.qmc.wradii[x]
        diff = newwidth - oldwidth
        l = len(aw.qmc.wradii)
        for i in range(l):
            if i != x:
                if diff > 0:
                    aw.qmc.wradii[i] -= abs(float(diff))/(l-1)
                else:
                    aw.qmc.wradii[i] += abs(float(diff))/(l-1)
        aw.qmc.wradii[x] = newwidth
        #Need 100.0% coverage. Correct for numerical floating point rounding errors:
        count = 0.
        for i in range(len(aw.qmc.wradii)):
            count +=  aw.qmc.wradii[i]
        diff = 100. - count
        if diff  != 0.:
            if diff > 0.000:  #if count smaller
                aw.qmc.wradii[x] += abs(diff)
            else:
                aw.qmc.wradii[x] -= abs(diff)
        aw.qmc.drawWheel()

    #sets starting angle (rotation) for a wheel with index x
    def setangle(self,z,x):
        angleSpinBox = self.datatable.cellWidget(x,5)
        aw.qmc.startangle[x] = angleSpinBox.value()
        aw.qmc.drawWheel()

    #sets text projection style for a wheel with index x
    def setprojection(self,z,x):
        projectionComboBox = self.datatable.cellWidget(x,6)
        aw.qmc.projection[x] = projectionComboBox.currentIndex()
        aw.qmc.drawWheel()

    #chages text size in wheel with index x
    def setTextsizeX(self,z,x):
        txtSpinBox = self.datatable.cellWidget(x,7)
        aw.qmc.wheeltextsize[x] = txtSpinBox.value()
        aw.qmc.drawWheel()

    #changes size of text in whole graph
    def changetext(self,x):
        for i in range(len(aw.qmc.wheeltextsize)):
            if x == 1:
                aw.qmc.wheeltextsize[i] += 1
            else:
                aw.qmc.wheeltextsize[i] -= 1
        aw.qmc.drawWheel()

    #adds new top wheel 
    def insertwheel(self):
        ndata = len(aw.qmc.wradii)
        if ndata:
            count = 0.
            for i in range(ndata):
                aw.qmc.wradii[i] = 100./(ndata+1)
                count += aw.qmc.wradii[i]
            aw.qmc.wradii.append(100.-count)
        else:
            aw.qmc.wradii.append(100.)
        #find number of labels of most outer wheel (last)
        if len(aw.qmc.wheelnames):
            nwheels = len(aw.qmc.wheelnames[-1])
        else:                                       #if no wheels
            nwheels = 3
        wn,sl,sa,wlp,co = [],[],[],[],[]
        for i in range(nwheels+1):
            wn.append("W%i %i"%(len(aw.qmc.wheelnames)+1,i+1))
            sl.append(100./(nwheels+1))
            sa.append(.3)
            wlp.append(0)
            color = QColor()
            color.setHsv((360/(nwheels+1))*i,255,255,255)
            co.append(str(color.name()))
        aw.qmc.wheelnames.append(wn)
        aw.qmc.segmentlengths.append(sl)
        aw.qmc.segmentsalpha.append(sa)
        aw.qmc.wheellabelparent.append(wlp)
        aw.qmc.startangle.append(0)
        aw.qmc.projection.append(2)
        aw.qmc.wheeltextsize.append(10)
        aw.qmc.wheelcolor.append(co)
        self.createdatatable()
        aw.qmc.drawWheel()

    #deletes wheel with index x
    def popwheel(self,x):
        #correct raius of other wheels (to use 100% coverage)
        width = aw.qmc.wradii[x]
        l = len(aw.qmc.wradii)
        for i in range(l):
            if i != x:
                aw.qmc.wradii[i] += float(width)/(l-1)
        aw.qmc.wheelnames.pop(x)
        aw.qmc.wradii.pop(x)
        aw.qmc.startangle.pop(x)
        aw.qmc.projection.pop(x)
        aw.qmc.wheeltextsize.pop(x)
        aw.qmc.segmentlengths.pop(x)
        aw.qmc.segmentsalpha.pop(x)
        aw.qmc.wheellabelparent.pop(x)
        aw.qmc.wheelcolor.pop(x)
        self.createdatatable()
        aw.qmc.drawWheel()

    def fileSave(self):
        try:
            filename = aw.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Wheel graph",None, QApplication.UnicodeUTF8),ext="*.wg")
            if filename:
                #write
                aw.serialize(filename,aw.getWheelGraph())
                aw.sendmessage(QApplication.translate("Message","Wheel Graph saved",None, QApplication.UnicodeUTF8))
        except IOError as e:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:",None, QApplication.UnicodeUTF8) + " Wheel graph filesave(): %1").arg(str(e)))
            return

    def loadWheel(self):
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Open Wheel Graph",None, QApplication.UnicodeUTF8),path = aw.getDefaultPath(),ext="*.wg")
        if filename:
            aw.loadWheel(filename)
            self.createdatatable()
            aw.qmc.drawWheel()

    def closeEvent(self, event):
        #if switching to View-mode don't redraw() (faster)
        if not self.viewmodeflag:
            aw.qmc.disconnectWheel()
            aw.qmc.redraw(recomputeAllDeltas=False)
        else:
            aw.qmc.disconnectWheel(buttomvisibility=False)

    def viewmode(self):
        self.viewmodeflag = True
        self.close()
        aw.qmc.connectWheel()
        aw.qmc.drawWheel()

############################################################
#######################  ALARM DIALOG  #####################
############################################################

class AlarmDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(AlarmDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Alarms",None, QApplication.UnicodeUTF8))
        #table for alarms
        self.alarmtable = QTableWidget()
        self.connect(self.alarmtable, SIGNAL("itemSelectionChanged()"),self.selectionChanged)
        self.createalarmtable()
        allonButton = QPushButton(QApplication.translate("Button","All On",None, QApplication.UnicodeUTF8))
        self.connect(allonButton,  SIGNAL("clicked()"), lambda flag=1: self.alarmson(flag))
        allonButton.setFocusPolicy(Qt.NoFocus)
        alloffButton = QPushButton(QApplication.translate("Button","All Off",None, QApplication.UnicodeUTF8))
        self.connect(alloffButton, SIGNAL("clicked()"), lambda flag=0: self.alarmson(flag))
        alloffButton.setFocusPolicy(Qt.NoFocus)
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        self.connect(addButton, SIGNAL("clicked()"),self.addalarm)
        addButton.setMinimumWidth(80)
        addButton.setFocusPolicy(Qt.NoFocus)
        self.insertButton = QPushButton(QApplication.translate("Button","Insert",None, QApplication.UnicodeUTF8))
        self.connect(self.insertButton, SIGNAL("clicked()"),self.insertalarm)
        self.insertButton.setMinimumWidth(80)
        self.insertButton.setFocusPolicy(Qt.NoFocus)
        self.insertButton.setEnabled(False)
        deleteButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
        self.connect(deleteButton, SIGNAL("clicked()"),self.deletealarm)
        deleteButton.setMinimumWidth(80)
        deleteButton.setFocusPolicy(Qt.NoFocus)
        importButton = QPushButton(QApplication.translate("Button","Load",None, QApplication.UnicodeUTF8))
        self.connect(importButton, SIGNAL("clicked()"),self.importalarms)
        importButton.setMinimumWidth(80)
        importButton.setFocusPolicy(Qt.NoFocus)
        exportButton = QPushButton(QApplication.translate("Button","Save",None, QApplication.UnicodeUTF8))
        self.connect(exportButton, SIGNAL("clicked()"),self.exportalarms)
        exportButton.setMinimumWidth(80)
        exportButton.setFocusPolicy(Qt.NoFocus)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self.closealarms)
        helpButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None, QApplication.UnicodeUTF8))
        helpButton.setFocusPolicy(Qt.NoFocus)
        helpButton.setMinimumWidth(80)
        self.connect(helpButton, SIGNAL("clicked()"),self.showAlarmbuttonhelp)
        clearButton = QPushButton(QApplication.translate("Button","Clear",None, QApplication.UnicodeUTF8))
        clearButton.setToolTip(QApplication.translate("Tooltip","Clear alarms table",None, QApplication.UnicodeUTF8))
        clearButton.setFocusPolicy(Qt.NoFocus)
        clearButton.setMinimumWidth(80)
        self.loadAlarmsFromProfile = QCheckBox(QApplication.translate("CheckBox", "Load alarms from profile",None, QApplication.UnicodeUTF8))
        self.loadAlarmsFromProfile.setChecked(aw.qmc.loadalarmsfromprofile)
        self.connect(clearButton, SIGNAL("clicked()"),self.clearalarms)
        self.alarmsfile = QLabel(aw.qmc.alarmsfile)
        self.alarmsfile.setAlignment(Qt.AlignRight)
        self.alarmsfile.setMinimumWidth(500)
        self.alarmsfile.setMaximumWidth(500)
        tablelayout = QVBoxLayout()
        buttonlayout = QHBoxLayout()
        okbuttonlayout = QHBoxLayout()
        mainlayout = QVBoxLayout()
        tablelayout.addWidget(self.alarmtable)
        buttonlayout.addWidget(addButton)
        buttonlayout.addWidget(self.insertButton)
        buttonlayout.addWidget(deleteButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(10)
        buttonlayout.addWidget(allonButton)
        buttonlayout.addWidget(alloffButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(10)
        buttonlayout.addWidget(importButton)
        buttonlayout.addWidget(exportButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(15)
        buttonlayout.addWidget(clearButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(15)
        buttonlayout.addWidget(helpButton)
        okbuttonlayout.addWidget(self.loadAlarmsFromProfile)
        okbuttonlayout.addStretch()
        okbuttonlayout.addWidget(self.alarmsfile)
        okbuttonlayout.addSpacing(15)
        okbuttonlayout.addWidget(okButton)
        mainlayout.addLayout(tablelayout)
        mainlayout.addLayout(buttonlayout)
        mainlayout.addLayout(okbuttonlayout)
        self.setLayout(mainlayout)

    def deselectAll(self):
        selected = self.alarmtable.selectedRanges()
        if selected and len(selected) > 0:
            self.alarmtable.setRangeSelected(selected[0],False)

    def selectionChanged(self):
        selected = self.alarmtable.selectedRanges()
        if selected and len(selected) > 0:
            self.insertButton.setEnabled(True)
        else:
            self.insertButton.setEnabled(False)

    def clearalarms(self):
        aw.qmc.alarmsfile = ""
        self.alarmsfile.setText(aw.qmc.alarmsfile)
        aw.qmc.alarmflag = []
        aw.qmc.alarmguard = []
        aw.qmc.alarmnegguard = []
        aw.qmc.alarmtime = []
        aw.qmc.alarmoffset = []
        aw.qmc.alarmcond = []
        aw.qmc.alarmstate = []
        aw.qmc.alarmsource = []
        aw.qmc.alarmtemperature = []
        aw.qmc.alarmaction = []
        aw.qmc.alarmbeep = []
        aw.qmc.alarmstrings = []
        self.alarmtable.setRowCount(0)

    def alarmson(self,flag):
        for i in range(len(aw.qmc.alarmflag)):
            if flag == 1:
                aw.qmc.alarmflag[i] = 1
            else:
                aw.qmc.alarmflag[i] = 0
        self.createalarmtable()

    def addalarm(self):
        aw.qmc.alarmflag.append(1)
        aw.qmc.alarmguard.append(-1)
        aw.qmc.alarmnegguard.append(-1)
        aw.qmc.alarmtime.append(-1)
        aw.qmc.alarmoffset.append(0)
        aw.qmc.alarmcond.append(1)
        aw.qmc.alarmstate.append(0)
        aw.qmc.alarmsource.append(1)
        aw.qmc.alarmtemperature.append(500)
        aw.qmc.alarmaction.append(0)
        aw.qmc.alarmbeep.append(0)
        aw.qmc.alarmstrings.append(QApplication.translate("Label","Enter description",None, QApplication.UnicodeUTF8))
        nalarms = self.alarmtable.rowCount()
        self.alarmtable.setRowCount(nalarms + 1)
        self.setalarmtablerow(nalarms)
        self.alarmtable.resizeColumnsToContents()
        self.alarmtable.resizeRowsToContents()
        # improve width of Qlineedit columns
        self.alarmtable.setColumnWidth(1,50)
        self.alarmtable.setColumnWidth(2,50)
        self.alarmtable.setColumnWidth(4,50)
        self.alarmtable.setColumnWidth(5,80)
        self.alarmtable.setColumnWidth(7,40)
        header = self.alarmtable.horizontalHeader()
        header.setStretchLastSection(False)
        self.deselectAll()
        # select newly added row i.e. the last one
        self.alarmtable.setRangeSelected(QTableWidgetSelectionRange(nalarms,0,nalarms,self.alarmtable.columnCount()-1),True)
        header.setStretchLastSection(True)
        self.markNotEnabledAlarmRows()

    def insertalarm(self):
        nalarms = self.alarmtable.rowCount()
        if nalarms:
            # check for selection
            selected = self.alarmtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                aw.qmc.alarmflag.insert(selected_row,1)
                aw.qmc.alarmguard.insert(selected_row,-1)
                aw.qmc.alarmnegguard.insert(selected_row,-1)
                aw.qmc.alarmtime.insert(selected_row,-1)
                aw.qmc.alarmoffset.insert(selected_row,0)
                aw.qmc.alarmcond.insert(selected_row,1)
                aw.qmc.alarmstate.insert(selected_row,0)
                aw.qmc.alarmsource.insert(selected_row,1)
                aw.qmc.alarmtemperature.insert(selected_row,500)
                aw.qmc.alarmaction.insert(selected_row,0)
                aw.qmc.alarmbeep.insert(selected_row,0)
                aw.qmc.alarmstrings.insert(selected_row,QApplication.translate("Label","Enter description",None, QApplication.UnicodeUTF8))
                self.alarmtable.insertRow(selected_row)
                self.setalarmtablerow(selected_row)
                self.alarmtable.resizeColumnsToContents()
                #  improve width of Qlineedit columns
                self.alarmtable.setColumnWidth(1,50)
                self.alarmtable.setColumnWidth(2,50)
                self.alarmtable.setColumnWidth(4,50)
                self.alarmtable.setColumnWidth(5,80)
                self.alarmtable.setColumnWidth(7,40)
                header = self.alarmtable.horizontalHeader()
                header.setStretchLastSection(False)
                self.deselectAll()
                # select newly inserted item
                self.alarmtable.setRangeSelected(QTableWidgetSelectionRange(selected_row,0,selected_row,self.alarmtable.columnCount()-1),True)
                header.setStretchLastSection(True)
                self.markNotEnabledAlarmRows()

    def deletealarm(self):
        nalarms = self.alarmtable.rowCount()
        if nalarms:
            # check for selection
            selected = self.alarmtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                self.alarmtable.removeRow(selected_row)
                aw.qmc.alarmflag = aw.qmc.alarmflag[0:selected_row] + aw.qmc.alarmflag[selected_row + 1:]
                aw.qmc.alarmguard = aw.qmc.alarmguard[0:selected_row] + aw.qmc.alarmguard[selected_row + 1:]
                aw.qmc.alarmnegguard = aw.qmc.alarmnegguard[0:selected_row] + aw.qmc.alarmnegguard[selected_row + 1:]
                aw.qmc.alarmtime = aw.qmc.alarmtime[0:selected_row] + aw.qmc.alarmtime[selected_row + 1:]
                aw.qmc.alarmoffset = aw.qmc.alarmoffset[0:selected_row] + aw.qmc.alarmoffset[selected_row + 1:]
                aw.qmc.alarmcond = aw.qmc.alarmcond[0:selected_row] + aw.qmc.alarmcond[selected_row + 1:]
                aw.qmc.alarmstate = aw.qmc.alarmstate[0:selected_row] + aw.qmc.alarmstate[selected_row + 1:]
                aw.qmc.alarmsource = aw.qmc.alarmsource[0:selected_row] + aw.qmc.alarmsource[selected_row + 1:]
                aw.qmc.alarmtemperature = aw.qmc.alarmtemperature[0:selected_row] + aw.qmc.alarmtemperature[selected_row + 1:]
                aw.qmc.alarmaction = aw.qmc.alarmaction[0:selected_row] + aw.qmc.alarmaction[selected_row + 1:]
                aw.qmc.alarmbeep = aw.qmc.alarmbeep[0:selected_row] + aw.qmc.alarmbeep[selected_row + 1:]
                aw.qmc.alarmstrings = aw.qmc.alarmstrings[0:selected_row] + aw.qmc.alarmstrings[selected_row + 1:]
                self.alarmtable.setRowCount(nalarms - 1)
                self.deselectAll()
                # select row number that was just deleted
                self.alarmtable.setRangeSelected(QTableWidgetSelectionRange(selected_row,0,selected_row,self.alarmtable.columnCount()-1),True)
            else:
                self.alarmtable.removeRow(self.alarmtable.rowCount() - 1)
                # nothing selected, we pop the last element
                aw.qmc.alarmflag.pop()
                aw.qmc.alarmguard.pop()
                aw.qmc.alarmnegguard.pop()
                aw.qmc.alarmtime.pop()
                aw.qmc.alarmoffset.pop()
                aw.qmc.alarmcond.pop()
                aw.qmc.alarmstate.pop()
                aw.qmc.alarmsource.pop()
                aw.qmc.alarmtemperature.pop()
                aw.qmc.alarmaction.pop()
                aw.qmc.alarmbeep.pop()
                aw.qmc.alarmstrings.pop()
                self.alarmtable.setRowCount(nalarms - 1)
                self.deselectAll()
            self.markNotEnabledAlarmRows()

    def importalarms(self):
        aw.fileImport(QApplication.translate("Message", "Load Alarms",None, QApplication.UnicodeUTF8),self.importalarmsJSON)

    def importalarmsJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            alarms = json.load(infile)
            infile.close()
            aw.qmc.alarmsfile = filename            
            self.alarmsfile.setText(aw.qmc.alarmsfile)
            aw.qmc.alarmflag = alarms["alarmflags"]
            aw.qmc.alarmguard = alarms["alarmguards"]
            if "alarmnegguards" in alarms:
                aw.qmc.alarmnegguard = alarms["alarmnegguards"]
            else:
                aw.qmc.alarmnegguard = [0]*len(aw.qmc.alarmflag)
            aw.qmc.alarmtime = alarms["alarmtimes"]
            aw.qmc.alarmoffset = alarms["alarmoffsets"]
            aw.qmc.alarmcond = alarms["alarmconds"]
            aw.qmc.alarmstate = [0]*len(aw.qmc.alarmflag)
            aw.qmc.alarmsource = alarms["alarmsources"]  
            aitems = self.buildAlarmSourceList()
            for i in range(len(aw.qmc.alarmsource)):
                if aw.qmc.alarmsource[i] + 3 >= len(aitems):
                    aw.qmc.alarmsource[i] = 1 # BT
            aw.qmc.alarmtemperature = alarms["alarmtemperatures"]
            aw.qmc.alarmaction = alarms["alarmactions"]
            if "alarmbeep" in alarms:
                aw.qmc.alarmbeep = alarms["alarmbeep"]
            else:
                aw.qmc.alarmbeep = [0]*len(aw.qmc.alarmflag)
            aw.qmc.alarmstrings = alarms["alarmstrings"]
            self.createalarmtable()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importalarmsJSON() %1").arg(str(ex)),exc_tb.tb_lineno)

    def exportalarms(self):
        aw.fileExport(QApplication.translate("Message", "Save Alarms",None, QApplication.UnicodeUTF8),"*.alrm",self.exportalarmsJSON)

    def exportalarmsJSON(self,filename):
        try:
            self.savealarms()
            alarms = {}
            alarms["alarmflags"] = aw.qmc.alarmflag
            alarms["alarmguards"] = aw.qmc.alarmguard
            alarms["alarmnegguards"] = aw.qmc.alarmnegguard
            alarms["alarmtimes"] = aw.qmc.alarmtime
            alarms["alarmoffsets"] = aw.qmc.alarmoffset
            alarms["alarmconds"] = aw.qmc.alarmcond
            alarms["alarmsources"] = aw.qmc.alarmsource
            alarms["alarmtemperatures"] = aw.qmc.alarmtemperature
            alarms["alarmactions"] = aw.qmc.alarmaction
            alarms["alarmbeep"] = aw.qmc.alarmbeep
            alarms["alarmstrings"] = list(map(lambda s:u(s),aw.qmc.alarmstrings))
            outfile = open(filename, 'w')
            json.dump(alarms, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " exportalarmsJSON(): %1").arg(str(ex)),exc_tb.tb_lineno)
            return False

    def closealarms(self):
        self.savealarms()
        self.accept()

    def showAlarmbuttonhelp(self):
        string  = u(QApplication.translate("Message", "<b>Status:</b> activate or deactive alarm",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>If Alarm:</b> alarm triggered only if the alarm with the given number was triggered before. Use 0 for no guard.",None, QApplication.UnicodeUTF8)) + "<br><br>"  
        string += u(QApplication.translate("Message", "<b>But Not:</b> alarm triggered only if the alarm with the given number was not triggered before. Use 0 for no guard.",None, QApplication.UnicodeUTF8)) + "<br><br>"  
        string += u(QApplication.translate("Message", "<b>From:</b> alarm only triggered after the given event",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Time:</b> if not 00:00, alarm is triggered mm:ss after the event 'From' happend",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Source:</b> the temperature source that is observed",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Condition:</b> alarm is triggered if source rises above or below the specified temperature",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Temp:</b> the speficied temperature limit",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Action:</b> if all conditions are fulfilled the alarm triggeres the corresponding action",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Description:</b> the text of the popup, the name of the program, the number of the event button or the new value of the slider",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>NOTE:</b> each alarm is only triggered once",None, QApplication.UnicodeUTF8))
        QMessageBox.information(self,QApplication.translate("Button", "Help",None, QApplication.UnicodeUTF8),string)

    def savealarms(self):
        try:
            nalarms = self.alarmtable.rowCount()
            aw.qmc.loadalarmsfromprofile = self.loadAlarmsFromProfile.isChecked()
            aw.qmc.alarmflag = [1]*nalarms
            aw.qmc.alarmguard = [-1]*nalarms
            aw.qmc.alarmnegguard = [-1]*nalarms
            aw.qmc.alarmtime = [-1]*nalarms
            aw.qmc.alarmoffset = [0]*nalarms
            aw.qmc.alarmcond = [1]*nalarms
            aw.qmc.alarmsource = [1]*nalarms
            aw.qmc.alarmtemperature = [500]*nalarms
            aw.qmc.alarmaction = [0]*nalarms
            aw.qmc.alarmbeep = [0]*nalarms
            aw.qmc.alarmstrings = [""]*nalarms
            for i in range(nalarms):
                flag = self.alarmtable.cellWidget(i,0)
                aw.qmc.alarmflag[i] = int(flag.isChecked())
                guard = self.alarmtable.cellWidget(i,1)
                try:
                    guard_value = int(str(guard.text())) - 1
                except:
                    guard_value = -1
                if guard_value > -1 and guard_value < nalarms:
                    aw.qmc.alarmguard[i] = guard_value
                else:
                    aw.qmc.alarmguard[i] = -1
                negguard = self.alarmtable.cellWidget(i,2)
                try:
                    negguard_value = int(str(negguard.text())) - 1
                except:
                    negguard_value = -1
                if negguard_value > -1 and negguard_value < nalarms:
                    aw.qmc.alarmnegguard[i] = negguard_value
                else:
                    aw.qmc.alarmnegguard[i] = -1
                timez =  self.alarmtable.cellWidget(i,3)
                aw.qmc.alarmtime[i] = aw.qmc.menuidx2alarmtime[timez.currentIndex()]
                offset =  self.alarmtable.cellWidget(i,4)
                if offset and offset != "":
                    aw.qmc.alarmoffset[i] = max(0,aw.qmc.stringtoseconds(str(offset.text())))
                atype = self.alarmtable.cellWidget(i,5)
                aw.qmc.alarmsource[i] = int(str(atype.currentIndex())) - 3
                cond = self.alarmtable.cellWidget(i,6)
                aw.qmc.alarmcond[i] = int(str(cond.currentIndex())) 
                temp = self.alarmtable.cellWidget(i,7)
                try:
                    aw.qmc.alarmtemperature[i] = int(str(temp.text()))
                except:
                    aw.qmc.alarmtemperature[i] = 0
                action = self.alarmtable.cellWidget(i,8)
                aw.qmc.alarmaction[i] = int(str(action.currentIndex() - 1))
                beepWidget = self.alarmtable.cellWidget(i,9)
                beep = beepWidget.layout().itemAt(1).widget()
                if beep and beep != None:
                    aw.qmc.alarmbeep[i] = int(beep.isChecked())
                description = self.alarmtable.cellWidget(i,10)
                aw.qmc.alarmstrings[i] = u(description.text())
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " savealarms(): %1").arg(str(ex)),exc_tb.tb_lineno)
            
    def buildAlarmSourceList(self):
        extra_names = []
        for i in range(len(aw.qmc.extradevices)):
            extra_names.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            extra_names.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
        return ["",
             QApplication.translate("ComboBox","DeltaET",None, QApplication.UnicodeUTF8),
             QApplication.translate("ComboBox","DeltaBT",None, QApplication.UnicodeUTF8),
             QApplication.translate("ComboBox","ET",None, QApplication.UnicodeUTF8),
             QApplication.translate("ComboBox","BT",None, QApplication.UnicodeUTF8)] + extra_names

    # creates Widget in row i of self.alarmtable and sets them to values from local dialog variables at position i
    def setalarmtablerow(self,i):
        #flag
        flagComboBox = QCheckBox()
        flagComboBox.setFocusPolicy(Qt.NoFocus)
        flagComboBox.setText(QApplication.translate("ComboBox","ON",None, QApplication.UnicodeUTF8))
        if aw.qmc.alarmflag[i]:
            flagComboBox.setCheckState(Qt.Checked)
        else:
            flagComboBox.setCheckState(Qt.Unchecked)
        #guarded by alarm
        if aw.qmc.alarmguard[i] > -1:
            guardstr = str(aw.qmc.alarmguard[i] + 1)
        else:
            guardstr = "0"
        guardedit = QLineEdit(guardstr)
        guardedit.setValidator(QIntValidator(0, 30,guardedit))
        guardedit.setAlignment(Qt.AlignRight)
        #neg guarded by alarm
        if aw.qmc.alarmnegguard[i] > -1:
            negguardstr = str(aw.qmc.alarmnegguard[i] + 1)
        else:
            negguardstr = "0"
        negguardedit = QLineEdit(negguardstr)
        negguardedit.setValidator(QIntValidator(0, 30,negguardedit))
        negguardedit.setAlignment(Qt.AlignRight)
        #Effective time from
        timeComboBox = QComboBox()
        timeComboBox.addItems([QApplication.translate("ComboBox","ON",None, QApplication.UnicodeUTF8), # qmc.alarmtime 9
                               QApplication.translate("ComboBox","START",None, QApplication.UnicodeUTF8), # qmc.alarmtime -1
                               QApplication.translate("ComboBox","CHARGE",None, QApplication.UnicodeUTF8), # qmc.alarmtime 0
                               QApplication.translate("ComboBox","TP",None, QApplication.UnicodeUTF8), # qmc.alarmtime 8
                               QApplication.translate("ComboBox","DRY END",None, QApplication.UnicodeUTF8), # qmc.alarmtime 1
                               QApplication.translate("ComboBox","FC START",None, QApplication.UnicodeUTF8), # qmc.alarmtime 2
                               QApplication.translate("ComboBox","FC END",None, QApplication.UnicodeUTF8), # qmc.alarmtime 3
                               QApplication.translate("ComboBox","SC START",None, QApplication.UnicodeUTF8), # qmc.alarmtime 4
                               QApplication.translate("ComboBox","SC END",None, QApplication.UnicodeUTF8), # qmc.alarmtime 5
                               QApplication.translate("ComboBox","DROP",None, QApplication.UnicodeUTF8), # qmc.alarmtime 6
                               QApplication.translate("ComboBox","COOL",None, QApplication.UnicodeUTF8)]) # qmc.alarmtime 7
        timeComboBox.setCurrentIndex(aw.qmc.alarmtime2menuidx[aw.qmc.alarmtime[i]])
        #time after selected event
        timeoffsetedit = QLineEdit(aw.qmc.stringfromseconds(max(0,aw.qmc.alarmoffset[i])))
        timeoffsetedit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        timeoffsetedit.setValidator(QRegExpValidator(regextime,self))
        #type/source
        typeComboBox = QComboBox()
        aitems = self.buildAlarmSourceList()
        typeComboBox.addItems(aitems)
        if aw.qmc.alarmsource[i] + 3 < len(aitems):
            typeComboBox.setCurrentIndex(aw.qmc.alarmsource[i] + 3)
        else:
            typeComboBox.setCurrentIndex(3)
        #condition
        condComboBox = QComboBox()
        condComboBox.addItems([QApplication.translate("ComboBox","below",None, QApplication.UnicodeUTF8),
                               QApplication.translate("ComboBox","above",None, QApplication.UnicodeUTF8)])
        condComboBox.setCurrentIndex(aw.qmc.alarmcond[i])
        #temperature
        tempedit = QLineEdit(str(aw.qmc.alarmtemperature[i]))
        tempedit.setAlignment(Qt.AlignRight)
        tempedit.setMaximumWidth(100)
        tempedit.setValidator(QIntValidator(0, 999,tempedit))
        #action
        actionComboBox = QComboBox()
        actionComboBox.addItems(["",
                                 QApplication.translate("ComboBox","Pop Up",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","Call Program",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","Event Button",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(0)),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(1)),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(2)),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(3)),
                                 QApplication.translate("ComboBox","START",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","DRY",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","FCs",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","FCe",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","SCs",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","SCe",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","DROP",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","COOL END",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","OFF",None, QApplication.UnicodeUTF8)])
        actionComboBox.setCurrentIndex(aw.qmc.alarmaction[i] + 1)
        #beep
        beepWidget = QWidget()
        beepComboBox = QCheckBox()
        beepComboBox.setFocusPolicy(Qt.NoFocus)
        beepLayout = QHBoxLayout()
        beepLayout.addStretch()
        beepLayout.addWidget(beepComboBox)
        beepLayout.addSpacing(6);        
        beepLayout.addStretch()
        beepLayout.setContentsMargins(0,0,0,0)
        beepLayout.setSpacing(0)
        beepWidget.setLayout(beepLayout)
        if len(aw.qmc.alarmbeep) > i and aw.qmc.alarmbeep[i]:
            beepComboBox.setCheckState(Qt.Checked)
        else:
            beepComboBox.setCheckState(Qt.Unchecked)
        #text description
        descriptionedit = QLineEdit(u(aw.qmc.alarmstrings[i]))
        descriptionedit.setCursorPosition(0)
        self.alarmtable.setCellWidget(i,0,flagComboBox)
        self.alarmtable.setCellWidget(i,1,guardedit)
        self.alarmtable.setCellWidget(i,2,negguardedit)
        self.alarmtable.setCellWidget(i,3,timeComboBox)
        self.alarmtable.setCellWidget(i,4,timeoffsetedit)
        self.alarmtable.setCellWidget(i,5,typeComboBox)
        self.alarmtable.setCellWidget(i,6,condComboBox)
        self.alarmtable.setCellWidget(i,7,tempedit)
        self.alarmtable.setCellWidget(i,8,actionComboBox)
        self.alarmtable.setCellWidget(i,9,beepWidget)
        self.alarmtable.setCellWidget(i,10,descriptionedit)

    # puts a gray background on alarm rows that have already been fired
    def markNotEnabledAlarmRows(self):
        for i in range(self.alarmtable.rowCount()):
            for j in range(10):
                if aw.qmc.alarmstate[i]:
                    self.alarmtable.setItem(i,j,QTableWidgetItem())
                    self.alarmtable.item(i,j).setBackgroundColor(QColor(191, 191, 191))

    def createalarmtable(self):
        try:
            self.alarmtable.clear()
            self.alarmtable.setTabKeyNavigation(True)
            self.alarmtable.setColumnCount(11)
            self.alarmtable.setHorizontalHeaderLabels([QApplication.translate("Table","Status",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","If Alarm",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","But Not",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","From",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Time",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Source",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Condition",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Temp",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Action",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Beep",None, QApplication.UnicodeUTF8),
                                                           QApplication.translate("Table","Description",None, QApplication.UnicodeUTF8)])
            self.alarmtable.setAlternatingRowColors(True)
            self.alarmtable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.alarmtable.setSelectionBehavior(QTableWidget.SelectRows)
            self.alarmtable.setSelectionMode(QTableWidget.SingleSelection)
            self.alarmtable.setShowGrid(True)
            nalarms = len(aw.qmc.alarmtemperature)
            self.alarmtable.verticalHeader().setResizeMode(2)
            if nalarms:
                self.alarmtable.setRowCount(nalarms)
                #populate table
                for i in range(nalarms):
                    self.setalarmtablerow(i)
                self.alarmtable.resizeColumnsToContents()
                # improve width of Qlineedit columns
                self.alarmtable.setColumnWidth(1,50)
                self.alarmtable.setColumnWidth(2,50)
                self.alarmtable.setColumnWidth(4,50)
                self.alarmtable.setColumnWidth(5,80)
                self.alarmtable.setColumnWidth(7,40)
                header = self.alarmtable.horizontalHeader()
                header.setStretchLastSection(True)
                self.markNotEnabledAlarmRows()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " createalarmtable() %1").arg(str(ex)),exc_tb.tb_lineno)


# UNDER WORK 
#######################################################################################
#################### COFFEE CRACK  DETECTOR PROJECT ###################################
#######################################################################################

#class soundcrack(FigureCanvas):
#    def __init__(self,parent):
#        self.fig = Figure(facecolor='lightgrey')
#        FigureCanvas.__init__(self, self.fig)
#        self.ax = self.fig.add_subplot(111, axisbg="black")
#        self.ax.grid(True,linewidth=2,color="green")
#        self.ax.set_xlim(0,5500)
#        self.ax.set_ylim(-1,1)
#        #make first empty plot of frequency
#        self.Freqline, = self.ax.plot([], [], animated=True, lw=1,color = "#78E800")
#        #make first empty plot of rms amplitude     
#        self.Ampline, = self.ax.plot([], [], animated=True, lw=2,color = "orange")
#        self.N_SAMPLES = 1024
#        self.SAMPLING_RATE = 11025
#        self.amplitudeThreshold = .6
#        self.fig.canvas.draw()
#        self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
#        self.ampsensitivity = 10
#        self.freqs = numpy.fft.fftfreq(self.N_SAMPLES,1./self.SAMPLING_RATE)[:self.N_SAMPLES/2] #X axis
#        self.stream = None
#        self.pa = None
#        self.ON = 0
#
#    def reset(self):
#        self.fig.clf()   #wipe out figure
#        self.ax = self.fig.add_subplot(111, axisbg="black")
#        self.ax.grid(True,linewidth=2,color="green")
#        self.ax.set_xlim(0,5500)
#        self.ax.set_ylim(-1,1)
#        self.fig.canvas.draw()
#        self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
#
#    def crackdetedted(self):
#        pass
#
#    #updates animated display
#    def blitsound(self):   
#        if self.ON:
#            self.fig.canvas.restore_region(self.background)
#            F,amplitude = self.getsound()
#            amplitude *= self.ampsensitivity
#            self.Freqline.set_data(self.freqs,F)
#            self.Ampline.set_data([0,5500],[amplitude,amplitude])
#            self.ax.draw_artist(self.Freqline)
#            self.ax.draw_artist(self.Ampline)
#            self.fig.canvas.blit(self.ax.bbox)
#
#    def opensound(self):
#        try:
#            import pyaudio
#        except ImportError:
#            return False
#        self.reset()
#        self.ON = 1
#        self.pa = pyaudio.PyAudio()
#        self.stream = self.pa.open(format=pyaudio.paInt16, channels=1, rate=self.SAMPLING_RATE,
#                     input=True, frames_per_buffer=self.N_SAMPLES)
#
#    def closesound(self):
#        self.ON = 0
#        self.stream.close()
#        self.pa.terminate()
#        
#    def getsound(self):
#        #F[m] = m*SAMPLING_RATE/N_SAMPLES   (List with magnitudes of frequencies) Y axis
#        
#        block = self.stream.read(self.N_SAMPLES)
#        
#        count = len(block)/2
#        formatS = "%dh"%(count)
#        audio_data  = struct.unpack(formatS, block)
#        sum_squares = 0
#        naudio = []
#        for sample in audio_data:
#            n = sample /32768.            #normalize
#            naudio.append(n)
#            sum_squares += n*n
#        from scipy import fft
#        F = fft(naudio)[:self.N_SAMPLES/2]
#        amplitude =  math.sqrt(sum_squares / count)    #rms
#        return F,amplitude
#
#    def keyPressEvent(self,event):
#        key = int(event.key())
#        #uncomment next line to find the integer value of a key
#        #print key
#        if key == 16777216: #ESCAPE
#            self.close()

#########################################################################
######################## FUJI PXR CONTROL DIALOG  #######################
#########################################################################

class PXRpidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(PXRpidDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXR PID Control",None, QApplication.UnicodeUTF8))
        #create Ramp Soak control button colums
        self.labelrs1 = QLabel()
        self.labelrs1.setMargin(5)
        self.labelrs1.setStyleSheet("background-color:'#CCCCCC';")
        self.labelrs1.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak HH:MM<br>(1-4)",None, QApplication.UnicodeUTF8) + "</b></font>")
        self.labelrs1.setMaximumSize(120, 62)
        self.labelrs2 = QLabel()
        self.labelrs2.setMargin(5)
        self.labelrs2.setStyleSheet("background-color:'#CCCCCC';")
        self.labelrs2.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak HH:MM<br>(5-8)",None, QApplication.UnicodeUTF8) + "</b></font>")
        self.labelrs2.setMaximumSize(120, 62)
        labelpattern = QLabel(QApplication.translate("Label", "Ramp/Soak Pattern",None, QApplication.UnicodeUTF8))
        self.patternComboBox =  QComboBox()
        self.patternComboBox.addItems(["1-4","5-8","1-8"])
        self.patternComboBox.setCurrentIndex(aw.fujipid.PXR["rampsoakpattern"][0])
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Ready",None, QApplication.UnicodeUTF8),5000)
        self.label_rs1 =  QLabel()
        self.label_rs2 =  QLabel()
        self.label_rs3 =  QLabel()
        self.label_rs4 =  QLabel()
        self.label_rs5 =  QLabel()
        self.label_rs6 =  QLabel()
        self.label_rs7 =  QLabel()
        self.label_rs8 =  QLabel()
        self.paintlabels()
        #update button and exit button
        button_getall = QPushButton(QApplication.translate("Button","Read Ra/So values",None, QApplication.UnicodeUTF8))
        button_rson =  QPushButton(QApplication.translate("Button","RampSoak ON",None, QApplication.UnicodeUTF8))
        button_rsoff =  QPushButton(QApplication.translate("Button","RampSoak OFF",None, QApplication.UnicodeUTF8))
        button_standbyON = QPushButton(QApplication.translate("Button","PID OFF",None, QApplication.UnicodeUTF8))
        button_standbyOFF = QPushButton(QApplication.translate("Button","PID ON",None, QApplication.UnicodeUTF8))
        button_exit = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        self.connect(self.patternComboBox,SIGNAL("currentIndexChanged(int)"),self.paintlabels)
        self.connect(button_getall, SIGNAL("clicked()"), self.getallsegments)
        self.connect(button_rson, SIGNAL("clicked()"), lambda flag=1: self.setONOFFrampsoak(flag))
        self.connect(button_rsoff, SIGNAL("clicked()"), lambda flag=0: self.setONOFFrampsoak(flag))
        self.connect(button_standbyON, SIGNAL("clicked()"), lambda flag=1: self.setONOFFstandby(flag))
        self.connect(button_standbyOFF, SIGNAL("clicked()"), lambda flag=0: self.setONOFFstandby(flag))
        self.connect(button_exit, SIGNAL("clicked()"),self, SLOT("reject()"))
        #TAB 2
        tab2svbutton = QPushButton(QApplication.translate("Button","Write SV",None, QApplication.UnicodeUTF8))
        tab2cancelbutton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton = QPushButton(QApplication.translate("Button","SV Buttons ON",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton.setStyleSheet("QPushButton { background-color: #ffaaff}")
        tab2easyOFFsvbutton = QPushButton(QApplication.translate("Button","SV Buttons OFF",None, QApplication.UnicodeUTF8))
        tab2easyOFFsvbutton.setStyleSheet("QPushButton { background-color: lightblue}")
        tab2getsvbutton = QPushButton(QApplication.translate("Button","Read SV",None, QApplication.UnicodeUTF8))
        self.readsvedit = QLineEdit()
        self.connect(tab2svbutton, SIGNAL("clicked()"),self.setsv)
        self.connect(tab2getsvbutton, SIGNAL("clicked()"),self.getsv)
        self.connect(tab2cancelbutton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(tab2easyONsvbutton, SIGNAL("clicked()"), lambda flag=1: aw.fujipid.activateONOFFeasySV(flag))
        self.connect(tab2easyOFFsvbutton, SIGNAL("clicked()"), lambda flag=0: aw.fujipid.activateONOFFeasySV(flag))
        svwarning1 = QLabel("<CENTER><b>" + QApplication.translate("Label", "WARNING",None, QApplication.UnicodeUTF8) + "</b><br>"
                            + QApplication.translate("Label", "Writing eeprom memory",None, QApplication.UnicodeUTF8) + "<br>"
                            + QApplication.translate("Label", "<u>Max life</u> 10,000 writes",None, QApplication.UnicodeUTF8) + "<br>"
                            + QApplication.translate("Label", "Infinite read life.",None, QApplication.UnicodeUTF8) + "</CENTER>")
        svwarning2 = QLabel("<CENTER><b>" + QApplication.translate("Label", "WARNING",None, QApplication.UnicodeUTF8) + "</b><br>"
                            + QApplication.translate("Label", "After <u>writing</u> an adjustment,<br>never power down the pid<br>for the next 5 seconds <br>or the pid may never recover.",None, QApplication.UnicodeUTF8) + "<br>"
                            + QApplication.translate("Label", "Read operations manual",None, QApplication.UnicodeUTF8) + "</CENTER>")
        self.svedit = QLineEdit()
        self.svedit.setValidator(QDoubleValidator(0., 999., 1, self.svedit))
        #TAB 3
        button_p = QPushButton(QApplication.translate("Button","Set p",None, QApplication.UnicodeUTF8))
        button_i = QPushButton(QApplication.translate("Button","Set i",None, QApplication.UnicodeUTF8))
        button_d = QPushButton(QApplication.translate("Button","Set d",None, QApplication.UnicodeUTF8))
        plabel =  QLabel("p")
        ilabel =  QLabel("i")
        dlabel =  QLabel("d")
        self.pedit = QLineEdit(str(aw.fujipid.PXR["p"][0]))
        self.iedit = QLineEdit(str(aw.fujipid.PXR["i"][0]))
        self.dedit = QLineEdit(str(aw.fujipid.PXR["d"][0]))
        self.pedit.setMaximumWidth(60)
        self.iedit.setMaximumWidth(60)
        self.dedit.setMaximumWidth(60)
        self.pedit.setValidator(QDoubleValidator(0., 999., 1, self.pedit))
        self.iedit.setValidator(QIntValidator(0, 3200, self.iedit))
        self.dedit.setValidator(QDoubleValidator(0., 999.0, 1, self.dedit))
        button_autotuneON = QPushButton(QApplication.translate("Button","Autotune ON",None, QApplication.UnicodeUTF8))
        button_autotuneOFF = QPushButton(QApplication.translate("Button","Autotune OFF",None, QApplication.UnicodeUTF8))
        button_readpid = QPushButton(QApplication.translate("Button","Read PID Values",None, QApplication.UnicodeUTF8))
        tab3cancelbutton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        self.connect(button_autotuneON, SIGNAL("clicked()"), lambda flag=1: self.setONOFFautotune(flag))
        self.connect(button_autotuneOFF, SIGNAL("clicked()"), lambda flag=0: self.setONOFFautotune(flag))
        self.connect(button_p, SIGNAL("clicked()"), lambda var="p": self.setpid(var))
        self.connect(button_i, SIGNAL("clicked()"), lambda var="i": self.setpid(var))
        self.connect(button_d, SIGNAL("clicked()"), lambda var="d": self.setpid(var))
        self.connect(tab3cancelbutton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(button_readpid, SIGNAL("clicked()"), self.getpid)
        #TAB4
        #table for setting segments
        self.segmenttable = QTableWidget()
        self.createsegmenttable()
        #****************************   TAB5 WIDGETS
        BTthermolabelnote = QLabel(QApplication.translate("Label","NOTE: BT Thermocouple type is not stored in the Artisan settings",None, QApplication.UnicodeUTF8))
        self.ETthermocombobox = QComboBox()
        self.BTthermocombobox = QComboBox()
        #self.BTthermocombobox.setStyleSheet("background-color:'lightgrey';")
        ## FUJI PXG input types
        ##0 (JPT 100'3f)
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##9 (no function)
        ##10 (no function)
        ##11 (no function)
        ##12 (N)
        ##13 (PL- 2)
        ##14 (no function)
        ##15 (0V to 5V / 0mA to 20mA
        ##16 (1V to 5V/4mA to 20mA)
        ##17 (0mV to 10V)
        ##18 (2V to 10V)
        ##19 (0mV to 100mV)
        self.PXGthermotypes = ["JPT 100",#0
                            "PT 100",    #1
                            "J",         #2
                            "K",         #3
                            "R",         #4
                            "B",         #5
                            "S",         #6
                            "T",         #7
                            "E",         #8
                            "N",         #12
                            "PL-2",      #13
                            "0V-5V/0mA-20mA", #15
                            "1V-5V/4mA-20mA", #16
                            "0mV-10V",   #17
                            "2V to 10V", #18
                            "0mV-100mV"  #19
                            ]
        self.PXGconversiontoindex = [0,1,2,3,4,5,6,7,8,12,13,15,16,17,18,19]  #converts fuji PID PXG types to indexes
        ## FUJI PXR input types
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##12 (N)
        ##13 (PL- 2)
        ##16 (1V to 5V/4mA to 20mA)
        self.PXRthermotypes = [
                            "PT 100",   #1
                            "J",        #2
                            "K",        #3
                            "R",        #4
                            "B",        #5
                            "S",        #6
                            "T",        #7
                            "E",        #8
                            "N",        #12
                            "PL-2",    #13
                            "1V to 5V/4mA to 20mA" #16
                            ]
        self.PXRconversiontoindex = [1,2,3,4,5,6,7,8,12,13,16]  #converts fuji PID PXR types to indexes
        self.ETthermocombobox.addItems(self.PXRthermotypes)
        if aw.ser.readBTpid[0] == 0:        #fuji PXG
            self.BTthermocombobox.addItems(self.PXGthermotypes)
        else:                               #fuji PXR
            self.BTthermocombobox.addItems(self.PXRthermotypes)
        if aw.fujipid.PXR["pvinputtype"][0] in self.PXRconversiontoindex:
            self.ETthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(aw.fujipid.PXR["pvinputtype"][0]))
        setETthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        setBTthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        getETthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        getBTthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        setETthermocouplebutton.setMaximumWidth(80)
        getETthermocouplebutton.setMaximumWidth(80)
        setBTthermocouplebutton.setMaximumWidth(80)
        getBTthermocouplebutton.setMaximumWidth(80)
        self.connect(setETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.setthermocoupletype(PID))
        self.connect(setBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.setthermocoupletype(PID))
        self.connect(getETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.readthermocoupletype(PID))
        self.connect(getBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.readthermocoupletype(PID))
        PointButtonET = QPushButton(QApplication.translate("Button","Set ET PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonET.setFocusPolicy(Qt.NoFocus)
        PointButtonBT = QPushButton(QApplication.translate("Button","Set BT PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonBT.setFocusPolicy(Qt.NoFocus)
        PointButtonET.setMaximumWidth(250)
        PointButtonBT.setMaximumWidth(250)
        pointlabel = QLabel(QApplication.translate("Label","Artisan uses 1 decimal point",None, QApplication.UnicodeUTF8))
        self.connect(PointButtonET, SIGNAL("clicked()"), lambda PID="ET": self.setpoint(PID))
        self.connect(PointButtonBT, SIGNAL("clicked()"), lambda PID="BT": self.setpoint(PID))
        #create layouts
        buttonMasterLayout = QGridLayout()
        buttonRampSoakLayout1 = QVBoxLayout()
        buttonRampSoakLayout2 = QVBoxLayout()
        tab3layout = QGridLayout()
        svlayout = QGridLayout()
        #place rs buttoms in RampSoakLayout1
        buttonRampSoakLayout1.addWidget(self.labelrs1,0)
        buttonRampSoakLayout1.addWidget(self.label_rs1,1)
        buttonRampSoakLayout1.addWidget(self.label_rs2,2)
        buttonRampSoakLayout1.addWidget(self.label_rs3,3)
        buttonRampSoakLayout1.addWidget(self.label_rs4,4)
        buttonRampSoakLayout2.addWidget(self.labelrs2,0)
        buttonRampSoakLayout2.addWidget(self.label_rs5,1)
        buttonRampSoakLayout2.addWidget(self.label_rs6,2)
        buttonRampSoakLayout2.addWidget(self.label_rs7,3)
        buttonRampSoakLayout2.addWidget(self.label_rs8,4)
        buttonMasterLayout.addLayout(buttonRampSoakLayout1,0,0)
        buttonMasterLayout.addLayout(buttonRampSoakLayout2,0,1)
        buttonMasterLayout.addWidget(labelpattern,1,0)
        buttonMasterLayout.addWidget(self.patternComboBox,1,1)
        buttonMasterLayout.addWidget(button_rson,2,0)
        buttonMasterLayout.addWidget(button_rsoff,2,1)
        buttonMasterLayout.addWidget(button_autotuneOFF,3,1)
        buttonMasterLayout.addWidget(button_autotuneON,3,0)
        buttonMasterLayout.addWidget(button_standbyOFF,4,0)
        buttonMasterLayout.addWidget(button_standbyON,4,1)
        buttonMasterLayout.addWidget(button_getall,5,0)
        buttonMasterLayout.addWidget(button_exit,5,1)
        #tab 2
        svlayout.addWidget(svwarning2,0,0)
        svlayout.addWidget(svwarning1,0,1)
        svlayout.addWidget(self.readsvedit,1,0)
        svlayout.addWidget(tab2getsvbutton,1,1)
        svlayout.addWidget(self.svedit,2,0)
        svlayout.addWidget(tab2svbutton,2,1)
        svlayout.addWidget(tab2easyONsvbutton,3,0)
        svlayout.addWidget(tab2easyOFFsvbutton,3,1)
        svlayout.addWidget(tab2cancelbutton,4,1)
        #tab 3
        tab3layout.addWidget(plabel,0,0)
        tab3layout.addWidget(self.pedit,0,1)
        tab3layout.addWidget(button_p,0,2)
        tab3layout.addWidget(ilabel,1,0)
        tab3layout.addWidget(self.iedit,1,1)
        tab3layout.addWidget(button_i,1,2)
        tab3layout.addWidget(dlabel,2,0)
        tab3layout.addWidget(self.dedit,2,1)
        tab3layout.addWidget(button_d,2,2)
        tab3layout.addWidget(button_autotuneON,3,1)
        tab3layout.addWidget(button_autotuneOFF,3,2)
        tab3layout.addWidget(button_readpid,4,1)
        tab3layout.addWidget(tab3cancelbutton,4,2)
        tab4layout = QVBoxLayout()
        tab4layout.addWidget(self.segmenttable)
        #tab5
        thermolayoutET = QHBoxLayout()
        thermolayoutET.addWidget(self.ETthermocombobox)
        thermolayoutET.addStretch()
        thermolayoutET.addWidget(getETthermocouplebutton)
        thermolayoutET.addWidget(setETthermocouplebutton)
        ETGroupBox = QGroupBox(QApplication.translate("Label","ET Thermocouple type",None, QApplication.UnicodeUTF8))
        ETGroupBox.setLayout(thermolayoutET)
        thermolayoutBT = QHBoxLayout()
        thermolayoutBT.addWidget(self.BTthermocombobox)
        thermolayoutBT.addStretch()
        thermolayoutBT.addWidget(getBTthermocouplebutton)
        thermolayoutBT.addWidget(setBTthermocouplebutton)
        BTGroupBox = QGroupBox(QApplication.translate("Label","BT Thermocouple type",None, QApplication.UnicodeUTF8))
        BTGroupBox.setLayout(thermolayoutBT)
        tab5Layout = QVBoxLayout()
        tab5Layout.addWidget(ETGroupBox)
        tab5Layout.addWidget(BTGroupBox)
        tab5Layout.addWidget(BTthermolabelnote)
        tab5Layout.addStretch()
        tab5Layout.addWidget(pointlabel)
        tab5Layout.addWidget(PointButtonET)
        tab5Layout.addWidget(PointButtonBT)
        tab5Layout.addStretch()
        ###################################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(buttonMasterLayout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","RS",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(svlayout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","SV",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","PID",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Set RS",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Extra",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(self.status,0)
        Mlayout.addWidget(TabWidget,1)
        self.setLayout(Mlayout)

    def setpoint(self,PID):
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                if PID == "ET":
                    slaveID = aw.ser.controlETpid[1]
                    reg = aw.modbus.address2register(aw.fujipid.PXR["decimalposition"][1],6)
                elif PID == "BT":
                    slaveID = aw.ser.readBTpid[1]
                    if aw.ser.readBTpid[0] == 0:
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["decimalposition"][1],6)
                    elif aw.ser.readBTpid[0] == 1:
                        reg = aw.modbus.address2register(aw.fujipid.PXR["decimalposition"][1],6)
                if reg:
                    aw.modbus.writeSingleRegister(slaveID,reg,1)
                r = command
            else:
                if PID == "ET":
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["decimalposition"][1],1)
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["decimalposition"][1],1)
                    elif aw.ser.readBTpid[0] == 1:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["decimalposition"][1],1)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Decimal position successfully set to 1",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting decimal position",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setpoint(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setthermocoupletype(self,PID):
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                if PID == "ET":
                    slaveID = aw.ser.controlETpid[1]
                    index = self.ETthermocombobox.currentIndex()
                    value = self.PXRconversiontoindex[index]
                    reg = aw.modbus.address2register(aw.fujipid.PXR["pvinputtype"][1],6)
                elif PID == "BT":
                    slaveID = aw.ser.readBTpid[1]
                    index = self.BTthermocombobox.currentIndex()
                    if aw.ser.readBTpid[0] == 0:
                        value = self.PXGconversiontoindex[index]
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["pvinputtype"][1],6)
                    elif aw.ser.readBTpid[0] == 1:
                        value = self.PXRconversiontoindex[index]
                        reg = aw.modbus.address2register(aw.fujipid.PXR["pvinputtype"][1],6)
                if reg:
                    aw.modbus.writeSingleRegister(slaveID,reg,value)
                r = command
            else:
                if PID == "ET":
                    index = self.ETthermocombobox.currentIndex()
                    value = self.PXRconversiontoindex[index]
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["pvinputtype"][1],value)
                elif PID == "BT":
                    index = self.BTthermocombobox.currentIndex()
                    if aw.ser.readBTpid[0] == 0:
                        value = self.PXGconversiontoindex[index]
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["pvinputtype"][1],value)
                    elif aw.ser.readBTpid[0] == 1:
                        value = self.PXRconversiontoindex[index]
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["pvinputtype"][1],value)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                if PID == "ET":
                    aw.fujipid.PXG4["pvinputtype"][0] = self.PXRconversiontoindex[self.ETthermocombobox.currentIndex()]
                elif PID == "BT":
                    pass #this info is not stored
                message = QApplication.translate("StatusBar","Thermocouple type successfully set to %i"%(value),None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting thermocouple type",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def readthermocoupletype(self,PID):
        message = "empty"
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                if PID == "ET":
                    reg = aw.modbus.address2register(aw.fujipid.PXR["pvinputtype"][1],3)
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["pvinputtype"][1],3)
                    elif aw.ser.readBTpid[0] == 1:
                        reg = aw.modbus.address2register(aw.fujipid.PXR["pvinputtype"][1],3)
                if reg:
                    Thtype = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
            else:
                if PID == "ET":
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["pvinputtype"][1],1)
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXG4["pvinputtype"][1],1)
                    elif aw.ser.readBTpid[0] == 1:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXR["pvinputtype"][1],1)
                if command:
                    Thtype = aw.fujipid.readoneword(command)
                
            if command:                
                if PID == "ET":
                    if Thtype in self.PXRconversiontoindex:
                        self.ETthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(Thtype))
                        aw.fujipid.PXR["pvinputtype"][0] = Thtype
                        message = "ET PXR input type %i: %s"%(Thtype,self.PXRthermotypes[self.PXRconversiontoindex.index(Thtype)])
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        if Thtype in self.PXGconversiontoindex:
                            self.BTthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(Thtype))
                            message = "BT PXG input type %i: %s"%(Thtype,self.PXGthermotypes[self.PXGconversiontoindex.index(Thtype)])
                    elif aw.ser.readBTpid[0] == 1:
                        if Thtype in self.PXRconversiontoindex:
                            self.BTthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(Thtype))
                            aw.fujipid.PXR["pvinputtype"][0] = Thtype
                            message = "BT PXR input type %i: %s"%(Thtype,self.PXRthermotypes[self.PXRconversiontoindex.index(Thtype)])
                self.status.showMessage(message,5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " readthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def paintlabels(self):
        str1 = "T = " + str(aw.fujipid.PXR["segment1sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment1ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment1soak"][0]))
        str2 = "T = " + str(aw.fujipid.PXR["segment2sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment2ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment2soak"][0]))
        str3 = "T = " + str(aw.fujipid.PXR["segment3sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment3ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment3soak"][0]))
        str4 = "T = " + str(aw.fujipid.PXR["segment4sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment4ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment4soak"][0]))
        str5 = "T = " + str(aw.fujipid.PXR["segment5sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment5ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment5soak"][0]))
        str6 = "T = " + str(aw.fujipid.PXR["segment6sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment6ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment6soak"][0]))
        str7 = "T = " + str(aw.fujipid.PXR["segment7sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment7ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment7soak"][0]))
        str8 = "T = " + str(aw.fujipid.PXR["segment8sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment8ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment8soak"][0]))
        self.label_rs1.setText(QString(str1))
        self.label_rs2.setText(QString(str2))
        self.label_rs3.setText(QString(str3))
        self.label_rs4.setText(QString(str4))
        self.label_rs5.setText(QString(str5))
        self.label_rs6.setText(QString(str6))
        self.label_rs7.setText(QString(str7))
        self.label_rs8.setText(QString(str8))
        pattern = [[1,1,1,1,0,0,0,0],
                  [0,0,0,0,1,1,1,1],
                  [1,1,1,1,1,1,1,1]]
        aw.fujipid.PXR["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][0]:   
            self.label_rs1.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs1.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][1]:
            self.label_rs2.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs2.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][2]:   
            self.label_rs3.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs3.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][3]:   
            self.label_rs4.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs4.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][4]:   
            self.label_rs5.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs5.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][5]:   
            self.label_rs6.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs6.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][6]:   
            self.label_rs7.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs7.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][7]:   
            self.label_rs8.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs8.setStyleSheet("background-color:white;")

    def setONOFFautotune(self,flag):
        self.status.showMessage(QApplication.translate("StatusBar","setting autotune...",None, QApplication.UnicodeUTF8),500)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["autotuning"][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
            r = "00000000"
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["autotuning"][1],flag)
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
        if len(r) == 8:
            if flag == 0:
                aw.fujipid.PXR["autotuning"][0] = 0
                self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned OFF",None, QApplication.UnicodeUTF8),5000)
            if flag == 1:
                aw.fujipid.PXR["autotuning"][0] = 1
                self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned ON",None, QApplication.UnicodeUTF8),5000)
        else:
            mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFautotune()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFautotune()")

    def setONOFFstandby(self,flag):
        #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
        #flag = 0 standby OFF, flag = 1 standby ON (pid off)
        self.status.showMessage(QApplication.translate("StatusBar","wait...",None, QApplication.UnicodeUTF8),500)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["runstandby"][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
            r = "00000000"
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["runstandby"][1],flag)
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
        if r == command:
            if flag == 1:
                message = QApplication.translate("StatusBar","PID OFF",None, QApplication.UnicodeUTF8)     #put pid in standby 1 (pid on)
                aw.fujipid.PXR["runstandby"][0] = 1
            elif flag == 0:
                message = QApplication.translate("StatusBar","PID ON",None, QApplication.UnicodeUTF8)      #put pid in standby 0 (pid off)
                aw.fujipid.PXR["runstandby"][0] = 0
            self.status.showMessage(message,5000)
        else:
            mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFstandby()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def setsv(self):
        if self.svedit.text() != "":
            newSVvalue = int(float(self.svedit.text())*10) #multiply by 10 because of decimal point
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["sv0"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newSVvalue)
                message = QApplication.translate("StatusBar","SV successfully set to %1",None, QApplication.UnicodeUTF8).arg(self.svedit.text())
                aw.fujipid.PXR["sv0"][0] = float(str(self.svedit.text()))
                self.status.showMessage(message,5000)
                #record command as an Event 
                strcommand = "SETSV::"+ str("%.1f"%(newSVvalue/10.))
                aw.qmc.DeviceEventRecord(strcommand)
            else:          
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["sv0"][1],newSVvalue)
                r = aw.ser.sendFUJIcommand(command,8)
                if r == command:
                    message = QApplication.translate("StatusBar","SV successfully set to %1",None, QApplication.UnicodeUTF8).arg(self.svedit.text())
                    aw.fujipid.PXR["sv0"][0] = float(str(self.svedit.text()))
                    self.status.showMessage(message,5000)
                    #record command as an Event 
                    strcommand = "SETSV::"+ str("%.1f"%(newSVvalue/10.))
                    aw.qmc.DeviceEventRecord(strcommand)
                else:
                    mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setsv()"
                    self.status.showMessage(mssg,5000)
                    aw.qmc.adderror(mssg)
        else:
            self.status.showMessage(QApplication.translate("StatusBar","Empty SV box",None, QApplication.UnicodeUTF8),5000)

    def getsv(self):
        temp = aw.fujipid.readcurrentsv()
        if temp != -1:
            aw.fujipid.PXR["sv0"][0] =  temp
            aw.lcd6.display(aw.fujipid.PXR["sv0"][0])
            self.readsvedit.setText(str(aw.fujipid.PXR["sv0"][0]))
        else:
            self.status.showMessage(QApplication.translate("StatusBar","Unable to read SV",None, QApplication.UnicodeUTF8),5000)

    def checkrampsoakmode(self):
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["rampsoakmode"][1],3)
            currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["rampsoakmode"][1],1)
            currentmode = aw.fujipid.readoneword(msg)
        aw.fujipid.PXR["rampsoakstartend"][0] = currentmode
        if currentmode == 0:
            mode = ["0",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 1:
            mode = ["1",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 2:
            mode = ["2",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 3:
            mode = ["3",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 4:
            mode = ["4",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 5:
            mode = ["5",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 6:
            mode = ["6",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 7:
            mode = ["7",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 8:
            mode = ["8",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 9:
            mode = ["9",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 10:
            mode = ["10",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 11:
            mode = ["11",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 12:
            mode = ["12",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 13:
            mode = ["13",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 14:
            mode = ["14",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 15:
            mode = ["15",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        else:
            return -1
        string =  QApplication.translate("Message","The rampsoak-mode tells how to start and end the ramp/soak",None, QApplication.UnicodeUTF8) + "\n\n"
        string += QApplication.translate("Message","Your rampsoak mode in this pid is:",None, QApplication.UnicodeUTF8) + "\n\n"
        string += QApplication.translate("Message","Mode = %1",None, QApplication.UnicodeUTF8).arg(mode[0]) + "\n"
        string += "-----------------------------------------------------------------------\n"
        string += QApplication.translate("Message","Start to run from PV value: %1",None, QApplication.UnicodeUTF8).arg(mode[1]) + "\n"
        string += QApplication.translate("Message","End output status at the end of ramp/soak: %1",None, QApplication.UnicodeUTF8).arg(mode[2]) + "\n"
        string += QApplication.translate("Message","Output status while ramp/soak operation set to OFF: %1",None, QApplication.UnicodeUTF8).arg(mode[3]) + "\n"
        string += QApplication.translate("Message","\nRepeat Operation at the end: %1",None, QApplication.UnicodeUTF8).arg(mode[4]) + "\n"
        string += "-----------------------------------------------------------------------\n"
        string += QApplication.translate("Message","Recomended Mode = 0",None, QApplication.UnicodeUTF8) + "\n\n"
        string += QApplication.translate("Message","If you need to change it, change it now and come back later",None, QApplication.UnicodeUTF8) + "\n"
        string += QApplication.translate("Message","Use the Parameter Loader Software by Fuji if you need to\n\n",None, QApplication.UnicodeUTF8) + "\n\n\n"
        string += QApplication.translate("Message","Continue?",None, QApplication.UnicodeUTF8)
        QMessageBox.information(self,QApplication.translate("Message", "RampSoak Mode",None, QApplication.UnicodeUTF8),string)

    def setONOFFrampsoak(self,flag):
        #flag =0 OFF, flag = 1 ON, flag = 2 hold
        #set rampsoak pattern ON
        if flag == 1:
            check = self.checkrampsoakmode()
            if check == 0:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak operation cancelled",None, QApplication.UnicodeUTF8), 5000)
                return
            elif check == -1:
                self.status.showMessage(QApplication.translate("StatusBar","No RX data",None, QApplication.UnicodeUTF8), 5000)

            self.status.showMessage(QApplication.translate("StatusBar","RS ON",None, QApplication.UnicodeUTF8),500)
            #0 = 1-4
            #1 = 5-8
            #2 = 1-8
            selectedmode = self.patternComboBox.currentIndex()
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["rampsoakpattern"][1],3)
                currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
            else:            
                msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["rampsoakpattern"][1],1)
                currentmode = aw.fujipid.readoneword(msg)            
            if currentmode != -1:
                aw.fujipid.PXR["rampsoakpattern"][0] = currentmode
                if currentmode != selectedmode:
                    #set mode in pid to match the mode selected in the combobox
                    self.status.showMessage(QApplication.translate("StatusBar","Need to change pattern mode...",None, QApplication.UnicodeUTF8),1000)
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(aw.fujipid.PXR["rampsoakpattern"][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,selectedmode)
                        r = "00000000"
                    else:
                        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["rampsoakpattern"][1],selectedmode)
                        r = aw.ser.sendFUJIcommand(command,8)
                    if len(r) == 8:
                        self.status.showMessage(QApplication.translate("StatusBar","Pattern has been changed. Wait 5 secs.",None, QApplication.UnicodeUTF8), 500)
                        aw.fujipid.PXR["rampsoakpattern"][0] = selectedmode
                    else:
                        self.status.showMessage(QApplication.translate("StatusBar","Pattern could not be changed",None, QApplication.UnicodeUTF8), 5000)
                        return
                #combobox mode matches pid mode
                #set ramp soak mode ON
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXR["rampsoak"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                    r = command = ""
                else:                
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["rampsoak"][1],flag)
                    r = aw.ser.sendFUJIcommand(command,8)
                if r == command:
                    #record command as an Event if flag = 1
                    self.status.showMessage(QApplication.translate("StatusBar","RS ON",None, QApplication.UnicodeUTF8), 5000)
                    #ramp soak pattern. 0=executes 1 to 4; 1=executes 5 to 8; 2=executes 1 to 8
                    pattern =[[1,4],[5,8],[1,8]]
                    start = pattern[aw.fujipid.PXR["rampsoakpattern"][0]][0]
                    end = pattern[aw.fujipid.PXR["rampsoakpattern"][0]][1]+1
                    strcommand = "SETRS"
                    result = ""
                    for i in range(start,end):
                        svkey = "segment"+str(i)+"sv"
                        rampkey = "segment"+str(i)+"ramp"
                        soakkey = "segment"+str(i)+"soak"
                        strcommand += "::" + str(aw.fujipid.PXR[svkey][0]) + "::" + str(aw.fujipid.PXR[rampkey][0]) + "::" + str(aw.fujipid.PXR[soakkey][0])+"::"
                        result += strcommand
                        strcommand = "SETRS"
                    result = result.strip("::")
                    aw.qmc.DeviceEventRecord(result)
                else:
                    self.status.showMessage(QApplication.translate("StatusBar","RampSoak could not be changed",None, QApplication.UnicodeUTF8), 5000)
            else:
                mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFrampsoak()"
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
        #set ramp soak OFF
        elif flag == 0:
            self.status.showMessage(QApplication.translate("StatusBar","RS OFF",None, QApplication.UnicodeUTF8),500)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["rampsoak"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["rampsoak"][1],flag)
                r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                self.status.showMessage(QApplication.translate("StatusBar","RS successfully turned OFF",None, QApplication.UnicodeUTF8), 5000)
                aw.fujipid.PXR["rampsoak"][0] = flag
            else:
                mssg = QApplication.translate("StatusBar","setONOFFrampsoak(): Ramp Soak could not be set OFF",None, QApplication.UnicodeUTF8)
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)

    def getsegment(self, idn):
        svkey = "segment" + str(idn) + "sv"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR[svkey][1],3)
            sv = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR[svkey][1],1)
            sv = aw.fujipid.readoneword(svcommand)
        if sv == -1:
            mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " getsegment()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            return -1
        aw.fujipid.PXR[svkey][0] = sv/10.              #divide by 10 because the decimal point is not sent by the PID
        rampkey = "segment" +str(idn) + "ramp"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR[rampkey][1],3)
            ramp = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR[rampkey][1],1)
            ramp = aw.fujipid.readoneword(rampcommand)
        if ramp == -1:
            mssg = QApplication.translate("StatusBar","getsegment(): problem reading ramp",None, QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            return -1
        aw.fujipid.PXR[rampkey][0] = ramp/10.
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR[soakkey][1],3)
            soak = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR[soakkey][1],1)
            soak = aw.fujipid.readoneword(soakcommand)
        if soak == -1:
            mssg = QApplication.translate("StatusBar","getsegment(): problem reading soak",None, QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            return -1
        aw.fujipid.PXR[soakkey][0] = soak/10.

    #get all Ramp Soak values for all 8 segments
    def getallsegments(self):
        for i in range(8):
            msg = QApplication.translate("StatusBar","Reading Ramp/Soak %1 ...",None, QApplication.UnicodeUTF8).arg(str(i+1))
            self.status.showMessage(msg,500)
            k = self.getsegment(i+1)
            libtime.sleep(0.03)
            if k == -1:
                self.status.showMessage(QApplication.translate("StatusBar","problem reading Ramp/Soak",None, QApplication.UnicodeUTF8),5000)
                return
            self.paintlabels()
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading Ramp/Soak val.",None, QApplication.UnicodeUTF8),5000)
        self.createsegmenttable()

    def getpid(self):
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["p"][1],3)
            p = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
        else:    
            pcommand= aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["p"][1],1)
            p = aw.fujipid.readoneword(pcommand)/10.
        if p == -1 :
            return -1
        else:
            self.pedit.setText(str(p))
            aw.fujipid.PXR["p"][0] = p
        #i is int range 0-3200
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["i"][1],3)
            i = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
        else:
            icommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["i"][1],1)
            i = aw.fujipid.readoneword(icommand)/10.
        if i == -1:
            return -1
        else:
            self.iedit.setText(str(int(i)))
            aw.fujipid.PXR["i"][0] = i
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["d"][1],3)
            d = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
        else:
            dcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["d"][1],1)
            d = aw.fujipid.readoneword(dcommand)/10.
        if d == -1:
            return -1
        else:
            self.dedit.setText(str(d))
            aw.fujipid.PXR["d"][0] = d
            
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading pid values",None, QApplication.UnicodeUTF8),5000)

    def setpid(self,var):
        r = ""
        if var == "p":
            if str(self.pedit.text()).isdigit():
                p = int(str(self.pedit.text()))*10
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXR["p"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,p)
                    r = "        "
                else:
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["p"][1],p)
                    r = aw.ser.sendFUJIcommand(command,8)
            else:
                return -1
        elif var == "i":
            if str(self.iedit.text()).isdigit():
                i = int(str(self.iedit.text()))*10
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXR["i"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,i)
                    r = "        "
                else:
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["i"][1],i)
                    r = aw.ser.sendFUJIcommand(command,8)
            else:
                return -1
        elif var == "d":
            if str(self.dedit.text()).isdigit():
                d = int(str(self.dedit.text()))*10
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXR["d"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,d)
                    r = "        "
                else:
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["d"][1],d)
                    r = aw.ser.sendFUJIcommand(command,8)
            else:
                return -1

        if len(r) == 8:
            message = QApplication.translate("StatusBar","%1 successfully sent to pid ",None, QApplication.UnicodeUTF8).arg(var)
            self.status.showMessage(message,5000)
            if var == "p":
                aw.fujipid.PXR["p"][0] = p
            elif var == "i":
                aw.fujipid.PXR["i"][0] = i
            elif var == "d":
                aw.fujipid.PXR["i"][0] = d
        else:
            mssg = QApplication.translate("StatusBar","setpid(): There was a problem setting %1",None, QApplication.UnicodeUTF8).arg(var)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def createsegmenttable(self):
        self.segmenttable.setRowCount(8)
        self.segmenttable.setColumnCount(4)
        self.segmenttable.setHorizontalHeaderLabels([QApplication.translate("Table","SV",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("Table","Ramp HH:MM",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("Table","Soak HH:MM",None, QApplication.UnicodeUTF8),""])
        self.segmenttable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.segmenttable.setSelectionBehavior(QTableWidget.SelectRows)
        self.segmenttable.setSelectionMode(QTableWidget.SingleSelection)
        self.segmenttable.setShowGrid(True)
        self.segmenttable.verticalHeader().setResizeMode(2)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #populate table
        for i in range(8):
            #create widgets
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            
            svedit = QLineEdit(str(aw.fujipid.PXR[svkey][0]))
            svedit.setValidator(QDoubleValidator(0., 999., 1, svedit))
            rampedit = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXR[rampkey][0])))
            rampedit.setValidator(QRegExpValidator(regextime,self))
            soakedit  = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXR[soakkey][0])))
            soakedit.setValidator(QRegExpValidator(regextime,self))
            setButton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
            self.connect(setButton,SIGNAL("clicked()"),lambda idn = i:self.setsegment(idn))
            #add widgets to the table
            self.segmenttable.setCellWidget(i,0,svedit)
            self.segmenttable.setCellWidget(i,1,rampedit)
            self.segmenttable.setCellWidget(i,2,soakedit)
            self.segmenttable.setCellWidget(i,3,setButton)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    def setsegment(self,i):
        idn = i+1
        svedit =  self.segmenttable.cellWidget(i,0)
        rampedit = self.segmenttable.cellWidget(i,1)
        soakedit = self.segmenttable.cellWidget(i,2)
        sv = float(str(svedit.text()))
        ramp = aw.qmc.stringtoseconds(str(rampedit.text()))
        soak = aw.qmc.stringtoseconds(str(soakedit.text()))
        svkey = "segment" + str(idn) + "sv"
        rampkey = "segment" + str(idn) + "ramp"
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR[svkey][1],6)       
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(sv*10))
            libtime.sleep(0.1) #important time between writings
            reg = aw.modbus.address2register(aw.fujipid.PXR[rampkey][1],6)       
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,ramp)
            libtime.sleep(0.1) #important time between writings
            reg = aw.modbus.address2register(aw.fujipid.PXR[soakkey][1],6)       
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,soak)        
            r1 = r2 = r3 = "        "
        else:
            svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[svkey][1],int(sv*10))
            r1 = aw.ser.sendFUJIcommand(svcommand,8)
            libtime.sleep(0.1) #important time between writings
            rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[rampkey][1],ramp)
            r2 = aw.ser.sendFUJIcommand(rampcommand,8)
            libtime.sleep(0.1) #important time between writings
            soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[soakkey][1],soak)
            r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1) == 8 and len(r2) == 8 and len(r3) == 8:
            aw.fujipid.PXR[svkey][0] = sv
            aw.fujipid.PXR[rampkey][0] = ramp
            aw.fujipid.PXR[soakkey][0] = soak
            self.paintlabels()
            self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak successfully written",None, QApplication.UnicodeUTF8),5000) 
        else:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None, QApplication.UnicodeUTF8))

############################################################################
######################## FUJI PXG4 PID CONTROL DIALOG ######################
############################################################################

class PXG4pidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(PXG4pidDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXG PID Control",None, QApplication.UnicodeUTF8))
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Ready",None, QApplication.UnicodeUTF8),5000)
        #*************    TAB 1 WIDGETS
        labelrs1 = QLabel()
        labelrs1.setMargin(5)
        labelrs1.setStyleSheet("background-color:'#CCCCCC';")
        labelrs1.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak (MM:SS)<br>(1-7)",None, QApplication.UnicodeUTF8) + "</b></font>")
        #labelrs1.setMaximumSize(90, 42)
        #labelrs1.setMinimumHeight(50)
        labelrs2 = QLabel()
        labelrs2.setMargin(5)
        labelrs2.setStyleSheet("background-color:'#CCCCCC';")
        labelrs2.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak (MM:SS)<br>(8-16)",None, QApplication.UnicodeUTF8) + "</b></font>")
        #labelrs2.setMaximumSize(90, 42)
        #labelrs2.setMinimumHeight(50)
        self.label_rs1 =  QLabel()
        self.label_rs2 =  QLabel()
        self.label_rs3 =  QLabel()
        self.label_rs4 =  QLabel()
        self.label_rs5 =  QLabel()
        self.label_rs6 =  QLabel()
        self.label_rs7 =  QLabel()
        self.label_rs8 =  QLabel()
        self.label_rs9 =  QLabel()
        self.label_rs10 =  QLabel()
        self.label_rs11 =  QLabel()
        self.label_rs12 =  QLabel()
        self.label_rs13 =  QLabel()
        self.label_rs14 =  QLabel()
        self.label_rs15 =  QLabel()
        self.label_rs16 =  QLabel()
        self.label_rs1.setMinimumWidth(170)
        self.label_rs2.setMinimumWidth(170)
        self.label_rs3.setMinimumWidth(170)
        self.label_rs4.setMinimumWidth(170)
        self.label_rs5.setMinimumWidth(170)
        self.label_rs6.setMinimumWidth(170)
        self.label_rs7.setMinimumWidth(170)
        self.label_rs8.setMinimumWidth(170)
        self.label_rs9.setMinimumWidth(170)
        self.label_rs10.setMinimumWidth(170)
        self.label_rs11.setMinimumWidth(170)
        self.label_rs12.setMinimumWidth(170)
        self.label_rs13.setMinimumWidth(170)
        self.label_rs14.setMinimumWidth(170)
        self.label_rs15.setMinimumWidth(170)
        self.label_rs16.setMinimumWidth(170)
        self.patternComboBox =  QComboBox()
        self.patternComboBox.addItems(["1-4","5-8","1-8","9-12","13-16","9-16","1-16"])
        self.patternComboBox.setCurrentIndex(aw.fujipid.PXG4["rampsoakpattern"][0])
        self.patternComboBox.setFocusPolicy(Qt.NoFocus)
        self.connect(self.patternComboBox,SIGNAL("currentIndexChanged(int)"),self.paintlabels)
        self.paintlabels()
        button_load = QPushButton(QApplication.translate("Button","Load",None, QApplication.UnicodeUTF8))
        button_load.setFocusPolicy(Qt.NoFocus)
        button_save = QPushButton(QApplication.translate("Button","Save",None, QApplication.UnicodeUTF8))
        button_save.setFocusPolicy(Qt.NoFocus)
        button_writeall = QPushButton(QApplication.translate("Button","Write All",None, QApplication.UnicodeUTF8))
        button_writeall.setFocusPolicy(Qt.NoFocus)
        patternlabel = QLabel(QApplication.translate("Label","Pattern",None, QApplication.UnicodeUTF8))
        patternlabel.setAlignment(Qt.AlignRight)
        button_getall = QPushButton(QApplication.translate("Button","Read RS values",None, QApplication.UnicodeUTF8))
        button_getall.setFocusPolicy(Qt.NoFocus)
        button_writeallrs = QPushButton(QApplication.translate("Button","Write RS values",None, QApplication.UnicodeUTF8))
        button_writeallrs.setFocusPolicy(Qt.NoFocus)
        button_rson =  QPushButton(QApplication.translate("Button","RampSoak ON",None, QApplication.UnicodeUTF8)) 
        button_rson.setFocusPolicy(Qt.NoFocus)
        button_rsoff =  QPushButton(QApplication.translate("Button","RampSoak OFF",None, QApplication.UnicodeUTF8))
        button_rsoff.setFocusPolicy(Qt.NoFocus)
        button_exit = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
#        button_exit2 = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        button_standbyON = QPushButton(QApplication.translate("Button","PID OFF",None, QApplication.UnicodeUTF8))
        button_standbyON.setFocusPolicy(Qt.NoFocus)
        button_standbyOFF = QPushButton(QApplication.translate("Button","PID ON",None, QApplication.UnicodeUTF8))
        button_standbyOFF.setFocusPolicy(Qt.NoFocus)
        self.connect(button_getall, SIGNAL("clicked()"), self.getallsegments)
        self.connect(button_writeallrs, SIGNAL("clicked()"), self.writeRSValues)
        self.connect(button_rson, SIGNAL("clicked()"), lambda flag=1: self.setONOFFrampsoak(flag))
        self.connect(button_rsoff, SIGNAL("clicked()"), lambda flag=0: self.setONOFFrampsoak(flag))
        self.connect(button_standbyON, SIGNAL("clicked()"), lambda flag=1: self.setONOFFstandby(flag))
        self.connect(button_standbyOFF, SIGNAL("clicked()"), lambda flag=0: self.setONOFFstandby(flag))
        self.connect(button_exit, SIGNAL("clicked()"),self, SLOT("reject()"))
#        self.connect(button_exit2, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(button_load, SIGNAL("clicked()"),lambda : self.load())
        self.connect(button_save, SIGNAL("clicked()"),lambda : self.save())
        self.connect(button_writeall, SIGNAL("clicked()"),lambda : self.writeAll())
        #create layouts and place tab1 widgets inside 
        buttonRampSoakLayout1 = QVBoxLayout() #TAB1/COLUNM 1
        buttonRampSoakLayout1.setSpacing(10)
        buttonRampSoakLayout2 = QVBoxLayout() #TAB1/COLUMN 2
        buttonRampSoakLayout2.setSpacing(10)
        #place rs labels in RampSoakLayout1 #TAB1/COLUNM 1
        buttonRampSoakLayout1.addWidget(labelrs1)
        buttonRampSoakLayout1.addWidget(self.label_rs1)
        buttonRampSoakLayout1.addWidget(self.label_rs2)
        buttonRampSoakLayout1.addWidget(self.label_rs3)
        buttonRampSoakLayout1.addWidget(self.label_rs4)
        buttonRampSoakLayout1.addWidget(self.label_rs5)
        buttonRampSoakLayout1.addWidget(self.label_rs6)
        buttonRampSoakLayout1.addWidget(self.label_rs7)
        buttonRampSoakLayout1.addWidget(self.label_rs8)
        #place rs labels in RampSoakLayout2 #TAB1/COLUMN 2
        buttonRampSoakLayout2.addWidget(labelrs2)
        buttonRampSoakLayout2.addWidget(self.label_rs9)
        buttonRampSoakLayout2.addWidget(self.label_rs10)
        buttonRampSoakLayout2.addWidget(self.label_rs11)
        buttonRampSoakLayout2.addWidget(self.label_rs12)
        buttonRampSoakLayout2.addWidget(self.label_rs13)
        buttonRampSoakLayout2.addWidget(self.label_rs14)
        buttonRampSoakLayout2.addWidget(self.label_rs15)
        buttonRampSoakLayout2.addWidget(self.label_rs16)
        # *************** TAB 2 WIDGETS
        labelsv = QLabel()
        labelsv.setMargin(10)
        labelsv.setStyleSheet("background-color:'#CCCCCC';")
        labelsv.setText("<font color='white'><b>" + QApplication.translate("Label", "SV (7-0)",None, QApplication.UnicodeUTF8) + "</b></font>")
        labelsv.setMaximumSize(100, 42)
        labelsv.setMinimumHeight(50)
        labelsvedit = QLabel()
        labelsvedit.setMargin(10)
        labelsvedit.setStyleSheet("background-color:'#CCCCCC';")
        labelsvedit.setText("<font color='white'><b>" + QApplication.translate("Label", "Write",None, QApplication.UnicodeUTF8) + "</b></font>")
        labelsvedit.setMaximumSize(100, 42)
        labelsvedit.setMinimumHeight(50)
        button_sv1 =QPushButton(QApplication.translate("Button","Write SV1",None, QApplication.UnicodeUTF8))
        button_sv1.setFocusPolicy(Qt.NoFocus)
        button_sv2 =QPushButton(QApplication.translate("Button","Write SV2",None, QApplication.UnicodeUTF8))
        button_sv2.setFocusPolicy(Qt.NoFocus)
        button_sv3 =QPushButton(QApplication.translate("Button","Write SV3",None, QApplication.UnicodeUTF8))
        button_sv3.setFocusPolicy(Qt.NoFocus)
        button_sv4 =QPushButton(QApplication.translate("Button","Write SV4",None, QApplication.UnicodeUTF8))
        button_sv4.setFocusPolicy(Qt.NoFocus)
        button_sv5 =QPushButton(QApplication.translate("Button","Write SV5",None, QApplication.UnicodeUTF8))
        button_sv5.setFocusPolicy(Qt.NoFocus)
        button_sv6 =QPushButton(QApplication.translate("Button","Write SV6",None, QApplication.UnicodeUTF8))
        button_sv6.setFocusPolicy(Qt.NoFocus)
        button_sv7 =QPushButton(QApplication.translate("Button","Write SV7",None, QApplication.UnicodeUTF8))
        button_sv7.setFocusPolicy(Qt.NoFocus)
        self.connect(button_sv1, SIGNAL("clicked()"), lambda v=1: self.setsv(v))
        self.connect(button_sv2, SIGNAL("clicked()"), lambda v=2: self.setsv(v))
        self.connect(button_sv3, SIGNAL("clicked()"), lambda v=3: self.setsv(v))
        self.connect(button_sv4, SIGNAL("clicked()"), lambda v=4: self.setsv(v))
        self.connect(button_sv5, SIGNAL("clicked()"), lambda v=5: self.setsv(v))
        self.connect(button_sv6, SIGNAL("clicked()"), lambda v=6: self.setsv(v))
        self.connect(button_sv7, SIGNAL("clicked()"), lambda v=7: self.setsv(v))
        self.sv1edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv1"][0])))
        self.sv2edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv2"][0])))
        self.sv3edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv3"][0])))
        self.sv4edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv4"][0])))
        self.sv5edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv5"][0])))
        self.sv6edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv6"][0])))
        self.sv7edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv7"][0])))
        self.sv1edit.setMaximumWidth(80)
        self.sv2edit.setMaximumWidth(80)
        self.sv3edit.setMaximumWidth(80)
        self.sv4edit.setMaximumWidth(80)
        self.sv5edit.setMaximumWidth(80)
        self.sv6edit.setMaximumWidth(80)
        self.sv7edit.setMaximumWidth(80)
        self.sv1edit.setValidator(QDoubleValidator(0., 999., 1, self.sv1edit))
        self.sv2edit.setValidator(QDoubleValidator(0., 999., 1, self.sv2edit))
        self.sv3edit.setValidator(QDoubleValidator(0., 999., 1, self.sv3edit))
        self.sv4edit.setValidator(QDoubleValidator(0., 999., 1, self.sv4edit))
        self.sv5edit.setValidator(QDoubleValidator(0., 999., 1, self.sv5edit))
        self.sv6edit.setValidator(QDoubleValidator(0., 999., 1, self.sv6edit))
        self.sv7edit.setValidator(QDoubleValidator(0., 999., 1, self.sv7edit))
        self.radiosv1 = QRadioButton()
        self.radiosv2 = QRadioButton()
        self.radiosv3 = QRadioButton()
        self.radiosv4 = QRadioButton()
        self.radiosv5 = QRadioButton()
        self.radiosv6 = QRadioButton()
        self.radiosv7 = QRadioButton()
        N = aw.fujipid.PXG4["selectsv"][0]
        if N == 1:
            self.radiosv1.setChecked(True)
        elif N == 2:
            self.radiosv2.setChecked(True)
        elif N == 3:
            self.radiosv3.setChecked(True)
        elif N == 4:
            self.radiosv4.setChecked(True)
        elif N == 5:
            self.radiosv5.setChecked(True)
        elif N == 6:
            self.radiosv6.setChecked(True)
        elif N == 7:
            self.radiosv7.setChecked(True)
        tab2svbutton = QPushButton(QApplication.translate("Button","Write SV",None, QApplication.UnicodeUTF8))
        tab2svbutton.setFocusPolicy(Qt.NoFocus)
#        tab2cancelbutton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
#        tab2cancelbutton.setFocusPolicy(Qt.NoFocus)
        tab2easyONsvbutton = QPushButton(QApplication.translate("Button","ON SV buttons",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton.setStyleSheet("QPushButton { background-color: 'lightblue'}")
        tab2easyONsvbutton.setFocusPolicy(Qt.NoFocus)
        tab2easyOFFsvbutton = QPushButton(QApplication.translate("Button","OFF SV buttons",None, QApplication.UnicodeUTF8))
        tab2easyOFFsvbutton.setFocusPolicy(Qt.NoFocus)
        tab2easyOFFsvbutton.setStyleSheet("QPushButton { background-color:'#ffaaff' }")
        tab2getsvbutton = QPushButton(QApplication.translate("Button","Read SV (7-0)",None, QApplication.UnicodeUTF8))
        tab2getsvbutton.setFocusPolicy(Qt.NoFocus)
        tab2putsvbutton = QPushButton(QApplication.translate("Button","Write SV (7-0)",None, QApplication.UnicodeUTF8))
        tab2putsvbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(tab2svbutton, SIGNAL("clicked()"),self.setsv)
        self.connect(tab2getsvbutton, SIGNAL("clicked()"),self.getallsv)
        self.connect(tab2putsvbutton, SIGNAL("clicked()"),self.writeSetValues)
#        self.connect(tab2cancelbutton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(tab2easyONsvbutton, SIGNAL("clicked()"), lambda flag=1: aw.fujipid.activateONOFFeasySV(flag))
        self.connect(tab2easyOFFsvbutton, SIGNAL("clicked()"), lambda flag=0: aw.fujipid.activateONOFFeasySV(flag))
        self.connect(self.radiosv1,SIGNAL("clicked()"), lambda sv=1: self.setNsv(sv))
        self.connect(self.radiosv2,SIGNAL("clicked()"), lambda sv=2: self.setNsv(sv))
        self.connect(self.radiosv3,SIGNAL("clicked()"), lambda sv=3: self.setNsv(sv))
        self.connect(self.radiosv4,SIGNAL("clicked()"), lambda sv=4: self.setNsv(sv))
        self.connect(self.radiosv5,SIGNAL("clicked()"), lambda sv=5: self.setNsv(sv))
        self.connect(self.radiosv6,SIGNAL("clicked()"), lambda sv=6: self.setNsv(sv))
        self.connect(self.radiosv7,SIGNAL("clicked()"), lambda sv=7: self.setNsv(sv))
        #****************   TAB 3 WIDGETS
        plabel = QLabel()
        plabel.setMargin(10)
        plabel.setStyleSheet("background-color:'#CCCCCC';")
        plabel.setText("<font color='white'><b>" + QApplication.translate("Label", "P",None, QApplication.UnicodeUTF8) + "</b></font>")
        plabel.setMaximumSize(50, 42)
        plabel.setMinimumHeight(50)
        ilabel = QLabel()
        ilabel.setMargin(10)
        ilabel.setStyleSheet("background-color:'#CCCCCC';")
        ilabel.setText("<font color='white'><b>" + QApplication.translate("Label", "I",None, QApplication.UnicodeUTF8) + "</b></font>")
        ilabel.setMaximumSize(50, 42)
        ilabel.setMinimumHeight(50)
        dlabel = QLabel()
        dlabel.setMargin(10)
        dlabel.setStyleSheet("background-color:'#CCCCCC';")
        dlabel.setText("<font color='white'><b>" + QApplication.translate("Label", "D",None, QApplication.UnicodeUTF8) + "</b></font>")
        dlabel.setMaximumSize(50, 420)
        dlabel.setMinimumHeight(50)
        wlabel = QLabel()
        wlabel.setMargin(10)
        wlabel.setStyleSheet("background-color:'#CCCCCC';")
        wlabel.setText("<font color='white'><b>" + QApplication.translate("Label", "Write",None, QApplication.UnicodeUTF8) + "</b></font>")
        wlabel.setMaximumSize(100, 42)
        wlabel.setMinimumHeight(50)
        self.p1edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p1"][0])))
        self.p2edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p2"][0])))
        self.p3edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p3"][0])))
        self.p4edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p4"][0])))
        self.p5edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p5"][0])))
        self.p6edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p6"][0])))
        self.p7edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p7"][0])))
        self.i1edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i1"][0])))
        self.i2edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i2"][0])))
        self.i3edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i3"][0])))
        self.i4edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i4"][0])))
        self.i5edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i5"][0])))
        self.i6edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i6"][0])))
        self.i7edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i7"][0])))
        self.d1edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d1"][0])))
        self.d2edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d2"][0])))
        self.d3edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d3"][0])))
        self.d4edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d4"][0])))
        self.d5edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d5"][0])))
        self.d6edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d6"][0])))
        self.d7edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d7"][0])))
        self.p1edit.setMaximumSize(50, 42)
        self.p2edit.setMaximumSize(50, 42)
        self.p3edit.setMaximumSize(50, 42)
        self.p4edit.setMaximumSize(50, 42)
        self.p5edit.setMaximumSize(50, 42)
        self.p6edit.setMaximumSize(50, 42)
        self.p7edit.setMaximumSize(50, 42)
        self.i1edit.setMaximumSize(50, 42)
        self.i2edit.setMaximumSize(50, 42)
        self.i3edit.setMaximumSize(50, 42)
        self.i4edit.setMaximumSize(50, 42)
        self.i5edit.setMaximumSize(50, 42)
        self.i6edit.setMaximumSize(50, 42)
        self.i7edit.setMaximumSize(50, 42)
        self.d1edit.setMaximumSize(50, 42)
        self.d2edit.setMaximumSize(50, 42)
        self.d3edit.setMaximumSize(50, 42)
        self.d4edit.setMaximumSize(50, 42)
        self.d5edit.setMaximumSize(50, 42)
        self.d6edit.setMaximumSize(50, 42)
        self.d7edit.setMaximumSize(50, 42)
        #p = 0-999.9
        self.p1edit.setValidator(QDoubleValidator(0., 999., 1, self.p1edit))
        self.p2edit.setValidator(QDoubleValidator(0., 999., 1, self.p2edit))
        self.p3edit.setValidator(QDoubleValidator(0., 999., 1, self.p3edit))
        self.p4edit.setValidator(QDoubleValidator(0., 999., 1, self.p4edit))
        self.p5edit.setValidator(QDoubleValidator(0., 999., 1, self.p5edit))
        self.p6edit.setValidator(QDoubleValidator(0., 999., 1, self.p6edit))
        self.p7edit.setValidator(QDoubleValidator(0., 999., 1, self.p7edit))
        #i are int 0-3200
        self.i1edit.setValidator(QIntValidator(0, 3200, self.i1edit))
        self.i2edit.setValidator(QIntValidator(0, 3200, self.i2edit))
        self.i3edit.setValidator(QIntValidator(0, 3200, self.i3edit))
        self.i4edit.setValidator(QIntValidator(0, 3200, self.i4edit))
        self.i5edit.setValidator(QIntValidator(0, 3200, self.i5edit))
        self.i6edit.setValidator(QIntValidator(0, 3200, self.i6edit))
        self.i7edit.setValidator(QIntValidator(0, 3200, self.i7edit))
        #d 0-999.9
        self.d1edit.setValidator(QDoubleValidator(0., 999., 1, self.d1edit))
        self.d2edit.setValidator(QDoubleValidator(0., 999., 1, self.d2edit))
        self.d3edit.setValidator(QDoubleValidator(0., 999., 1, self.d3edit))
        self.d4edit.setValidator(QDoubleValidator(0., 999., 1, self.d4edit))
        self.d5edit.setValidator(QDoubleValidator(0., 999., 1, self.d5edit))
        self.d6edit.setValidator(QDoubleValidator(0., 999., 1, self.d6edit))
        self.d7edit.setValidator(QDoubleValidator(0., 999., 1, self.d7edit))
        pid1button = QPushButton(QApplication.translate("Button","pid 1",None, QApplication.UnicodeUTF8))
        pid1button.setFocusPolicy(Qt.NoFocus)
        pid2button = QPushButton(QApplication.translate("Button","pid 2",None, QApplication.UnicodeUTF8))
        pid2button.setFocusPolicy(Qt.NoFocus)
        pid3button = QPushButton(QApplication.translate("Button","pid 3",None, QApplication.UnicodeUTF8))
        pid3button.setFocusPolicy(Qt.NoFocus)
        pid4button = QPushButton(QApplication.translate("Button","pid 4",None, QApplication.UnicodeUTF8))
        pid4button.setFocusPolicy(Qt.NoFocus)
        pid5button = QPushButton(QApplication.translate("Button","pid 5",None, QApplication.UnicodeUTF8))
        pid5button.setFocusPolicy(Qt.NoFocus)
        pid6button = QPushButton(QApplication.translate("Button","pid 6",None, QApplication.UnicodeUTF8))
        pid6button.setFocusPolicy(Qt.NoFocus)
        pid7button = QPushButton(QApplication.translate("Button","pid 7",None, QApplication.UnicodeUTF8))
        pid7button.setFocusPolicy(Qt.NoFocus)
        pidreadallbutton = QPushButton(QApplication.translate("Button","Read PIDs",None, QApplication.UnicodeUTF8))
        pidreadallbutton.setFocusPolicy(Qt.NoFocus)
        pidwriteallbutton = QPushButton(QApplication.translate("Button","Write PIDs",None, QApplication.UnicodeUTF8))
        pidwriteallbutton.setFocusPolicy(Qt.NoFocus)
        autotuneONbutton = QPushButton(QApplication.translate("Button","Autotune ON",None, QApplication.UnicodeUTF8))
        autotuneONbutton.setFocusPolicy(Qt.NoFocus)
        autotuneOFFbutton = QPushButton(QApplication.translate("Button","Autotune OFF",None, QApplication.UnicodeUTF8))
        autotuneOFFbutton.setFocusPolicy(Qt.NoFocus)
        cancel3button = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancel3button.setFocusPolicy(Qt.NoFocus)
        self.radiopid1 = QRadioButton()
        self.radiopid2 = QRadioButton()
        self.radiopid3 = QRadioButton()
        self.radiopid4 = QRadioButton()
        self.radiopid5 = QRadioButton()
        self.radiopid6 = QRadioButton()
        self.radiopid7 = QRadioButton()
        self.connect(pidreadallbutton, SIGNAL("clicked()"),self.getallpid)
        self.connect(pidwriteallbutton, SIGNAL("clicked()"),self.writePIDValues)
        self.connect(self.radiopid1,SIGNAL("clicked()"), lambda pid=1: self.setNpid(pid))
        self.connect(self.radiopid2,SIGNAL("clicked()"), lambda pid=2: self.setNpid(pid))
        self.connect(self.radiopid3,SIGNAL("clicked()"), lambda pid=3: self.setNpid(pid))
        self.connect(self.radiopid4,SIGNAL("clicked()"), lambda pid=4: self.setNpid(pid))
        self.connect(self.radiopid5,SIGNAL("clicked()"), lambda pid=5: self.setNpid(pid))
        self.connect(self.radiopid6,SIGNAL("clicked()"), lambda pid=6: self.setNpid(pid))
        self.connect(self.radiopid7,SIGNAL("clicked()"), lambda pid=7: self.setNpid(pid))
        self.connect(pid1button, SIGNAL("clicked()"), lambda v=1: self.setpid(v))
        self.connect(pid2button, SIGNAL("clicked()"), lambda v=2: self.setpid(v))
        self.connect(pid3button, SIGNAL("clicked()"), lambda v=3: self.setpid(v))
        self.connect(pid4button, SIGNAL("clicked()"), lambda v=4: self.setpid(v))
        self.connect(pid5button, SIGNAL("clicked()"), lambda v=5: self.setpid(v))
        self.connect(pid6button, SIGNAL("clicked()"), lambda v=6: self.setpid(v))
        self.connect(pid7button, SIGNAL("clicked()"), lambda v=7: self.setpid(v))
        self.connect(cancel3button, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(autotuneONbutton, SIGNAL("clicked()"), lambda flag=1: self.setONOFFautotune(flag))
        self.connect(autotuneOFFbutton, SIGNAL("clicked()"), lambda flag=0: self.setONOFFautotune(flag))
        #****************************   TAB4 WIDGETS
        #table for setting segments
        self.segmenttable = QTableWidget()
        self.createsegmenttable()
        #****************************   TAB5 WIDGETS
        BTthermolabelnote = QLabel(QApplication.translate("Label","NOTE: BT Thermocouple type is not stored in the Artisan settings",None, QApplication.UnicodeUTF8))
        self.ETthermocombobox = QComboBox()
        self.ETthermocombobox.setFocusPolicy(Qt.NoFocus)
        self.BTthermocombobox = QComboBox()
        self.BTthermocombobox.setFocusPolicy(Qt.NoFocus)
#        self.BTthermocombobox.setStyleSheet("background-color:'lightgrey';")
        ## FUJI PXG input types
        ##0 (JPT 100'3f)
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##9 (no function)
        ##10 (no function)
        ##11 (no function)
        ##12 (N)
        ##13 (PL- 2)
        ##14 (no function)
        ##15 (0V to 5V / 0mA to 20mA
        ##16 (1V to 5V/4mA to 20mA)
        ##17 (0mV to 10V)
        ##18 (2V to 10V)
        ##19 (0mV to 100mV)
        self.PXGthermotypes = ["JPT 100",#0
                            "PT 100",    #1
                            "J",         #2
                            "K",         #3
                            "R",         #4
                            "B",         #5
                            "S",         #6
                            "T",         #7
                            "E",         #8
                            "N",         #12
                            "PL-2",      #13
                            "0V-5V/0mA-20mA", #15
                            "1V-5V/4mA-20mA", #16
                            "0mV-10V",   #17
                            "2V to 10V", #18
                            "0mV-100mV"  #19
                            ]
        self.PXGconversiontoindex = [0,1,2,3,4,5,6,7,8,12,13,15,16,17,18,19]  #converts fuji PID PXG types to indexes
        ## FUJI PXR input types
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##12 (N)
        ##13 (PL- 2)
        ##16 (1V to 5V/4mA to 20mA)
        self.PXRthermotypes = [
                            "PT 100",   #1
                            "J",        #2
                            "K",        #3
                            "R",        #4
                            "B",        #5
                            "S",        #6
                            "T",        #7
                            "E",        #8
                            "N",        #12
                            "PL-2",    #13
                            "1V to 5V/4mA to 20mA" #16
                            ]
        self.PXRconversiontoindex = [1,2,3,4,5,6,7,8,12,13,16]  #converts fuji PID PXR types to indexes
        self.ETthermocombobox.addItems(self.PXGthermotypes)
        if aw.ser.readBTpid[0] == 0:        #fuji PXG
            self.BTthermocombobox.addItems(self.PXGthermotypes)
        else:                               #fuji PXR
            self.BTthermocombobox.addItems(self.PXRthermotypes)
        if aw.fujipid.PXG4["pvinputtype"][0] in self.PXGconversiontoindex:
            self.ETthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(aw.fujipid.PXG4["pvinputtype"][0]))
        setETthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        setETthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        setBTthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        setBTthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        getETthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        getETthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        getBTthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        getBTthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        setETthermocouplebutton.setMaximumWidth(80)
        getETthermocouplebutton.setMaximumWidth(80)
        setBTthermocouplebutton.setMaximumWidth(80)
        getBTthermocouplebutton.setMaximumWidth(80)
        self.connect(setETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.setthermocoupletype(PID))
        self.connect(setBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.setthermocoupletype(PID))
        self.connect(getETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.readthermocoupletype(PID))
        self.connect(getBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.readthermocoupletype(PID))
        PointButtonET = QPushButton(QApplication.translate("Button","Set ET PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonET.setFocusPolicy(Qt.NoFocus)
        PointButtonBT = QPushButton(QApplication.translate("Button","Set BT PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonBT.setFocusPolicy(Qt.NoFocus)
        timeunitsbutton = QPushButton(QApplication.translate("Button","Set ET PID to MM:SS time units",None, QApplication.UnicodeUTF8))
        timeunitsbutton.setFocusPolicy(Qt.NoFocus)
#        PointButtonET.setMaximumWidth(180)
#        PointButtonBT.setMaximumWidth(180)
#        timeunitsbutton.setMaximumWidth(180)
        pointlabel = QLabel(QApplication.translate("Label","Artisan uses 1 decimal point",None, QApplication.UnicodeUTF8))
        timelabel = QLabel(QApplication.translate("Label","Artisan Fuji PXG uses MINUTES:SECONDS units in Ramp/Soaks",None, QApplication.UnicodeUTF8))
        self.connect(PointButtonET, SIGNAL("clicked()"), lambda PID="ET": self.setpoint(PID))
        self.connect(PointButtonBT, SIGNAL("clicked()"), lambda PID="BT": self.setpoint(PID))
        self.connect(timeunitsbutton, SIGNAL("clicked()"), self.settimeunits)
        # LAYOUTS
        tab1Layout = QGridLayout() #TAB1
        tab1Layout.setSpacing(10)
        tab1Layout.setSizeConstraint(2)
        tab1Layout.addLayout(buttonRampSoakLayout1,0,0)
        tab1Layout.addLayout(buttonRampSoakLayout2,0,1)
        tab1Layout.addWidget(button_rson,1,0)
        tab1Layout.addWidget(button_rsoff,1,1)
        tab1Layout.addWidget(button_standbyOFF,2,0)
        tab1Layout.addWidget(button_standbyON,2,1)
        tab1Layout.addWidget(patternlabel,3,0)
        tab1Layout.addWidget(self.patternComboBox,3,1)
        tab1Layout.addWidget(button_getall,4,0)
        tab1Layout.addWidget(button_writeallrs,4,1)
        tab2Layout = QGridLayout() #TAB2 
        tab2Layout.setSpacing(10)
        tab2Layout.setSizeConstraint(2)
        tab2Layout.addWidget(labelsv,0,0)
        tab2Layout.addWidget(labelsvedit,0,1)
        tab2Layout.addWidget(self.sv7edit,1,0)
        tab2Layout.addWidget(button_sv7,1,1)
        tab2Layout.addWidget(self.sv6edit,2,0)
        tab2Layout.addWidget(button_sv6,2,1)
        tab2Layout.addWidget(self.sv5edit,3,0)
        tab2Layout.addWidget(button_sv5,3,1)
        tab2Layout.addWidget(self.sv4edit,4,0)
        tab2Layout.addWidget(button_sv4,4,1)
        tab2Layout.addWidget(self.sv3edit,5,0)
        tab2Layout.addWidget(button_sv3,5,1)
        tab2Layout.addWidget(self.sv2edit,6,0)
        tab2Layout.addWidget(button_sv2,6,1)
        tab2Layout.addWidget(self.sv1edit,7,0)
        tab2Layout.addWidget(button_sv1,7,1)
        tab2Layout.addWidget(self.radiosv7,1,2)
        tab2Layout.addWidget(self.radiosv6,2,2)
        tab2Layout.addWidget(self.radiosv5,3,2)
        tab2Layout.addWidget(self.radiosv4,4,2)
        tab2Layout.addWidget(self.radiosv3,5,2)
        tab2Layout.addWidget(self.radiosv2,6,2)
        tab2Layout.addWidget(self.radiosv1,7,2)
        tab2Layout.addWidget(tab2easyOFFsvbutton,8,0)
        tab2Layout.addWidget(tab2easyONsvbutton,8,1)
        tab2Layout.addWidget(tab2getsvbutton,9,0)
        tab2Layout.addWidget(tab2putsvbutton,9,1)
        tab3Layout = QGridLayout() #TAB3
        tab3Layout.setSpacing(10)
        tab3Layoutbutton = QGridLayout()
        tab3MasterLayout = QVBoxLayout()
        tab3MasterLayout.addLayout(tab3Layout,0)
        tab3MasterLayout.addLayout(tab3Layoutbutton,1)
        tab3Layout.addWidget(plabel,0,0)
        tab3Layout.addWidget(ilabel,0,1)
        tab3Layout.addWidget(dlabel,0,2)
        tab3Layout.addWidget(wlabel,0,3)
        tab3Layout.addWidget(self.p1edit,1,0)
        tab3Layout.addWidget(self.i1edit,1,1)
        tab3Layout.addWidget(self.d1edit,1,2)
        tab3Layout.addWidget(pid1button,1,3)
        tab3Layout.addWidget(self.p2edit,2,0)
        tab3Layout.addWidget(self.i2edit,2,1)
        tab3Layout.addWidget(self.d2edit,2,2)
        tab3Layout.addWidget(pid2button,2,3)
        tab3Layout.addWidget(self.p3edit,3,0)
        tab3Layout.addWidget(self.i3edit,3,1)
        tab3Layout.addWidget(self.d3edit,3,2)
        tab3Layout.addWidget(pid3button,3,3)
        tab3Layout.addWidget(self.p4edit,4,0)
        tab3Layout.addWidget(self.i4edit,4,1)
        tab3Layout.addWidget(self.d4edit,4,2)
        tab3Layout.addWidget(pid4button,4,3)
        tab3Layout.addWidget(self.p5edit,5,0)
        tab3Layout.addWidget(self.i5edit,5,1)
        tab3Layout.addWidget(self.d5edit,5,2)
        tab3Layout.addWidget(pid5button,5,3)
        tab3Layout.addWidget(self.p6edit,6,0)
        tab3Layout.addWidget(self.i6edit,6,1)
        tab3Layout.addWidget(self.d6edit,6,2)
        tab3Layout.addWidget(pid6button,6,3)
        tab3Layout.addWidget(self.p7edit,7,0)
        tab3Layout.addWidget(self.i7edit,7,1)
        tab3Layout.addWidget(self.d7edit,7,2)
        tab3Layout.addWidget(pid7button,7,3)
        tab3Layout.addWidget(self.radiopid1,1,4)
        tab3Layout.addWidget(self.radiopid2,2,4)
        tab3Layout.addWidget(self.radiopid3,3,4)
        tab3Layout.addWidget(self.radiopid4,4,4)
        tab3Layout.addWidget(self.radiopid5,5,4)
        tab3Layout.addWidget(self.radiopid6,6,4)
        tab3Layout.addWidget(self.radiopid7,7,4)
        tab3Layoutbutton.addWidget(autotuneONbutton,0,0)
        tab3Layoutbutton.addWidget(autotuneOFFbutton,0,1)
        tab3Layoutbutton.addWidget(pidreadallbutton,1,0)
        tab3Layoutbutton.addWidget(pidwriteallbutton,1,1)
        #tab 4
        tab4layout = QVBoxLayout()
        tab4layout.addWidget(self.segmenttable)
        #tab5
        thermolayoutET = QHBoxLayout()
        thermolayoutET.addWidget(self.ETthermocombobox)
        thermolayoutET.addStretch()
        thermolayoutET.addWidget(getETthermocouplebutton)
        thermolayoutET.addWidget(setETthermocouplebutton)
        ETGroupBox = QGroupBox(QApplication.translate("Label","ET Thermocouple type",None, QApplication.UnicodeUTF8))
        ETGroupBox.setLayout(thermolayoutET)
        thermolayoutBT = QHBoxLayout()
        thermolayoutBT.addWidget(self.BTthermocombobox)
        thermolayoutBT.addStretch()
        thermolayoutBT.addWidget(getBTthermocouplebutton)
        thermolayoutBT.addWidget(setBTthermocouplebutton)
        BTGroupBox = QGroupBox(QApplication.translate("Label","BT Thermocouple type",None, QApplication.UnicodeUTF8))
        BTGroupBox.setLayout(thermolayoutBT)
        tab5Layout = QVBoxLayout()
        tab5Layout.addStretch()
        tab5Layout.addWidget(ETGroupBox)
        tab5Layout.addWidget(BTGroupBox)
        tab5Layout.addWidget(BTthermolabelnote)
        tab5Layout.addStretch()
        tab5Layout.addWidget(pointlabel)
        tab5Layout.addWidget(PointButtonET)
        tab5Layout.addWidget(PointButtonBT)
        tab5Layout.addStretch()
        tab5Layout.addWidget(timelabel)
        tab5Layout.addWidget(timeunitsbutton)
        tab5Layout.addStretch()
        ############################
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(button_load)
        buttonLayout.addWidget(button_save)
        buttonLayout.addStretch()
        buttonLayout.addWidget(button_writeall)
        buttonLayout.addStretch()
        buttonLayout.addWidget(button_exit)
        ############################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","RS",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","SV",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3MasterLayout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","PID",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Set RS",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Extra",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        layout = QVBoxLayout()
        layout.addWidget(self.status,0)
        layout.addWidget(TabWidget,1)
        layout.addLayout(buttonLayout,2)
        self.setLayout(layout)

    def load(self):
        aw.fileImport(QApplication.translate("Message", "Load PID Settings",None, QApplication.UnicodeUTF8),self.loadPIDJSON)

    def loadPIDJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            pids = json.load(infile)
            infile.close()
            # load set values
            setvalues = pids["setvalues"]
            for i in range(7):
                svkey = "sv" + str(i+1)
                aw.fujipid.PXG4[svkey][0] = setvalues[svkey]
            self.sv1edit.setText(QString(str(aw.fujipid.PXG4["sv1"][0])))
            self.sv2edit.setText(QString(str(aw.fujipid.PXG4["sv2"][0])))
            self.sv3edit.setText(QString(str(aw.fujipid.PXG4["sv3"][0])))
            self.sv4edit.setText(QString(str(aw.fujipid.PXG4["sv4"][0])))
            self.sv5edit.setText(QString(str(aw.fujipid.PXG4["sv5"][0])))
            self.sv6edit.setText(QString(str(aw.fujipid.PXG4["sv6"][0])))
            self.sv7edit.setText(QString(str(aw.fujipid.PXG4["sv7"][0])))
            # load PID values
            pidvalues = pids["pidvalues"]
            for i in range(7):
                pkey = "p" + str(i+1)
                ikey = "i" + str(i+1)
                dkey = "d" + str(i+1)
                aw.fujipid.PXG4[pkey][0] = pidvalues[pkey]
                aw.fujipid.PXG4[ikey][0] = pidvalues[ikey]
                aw.fujipid.PXG4[dkey][0] = pidvalues[dkey]
            self.p1edit.setText(QString(str(aw.fujipid.PXG4["p1"][0])))
            self.p2edit.setText(QString(str(aw.fujipid.PXG4["p2"][0])))
            self.p3edit.setText(QString(str(aw.fujipid.PXG4["p3"][0])))
            self.p4edit.setText(QString(str(aw.fujipid.PXG4["p4"][0])))
            self.p5edit.setText(QString(str(aw.fujipid.PXG4["p5"][0])))
            self.p6edit.setText(QString(str(aw.fujipid.PXG4["p6"][0])))
            self.p7edit.setText(QString(str(aw.fujipid.PXG4["p7"][0])))
            self.i1edit.setText(QString(str(aw.fujipid.PXG4["i1"][0])))
            self.i2edit.setText(QString(str(aw.fujipid.PXG4["i2"][0])))
            self.i3edit.setText(QString(str(aw.fujipid.PXG4["i3"][0])))
            self.i4edit.setText(QString(str(aw.fujipid.PXG4["i4"][0])))
            self.i5edit.setText(QString(str(aw.fujipid.PXG4["i5"][0])))
            self.i6edit.setText(QString(str(aw.fujipid.PXG4["i6"][0])))
            self.i7edit.setText(QString(str(aw.fujipid.PXG4["i7"][0])))
            self.d1edit.setText(QString(str(aw.fujipid.PXG4["d1"][0])))
            self.d2edit.setText(QString(str(aw.fujipid.PXG4["d2"][0])))
            self.d3edit.setText(QString(str(aw.fujipid.PXG4["d3"][0])))
            self.d4edit.setText(QString(str(aw.fujipid.PXG4["d4"][0])))
            self.d5edit.setText(QString(str(aw.fujipid.PXG4["d5"][0])))
            self.d6edit.setText(QString(str(aw.fujipid.PXG4["d6"][0])))
            self.d7edit.setText(QString(str(aw.fujipid.PXG4["d7"][0])))
            # load ramp-soak segments
            segments = pids["segments"]
            for i in range(16):
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                aw.fujipid.PXG4[svkey][0] = segments[svkey]
                aw.fujipid.PXG4[rampkey][0] = aw.qmc.stringtoseconds(segments[rampkey])
                aw.fujipid.PXG4[soakkey][0] = aw.qmc.stringtoseconds(segments[soakkey])
            self.createsegmenttable()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " loadPIDJSON() %1").arg(str(ex)),exc_tb.tb_lineno)

    def writeSetValues(self):
        for i in range(7):
            self.setsv(i+1)

    def writePIDValues(self):
        for i in range(7):
            self.setpid(i+1)

    def writeRSValues(self):
        for i in range(16):
            self.setsegment(i)

    def writeAll(self):
        self.writeSetValues()
        self.writePIDValues()
        self.writeRSValues()

    def save(self):
        aw.fileExport(QApplication.translate("Message", "Save PID Settings",None, QApplication.UnicodeUTF8),"*.apid",self.savePIDJSON)

    def savePIDJSON(self,filename):
        try:
            pids = {}
            # store set values
            setvalues = {}
            for i in range(7):
                svkey = "sv" + str(i+1)
                setvalues[svkey] = aw.fujipid.PXG4[svkey][0]
            pids["setvalues"] = setvalues
            # store PID values
            pidvalues = {}
            for i in range(7):
                pkey = "p" + str(i+1)
                ikey = "i" + str(i+1)
                dkey = "d" + str(i+1)
                pidvalues[pkey] = aw.fujipid.PXG4[pkey][0]
                pidvalues[ikey] = aw.fujipid.PXG4[ikey][0]
                pidvalues[dkey] = aw.fujipid.PXG4[dkey][0]
            pids["pidvalues"] = pidvalues
            # store ramp-soak segments
            segments = {}
            for i in range(16):
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                segments[svkey] = aw.fujipid.PXG4[svkey][0]
                segments[rampkey] = aw.qmc.stringfromseconds(aw.fujipid.PXG4[rampkey][0])
                segments[soakkey] = aw.qmc.stringfromseconds(aw.fujipid.PXG4[soakkey][0])
            pids["segments"] = segments
            outfile = open(filename, 'w')
            json.dump(pids, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " savePIDJSON(): %1").arg(str(ex)),exc_tb.tb_lineno)
            return False

    def settimeunits(self):
        try:
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["timeunits"][1],6)       
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,1)
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["timeunits"][1],1)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Time Units successfully set to MM:SS",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting time units",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " settimeunits(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setpoint(self,PID):
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                if PID == "ET":
                    slaveID = aw.ser.controlETpid[1]
                    reg = aw.modbus.address2register(aw.fujipid.PXG4["decimalposition"][1],6)
                elif PID == "BT":
                    slaveID = aw.ser.readBTpid[1]
                    if aw.ser.readBTpid[0] == 0:
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["decimalposition"][1],6)
                    elif aw.ser.readBTpid[0] == 1:
                        reg = aw.modbus.address2register(aw.fujipid.PXR["decimalposition"][1],6)
                if reg:
                    aw.modbus.writeSingleRegister(slaveID,reg,1)
                r = command
            else:
                if PID == "ET":
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["decimalposition"][1],1)
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["decimalposition"][1],1)
                    elif aw.ser.readBTpid[0] == 1:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["decimalposition"][1],1)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Decimal position successfully set to 1",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting decimal position",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setpoint(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setthermocoupletype(self,PID):
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                if PID == "ET":
                    slaveID = aw.ser.controlETpid[1]
                    index = self.ETthermocombobox.currentIndex()
                    value = self.PXGconversiontoindex[index]
                    reg = aw.modbus.address2register(aw.fujipid.PXG4["pvinputtype"][1],6)
                elif PID == "BT":
                    slaveID = aw.ser.readBTpid[1]
                    index = self.BTthermocombobox.currentIndex()
                    if aw.ser.readBTpid[0] == 0:
                        value = self.PXGconversiontoindex[index]
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["pvinputtype"][1],6)
                    elif aw.ser.readBTpid[0] == 1:
                        value = self.PXRconversiontoindex[index]
                        reg = aw.modbus.address2register(aw.fujipid.PXR["pvinputtype"][1],6)
                if reg:
                    aw.modbus.writeSingleRegister(slaveID,reg,value)
                r = command
            else:
                if PID == "ET":
                    index = self.ETthermocombobox.currentIndex()
                    value = self.PXGconversiontoindex[index]
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["pvinputtype"][1],value)
                elif PID == "BT":
                    index = self.BTthermocombobox.currentIndex()
                    if aw.ser.readBTpid[0] == 0:
                        value = self.PXGconversiontoindex[index]
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["pvinputtype"][1],value)
                    elif aw.ser.readBTpid[0] == 1:
                        value = self.PXRconversiontoindex[index]
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["pvinputtype"][1],value)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                if PID == "ET":
                    aw.fujipid.PXG4["pvinputtype"][0] = self.PXGconversiontoindex[self.ETthermocombobox.currentIndex()]
                elif PID == "BT":
                    pass #this info is not stored
                message = QApplication.translate("StatusBar","Thermocouple type successfully set",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting thermocouple type",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def readthermocoupletype(self,PID):
        command = ""
        message = "empty"
        reg = None
        try:
            if aw.ser.useModbusPort:
                if PID == "ET":
                    reg = aw.modbus.address2register(aw.fujipid.PXG4["pvinputtype"][1],3)
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["pvinputtype"][1],3)
                    elif aw.ser.readBTpid[0] == 1:
                        reg = aw.modbus.address2register(aw.fujipid.PXR["pvinputtype"][1],3)
                if reg:
                    Thtype = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
            else:
                if PID == "ET":
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["pvinputtype"][1],1)
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXG4["pvinputtype"][1],1)
                    elif aw.ser.readBTpid[0] == 1:
                        command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXR["pvinputtype"][1],1)
                if command:
                    Thtype = aw.fujipid.readoneword(command)
            if command:
                if PID == "ET":
                    if Thtype in self.PXGconversiontoindex:
                        aw.fujipid.PXG4["pvinputtype"][0] = Thtype
                        self.ETthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(Thtype))
                        message = "ET PXG type %i: %s"%(Thtype,self.PXGthermotypes[self.PXGconversiontoindex.index(Thtype)])
                    else:
                        message = "ERR"
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:        #fuji PXG
                        if Thtype in self.PXGconversiontoindex:
                            message = "BT PXG type %i: %s"%(Thtype,self.PXGthermotypes[self.PXGconversiontoindex.index(Thtype)])
                            self.BTthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(Thtype))
                    elif aw.ser.readBTpid[0] == 1:      #fuji PXR
                        if Thtype in self.PXRconversiontoindex:
                            message = "BT PXR type %i: %s"%(Thtype,self.PXRthermotypes[self.PXRconversiontoindex.index(Thtype)])
                            self.BTthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(Thtype))
                self.status.showMessage(message,5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " readthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def paintlabels(self):
        #read values of computer variables (not the actual pid values) to place in buttons
        str1 = "1 [T " + str(aw.fujipid.PXG4["segment1sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment1ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment1soak"][0])) + "]"
        str2 = "2 [T " + str(aw.fujipid.PXG4["segment2sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment2ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment2soak"][0])) + "]"
        str3 = "3 [T " + str(aw.fujipid.PXG4["segment3sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment3ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment3soak"][0])) + "]"
        str4 = "4 [T " + str(aw.fujipid.PXG4["segment4sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment4ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment4soak"][0])) + "]"
        str5 = "5 [T " + str(aw.fujipid.PXG4["segment5sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment5ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment5soak"][0])) + "]"
        str6 = "6 [T " + str(aw.fujipid.PXG4["segment6sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment6ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment6soak"][0])) + "]"
        str7 = "7 [T " + str(aw.fujipid.PXG4["segment7sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment7ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment7soak"][0])) + "]"
        str8 = "8 [T " + str(aw.fujipid.PXG4["segment8sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment8ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment8soak"][0])) + "]"
        str9 = "9 [T " + str(aw.fujipid.PXG4["segment9sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment9ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment9soak"][0])) + "]"
        str10 = "10 [T " + str(aw.fujipid.PXG4["segment10sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment10ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment10soak"][0])) + "]"
        str11 = "11 [T " + str(aw.fujipid.PXG4["segment11sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment11ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment11soak"][0])) + "]"
        str12 = "12 [T " + str(aw.fujipid.PXG4["segment12sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment12ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment12soak"][0])) + "]"
        str13 = "13 [T " + str(aw.fujipid.PXG4["segment13sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment13ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment13soak"][0])) + "]"
        str14 = "14 [T " + str(aw.fujipid.PXG4["segment14sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment14ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment14soak"][0])) + "]"
        str15 = "15 [T " + str(aw.fujipid.PXG4["segment15sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment15ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment15soak"][0])) + "]"
        str16 = "16 [T " + str(aw.fujipid.PXG4["segment16sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment16ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment16soak"][0])) + "]"
        self.label_rs1.setText(QString(str1))
        self.label_rs2.setText(QString(str2))
        self.label_rs3.setText(QString(str3))
        self.label_rs4.setText(QString(str4))
        self.label_rs5.setText(QString(str5))
        self.label_rs6.setText(QString(str6))
        self.label_rs7.setText(QString(str7))
        self.label_rs8.setText(QString(str8))
        self.label_rs9.setText(QString(str9))
        self.label_rs10.setText(QString(str10))
        self.label_rs11.setText(QString(str11))
        self.label_rs12.setText(QString(str12))
        self.label_rs13.setText(QString(str13))
        self.label_rs14.setText(QString(str14))
        self.label_rs15.setText(QString(str15))
        self.label_rs16.setText(QString(str16))
        pattern = [[1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                  [0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                  [1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                  [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
                  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        aw.fujipid.PXG4["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][0]:
            self.label_rs1.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs1.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][1]:
            self.label_rs2.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs2.setStyleSheet("background-color:white;")

        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][2]:
            self.label_rs3.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs3.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][3]:
            self.label_rs4.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs4.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][4]:
            self.label_rs5.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs5.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][5]:
            self.label_rs6.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs6.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][6]:
            self.label_rs7.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs7.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][7]:
            self.label_rs8.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs8.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][8]:
            self.label_rs9.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs9.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][9]:
            self.label_rs10.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs10.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][10]:
            self.label_rs11.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs11.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][11]:
            self.label_rs12.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs12.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][12]:
            self.label_rs13.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs13.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][13]:
            self.label_rs14.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs14.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][14]:
            self.label_rs15.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs15.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][15]:
            self.label_rs16.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs16.setStyleSheet("background-color:white;")

    #selects an sv
    def setNsv(self,svn):
        # read current sv N
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["selectsv"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectsv"][1],1)
            N = aw.fujipid.readoneword(command)
        # if current svN is different than requested svN
        if N != -1:
            if N != svn:
                string = QApplication.translate("Message","Current sv = %1. Change now to sv = %2?",None,QApplication.UnicodeUTF8).arg(str(N)).arg(str(svn))
                reply = QMessageBox.question(self,QApplication.translate("Message","Change svN",None,QApplication.UnicodeUTF8),string,
                                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    #change variable svN
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["selectsv"][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,svn)
                        r = command = ""
                    else:
                        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["selectsv"][1],svn)
                        r = aw.ser.sendFUJIcommand(command,8)
                    #check response from pid and update message on main window
                    if r == command:
                        aw.fujipid.PXG4["selectsv"][0] = svn
                        key = "sv" + str(svn)
                        message = QApplication.translate("StatusBar","SV%1 set to %2",None,QApplication.UnicodeUTF8).arg(str(svn)).arg(str(aw.fujipid.PXG4[key][0]))
                        aw.lcd6.display(str(aw.fujipid.PXG4[key][0]))
                        self.status.showMessage(message, 5000)
                    else:
                        self.status.showMessage(QApplication.translate("StatusBar","Problem setting SV",None,QApplication.UnicodeUTF8),5000)
                elif reply == QMessageBox.Cancel:
                    self.status.showMessage(QApplication.translate("StatusBar","Cancelled svN change",None,QApplication.UnicodeUTF8),5000)
                    #set radio button
                    if N == 1:
                        self.radiosv1.setChecked(True)
                    elif N == 2:
                        self.radiosv2.setChecked(True)
                    elif N == 3:
                        self.radiosv3.setChecked(True)
                    elif N == 4:
                        self.radiosv4.setChecked(True)
                    elif N == 5:
                        self.radiosv5.setChecked(True)
                    elif N == 6:
                        self.radiosv6.setChecked(True)
                    elif N == 7:
                        self.radiosv7.setChecked(True)
                    return 
            else:
                mssg = QApplication.translate("StatusBar","PID already using sv%1",None,QApplication.UnicodeUTF8).arg(str(N))
                self.status.showMessage(mssg,1000)
        else:
            mssg = QApplication.translate("StatusBar","setNsv(): bad response",None,QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,1000)
            aw.qmc.adderror(mssg)

    #selects an sv
    def setNpid(self,pidn):
        # read current sv N
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        if N != None and N != -1:
            aw.fujipid.PXG4["selectedpid"][0] = N
            # if current svN is different than requested svN
            if N != pidn:
                string = QApplication.translate("Message","Current pid = %1. Change now to pid =%2?",None,QApplication.UnicodeUTF8).arg(str(N)).arg(str(pidn))
                reply = QMessageBox.question(self,QApplication.translate("Message","Change svN",None,QApplication.UnicodeUTF8),string,
                                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    #change variable svN
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(aw.fujipid.PXG4["selectedpid"][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,pidn)
                        r = command = ""
                    else:
                        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["selectedpid"][1],pidn)
                        r = aw.ser.sendFUJIcommand(command,8)
                    #check response from pid and update message on main window
                    if r == command:
                        aw.fujipid.PXG4["selectedpid"][0] = pidn
                        #key = "sv" + str(pidn)
                        message = QApplication.translate("StatusBar","pid changed to %1",None,QApplication.UnicodeUTF8).arg(str(pidn))
                        self.status.showMessage(message, 5000)
                    else:
                        mssg = QApplication.translate("StatusBar","setNpid(): bad confirmation",None,QApplication.UnicodeUTF8)
                        self.status.showMessage(mssg,1000)
                        aw.qmc.adderror(mssg)
                elif reply == QMessageBox.Cancel:
                    self.status.showMessage(QApplication.translate("StatusBar","Cancelled pid change",None,QApplication.UnicodeUTF8),5000)
                    #put back radio button
                    if N == 1:
                        self.radiosv1.setChecked(True)
                    elif N == 2:
                        self.radiosv2.setChecked(True)
                    elif N == 3:
                        self.radiosv3.setChecked(True)
                    elif N == 4:
                        self.radiosv4.setChecked(True)
                    elif N == 5:
                        self.radiosv5.setChecked(True)
                    elif N == 6:
                        self.radiosv6.setChecked(True)
                    elif N == 7:
                        self.radiosv7.setChecked(True)
                    return
            else:
                mssg = QApplication.translate("StatusBar","PID was already using pid %1",None,QApplication.UnicodeUTF8).arg(str(N))
                self.status.showMessage(mssg,1000)
        else:
            mssg = QApplication.translate("StatusBar","setNpid(): Unable to set pid %1 ",None,QApplication.UnicodeUTF8).arg(str(N))
            self.status.showMessage(mssg,1000)
            aw.qmc.adderror(mssg)

    #writes new value on sv(i)
    def setsv(self,i):
        #first get the new sv value from the correspondig edit ine
        if i == 1:
            if self.sv1edit.text() != "":
                newSVvalue = int(float(str(self.sv1edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
        elif i == 2:
            if self.sv2edit.text() != "":
                newSVvalue = int(float(str(self.sv2edit.text()))*10.)
        elif i == 3:
            if self.sv3edit.text() != "":
                newSVvalue = int(float(str(self.sv3edit.text()))*10.)
        elif i == 4:
            if self.sv4edit.text() != "":
                newSVvalue = int(float(str(self.sv4edit.text()))*10.)
        elif i == 5:
            if self.sv5edit.text() != "":
                newSVvalue = int(float(str(self.sv5edit.text()))*10.)
        elif i == 6:
            if self.sv6edit.text() != "":
                newSVvalue = int(float(str(self.sv6edit.text()))*10.)
        elif i == 7:
            if self.sv7edit.text() != "":
                newSVvalue = int(float(str(self.sv7edit.text()))*10.)
        #send command to the right sv
        svkey = "sv"+ str(i)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4[svkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newSVvalue)
            r = "00000000"
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[svkey][1],newSVvalue)
            r = aw.ser.sendFUJIcommand(command,8)
        #verify it went ok
        if len(r) == 8:
            if i == 1:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv1edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv1edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(1)
                aw.lcd6.display(str(self.sv1edit.text()))
            elif i == 2:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv2edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv2edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(2)
                aw.lcd6.display(str(self.sv2edit.text()))
            elif i == 3:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv3edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv3edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(3)
                aw.lcd6.display(str(self.sv3edit.text()))
            elif i == 4:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv4edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv4edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(4)
                aw.lcd6.display(str(self.sv4edit.text()))
            elif i == 5:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv5edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv5edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(5)
                aw.lcd6.display(str(self.sv5edit.text()))
            elif i == 6:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv6edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv6edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(6)
                aw.lcd6.display(str(self.sv6edit.text()))
            elif i == 7:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv7edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv7edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(7)
                aw.lcd6.display(str(self.sv7edit.text()))
            #record command as an Event 
            strcommand = "SETSV::" + str("%.1f"%(newSVvalue/10.))
            aw.qmc.DeviceEventRecord(strcommand)
        else:
            mssg = QApplication.translate("StatusBar","setsv(): Unable to set SV",None,QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    #writes new values for p - i - d
    def setpid(self,k):
        #first get the new sv value from the correspondig edit ine
        if k == 1:
            if self.p1edit.text() != "" and self.i1edit.text() != "" and self.d1edit.text() != "":
                newPvalue = int(float(str(self.p1edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i1edit.text()))*10.)
                newDvalue = int(float(str(self.d1edit.text()))*10.)
        elif k == 2:
            if self.p2edit.text() != "" and self.i2edit.text() != "" and self.d2edit.text() != "":
                newPvalue = int(float(str(self.p2edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i2edit.text()))*10.)
                newDvalue = int(float(str(self.d2edit.text()))*10.) 
        elif k == 3:
            if self.p3edit.text() != "" and self.i3edit.text() != "" and self.d3edit.text() != "":
                newPvalue = int(float(str(self.p3edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i3edit.text()))*10.)
                newDvalue = int(float(str(self.d3edit.text()))*10.)
        elif k == 4:
            if self.p4edit.text() != "" and self.i4edit.text() != "" and self.d4edit.text() != "":
                newPvalue = int(float(str(self.p4edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i4edit.text()))*10.)
                newDvalue = int(float(str(self.d4edit.text()))*10.) 
        elif k == 5:
            if self.p5edit.text() != "" and self.i5edit.text() != "" and self.d5edit.text() != "":
                newPvalue = int(float(str(self.p5edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i5edit.text()))*10.)
                newDvalue = int(float(str(self.d5edit.text()))*10.) 
        elif k == 6:
            if self.p6edit.text() != "" and self.i6edit.text() != "" and self.d6edit.text() != "":
                newPvalue = int(float(str(self.p6edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i6edit.text()))*10.)
                newDvalue = int(float(str(self.d6edit.text()))*10.) 
        elif k == 7:
            if self.p7edit.text() != "" and self.i7edit.text() != "" and self.d7edit.text() != "":
                newPvalue = int(float(str(self.p7edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i7edit.text()))*10.)
                newDvalue = int(float(str(self.d7edit.text()))*10.) 
        #send command to the right sv
        pkey = "p" + str(k)
        ikey = "i" + str(k)
        dkey = "d" + str(k)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4[pkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newPvalue)
            reg = aw.modbus.address2register(aw.fujipid.PXG4[ikey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newIvalue)
            reg = aw.modbus.address2register(aw.fujipid.PXG4[dkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newDvalue)
            p = i = d = "        "
        else:
            commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[pkey][1],newPvalue)
            commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[ikey][1],newIvalue)
            commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[dkey][1],newDvalue)
            p = aw.ser.sendFUJIcommand(commandp,8)
            libtime.sleep(0.035) 
            i = aw.ser.sendFUJIcommand(commandi,8)
            libtime.sleep(0.035) 
            d = aw.ser.sendFUJIcommand(commandd,8)
            libtime.sleep(0.035) 
        #verify it went ok
        if len(p) == 8 and len(i)==8 and len(d) == 8:
            if k == 1:               
                aw.fujipid.PXG4[pkey][0] = float(str(self.p1edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i1edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d1edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p1edit.text())).arg(str(self.i1edit.text())).arg(str(self.d1edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(1)
            elif k == 2:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p2edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i2edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d2edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p2edit.text())).arg(str(self.i2edit.text())).arg(str(self.d2edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(2)
            elif k == 3:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p3edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i3edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d3edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p3edit.text())).arg(str(self.i3edit.text())).arg(str(self.d3edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(3)
            elif k == 4:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p4edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i4edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d4edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p4edit.text())).arg(str(self.i4edit.text())).arg(str(self.d4edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(4)
            elif k == 5:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p5edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i5edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d5edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p5edit.text())).arg(str(self.i5edit.text())).arg(str(self.d5edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(5)
            elif k == 6:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p6edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i6edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d6edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p6edit.text())).arg(str(self.i6edit.text())).arg(str(self.d6edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(6)
            elif k == 7:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p7edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i7edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d7edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p7edit.text())).arg(str(self.i7edit.text())).arg(str(self.d7edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(7) 
        else:
            lp = len(p)
            li = len(i)
            ld = len(d)
            mssg = QApplication.translate("StatusBar","pid command failed. Bad data at pid%1 (8,8,8): (%2,%3,%4) ",None,
                                                   QApplication.UnicodeUTF8).arg(str(k)).arg(str(lp)).arg(str(li)).arg(str(ld))
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            
    def getallpid(self):
        for k in range(1,8):
            pkey = "p" + str(k)
            ikey = "i" + str(k)
            dkey = "d" + str(k)
            msg = QApplication.translate("StatusBar","sending commands for p%1 i%2 d%3",None,
                                                   QApplication.UnicodeUTF8).arg(str(k)).arg(str(k)).arg(str(k))
            self.status.showMessage(msg,1000)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4[pkey][1],3)
                p = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[pkey][1],1)
                p = aw.fujipid.readoneword(commandp)/10.
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4[ikey][1],3)
                i = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[ikey][1],1)
                i = aw.fujipid.readoneword(commandi)/10.
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4[dkey][1],3)
                dd = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[dkey][1],1)
                dd = aw.fujipid.readoneword(commandd)/10.
            if p != -1 and i != -1 and dd != -1:
                aw.fujipid.PXG4[pkey][0] = p
                aw.fujipid.PXG4[ikey][0] = i
                aw.fujipid.PXG4[dkey][0] = dd
                if k == 1:
                    self.p1edit.setText(str(p))
                    self.i1edit.setText(str(i))
                    self.d1edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd) # No translation needed here
                    self.status.showMessage(mssg,1000)
                if k == 2:
                    self.p2edit.setText(str(p))
                    self.i2edit.setText(str(i))
                    self.d2edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 3:
                    self.p3edit.setText(str(p))
                    self.i3edit.setText(str(i))
                    self.d3edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 4:
                    self.p4edit.setText(str(p))
                    self.i4edit.setText(str(i))
                    self.d4edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 5:
                    self.p5edit.setText(str(p))
                    self.i5edit.setText(str(i))
                    self.d5edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 6:
                    self.p6edit.setText(str(p))
                    self.i6edit.setText(str(i))
                    self.d6edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 7:
                    self.p7edit.setText(str(p))
                    self.i7edit.setText(str(i))
                    self.d7edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
            else:
                mssg = QApplication.translate("StatusBar","getallpid(): Unable to read pid values",None,QApplication.UnicodeUTF8)
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
                return
        #read current pidN
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        libtime.sleep(0.035) 
        if N != -1:
            aw.fujipid.PXG4["selectedpid"][0] = N
            if N == 1:
                self.radiopid1.setChecked(True)
            elif N == 2:
                self.radiopid2.setChecked(True)
            elif N == 3:
                self.radiopid3.setChecked(True)
            elif N == 4:
                self.radiopid4.setChecked(True)
            elif N == 5:
                self.radiopid5.setChecked(True)
            elif N == 6:
                self.radiopid6.setChecked(True)
            elif N == 7:
                self.radiopid7.setChecked(True)
            mssg = QApplication.translate("StatusBar","PID is using pid = %1",None,QApplication.UnicodeUTF8).arg(str(N))
            self.status.showMessage(mssg,5000)
        else:
            mssg = QApplication.translate("StatusBar","getallpid(): Unable to read current sv",None,QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def getallsv(self):
        for i in reversed(list(range(1,8))):
            svkey = "sv" + str(i)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4[svkey][1],3)
                sv = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[svkey][1],1)
                sv = aw.fujipid.readoneword(command)/10.
            aw.fujipid.PXG4[svkey][0] = sv
            if i == 1:
                self.sv1edit.setText(str(sv))
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
            elif i == 2:
                self.sv2edit.setText(str(sv))
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
            elif i == 3:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv3edit.setText(str(sv))
            elif i == 4:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv4edit.setText(str(sv))
            elif i == 5:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv5edit.setText(str(sv))
            elif i == 6:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv6edit.setText(str(sv))
            elif i == 7:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv7edit.setText(str(sv))
        #read current svN
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["selectsv"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectsv"][1],1)
            N = aw.fujipid.readoneword(command)
        aw.fujipid.PXG4["selectsv"][0] = N
        if N == 1:
            self.radiosv1.setChecked(True)
        elif N == 2:
            self.radiosv2.setChecked(True)
        elif N == 3:
            self.radiosv3.setChecked(True)
        elif N == 4:
            self.radiosv4.setChecked(True)
        elif N == 5:
            self.radiosv5.setChecked(True)
        elif N == 6:
            self.radiosv6.setChecked(True)
        elif N == 7:
            self.radiosv7.setChecked(True)
        mssg = QApplication.translate("StatusBar","PID is using SV = %1",None,QApplication.UnicodeUTF8).arg(str(N))
        self.status.showMessage(mssg,5000)

    def checkrampsoakmode(self):
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoakmode"][1],3)
            currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["rampsoakmode"][1],1)
            currentmode = aw.fujipid.readoneword(msg)
        aw.fujipid.PXG4["rampsoakmode"][0] = currentmode
        if currentmode == 0:
            mode = ["0",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 1:
            mode = ["1",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 2:
            mode = ["2",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 3:
            mode = ["3",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 4:
            mode = ["4",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 5:
            mode = ["5",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 6:
            mode = ["6",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 7:
            mode = ["7",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 8:
            mode = ["8",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 9:
            mode = ["9",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 10:
            mode = ["10",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 11:
            mode = ["11",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 12:
            mode = ["12",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 13:
            mode = ["13",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 14:
            mode = ["14",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 15:
            mode = ["15",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        else:
            return -1
        string = "The rampsoak-mode tells how to start and end the ramp/soak\n\n"
        string += "Your rampsoak mode in this pid is:\n"
        string += "\nMode = " + mode[0]
        string += "\n-----------------------------------------------------------------------"
        string += "\nStart to run from PV value: " + mode[1]
        string += "\nEnd output status at the end of ramp/soak: " + mode[2]
        string += "\nOutput status while ramp/soak opearion set to OFF: " + mode[3] 
        string += "\nRepeat Operation at the end: " + mode[4]
        string += "\n-----------------------------------------------------------------------"
        string += "\n\nRecomended Mode = 0\n"
        string += "\nIf you need to change it, change it now and come back later"
        string += "\nUse the Parameter Loader Software by Fuji if you need to\n\n"
        string += "\n\n\nContinue?" 
        reply = QMessageBox.question(self,QApplication.translate("Message","Ramp Soak start-end mode",None,QApplication.UnicodeUTF8),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            return 0
        elif reply == QMessageBox.Yes:
            return 1

    def setONOFFrampsoak(self,flag):
        #warning check how it ends at "rampsoakend":[0,41081] can let pid inop till value changed    UNFINISHED
        
        # you can come out of this mode by putting the pid in standby (pid off) 
        #flag =0 OFF, flag = 1 ON, flag = 2 hold
        
        #set rampsoak pattern ON
        if flag == 1:
            check = self.checkrampsoakmode()
            if check == 0:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak operation cancelled",None,QApplication.UnicodeUTF8), 5000)
                return
            elif check == -1:
                self.status.showMessage(QApplication.translate("StatusBar","No RX data",None,QApplication.UnicodeUTF8), 5000)
            self.status.showMessage(QApplication.translate("StatusBar","RS ON",None,QApplication.UnicodeUTF8),500)
            selectedmode = self.patternComboBox.currentIndex()
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoakpattern"][1],3)
                currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
            else:                
                msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["rampsoakpattern"][1],1)
                currentmode = aw.fujipid.readoneword(msg)
            aw.fujipid.PXG4["rampsoakpattern"][0] = currentmode
            if currentmode != selectedmode:
                #set mode in pid to match the mode selected in the combobox
                self.status.showMessage(QApplication.translate("StatusBar","Need to change pattern mode...",None,QApplication.UnicodeUTF8),1000)
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoakpattern"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,selectedmode)
                    r = "        "
                else:
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoakpattern"][1],selectedmode)
                    r = aw.ser.sendFUJIcommand(command,8)
                if len(r) == 8:
                    self.status.showMessage(QApplication.translate("StatusBar","Pattern has been changed. Wait 5 secs.",None,QApplication.UnicodeUTF8), 500)
                    aw.fujipid.PXG4["rampsoakpattern"][0] = selectedmode
                else:
                    self.status.showMessage(QApplication.translate("StatusBar","Pattern could not be changed",None,QApplication.UnicodeUTF8), 5000)
                    return
            #combobox mode matches pid mode
            #set ramp soak mode ON/OFF
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoak"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoak"][1],flag)
                r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                #record command as an Event if flag = 1
                self.status.showMessage(QApplication.translate("StatusBar","RS ON",None,QApplication.UnicodeUTF8), 5000)
                pattern =[[1,4],[5,8],[1,8],[9,12],[13,16],[9,16],[1,16]]
                start = pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][0]
                end = pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][1]+1
                strcommand = "SETRS"
                result = ""
                for i in range(start,end):
                    svkey = "segment"+str(i)+"sv"
                    rampkey = "segment"+str(i)+"ramp"
                    soakkey = "segment"+str(i)+"soak"
                    strcommand += "::" + str(aw.fujipid.PXG4[svkey][0]) + "::" + str(aw.fujipid.PXG4[rampkey][0]) + "::" + str(aw.fujipid.PXG4[soakkey][0])+"::"
                    result += strcommand
                    strcommand = "SETRS"
                result = result.strip("::")
                aw.qmc.DeviceEventRecord(result)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","RampSoak could not be changed",None,QApplication.UnicodeUTF8), 5000)
        #set ramp soak OFF
        elif flag == 0:
            self.status.showMessage(QApplication.translate("StatusBar","RS OFF",None,QApplication.UnicodeUTF8),500)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoak"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoak"][1],flag)
                r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                self.status.showMessage(QApplication.translate("StatusBar","RS successfully turned OFF",None,QApplication.UnicodeUTF8), 5000)
                aw.fujipid.PXG4["rampsoak"][0] = flag
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp Soak could not be set OFF",None,QApplication.UnicodeUTF8), 5000)

    def setpattern(self):
        #Need to make sure that RampSoak is not ON in order to change pattern:
        onoff = self.getONOFFrampsoak()
        if onoff == 0:
            aw.fujipid.PXG4["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoakpattern"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,aw.fujipid.PXG4["rampsoakpattern"][0])
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoakpattern"][1],aw.fujipid.PXG4["rampsoakpattern"][0])
                #TX and RX
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                patterns = ["1-4","5-8","1-8","9-12","13-16","9-16","1-16"]
                message = QApplication.translate("Message","Pattern changed to %1", None, QApplication.UnicodeUTF8).arg(patterns[aw.fujipid.PXG4["rampsoakpattern"][0]])
            else:
                message = QApplication.translate("Message","Pattern did not changed",None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
        elif onoff == 1:
            aw.sendmessage(QApplication.translate("Message","Ramp/Soak was found ON! Turn it off before changing the pattern", None, QApplication.UnicodeUTF8))
        elif onoff == 2:
            aw.sendmessage(QApplication.translate("Message","Ramp/Soak was found in Hold! Turn it off before changing the pattern", None, QApplication.UnicodeUTF8))

    def setONOFFstandby(self,flag):
        #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
        #flag = 0 standby OFF, flag = 1 standby ON (pid off)
        self.status.showMessage(QApplication.translate("StatusBar","wait...",None, QApplication.UnicodeUTF8),500)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["runstandby"][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
            r = "00000000"
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["runstandby"][1],flag)
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
        if r == command and flag == 1:
            message = QApplication.translate("StatusBar","PID set to OFF",None, QApplication.UnicodeUTF8)     #put pid in standby 1 (pid on)
            aw.fujipid.PXG4["runstandby"][0] = 1
        elif r == command and flag == 0:
            message = QApplication.translate("StatusBar","PID set to ON",None, QApplication.UnicodeUTF8)      #put pid in standby 0 (pid off)
            aw.fujipid.PXG4["runstandby"][0] = 0
        else:
            message = QApplication.translate("StatusBar","Unable",None, QApplication.UnicodeUTF8)
        if r:
            self.status.showMessage(message,5000)
        else:
            self.status.showMessage(QApplication.translate("StatusBar","No data received",None, QApplication.UnicodeUTF8),5000)

    def getsegment(self, idn):
        svkey = "segment" + str(idn) + "sv"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4[svkey][1],3)
            sv = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[svkey][1],1)
            sv = aw.fujipid.readoneword(svcommand)
        if sv == -1:
            return -1
        aw.fujipid.PXG4[svkey][0] = sv/10.              #divide by 10 because the decimal point is not sent by the PID
        
        rampkey = "segment" + str(idn) + "ramp"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4[rampkey][1],3)
            ramp = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[rampkey][1],1)
            ramp = aw.fujipid.readoneword(rampcommand)
        
        if ramp == -1:
            return -1
        aw.fujipid.PXG4[rampkey][0] = ramp
        
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4[soakkey][1],3)
            soak = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[soakkey][1],1)
            soak = aw.fujipid.readoneword(soakcommand)
        if soak == -1:
            return -1
        aw.fujipid.PXG4[soakkey][0] = soak

    #get all Ramp Soak values for all 8 segments
    def getallsegments(self):
        for i in range(1,17):
            msg = QApplication.translate("StatusBar","Reading Ramp/Soak %1 ...",None, QApplication.UnicodeUTF8).arg(str(i))
            self.status.showMessage(msg,500)
            k = self.getsegment(i)
            libtime.sleep(0.03)
            if k == -1:
                self.status.showMessage(QApplication.translate("StatusBar","problem reading Ramp/Soak",None, QApplication.UnicodeUTF8),5000)
                return
            self.paintlabels()
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading Ramp/Soak val.",None, QApplication.UnicodeUTF8),5000)
        self.createsegmenttable()

    def setONOFFautotune(self,flag):
        self.status.showMessage(QApplication.translate("StatusBar","setting autotune...",None, QApplication.UnicodeUTF8),500)
        #read current pidN
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        aw.fujipid.PXG4["selectedpid"][0] = N
        string = QApplication.translate("StatusBar","Current pid = %1. Proceed with autotune command?",None, QApplication.UnicodeUTF8).arg(str(N))
        reply = QMessageBox.question(self,QApplication.translate("Message","Ramp Soak start-end mode",None, QApplication.UnicodeUTF8),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            self.status.showMessage(QApplication.translate("StatusBar","Autotune cancelled",None, QApplication.UnicodeUTF8),5000)
            return 0
        elif reply == QMessageBox.Yes:
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["autotuning"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                r = "00000000"
            else:        
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["autotuning"][1],flag)
                #TX and RX
                r = aw.ser.sendFUJIcommand(command,8)
            if len(r) == 8:
                if flag == 0:
                    aw.fujipid.PXG4["autotuning"][0] = 0
                    self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned OFF",None, QApplication.UnicodeUTF8),5000)
                if flag == 1:
                    aw.fujipid.PXG4["autotuning"][0] = 1
                    self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned ON",None, QApplication.UnicodeUTF8),5000) 
            else:
                self.status.showMessage(QApplication.translate("StatusBar","UNABLE to set Autotune",None, QApplication.UnicodeUTF8),5000) 

    def createsegmenttable(self):
        self.segmenttable.setRowCount(16)
        self.segmenttable.setColumnCount(4)
        self.segmenttable.setHorizontalHeaderLabels([QApplication.translate("StatusBar","SV",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("StatusBar","Ramp (MM:SS)",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("StatusBar","Soak (MM:SS)",None, QApplication.UnicodeUTF8),""])
        self.segmenttable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.segmenttable.setSelectionBehavior(QTableWidget.SelectRows)
        self.segmenttable.setSelectionMode(QTableWidget.SingleSelection)
        self.segmenttable.setShowGrid(True)
        self.segmenttable.verticalHeader().setResizeMode(2)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #populate table
        for i in range(16):
            #create widgets
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            svedit = QLineEdit(str(aw.fujipid.PXG4[svkey][0]))
            svedit.setValidator(QDoubleValidator(0., 999., 1, svedit))
            rampedit = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4[rampkey][0])))
            rampedit.setValidator(QRegExpValidator(regextime,self))    
            soakedit  = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4[soakkey][0])))
            soakedit.setValidator(QRegExpValidator(regextime,self))    
            setButton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
            setButton.setFocusPolicy(Qt.NoFocus)
            self.connect(setButton,SIGNAL("clicked()"),lambda kk=i: self.setsegment(kk))
            #add widgets to the table
            self.segmenttable.setCellWidget(i,0,svedit)
            self.segmenttable.setCellWidget(i,1,rampedit)
            self.segmenttable.setCellWidget(i,2,soakedit)
            self.segmenttable.setCellWidget(i,3,setButton)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    def setsegment(self,i):
        idn = i+1
        svedit =  self.segmenttable.cellWidget(i,0)
        rampedit = self.segmenttable.cellWidget(i,1)
        soakedit = self.segmenttable.cellWidget(i,2)
        sv = float(str(svedit.text()))
        ramp = aw.qmc.stringtoseconds(str(rampedit.text()))
        soak = aw.qmc.stringtoseconds(str(soakedit.text()))
        svkey = "segment" + str(idn) + "sv"
        rampkey = "segment" + str(idn) + "ramp"
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4[svkey][1],6)       
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(sv*10))
            libtime.sleep(0.1) #important time between writings
            reg = aw.modbus.address2register(aw.fujipid.PXG4[rampkey][1],6)       
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,ramp)
            libtime.sleep(0.1) #important time between writings
            reg = aw.modbus.address2register(aw.fujipid.PXG4[soakkey][1],6)       
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,soak)
            r1 = r2 = r3 = "        "
        else:
            svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[svkey][1],int(sv*10))
            r1 = aw.ser.sendFUJIcommand(svcommand,8)
            libtime.sleep(0.1) #important time between writings
            rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[rampkey][1],ramp)
            r2 = aw.ser.sendFUJIcommand(rampcommand,8)
            libtime.sleep(0.1) #important time between writings
            soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[soakkey][1],soak)
            r3 = aw.ser.sendFUJIcommand(soakcommand,8)    
        #check if OK
        if len(r1) == 8 and len(r2) == 8 and len(r3) == 8:
            aw.fujipid.PXG4[svkey][0] = sv
            aw.fujipid.PXG4[rampkey][0] = ramp
            aw.fujipid.PXG4[soakkey][0] = soak
            self.paintlabels()
            self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak successfully written",None, QApplication.UnicodeUTF8),5000) 
        else:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None, QApplication.UnicodeUTF8))

###################################################################################
##########################  FUJI PID CLASS DEFINITION  ############################
###################################################################################

# This class can work for either one Fuji PXR or one Fuji PXG. It is used for the controlling PID only.
# NOTE: There is only one controlling PID. The second pid is only used for reading BT and therefore,
# there is no need to create a second PID object since the second pid all it does is read temperature (always use the same command).
# All is needed for the second pid is its unit id number stored in aw.qmc.device[].
# The command to read T is the always the same for PXR and PXG but with the unit ID changed.

class FujiPID(object):
    def __init__(self):
        
        #refer to Fuji PID instruction manual for more information about the parameters and channels
        #dictionary "KEY": [VALUE,MEMORY_ADDRESS]
        self.PXG4={
                  ############ CH1  Selects controller modes 
                  # manual mode 0 = OFF(auto), 1 = ON(manual)
                  "manual": [0,41121],
                  #run or standby 0=OFF(during run), 1 = ON(during standby)
                  "runstandby": [0,41004],
                  #autotuning run command modes available 0=off, 1=on, 2=low
                  "autotuning": [0,41005],
                  #rampsoak command modes available 0=off, 1=run; 2=hold
                  "rampsoak": [0,41082],
                  #select SV sv1,...,sv7
                  "selectsv": [1,41221],
                  #selects PID number behaviour mode: pid1,...,pid7
                  "selectpid": [0,41222],
                  ############ CH2  Main operating pid parameters.
                  #proportional band  P0 (0% to 999.9%)
                  "p": [5,41006],
                  #integration time i0 (0 to 3200.0 sec)
                  "i": [240,41007],
                  #differential time d0 (0.0 to 999.9 sec)
                  "d": [60,41008],
                   ############ CH3 These are 7 pid storage locations
                  "sv1": [300.0,41241], "p1": [5,41242], "i1": [240,41243], "d1": [60,41244],
                  "sv2": [350.0,41251], "p2": [5,41252], "i2": [240,41253], "d2": [60,41254],
                  "sv3": [400.0,41261], "p3": [5,41262], "i3": [240,41263], "d3": [60,41264],
                  "sv4": [450.0,41271], "p4": [5,41272], "i4": [240,41273], "d4": [60,41274],
                  "sv5": [500.0,41281], "p5": [5,41282], "i5": [240,41283], "d5": [60,41284],
                  "sv6": [550.0,41291], "p6": [5,41292], "i6": [240,41293], "d6": [60,41294],
                  "sv7": [575.0,41301], "p7": [5,41302], "i7": [240,41303], "d7": [60,41304],
                  "selectedpid":[7,41225],
                  ############# CH4      Creates a pattern of temperatures (profiles) using ramp soak combination
                  #sv stands for Set Value (desired temperature value)
                  #the time to reach sv is called ramp 
                  #the time to hold the temperature at sv is called soak 
                  "timeunits": [1,41562],  #0=hh.MM (hour:min)  1=MM.SS (min:sec)                             # PXG has two time formats HH:MM (factory default) and MM:SS 
                  # Example. Dry roast phase. selects 3 or 4 minutes                                          # PXG needs to have parameter TIMU set to 1 (MM:SS)
                  "segment1sv": [270.0,41581],"segment1ramp": [180,41582],"segment1soak": [0,41583],          # See PXG Manual chapter 6: Ramp/Soak Time Units to set the parameter TIMU    
                  "segment2sv": [300.0,41584],"segment2ramp": [180,41585],"segment2soak": [0,41586],
                  "segment3sv": [350.0,41587],"segment3ramp": [180,41588],"segment3soak": [0,41589],
                  "segment4sv": [400.0,41590],"segment4ramp": [180,41591],"segment4soak": [0,41592],
                  # Example. Phase to 1C. selects 6 or 8 mins
                  "segment5sv": [530.0,41593],"segment5ramp": [180,41594],"segment5soak": [0,41595],
                  "segment6sv": [530.0,41596],"segment6ramp": [180,41597],"segment6soak": [0,41598],
                  "segment7sv": [540.0,41599],"segment7ramp": [180,41600],"segment7soak": [0,41601],
                  "segment8sv": [540.0,41602],"segment8ramp": [180,41603],"segment8soak": [0,41604],
                  "segment9sv": [550.0,41605],"segment9ramp": [180,41606],"segment9soak": [0,41607],
                  "segment10sv": [550.0,41608],"segment10ramp": [180,41609],"segment10soak": [0,41610],
                  "segment11sv": [560.0,41611],"segment11ramp": [180,41612],"segment11soak": [0,41613],
                  "segment12sv": [560.0,41614],"segment12ramp": [180,41615],"segment12soak": [0,41616],
                  # Eaxample. Finish phase. selects 3 mins for regular coffee or 5 mins for espresso
                  "segment13sv": [570.0,41617],"segment13ramp": [180,41618],"segment13soak": [0,41619],
                  "segment14sv": [570.0,41620],"segment14ramp": [180,41621],"segment14soak": [0,41622],
                  "segment15sv": [580.0,41623],"segment15ramp": [180,41624],"segment15soak": [0,41625],
                  "segment16sv": [580.0,41626],"segment16ramp": [180,41627],"segment16soak": [0,41628],
                  # "rampsoakmode" 0-15 = 1-16 IMPORTANT: Factory setting is 3 (BAD). Set it up to number 0 or it will
                  # sit on stanby (SV blinks) at the end till rampsoakmode changes. It will appear as if the PID broke (unresponsive)
                  "rampsoakmode":[0,41081],
                  "rampsoakpattern": [6,41561],  #ramp soak activation pattern 0=(1-4) 1=(5-8) 2=(1-8) 3=(9-12) 4=(13-16) 5=(9-16) 6=(1-16)
                  ################  CH5    Checks the ramp soak progress, control output, remaining time and other status functions
                  "stat":[41561], #reads only. 0=off,1=1ramp,2=1soak,3=2ramp,4=2soak,...31=16ramp,32=16soak,33=end
                  ################  CH6    Sets up the thermocouple type, input range, output range and other items for the controller
                  #input type: 0=NA,1=PT100ohms,2=J,3=K,4=R,5=B,6=S,7=T,8=E,12=N,13=PL2,15=(0-5volts),16=(1-5V),17=(0-10V),18=(2-10V),19=(0-100mV)
                  "pvinputtype": [3,41016],
                  "pvinputlowerlimit":[0,41018],
                  "pvinputupperlimit":[9999,41019],
                  "decimalposition": [1,41020],
                  "unitdisplay":[1,41345],         #0=Celsius; 1=Fahrenheit
                  #################  CH7    Assigns functions for DI (digital input), DO (digital output), LED lamp and other controls
                  "rampslopeunit":[1,41432], #0=hour,1=min
                  "controlmethod":[0,41002],  #0=pid,2=fuzzy,2=self,3=pid2
                  #################  CH8     Sets the defect conditions for each type of alarm
                  #################  CH9     Sets the station number id and communication parameters of the PID controller
                  #################  CH10    Changes settings for valve control 
                  #################  CH11    Sets passwords
                  #################  CH12    Sets the parameters mask functions to hide parameters from the user
                  ################# READ ONLY MEMORY (address starts with digit 3)
                  "pv?":[31001],"sv?":[0,31002],"alarm?":[31007],"fault?":[31008],"stat?":[31041],"mv1":[0,31042]
                  }
        # "KEY": [VALUE,MEMORY_ADDRESS]
        self.PXR = {"autotuning":[0,41005],
                    "segment1sv":[100.0,41057],"segment1ramp":[3,41065],"segment1soak":[0,41066], #PXR uses only HH:MM time format but stored as minutes in artisan
                    "segment2sv":[100.0,41058],"segment2ramp":[3,41067],"segment2soak":[0,41068],
                    "segment3sv":[100.0,41059],"segment3ramp":[3,41069],"segment3soak":[0,41070],
                    "segment4sv":[100.0,41060],"segment4ramp":[3,41071],"segment4soak":[0,41072],
                    "segment5sv":[100.0,41061],"segment5ramp":[3,41073],"segment5soak":[0,41074],
                    "segment6sv":[100.0,41062],"segment6ramp":[3,41075],"segment6soak":[0,41076],
                    "segment7sv":[100.0,41063],"segment7ramp":[3,41077],"segment7soak":[0,41078],
                    "segment8sv":[100.0,41064],"segment8ramp":[3,41079],"segment8soak":[0,41080],
                    #Tells what to do after finishing or how to start. See documentation under ramp soak pattern: 0-15 
                    "rampsoakmode":[0,41081],
                    #rampsoak command 0=OFF, 1= RUN, 2= HALTED, 3=END
                    "rampsoak":[0,41082],
                    #ramp soak pattern. 0=executes 1 to 4; 1=executes 5 to 8; 2=executes 1 to 8
                    "rampsoakpattern":[0,41083],
                    #PID=0,FUZZY=1,SELF=2
                    "controlmethod":[0,41002],
                    #sv set value
                    "sv0":[0,41003],
                    # run standby 0=RUN 1=STANDBY
                    "runstandby": [0,41004],
                    "p":[5,41006],
                    "i":[240,41007],
                    "d":[60,41008],
                    "decimalposition": [1,41020],
                    "svlowerlimit":[0,41031],
                    "svupperlimit":[0,41032],
                    "pvinputtype":[3,41016],
                    #READ ONLY
                    #current pv
                    "pv?":[0,31001],
                    #current sv on display (during ramp soak it changes)
                    "sv?":[0,31002],
                    #rampsoak current running position (1-8)
                    "segment?":[0,31009],
                    "mv1":[0,30004]   #duty cycle rx -300 to 10300  = -3.00% to 103.00% (divide by 100.)
                    }

    ##TX/RX FUNCTIONS
    #This function reads read-only memory (with 3xxxx memory we need function=4)
    #both PXR3 and PXG4 use the same memory location 31001 (3xxxx = read only)
    def gettemperature(self, stationNo):
        if aw.ser.useModbusPort:
            # we use the Minimalmodbus implementation
            return aw.modbus.readSingleRegister(stationNo,aw.modbus.address2register(31001,4),4)
        else:
            #we compose a message then we send it by using self.readoneword()
            return self.readoneword(self.message2send(stationNo,4,31001,1))

    #activates the PID SV buttons in the main window to adjust the SV value. Called from the PID control pannels/SV tab
    def activateONOFFeasySV(self,flag):
        #turn off
        if flag == 0:
            aw.button_12.setVisible(False)
            aw.button_13.setVisible(False)
            aw.button_14.setVisible(False)
            aw.button_15.setVisible(False)
            aw.button_16.setVisible(False)
            aw.button_17.setVisible(False)
        #turn on
        elif flag == 1:
            A = QLabel()
            reply = QMessageBox.question(A,QApplication.translate("Message","Activate PID front buttons",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("Message","Remember SV memory has a finite\nlife of ~10,000 writes.\n\nProceed?",None, QApplication.UnicodeUTF8),
                                         QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Cancel:
                return 
            elif reply == QMessageBox.Yes:
                aw.button_12.setVisible(True)
                aw.button_13.setVisible(True)
                aw.button_14.setVisible(True)
                aw.button_15.setVisible(True)
                aw.button_16.setVisible(True)
                aw.button_17.setVisible(True)

    def readcurrentsv(self):
        if aw.ser.useModbusPort:
            reg = None
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                reg = aw.modbus.address2register(self.PXG4["sv?"][1],4)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                reg = aw.modbus.address2register(self.PXR["sv?"][1],4)
            if reg != None:
                val = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,4)/10.
            else:
                val = -0.1
        else:
            command = ""
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXG4["sv?"][1],1)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXR["sv?"][1],1)
            val = self.readoneword(command)/10.
        if val != -0.1:
            return val
        else:
            return -1

    # returns Fuji duty signal in the range 0-100 or -1
    def readdutycycle(self):
        if aw.ser.useModbusPort:
            reg = None
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                reg = aw.modbus.address2register(self.PXG4["mv1"][1],4)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                reg = aw.modbus.address2register(self.PXR["mv1"][1],4)
            if reg != None:
                val = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,4)/100.
            else:
                val = -0.01
        else:
            command = ""
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXG4["mv1"][1],1)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXR["mv1"][1],1)
            val = self.readoneword(command)/100.
        if val >= 0 and val <= 110:
            return val
        else:
            return -1

    #turns ON turns OFF current ramp soak mode
    #flag =0 OFF, flag = 1 ON, flag = 2 hold
    #A ramp soak pattern defines a whole profile. They have a minimum of 4 segments.
    def setrampsoak(self,flag):
        if aw.ser.useModbusPort:
            reg = None
            #Fuji PXG 
            if aw.ser.controlETpid[0] == 0:
                reg = aw.modbus.address2register(self.PXG4["rampsoak"][1],6)
            #Fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                reg = aw.modbus.address2register(self.PXR["rampsoak"][1],6)
            if reg != None:
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                if flag == 1:
                    aw.sendmessage(QApplication.translate("Message","RS ON", None, QApplication.UnicodeUTF8))
                elif flag == 0:
                    aw.sendmessage(QApplication.translate("Message","RS OFF", None, QApplication.UnicodeUTF8))
                else:
                    aw.sendmessage(QApplication.translate("Message","RS on HOLD", None, QApplication.UnicodeUTF8))            
        else:
            command = ""
            #Fuji PXG 
            if aw.ser.controlETpid[0] == 0:
                command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4["rampsoak"][1],flag)
            #Fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                command = self.message2send(aw.ser.controlETpid[1],6,self.PXR["rampsoak"][1],flag)
            r = aw.ser.sendFUJIcommand(command,8)
            #if OK
            if r == command:
                if flag == 1:
                    aw.sendmessage(QApplication.translate("Message","RS ON", None, QApplication.UnicodeUTF8))
                elif flag == 0:
                    aw.sendmessage(QApplication.translate("Message","RS OFF", None, QApplication.UnicodeUTF8))
                else:
                    aw.sendmessage(QApplication.translate("Message","RS on HOLD", None, QApplication.UnicodeUTF8))
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","RampSoak could not be changed",None, QApplication.UnicodeUTF8))

    #sets a new sv value
    def setsv(self,value):
        command = ""
        #Fuji PXG 
        if aw.ser.controlETpid[0] == 0: 
            #send command to the current sv (1-7)
            svkey = "sv"+ str(aw.fujipid.PXG4["selectsv"][0]) #current sv
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(self.PXG4[svkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(value*10))
            else:
                command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],int(value*10))
                r = aw.ser.sendFUJIcommand(command,8)
            #check response
            if r == command or aw.ser.useModbusPort:
                # [Not sure the following will translate or even format properly... Need testing!]
                message = QApplication.translate("Message","PXG sv#%1 set to %2",None, QApplication.UnicodeUTF8).arg(self.PXG4["selectsv"][0]).arg("%.1f" % float(value))
                aw.sendmessage(message)
                self.PXG4[svkey][0] = value
                #record command as an Event 
                strcommand = "SETSV::" + str("%.1f"%float(value))
                aw.qmc.DeviceEventRecord(strcommand)
                aw.lcd6.display("%.1f"%float(value))
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setPXGsv()")
                return -1
        #Fuji PXR
        elif aw.ser.controlETpid[0] == 1:  
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["sv0"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(value*10))
            else:
                command = self.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["sv0"][1],int(value*10))
                r = aw.ser.sendFUJIcommand(command,8)
            #check response
            if r == command or aw.ser.useModbusPort:
                # [Not sure the following will translate or even format properly... Need testing!]
                message = QApplication.translate("Message","PXR sv set to %1",None, QApplication.UnicodeUTF8).arg("%.1f" % float(value))
                aw.fujipid.PXR["sv0"][0] = value
                aw.sendmessage(message)
                #record command as an Event 
                strcommand = "SETSV::" + str("%.1f"%float(value))
                aw.qmc.DeviceEventRecord(strcommand)
                aw.lcd6.display("%.1f"%float(value))
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setPXRsv()")
                return -1

    #used to set up or down SV by diff degrees from current sv setting
    def adjustsv(self,diff):
        currentsv = self.readcurrentsv()
        if currentsv != -1:
            newsv = int((currentsv + diff)*10.)          #multiply by 10 because we use a decimal point
            #   if control pid is fuji PXG
            if aw.ser.controlETpid[0] == 0:
                # read the current svN (1-7) being used
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXR["sv0"][1],3)
                    N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
                else:
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,self.PXG4["selectsv"][1],1)
                    N = aw.fujipid.readoneword(command)
                if N != -1:
                    self.PXG4["selectsv"][0] = N
                    svkey = "sv" + str(N)
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(self.PXG4[svkey][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newsv)
                    else:
                        command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],newsv)
                        r = aw.ser.sendFUJIcommand(command,8)
                    if len(r) == 8 or aw.ser.useModbusPort:
                        message = QApplication.translate("Message","SV%1 changed from %2 to %3)",None, QApplication.UnicodeUTF8).arg(str(N)).arg(str(currentsv)).arg(str(newsv/10.))
                        aw.sendmessage(message)
                        self.PXG4[svkey][0] = newsv/10
                        #record command as an Event to replay (not binary as it needs to be stored in a text file)
                        strcommand = "SETSV::" + str("%.1f"%(newsv/10.))
                        aw.qmc.DeviceEventRecord(strcommand)
                        aw.lcd6.display("%.1f"%float(newsv/10.))
                    else:
                        msg = QApplication.translate("Message","Unable to set sv%1",None, QApplication.UnicodeUTF8).arg(str(N))
                        aw.sendmessage(msg)
            #   or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(self.PXR["sv0"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newsv)
                else:
                    command = self.message2send(aw.ser.controlETpid[1],6,self.PXR["sv0"][1],newsv)
                    r = aw.ser.sendFUJIcommand(command,8)
                if len(r) == 8 or aw.ser.useModbusPort:
                    message = QApplication.translate("Message","SV changed from %1 to %2",None, QApplication.UnicodeUTF8).arg(str(currentsv)).arg(str(newsv/10.))                           
                    aw.sendmessage(message)
                    self.PXR["sv0"][0] = newsv/10
                    #record command as an Event to replay (not binary as it needs to be stored in a text file)
                    strcommand = "SETSV::" + str("%.1f"%(newsv/10.))
                    aw.qmc.DeviceEventRecord(strcommand)
                    aw.lcd6.display("%.1f"%float(newsv/10.))
                else:
                    aw.sendmessage(QApplication.translate("Message","Unable to set sv", None, QApplication.UnicodeUTF8))
        else:
            aw.sendmessage(QApplication.translate("Message","Unable to set new sv", None, QApplication.UnicodeUTF8))

    #format of the input string Command: COMMAND::VALUE1::VALUE2::VALUE3::ETC
    def replay(self,CommandString):
        parts = CommandString.split("::")
        command = parts[0]
        values = parts[1:]
        if command == "SETSV":
            self.setsv(float(values[0]))
            return
        elif command == "SETRS":
            self.replaysetrs(CommandString)
            return

    #example of command string with four segments (minimum for Fuji PIDs)
    # SETRS::270.0::3::0::SETRS::300.0::3::0::SETRS::350.0::3::0::SETRS::400.0::3::0
    def replaysetrs(self,CommandString):
        segments =CommandString.split("SETRS")
        if len(segments[0]) == 0:
            segments = segments[1:]          #remove first empty [""] list [[""],[etc]]
        if len(segments[-1]) == 0:
            segments = segments[:-1]          #remove last empty [""] list [[etc][""]]
        n = len(segments)
        #if parts is < 4, make it compatible with Fuji PID (4 segments needed)
        if n < 4:
            for i in range(4-n):
                #last temperature
                lasttemp = segments[-1].split("::")[1]
                #create a string with 4 segments ("SETRS" alredy removed) 
                string = "::" + lasttemp + "::0::0"   #add zero ramp time and zero soak time
                segments.append(string)
        rs = []
        changeflag = 0
        for i in range(n):
            rs.append(segments[i].split("::"))
            if len(rs[i][0]) == 0:          #remove first empty u"" [u"",u"300.5",u"3",u"0",u""] if one found
                rs[i] = rs[i][1:]
            if len(rs[i][-1]) == 0:          #remove last empty u"" [u"300.5",u"3",u"0",u""] if one found
                rs[i] = rs[i][:-1]
            if len(rs[i]) == 3:
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                if aw.ser.controlETpid[0] == 0:             #PXG4
                    if not n%4 or n > 16:
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PXG4 replaysetrs(): %1").arg(n))
                        return
                    if self.PXG4[svkey][0] != float(rs[i][0]):
                        self.PXG4[svkey][0] = float(rs[i][0])
                        changeflag = 1
                    if self.PXG4[rampkey][0] != int(rs[i][1]):
                        self.PXG4[rampkey][0] = int(rs[i][1])
                        changeflag = 1
                    if self.PXG4[soakkey][0] != int(rs[i][2]):
                        self.PXG4[soakkey][0] = int(rs[i][2])
                        changeflag = 1
                    if changeflag:
                        self.setsegment((i+1), self.PXG4[svkey][0], self.PXG4[rampkey][0] ,self.PXG4[soakkey][0])
                        changeflag = 0
                elif aw.ser.controlETpid[0] == 1:           #PXR
                    if not n%4 or n > 8:
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PXR replaysetrs(): %1").arg(n))
                        return
                    if self.PXR[svkey][0] != float(rs[i][0]):
                        self.PXR[svkey][0] = float(rs[i][0])
                        changeflag = 1
                    if self.PXR[rampkey][0] != int(rs[i][1]):
                        self.PXR[rampkey][0] = int(rs[i][1])
                        changeflag = 1
                    if self.PXR[soakkey][0] != int(rs[i][2]):
                        self.PXR[soakkey][0] = int(rs[i][2])
                        changeflag = 1
                    if changeflag:
                        self.setsegment((i+1), self.PXR[svkey][0], self.PXR[rampkey][0] ,self.PXR[soakkey][0])
                        changeflag = 0
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " replaysetrs()")
                return
        #start ramp soak ON
        self.setrampsoak(1)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    #used in replaysetrs()    
    def setsegment(self,idn,sv,ramp,soak):
        svkey = "segment" + str(idn) + "sv"
        rampkey = "segment" + str(idn) + "ramp"
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.useModbusPort:
            if aw.ser.controlETpid[0] == 0:
                reg1 = aw.modbus.address2register(self.PXG4[svkey][1],6)
                reg2 = aw.modbus.address2register(self.PXG4[rampkey][1],6)
                reg3 = aw.modbus.address2register(self.PXG4[soakkey][1],6)
            elif  aw.ser.controlETpid[0] == 1:
                reg1 = aw.modbus.address2register(self.PXR[svkey][1],6)
                reg2 = aw.modbus.address2register(self.PXR[rampkey][1],6)
                reg3 = aw.modbus.address2register(self.PXR[soakkey][1],6)                
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg1,int(sv*10))
            libtime.sleep(0.11) #important time between writings
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg2,ramp)
            libtime.sleep(0.11) #important time between writings
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg3,soak)
            r1 = r2 = r3 = "        "
        else:
            if aw.ser.controlETpid[0] == 0:
                svcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],int(sv*10))
                rampcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[rampkey][1],ramp)
                soakcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[soakkey][1],soak)
            elif  aw.ser.controlETpid[0] == 1:
                svcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[svkey][1],int(sv*10))
                rampcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[rampkey][1],ramp)
                soakcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[soakkey][1],soak)
            r1 = aw.ser.sendFUJIcommand(svcommand,8)
            libtime.sleep(0.11) #important time between writings
            r2 = aw.ser.sendFUJIcommand(rampcommand,8)
            libtime.sleep(0.11) #important time between writings
            r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1)!=8 or len(r2)!=8 or len(r3)!=8:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None, QApplication.UnicodeUTF8))

    def dec2HexRaw(self,decimal):
        # This method converts a decimal to a raw string appropiate for Fuji serial TX
        # Used to compose serial messages
        Nbytes = []
        while decimal:
            decimal, rem = divmod(decimal, 256)
            Nbytes.append(rem)
        Nbytes.reverse()
        if not Nbytes:
            Nbytes.append(0)
        return  "".join(chr(b) for b in Nbytes)

    def message2send(self, stationNo, FunctionCode, memory, Nword):
        # This method takes the arguments to compose a Fuji serial command and returns the complete raw string with crc16 included
        # memory must be given as the Resistor Number Engineering unit (example of memory = 41057 )
        #check to see if Nword is < 257. If it is, then add extra zero pad. 2^8 = 256 = 1 byte but 2 bytes always needed to send Nword
        if Nword < 257:
            pad1 = self.dec2HexRaw(0)
        else:
            pad1 = ""
        part1 = self.dec2HexRaw(stationNo)
        part2 = self.dec2HexRaw(FunctionCode)
        _,r = divmod(memory,10000)
        part3 = self.dec2HexRaw(r - 1)
        part4 = self.dec2HexRaw(Nword)
        datastring = part1 + part2 + part3 + pad1 + part4
        # calculate the crc16 of all this data string
        crc16int = self.fujiCrc16(datastring)
        #convert crc16 to hex string to change the order of the 2 bytes from AB.CD to CD.AB to match Fuji requirements
        crc16hex= hex(crc16int)[2:]
        #we need 4 chars but sometimes we get only three or two because of abreviations by hex(). Therefore, add "0" if needed.
        ll = 4 - len(crc16hex)
        pad =["","0","00","000"]
        crc16hex = pad[ll] + crc16hex
        #change now from AB.CD to CD.AB and convert from hex string to int
        crc16end = int(crc16hex[2:]+crc16hex[:2],16)
        #now convert the crc16 from int to binary
        part5 = self.dec2HexRaw(crc16end)
        #return total sum of binary parts  (assembled message)
        return (datastring + part5)

    #input string command. Output integer (not binary string); used for example to read temperature or to obtain the value of a variable
    def readoneword(self,command):
        #takes an already formated command to read 1 word data and returns the response from the pid
        #SEND command and RECEIVE 7 bytes back
        r = aw.ser.sendFUJIcommand(command,7)
        if len(r) == 7:
            # EVERYTHINK OK: convert data part binary string to hex representation
            s1 = hex2int(r[3],r[4])
            #conversion from hex to dec
            return s1
        else:
            #bad number of RX bytes 
            errorcode = QApplication.translate("Error Message","pid.readoneword(): %1 RX bytes received (7 needed) for unit ID=%2",None, QApplication.UnicodeUTF8).arg(len(r)).arg(ord(command[0]))
            aw.qmc.adderror(errorcode)
            return -1

    #FUJICRC16 function calculates the CRC16 of the data. It expects a binary string as input and returns an int
    def fujiCrc16(self,string):
        crc16tab = (0x0000,
                    0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
                    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880,
                    0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0,
                    0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100,
                    0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,
                    0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80,
                    0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0,
                    0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200,
                    0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
                    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80,
                    0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0,
                    0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700,
                    0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,
                    0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80,
                    0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0,
                    0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400,
                    0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040)
        cr=0xFFFF 
        for j in string:
            tmp = cr ^(ord(j))
            cr =(cr >> 8)^crc16tab[(tmp & 0xff)]
        return cr

############################################################################
######################## Arduino CONTROL DIALOG ######################
############################################################################

class ArduinoDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(ArduinoDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Arduino Control",None, QApplication.UnicodeUTF8))
        # PID tab
        tab1Layout = QVBoxLayout()
        pidGrp = QGroupBox(QApplication.translate("GroupBox","p-i-d",None, QApplication.UnicodeUTF8))
        self.pidKp = QDoubleSpinBox()
        self.pidKp.setAlignment(Qt.AlignRight)
        self.pidKp.setRange(.0,999.)
        self.pidKp.setSingleStep(.1)
        self.pidKp.setValue(aw.arduino.pidKp)
        pidKpLabel = QLabel("kp")
        self.pidKi = QDoubleSpinBox()
        self.pidKi.setAlignment(Qt.AlignRight)
        self.pidKi.setRange(.0,999.)
        self.pidKi.setSingleStep(.1)
        self.pidKi.setValue(aw.arduino.pidKi)         
        pidKiLabel = QLabel("ki")
        self.pidKd = QDoubleSpinBox()
        self.pidKd.setAlignment(Qt.AlignRight)
        self.pidKd.setRange(.0,999.)
        self.pidKd.setSingleStep(.1)
        self.pidKd.setValue(aw.arduino.pidKd)
        pidKdLabel = QLabel("kd")
        pidSetPID = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        self.connect(pidSetPID, SIGNAL("clicked()"),self.pidConf)
        
        pidSourceItems = ["1","2","3","4"]
        self.pidSource = QComboBox()
        self.pidSource.addItems(pidSourceItems)
        self.pidSource.setCurrentIndex(aw.arduino.pidSource - 1)        
        
        pidSourceLabel = QLabel(QApplication.translate("Label","Source",None, QApplication.UnicodeUTF8))
        
        pidGrid = QGridLayout()
        pidGrid.addWidget(pidKpLabel,0,0)
        pidGrid.addWidget(self.pidKp,0,1)
        pidGrid.addWidget(pidKiLabel,1,0)
        pidGrid.addWidget(self.pidKi,1,1)
        pidGrid.addWidget(pidKdLabel,2,0)
        pidGrid.addWidget(self.pidKd,2,1)              

        self.pidCycle = QSpinBox()
        self.pidCycle.setAlignment(Qt.AlignRight)
        self.pidCycle.setRange(0,99999)
        self.pidCycle.setSingleStep(100)
        self.pidCycle.setValue(aw.arduino.pidCycle)
        self.pidCycle.setSuffix(" ms")
        pidCycleLabel = QLabel(QApplication.translate("Label","Cycle",None, QApplication.UnicodeUTF8))
        pidSourceBox = QHBoxLayout()
        pidSourceBox.addStretch()
        pidSourceBox.addWidget(pidSourceLabel)
        pidSourceBox.addWidget(self.pidSource)
        pidSourceBox.addSpacing(80)
        pidSourceBox.addStretch()
        
        pidCycleBox = QHBoxLayout()
        pidCycleBox.addStretch()  
        pidCycleBox.addWidget(pidCycleLabel)
        pidCycleBox.addWidget(self.pidCycle)
        pidCycleBox.addSpacing(80)
        pidCycleBox.addStretch()  
        
        pidSetBox = QHBoxLayout()
        pidSetBox.addStretch()
        pidSetBox.addWidget(pidSetPID)
        
        pidVBox = QVBoxLayout()
        pidVBox.addLayout(pidSourceBox)
        pidVBox.addLayout(pidCycleBox)
        pidVBox.addLayout(pidSetBox)
        
        pidGridBox = QHBoxLayout()
        pidGridBox.addLayout(pidGrid)
        pidGridBox.addStretch()
        pidGridBox.addLayout(pidVBox)
        
        pidGridVBox = QVBoxLayout()
        pidGridVBox.addLayout(pidGridBox)
        pidGrp.setLayout(pidGridVBox)
        
        self.pidSV = QSpinBox()
        self.pidSV.setAlignment(Qt.AlignRight)
        self.pidSV.setRange(0,999)
        self.pidSV.setSingleStep(10)
        self.pidSV.setValue(aw.arduino.svValue)
        pidSVLabel = QLabel(QApplication.translate("Label","SV",None, QApplication.UnicodeUTF8))
        
        self.pidSVLookahead = QSpinBox()
        self.pidSVLookahead.setAlignment(Qt.AlignRight)
        self.pidSVLookahead.setRange(0,999)
        self.pidSVLookahead.setSingleStep(1)
        self.pidSVLookahead.setValue(aw.arduino.svLookahead)  
        self.pidSVLookahead.setSuffix(" s")
        pidSVLookaheadLabel = QLabel(QApplication.translate("Label","Lookahead",None, QApplication.UnicodeUTF8))
        
        pidSetSV = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        self.connect(pidSetSV, SIGNAL("clicked()"),self.setSV)
        
        pidSVModeLabel = QLabel(QApplication.translate("Label","Mode",None, QApplication.UnicodeUTF8))
        pidModeItems = [
            QApplication.translate("Label", "Manual",None, QApplication.UnicodeUTF8),
            QApplication.translate("Label", "Ramp/Soak",None, QApplication.UnicodeUTF8),
            QApplication.translate("Label", "Background",None, QApplication.UnicodeUTF8)]
        self.pidMode = QComboBox()
        self.pidMode.addItems(pidModeItems)
        self.pidMode.setCurrentIndex(aw.arduino.svMode)
        
        self.pidSVbuttonsFlag = QCheckBox(QApplication.translate("Label","SV Buttons",None, QApplication.UnicodeUTF8))
        self.pidSVbuttonsFlag.setChecked(aw.arduino.svButtons)
        self.connect(self.pidSVbuttonsFlag, SIGNAL("stateChanged(int)"), lambda flag=1: aw.arduino.activateONOFFeasySV(flag))
        self.pidSVsliderFlag = QCheckBox(QApplication.translate("Label","SV Slider",None, QApplication.UnicodeUTF8))
        self.pidSVsliderFlag.setChecked(aw.arduino.svSlider)
        self.connect(self.pidSVsliderFlag, SIGNAL("stateChanged(int)"), lambda flag=1: aw.arduino.activateSVSlider(flag))
        
        self.pidSVSliderMin = QSpinBox()
        self.pidSVSliderMin.setAlignment(Qt.AlignRight)
        self.pidSVSliderMin.setRange(0,999)
        self.pidSVSliderMin.setSingleStep(10)
        self.pidSVSliderMin.setValue(aw.arduino.svSliderMin)
        pidSVSliderMinLabel = QLabel(QApplication.translate("Label","min",None, QApplication.UnicodeUTF8))
        self.connect(self.pidSVSliderMin, SIGNAL("valueChanged(int)"), aw.arduino.sliderMinValueChanged)
        
        self.pidSVSliderMax = QSpinBox()
        self.pidSVSliderMax.setAlignment(Qt.AlignRight)
        self.pidSVSliderMax.setRange(0,999)
        self.pidSVSliderMax.setSingleStep(10)
        self.pidSVSliderMax.setValue(aw.arduino.svSliderMax)   
        pidSVSliderMaxLabel = QLabel(QApplication.translate("Label","max",None, QApplication.UnicodeUTF8))
        self.connect(self.pidSVSliderMax, SIGNAL("valueChanged(int)"), aw.arduino.sliderMaxValueChanged)
        
        if aw.qmc.mode == "F":
            self.pidSVSliderMin.setSuffix(" F")
            self.pidSVSliderMax.setSuffix(" F")
            self.pidSV.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.pidSVSliderMin.setSuffix(" C")
            self.pidSVSliderMax.setSuffix(" C")
            self.pidSV.setSuffix(" C")
        
        modeBox = QHBoxLayout()
        modeBox.addWidget(pidSVModeLabel)
        modeBox.addWidget(self.pidMode)
        modeBox.addStretch()
        modeBox.addWidget(pidSVLookaheadLabel)
        modeBox.addWidget(self.pidSVLookahead)
        
        sliderBox = QHBoxLayout()
        sliderBox.addWidget(self.pidSVsliderFlag)
        sliderBox.addStretch()
        sliderBox.addWidget(pidSVSliderMinLabel)
        sliderBox.addWidget(self.pidSVSliderMin)        
        sliderBox.addSpacing(10)
        sliderBox.addWidget(pidSVSliderMaxLabel)
        sliderBox.addWidget(self.pidSVSliderMax)
        
        svInputBox = QHBoxLayout()
        svInputBox.addWidget(self.pidSVbuttonsFlag)
        svInputBox.addStretch()
        svInputBox.addWidget(pidSVLabel)
        svInputBox.addWidget(self.pidSV)
        svInputBox.addWidget(pidSetSV)
        
        svGrpBox = QVBoxLayout()
        svGrpBox.addLayout(modeBox)
        svGrpBox.addLayout(sliderBox)
        svGrpBox.addLayout(svInputBox)
        svGrpBox.addStretch()
        svGrp = QGroupBox(QApplication.translate("GroupBox","Set Value",None, QApplication.UnicodeUTF8))
        svGrp.setLayout(svGrpBox)
        
        pidBox = QHBoxLayout()
        pidBox.addWidget(pidGrp)
        
        svBox = QHBoxLayout()
        svBox.addWidget(svGrp)
                
        self.startPIDonCHARGE = QCheckBox(QApplication.translate("CheckBox", "Start PID on CHARGE",None, QApplication.UnicodeUTF8))
        self.startPIDonCHARGE.setChecked(aw.arduino.pidOnCHARGE)

        tab1Layout.addLayout(pidBox)
        tab1Layout.addLayout(svBox)
        tab1Layout.addWidget(self.startPIDonCHARGE)
        tab1Layout.addStretch()
        
        
        # Ramp/Soak tab
        tab2Layout = QVBoxLayout()
        tab2InnerLayout = QHBoxLayout()
        tab2Layout.addLayout(tab2InnerLayout)
        rsGrid = QGridLayout()
        self.SVWidgets = []
        self.RampWidgets = []
        self.SoakWidgets = []
        rsGrid.addWidget(QLabel("SV"),0,1)
        rsGrid.addWidget(QLabel("Ramp"),0,2)
        rsGrid.addWidget(QLabel("Soak"),0,3)
        for i in range(8):
            n = i+1
            svwidget = QSpinBox()
            svwidget.setAlignment(Qt.AlignRight)
            svwidget.setRange(0,999)
            svwidget.setSingleStep(10)
            if aw.qmc.mode == "F":
                svwidget.setSuffix(" F")
            elif aw.qmc.mode == "C":
                svwidget.setSuffix(" C")
            self.SVWidgets.append(svwidget)
            rampwidget = QTimeEdit()
            rampwidget.setDisplayFormat("mm:ss")
            rampwidget.setAlignment(Qt.AlignRight)
            self.RampWidgets.append(rampwidget)
            soakwidget = QTimeEdit()
            soakwidget.setDisplayFormat("mm:ss")
            soakwidget.setAlignment(Qt.AlignRight)
            self.SoakWidgets.append(soakwidget)
            rsGrid.addWidget(QLabel(str(n)),n,0)
            rsGrid.addWidget(svwidget,n,1)
            rsGrid.addWidget(self.RampWidgets[i],n,2)
            rsGrid.addWidget(self.SoakWidgets[i],n,3)
        self.setrampsoaks()
        importButton = QPushButton(QApplication.translate("Button","Load",None, QApplication.UnicodeUTF8))
        importButton.setMinimumWidth(80)
        self.connect(importButton, SIGNAL("clicked()"),self.importrampsoaks)
        exportButton = QPushButton(QApplication.translate("Button","Save",None, QApplication.UnicodeUTF8))
        exportButton.setMinimumWidth(80)
        self.connect(exportButton, SIGNAL("clicked()"),self.exportrampsoaks)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(importButton)
        buttonLayout.addWidget(exportButton)
        buttonLayout.addStretch()
        self.loadRampSoakFromProfile = QCheckBox(QApplication.translate("CheckBox", "Load Ramp/Soak table from profile",None, QApplication.UnicodeUTF8))
        self.loadRampSoakFromProfile.setChecked(aw.arduino.loadRampSoakFromProfile)
        
        tab2InnerLayout.addStretch()
        tab2InnerLayout.addLayout(rsGrid)
        tab2InnerLayout.addStretch()
        tab2Layout.addLayout(buttonLayout)
        tab2Layout.addStretch()
        tab2Layout.addWidget(self.loadRampSoakFromProfile)
            
            
        ############################
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self.close)
        onButton = QPushButton(QApplication.translate("Button","On",None, QApplication.UnicodeUTF8))
        self.connect(onButton, SIGNAL("clicked()"), aw.arduino.pidOn)
        offButton = QPushButton(QApplication.translate("Button","Off",None, QApplication.UnicodeUTF8))
        self.connect(offButton, SIGNAL("clicked()"), aw.arduino.pidOff)
        okButtonLayout = QHBoxLayout()
        okButtonLayout.addWidget(onButton)
        okButtonLayout.addWidget(offButton)
        okButtonLayout.addStretch()
        okButtonLayout.addWidget(okButton)
        tabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        tabWidget.addTab(C1Widget,QApplication.translate("Tab","PID",None, QApplication.UnicodeUTF8))
        C1Widget.setTabOrder(self.pidCycle, self.pidSource)
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        tabWidget.addTab(C2Widget,QApplication.translate("Tab","Ramp/Soak",None, QApplication.UnicodeUTF8))
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(tabWidget)
        mainLayout.addLayout(okButtonLayout)
        self.setLayout(mainLayout)
        okButton.setFocus()
                
    def importrampsoaks(self):
        aw.fileImport(QApplication.translate("Message", "Load Ramp/Soak Table",None, QApplication.UnicodeUTF8),self.importrampsoaksJSON)
        
    def importrampsoaksJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            rampsoaks = json.load(infile)
            infile.close()
            aw.arduino.svValues = rampsoaks["svValues"]
            aw.arduino.svRamps = rampsoaks["svRamps"]
            aw.arduino.svSoaks = rampsoaks["svSoaks"]
            self.setrampsoaks()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importrampsoaksJSON() %1").arg(str(ex)),exc_tb.tb_lineno)
    
    def exportrampsoaks(self):
        aw.fileExport(QApplication.translate("Message", "Save Ramp/Soak Table",None, QApplication.UnicodeUTF8),"*.ars",self.exportrampsoaksJSON)
        
    def exportrampsoaksJSON(self,filename):
        try:
            self.saverampsoaks()
            rampsoaks = {}
            rampsoaks["svValues"] = aw.arduino.svValues
            rampsoaks["svRamps"] = aw.arduino.svRamps
            rampsoaks["svSoaks"] = aw.arduino.svSoaks
            rampsoaks["mode"] = aw.qmc.mode
            outfile = open(filename, 'w')
            json.dump(rampsoaks, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " exportrampsoaksJSON(): %1").arg(str(ex)),exc_tb.tb_lineno)
            return False
            
    def saverampsoaks(self):
        for i in range(8):
            aw.arduino.svValues[i] = self.SVWidgets[i].value()
            aw.arduino.svRamps[i] = aw.arduino.QTime2time(self.RampWidgets[i].time())
            aw.arduino.svSoaks[i] = aw.arduino.QTime2time(self.SoakWidgets[i].time())
            
    def setrampsoaks(self):
        for i in range(8):
            self.SVWidgets[i].setValue(aw.arduino.svValues[i])
            self.RampWidgets[i].setTime(aw.arduino.time2QTime(aw.arduino.svRamps[i]))
            self.SoakWidgets[i].setTime(aw.arduino.time2QTime(aw.arduino.svSoaks[i]))
    
    def pidConf(self):
        kp = self.pidKp.value() # 5.00
        ki = self.pidKi.value() # 0.15
        kd = self.pidKd.value() # 0.00
        source = self.pidSource.currentIndex() + 1 # 1-4, def 1
        cycle = self.pidCycle.value() # def 1000 in ms
        aw.arduino.confPID(kp,ki,kd,source,cycle)
        
    def setSV(self):
        aw.arduino.setSV(self.pidSV.value())
        
    def close(self):
        kp = self.pidKp.value() # 5.00
        ki = self.pidKi.value() # 0.15
        kd = self.pidKd.value() # 0.00
        source = self.pidSource.currentIndex() + 1 # 1-4, def 1
        cycle = self.pidCycle.value() # def 1000 in ms
        aw.arduino.setPID(kp,ki,kd,source,cycle)
        #
        aw.arduino.pidOnCHARGE = self.startPIDonCHARGE.isChecked()
        aw.arduino.loadRampSoakFromProfile = self.loadRampSoakFromProfile.isChecked()
        aw.arduino.svSlider = self.pidSVsliderFlag.isChecked()
        aw.arduino.svButtons = self.pidSVbuttonsFlag.isChecked()
        aw.arduino.activateONOFFeasySV(aw.arduino.svButtons)
        aw.arduino.svMode = self.pidMode.currentIndex()
        aw.arduino.svSliderMin = min(self.pidSVSliderMin.value(),self.pidSVSliderMax.value())
        aw.arduino.svSliderMax = max(self.pidSVSliderMin.value(),self.pidSVSliderMax.value())
        aw.arduino.svLookahead = self.pidSVLookahead.value()
        aw.arduino.svValue = self.pidSV.value()
        #
        self.saverampsoaks()
        #
        self.closeEvent(None)        

    def closeEvent(self,event):
        self.accept()


############################################################################
######################## DTA PID CONTROL DIALOG ######################
############################################################################

class DTApidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(DTApidDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Delta DTA PID Control",None, QApplication.UnicodeUTF8))
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Work in Progress",None, QApplication.UnicodeUTF8),5000)
        svlabel = QLabel(QApplication.translate("Label", "SV", None, QApplication.UnicodeUTF8))
        self.svedit = QLineEdit(str(aw.dtapid.dtamem["sv"][0]))
        self.svedit.setValidator(QDoubleValidator(0., 999.,1, self.svedit))
        readsvbutton = QPushButton(QApplication.translate("Button","Read", None, QApplication.UnicodeUTF8))
        writesvbutton = QPushButton(QApplication.translate("Button","Write", None, QApplication.UnicodeUTF8))
        self.connect(readsvbutton,SIGNAL("clicked()"),self.readsv)
        self.connect(writesvbutton,SIGNAL("clicked()"),self.writesv)
        tab1Layout = QGridLayout()
        tab1Layout.addWidget(svlabel,0,0)
        tab1Layout.addWidget(self.svedit,0,1)
        tab1Layout.addWidget(readsvbutton,0,2)
        tab1Layout.addWidget(writesvbutton,0,3)
        ############################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","General",None, QApplication.UnicodeUTF8))
        mainlayout = QVBoxLayout()
        mainlayout.addWidget(self.status,0)
        mainlayout.addWidget(TabWidget,1)
        self.setLayout(mainlayout)

    def readsv(self):
        ### create command message2send(unitID,function,address,ndata)
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],3,aw.dtapid.dtamem["sv"][1],1)
        #read sv
        sv = aw.ser.sendDTAcommand(command)
        #update SV value 
        aw.dtapid.dtamem["sv"][0] = sv
        #update svedit
        self.svedit.setText(str(sv)) 
        #update sv LCD
        aw.lcd6.display(sv)
        #update status
        message = QApplication.translate("StatusBar","SV = %s"%(str(sv)),None, QApplication.UnicodeUTF8)
        self.status.showMessage(message,5000)

    #write uses function = 6
    def writesv(self):
        newsv = hex(int(abs(float(str(self.svedit.text())))*10.))[2:].upper()
        ### create command message2send(unitID,function,address,ndata)
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],6,aw.dtapid.dtamem["sv"][1],newsv)
        #read sv
        aw.ser.sendDTAcommand(command)

###################################################################################
##########################  ARDUINO CLASS DEFINITION  ############################
###################################################################################

class ArduinoTC4(object):
    def __init__(self):
        self.pidActive = False
        self.sv = 0 # the last sv send to the Arduino
        #
        self.pidOnCHARGE = False
        self.loadRampSoakFromProfile = False
        self.svValues = [0,0,0,0,0,0,0,0] # sv temp as int per 8 channels
        self.svRamps = [0,0,0,0,0,0,0,0] # seconds as int per 8 channels
        self.svSoaks = [0,0,0,0,0,0,0,0] # seconds as int per 8 channels
        self.svSlider = False
        self.svButtons = False
        self.svMode = 0 # 0: manual, 1: Ramp/Soak, 2: Follow (background profile)
        self.svLookahead = 0
        self.svSliderMin = 300
        self.svSliderMax = 480
        self.svValue = 390 # the value in the setSV textinput box of the PID dialog
        self.pidKp = 11.0
        self.pidKi = 0.05
        self.pidKd = 0.0
        self.pidSource = 1 # TC4 input channel
        self.pidCycle = 1000
        
    def conv2celsius(self):
        try:
            self.svValue = aw.qmc.fromFtoC(self.svValue)
            self.svSliderMin = aw.qmc.fromFtoC(self.svSliderMin)
            self.svSliderMax = aw.qmc.fromFtoC(self.svSliderMax)
            self.pidKp = self.pidKp * (9/5.)
            self.pidKi = self.pidKi * (9/5.)
            self.pidKd = self.pidKd * (9/5.)
            for i in range(self.svValues):
                self.svValues[i] = aw.qmc.fromFtoC(self.svValues[i])
        except:
            pass
    
    def conv2fahrenheit(self):
        try:
            self.svValue = aw.qmc.fromCtoF(self.svValue)
            self.svSliderMin = aw.qmc.fromCtoF(self.svSliderMin)
            self.svSliderMax = aw.qmc.fromCtoF(self.svSliderMax)
            self.pidKp = self.pidKp / (9/5.)
            self.pidKi = self.pidKi / (9/5.)
            self.pidKd = self.pidKd / (9/5.)
            for i in range(self.svValues):
                self.svValues[i] = aw.qmc.fromCtoF(self.svValues[i])
        except:
            pass
    
    # takes an "Arduino" float time in seconds and returns the corresponding QTime() object
    def time2QTime(self,t):
        return QTime(0,t/60,t%60)
        
    def QTime2time(self,t):
        return t.minute() * 60 + t.second()
        
    def togglePID(self):
        if self.pidActive:
            self.pidOff()
        else:
            self.pidOn()

    def pidOn(self):
        if aw.ser.ArduinoIsInitialized:
            self.confPID(self.pidKp,self.pidKi,self.pidKd,self.pidSource,self.pidCycle) # first configure PID according to the actual settings
            try:
                #### lock shared resources #####
                aw.ser.COMsemaphore.acquire(1)
                if aw.ser.SP.isOpen():
                    aw.ser.SP.flushInput()
                    aw.ser.SP.flushOutput()
                    aw.ser.SP.write(str2cmd("PID;ON\n"))
                    self.pidActive = True
                    aw.button_10.setStyleSheet(aw.pushbuttonstyles["PIDactive"])                    
                    aw.sendmessage(QApplication.translate("Message","PID turned on", None, QApplication.UnicodeUTF8))
            finally:
                if aw.ser.COMsemaphore.available() < 1:
                    aw.ser.COMsemaphore.release(1)

    def pidOff(self):
        if aw.ser.ArduinoIsInitialized:
            try:
                #### lock shared resources #####
                aw.ser.COMsemaphore.acquire(1)
                if aw.ser.SP.isOpen():
                    aw.ser.SP.flushInput()
                    aw.ser.SP.flushOutput()
                    aw.ser.SP.write(str2cmd("PID;OFF\n"))
                    aw.sendmessage(QApplication.translate("Message","PID turned off", None, QApplication.UnicodeUTF8))
            finally:
                if aw.ser.COMsemaphore.available() < 1:
                    aw.ser.COMsemaphore.release(1)
            aw.button_10.setStyleSheet(aw.pushbuttonstyles["PID"])
            self.pidActive = False
        
    def sliderMinValueChanged(self,i):
        self.svSliderMin = i
        aw.sliderSV.setMinimum(self.svSliderMin)

    def sliderMaxValueChanged(self,i):
        self.svSliderMax = i
        aw.sliderSV.setMaximum(self.svSliderMax)

    # returns SV (or None) wrt. to the ramp-soak table and the given time t
    def svRampSoak(self,t):
        segment_end_time = 0 # the (end) time of the segments
        prev_segment_end_time = 0 # the (end) time of the previous segment
        segment_start_sv = 0 # the (target) sv of the segment
        prev_segment_start_sv = 0 # the (target) sv of the previous segment
        for i in range(len(self.svValues)):
            # Ramp
            segment_end_time = segment_end_time + self.svRamps[i]
            segment_start_sv = self.svValues[i]
            if segment_end_time > t:
                # t is within the current segment
                k = float(segment_start_sv - prev_segment_start_sv) / float(segment_end_time - prev_segment_end_time)
                return prev_segment_start_sv + k*(t - prev_segment_end_time)
            prev_segment_end_time = segment_end_time
            prev_segment_start_sv = segment_start_sv
            # Soak
            segment_end_time = segment_end_time + self.svSoaks[i]
            segment_start_sv = self.svValues[i]
            if segment_end_time > t:
                # t is within the current segment
                return prev_segment_start_sv
            prev_segment_end_time = segment_end_time
            prev_segment_start_sv = segment_start_sv
        return None              
                        
    # returns None if in manual mode or no other sv (via ramp/soak or follow mode) defined
    def calcSV(self,tx):
        if self.svMode == 1:
            # Ramp/Soak mode
            # actual time (after CHARGE):            
            return self.svRampSoak(tx)
        elif self.svMode == 2 and aw.qmc.background:
            # Follow Background mode
            if int(aw.ser.arduinoETChannel) == self.pidSource: # we observe the ET
                j = aw.qmc.backgroundtime2index(tx + self.svLookahead)
                return aw.qmc.temp1B[j]
            elif int(aw.ser.arduinoBTChannel) == self.pidSource: # we observe the BT
                j = aw.qmc.backgroundtime2index(tx + self.svLookahead)
                return aw.qmc.temp2B[j]
        else:
            # return None in manual mode
            return None

    def setSV(self,sv,move=True):
        if aw.ser.ArduinoIsInitialized:
            sv = max(0,sv)
            if self.sv != sv: # nothing to do (avoid loops via moveslider!)
                try:
                    #### lock shared resources #####
                    aw.ser.COMsemaphore.acquire(1)
                    if aw.ser.SP.isOpen():
                        aw.ser.SP.flushInput()
                        aw.ser.SP.flushOutput()
                        aw.ser.SP.write(str2cmd("PID;SV;" + str(sv) +"\n"))
                        self.sv = sv
                        if move:
                            aw.moveSVslider(sv)
                        libtime.sleep(.1)
                finally:
                    if aw.ser.COMsemaphore.available() < 1:
                        aw.ser.COMsemaphore.release(1)

    def adjustsv(self,diff):
        self.setSV(self.sv + diff,True)

    def activateSVSlider(self,flag):
        if flag and aw.qmc.device == 19: # only show for Arduino TC4
            if aw.qmc.flagon:
                aw.sliderGrpBoxSV.setVisible(True)
                aw.sliderSV.setMinimum(self.svSliderMin)
                aw.sliderSV.setMaximum(self.svSliderMax)
            self.svSlider = True
        else:
            aw.sliderGrpBoxSV.setVisible(False)
            self.svSlider = False

    def activateONOFFeasySV(self,flag):
        if flag and aw.qmc.device == 19: # only show for Arduino TC4
            if aw.qmc.flagon:
                aw.button_12.setVisible(True)
                aw.button_13.setVisible(True)
                aw.button_14.setVisible(True)
                aw.button_15.setVisible(True)
                aw.button_16.setVisible(True)
                aw.button_17.setVisible(True)
            self.svButtons = True
        else:
            aw.button_12.setVisible(False)
            aw.button_13.setVisible(False)
            aw.button_14.setVisible(False)
            aw.button_15.setVisible(False)
            aw.button_16.setVisible(False)
            aw.button_17.setVisible(False)
            self.svButtons = False

    def setPID(self,kp,ki,kd,source,cycle):
        self.pidKp = kp
        self.pidKi = ki
        self.pidKd = kd
        self.pidSource = source
        self.pidCycle = cycle
    
    def confPID(self,kp,ki,kd,source,cycle):
        if aw.ser.ArduinoIsInitialized:
            try:
                #### lock shared resources #####
                aw.ser.COMsemaphore.acquire(1)
                if aw.ser.SP.isOpen():
                    aw.ser.SP.flushInput()
                    aw.ser.SP.flushOutput()
                    aw.ser.SP.write(str2cmd("PID;T;" + str(kp) + ";" + str(ki) + ";" + str(kd) + "\n"))
                    libtime.sleep(.1)
                    aw.ser.SP.write(str2cmd("PID;CHAN;" + str(source) + "\n"))
                    libtime.sleep(.1)
                    aw.ser.SP.write(str2cmd("PID;CT;" + str(cycle) + "\n"))
                    libtime.sleep(.1)
            finally:
                if aw.ser.COMsemaphore.available() < 1:
                    aw.ser.COMsemaphore.release(1)


###################################################################################
##########################  DTA PID CLASS DEFINITION  ############################
###################################################################################
# documentation
# http://www.deltaww.hu/homersekletszabalyozok/DTA_series_temperature_controller_instruction_sheet_English.pdf
class DtaPID(object):
    def __init__(self):
        #refer to Delta instruction manual for more information
        #dictionary "KEY": [VALUE,ASCII_MEMORY_ADDRESS]  note: address contains hex alpha characters
        self.dtamem={
                  "pv": [0,"4700"],             # process value (temperature reading)
                  "sv": [100.0,"4701"],           # set point
                  "p": [5,"4708"],              # p value 0-9999
                  "i": [240,"4709"],            # i value 0-9999
                  "d": [60,"470A"],             # d value 0-9999
                  "sensortype": [0,"4710"],     # 0 = K type1; 1 = K type2; 2 = J type1; 3 = J type2
                                                # 4 = T type1; 5 = T type2; 6 = E ; 7 = N; 8 = R; 9 = S; 10 = B
                                                # 11 = JPT100 type1; 12 = JPT100 type2; 13 = PT100 type1; 14 = PT100 type2
                                                # 15 = PT100 type3; 16 = L ; 17 = U; 18 = Txk
                  "controlmethod":[0,"4711"],   # 0 = pid; 1 = ON/OFF; 2 = manual
                  "units":[1,"4717"],           # units C = 1; F = 2
                  "controlsetting":[1,"4719"],  # 1=Run; 0 = Stop  
                  "error":[0,"472B"]            # note: read only memory. Values:
                                                # 0 = Normal,1 = Initial process; 2 = Initial status;
                                                # 3 = sensor not connected; 4 = sensor input error
                                                # 5 = Exceeds max temperature; 6 = Number Internal error
                                                # 7 EEPROM error
                  }
    #command  string = ID (ADR)+ FUNCTION (CMD) + ADDRESS + NDATA + LRC_CHK 
    def writeDTE(self,value,DTAaddress):
        newsv = hex(int(abs(float(str(value)))))[2:].upper()
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],6,str(DTAaddress),newsv)
        aw.ser.sendDTAcommand(command)

    def message2send(self,unitID,FUNCTION,ADDRESS, NDATA):
        #compose command
        string_unitID = str(unitID).zfill(2)
        string_FUNCTION = str(FUNCTION).zfill(2)
        string_ADDRESS = ADDRESS                 #ADDRESS is a 4 char string
        string_NDATA = str(NDATA).zfill(4)
        cmd = string_unitID + string_FUNCTION + string_ADDRESS + string_NDATA
        checksum = hex(self.DTACalcChecksum(cmd))[2:].zfill(2).upper()
        command = ":" + cmd + checksum + "\r\n"
        return command

    def DTACalcChecksum(self,string):
        def tobin(x, count=8):
            return "".join([str((x>>y)&1) for y in range(count-1, -1, -1)])
        def twoscomp(num_str):
            return tobin(-int(num_str,2),len(num_str))
        length = len(string)
        # start at index 1 because of heading ':' cmd
        count = 0
        val = 0x00
        while count < length:
            val +=  int(string[count] + string[count+1], 16)  #string[count+1] goes out of range
            count += 2
        h_bs = bin(val)[2:]
    #    print "val:", val, h_bs
        h2comp = twoscomp(h_bs)
    #    print "2comp(val):", twoscomp(h_bs), hex(int(h2comp,2))
        rval = int(h2comp,2)
    #    print "val:", rval
        if (val & 0x80) == 0:
            rval = rval | 0x80
    #    print "comp:", rval
        return rval

###########################################################################################################################################
###########################################################################################################################################


def main():
    # suppress all warnings
    warnings.filterwarnings('ignore')
    
    global aw
    aw = None # this is to ensure that the variable aw is already defined during application initialization
    
    # font fix for OS X 10.9
    try:
        v, _, _ = platform.mac_ver()
        v = float('.'.join(v.split('.')[:2]))
        if v >= 10.10:
            # fix Mac OS X 10.10 (Yosemite) font issue
            # https://bugreports.qt-project.org/browse/QTBUG-40833
            QFont.insertSubstitution(".Helvetica Neue DeskInterface", "Helvetica Neue")  
        elif v >= 10.9:
            # fix Mac OS X 10.9 (Mavericks) font issue
            # https://bugreports.qt-project.org/browse/QTBUG-32789
            QFont.insertSubstitution(".Lucida Grande UI", "Lucida Grande")            
    except:
        pass

    aw = ApplicationWindow()

    if locale == "ar":
        QApplication.setLayoutDirection(Qt.RightToLeft)
    else:
        QApplication.setLayoutDirection(Qt.LeftToRight)

    try:
        aw.defaultAppearance = str(aw.style().objectName()).lower()
    except:
        pass
    aw.settingsLoad()
    aw.setFonts()

    try:
        if sys.argv and len(sys.argv) > 1:
            argv_file = sys.argv[1]
            qfile = QFileInfo(u(argv_file))
            file_suffix = u(qfile.suffix())
            if file_suffix == "alog":
                # load Artisan profile on double-click on *.alog file
                aw.loadFile(u(argv_file))
            elif file_suffix == "alrm":
                # load Artisan alarms on double-click on *.alrm file
                aw.loadAlarms(u(argv_file))
            elif file_suffix == "apal":
                # load Artisan palettes on double-click on *.apal file
                aw.loadPalettes(u(argv_file))
    except Exception:
        pass
        
    if platf == 'Windows' and aw.appFrozen():
        try:
            sys.stderr = sys.stdout
        except:
            pass

    aw.show()
    #the following line is to trap numpy warnings that occure in the Cup Profile dialog if all values are set to 0
    with numpy.errstate(invalid='ignore'):
        app.exec_()

##############################################################################################################################################
##############################################################################################################################################
