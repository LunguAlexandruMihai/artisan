#!/usr/bin/python
# -*- coding: utf-8 -*-

from artisanlib import __version__
from artisanlib import __revision__

# ABOUT
# This program shows how to plot the temperature and its rate of change from a
# Fuji PID or a thermocouple meter

# LICENSE
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 2 of the License, or
# version 3 of the License, or (at your option) any later versiSon. It is
# provided for educational purposes and is distributed in the hope that
# it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
# the GNU General Public License for more details.
#

#########################   POLICIES  ###########################################################################
# 1  STRINGS
#
# When possible, use QString and Unicode characters in user inputs. Use ASCII only for serial comm (raw data).
# There are two ways to create a unicode string: u"one way" and unicode("second way").
# There are two ways to create a QString: QString("one way") and the return of QTfunction()
# There are several ways to create ASCII strings: "one way", str("second way"), and return of python function().
# Inmideately convert ascii strings to Unicode at return of functions by using unicode().
# There is 7 bits Ascii, and then there is 8 bit Western Europe Ascii.
# WARNING: If an ascii str contains characters outside the 7 bit range, Python raises UnicodeEncodeError exception.
#################################################################################################################


import sys
import platform
import serial
import math
import binascii
import time as libtime
import glob
import os
import warnings
import string as libstring
import cgi
import codecs
import numpy
#import struct

# write logtrace to Console on OS X:
#try:
#..
#except Exception as e:
#    import syslog
#    syslog.openlog("artisan")
#    syslog.syslog(syslog.LOG_ALERT, str(e))
#    import traceback
#    syslog.syslog(syslog.LOG_ALERT, str(traceback.format_exc()))


import sip
sip.setapi('QString', 1)
sip.setapi('QVariant', 1)

from PyQt4.QtGui import (QLayout, QAction, QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog,
                         QInputDialog, QGroupBox, QDialog, QLineEdit, QFontDatabase,
                         QSizePolicy, QGridLayout, QVBoxLayout, QHBoxLayout, QPushButton, QDialogButtonBox,
                         QLCDNumber, QKeySequence, QSpinBox, QComboBox,
                         QSlider, QTabWidget, QStackedWidget, QTextEdit, QPrinter, QPrintDialog, QRadioButton,
                         QPixmap, QColor, QColorDialog, QPalette, QFrame, QCheckBox, QDesktopServices, QIcon,
                         QStatusBar, QRegExpValidator, QDoubleValidator, QIntValidator, QPainter, QFont, QBrush, QRadialGradient,
                         QStyleFactory, QTableWidget, QTableWidgetItem, QMenu, QCursor, QDoubleSpinBox, QTextDocument)
from PyQt4.QtCore import (QString, QStringList, QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, 
                          QT_VERSION_STR,SIGNAL, QTime, QTimer, QFile, QIODevice, QTextStream, QSettings, SLOT,
                          QRegExp, QDate, QUrl, QDir, QVariant, Qt, QPoint, QEvent, QDateTime, QThread, QSemaphore)


import matplotlib as mpl
from functools import reduce as freduce
mpl.use('qt4agg')

from matplotlib.figure import Figure
from matplotlib.colors import cnames as cnames
import matplotlib.patches as patches
import matplotlib.transforms as transforms
import matplotlib.font_manager as font_manager
import matplotlib.ticker as ticker

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar

try:
    import matplotlib.backends.qt4_editor.figureoptions as figureoptions
except ImportError:
    figureoptions = None

import minimalmodbus

import json

# to make py2exe happy with scipy >0.11
def dependencies_for_myprogram():
    from scipy.sparse.csgraph import _validation
    import PyQt4.QtSvg
    import PyQt4.QtXml

if sys.version < '3':
    def o(x): # converts char to byte
        return ord(x)
    def u(x): # convert to unicode string
        return unicode(x)
    def d(x):
        if x is not None:
            try:
                return codecs.unicode_escape_decode(x)[0]
            except Exception:
                return x
        else:
            return None
    def e(x):
        if x is not None:
            return codecs.unicode_escape_encode(unicode(x))[0]
        else:
            return None
    def hex2int(h1,h2=""):
        return int(binascii.hexlify(h1+h2),16)
    def str2cmd(s):
        return s
    def cmd2str(c):
        return c
else:
    def o(x): # converts char to byte
        return x
    def u(x): # convert to unicode string
        return str(x)
    def d(x):
        if x is not None:
            return codecs.unicode_escape_decode(x)[0]
        else:
            return None
    def e(x):
        if x is not None:
            return codecs.unicode_escape_encode(str(x))[0].decode("utf8")
        else:
            return None
    def hex2int(h1,h2=None):
        if h2:
            return int(h1*256 + h2)
        else:
            return int(h1)
    def str2cmd(s):
        return bytes(s,"ascii")
    def cmd2str(c):
        return str(c,"latin1")

platf = str(platform.system())

#######################################################################################
#################### minimal modbus monkey patch to support little-endian  ############
#################### little-endian in addition to big-endian for floats    ############
#######################################################################################

def littleEndianBytestringToFloat(bytestring, numberOfRegisters=2):
    """Convert a four-byte string to a float.

    """
    minimalmodbus._checkString(bytestring, minlength=4, maxlength=8, description='bytestring')
    minimalmodbus._checkInt(numberOfRegisters, minvalue=2, maxvalue=4, description='number of registers')

    numberOfBytes = minimalmodbus._NUMBER_OF_BYTES_PER_REGISTER * numberOfRegisters

    formatcode = '<'  # Little-endian
    if numberOfRegisters == 2:
        formatcode += 'f'  # Float (4 bytes)
    elif numberOfRegisters == 4:
        formatcode += 'd'  # Double (8 bytes)
    else:
        raise ValueError('Wrong number of registers! Given value is {0!r}'.format(numberOfRegisters))

    if len(bytestring) != numberOfBytes:
        raise ValueError('Wrong length of the byte string! Given value is {0!r}, and numberOfRegisters is {1!r}.'.\
            format(bytestring, numberOfRegisters))

    return minimalmodbus._unpack(formatcode, bytestring)
    
bigEndianBytestringToFloat = minimalmodbus._bytestringToFloat

#######################################################################################
#################### Main Application  ################################################
#######################################################################################

    
class Artisan(QApplication):
    def __init__(self, args):
        super(Artisan, self).__init__(args)

    def event(self, event):
        if event.type() == QEvent.FileOpen:
            try:
                filename = u(event.file())
                qfile = QFileInfo(filename)
                file_suffix = u(qfile.suffix())
                if file_suffix == "alog":
                    # load Artisan profile on double-click on *.alog file
                    if not aw.qmc.flagon: # only if not yet monitoring
                        aw.loadFile(filename)
                elif file_suffix == "alrm":
                    # load Artisan alarms on double-click on *.alrm file
                    if not aw.qmc.flagstart:
                        aw.loadAlarms(filename)
                elif file_suffix == "apal":
                    # load Artisan palettes on double-click on *.apal file
                    if not aw.qmc.flagstart:
                        aw.loadPalettes(filename)
            except Exception:
                pass
            return 1
        return super(Artisan, self).event(event)


app = Artisan(sys.argv)
app.setApplicationName("Artisan")                                       #needed by QSettings() to store windows geometry in operating system
app.setOrganizationName("YourQuest")                                    #needed by QSettings() to store windows geometry in operating system
app.setOrganizationDomain("p.code.google.com")                          #needed by QSettings() to store windows geometry in operating system 
if platf == 'Windows':
    app.setWindowIcon(QIcon("artisan.png"))

#Localization support
locale = QSettings().value('locale').toString()
if len(locale) == 0:
    locale = QLocale.system().name()
    QSettings().setValue('locale', locale)

qtTranslator = QTranslator()
#load Qt default translations from QLibrary
if qtTranslator.load("qt_" + locale, QLibraryInfo.location(QLibraryInfo.TranslationsPath)):
    app.installTranslator(qtTranslator)
#find Qt default translations in Mac binary
elif qtTranslator.load("qt_" + locale, QApplication.applicationDirPath() + "/../translations"):
    app.installTranslator(qtTranslator)
#load Artisan translations
appTranslator = QTranslator()
#find application translations in source folder
if appTranslator.load("artisan_" + locale, "translations"): 
    app.installTranslator(appTranslator)
#find application translations in Mac binary
elif appTranslator.load("artisan_" + locale, QApplication.applicationDirPath() + "/../translations"):
    app.installTranslator(appTranslator)

from const import UIconst

if platf == 'Windows':
    minimalmodbus.CLOSE_PORT_AFTER_EACH_CALL=True
else:
    minimalmodbus.CLOSE_PORT_AFTER_EACH_CALL=False

#######################################################################################
#################### GRAPH DRAWING WINDOW  ############################################
#######################################################################################


class tgraphcanvas(FigureCanvas):
    def __init__(self,parent):

        #default palette of colors
        self.palette = {"background":'white',"grid":'green',"ylabel":'black',"xlabel":'black',"title":'black',"rect1":'green',
                        "rect2":'orange',"rect3":'#996633',"rect4":'lightblue',"et":'red',"bt":'#00007f',"deltaet":'orange',
                        "deltabt":'blue',"markers":'black',"text":'black',"watermarks":'yellow',"Cline":'blue'}

        self.artisanflavordefaultlabels = [QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Clean Cup",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Head",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Sweetness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8)]

        # custom labels are stored in the application settings and can be edited by the user
        self.customflavorlabels = self.artisanflavordefaultlabels

        self.SCCAflavordefaultlabels = [QApplication.translate("Textbox", "Sour",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Critical\nStimulus",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Bitter",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Astringency",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Solubles\nConcentration",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Mouthfeel",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Other",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aromatic\nComplexity",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Roast\nColor",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aromatic\nPungency",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Sweet",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "pH",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]


        self.CQIflavordefaultlabels =  [QApplication.translate("Textbox", "Fragance",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8)]

        self.SweetMariasflavordefaultlabels = [QApplication.translate("Textbox", "Dry Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Uniformity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Complexity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Clean Cup",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Sweetness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Finish",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Brightness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Wet Aroma",None, QApplication.UnicodeUTF8)]

        self.Cflavordefaultlabels = [QApplication.translate("Textbox", "Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Taste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Nose",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8)]

        self.Eflavordefaultlabels = [QApplication.translate("Textbox", "Fragrance-Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Flavor",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]


        self.coffeegeekflavordefaultlabels = [QApplication.translate("Textbox", "Aroma",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Mouthfeel",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Flavour",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aftertaste",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]


        self.Intelligentsiaflavordefaultlabels = [QApplication.translate("Textbox", "Sweetness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Finish",None, QApplication.UnicodeUTF8)]

        self.IstitutoInternazionaleAssaggiatoriCaffe = [QApplication.translate("Textbox", "Roast Color",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Crema Texture",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Crema Volume",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Fragrance",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Body",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Acidity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Bitterness",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Defects",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma Intensity",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Aroma Persistence",None, QApplication.UnicodeUTF8),
                                            QApplication.translate("Textbox", "Balance",None, QApplication.UnicodeUTF8)]

        self.ax1 = self.ax2 = None

        self.flavorlabels = list(self.artisanflavordefaultlabels)
        #Initial flavor parameters. 
        self.flavors = [5., 5., 5., 5., 5., 5., 5., 5., 5.]
        self.flavorstartangle = 90
        self.flavoraspect = 1.0  #aspect ratio

        #F = Fahrenheit; C = Celsius
        self.mode = "F"
        self.errorlog = []

        # default delay between readings in miliseconds
        self.delay = 3000

        #watermarks limits: dryphase1, dryphase2, midphase, and finish phase Y limits
        self.phases_fahrenheit_defaults = [200,300,390,450]
        self.phases_celsius_defaults = [95,150,200,230]
        self.phases = list(self.phases_fahrenheit_defaults)
        #this flag makes the main push buttons DryEnd, and FCstart change the phases[1] and phases[2] respectively
        self.phasesbuttonflag = False #False no change; True make the DRY and FC buttons change the phases during roast automatically
        self.watermarksflag = True

        #statistics flags selects to display: stat. time, stat. bar, stat. flavors, stat. area, stat. deg/min, stat. ETBTarea
        self.statisticsflags = [1,1,0,1,1,0]
        #conditions to estimate bad flavor:dry[min,max],mid[min,max],finish[min,max] in seconds
        self.statisticsconditions = [180,360,180,600,180,360,180,300]
        #records length in seconds of total time [0], dry phase [1],mid phase[2],finish phase[3], cool phase[4]
        self.statisticstimes = [0,0,0,0,0]

        #DEVICES
        self.device = 18                                    # default device selected to None (18). Calls appropiate function

        #menu of thermocouple devices
        #device with first letter + only shows in extra device tab
        #device with first letter - does not show in any tab (but its position in the list is important)
        # device labels (used in Dialog config).

        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
        # - add to self.devices
        self.devices = [#Fuji PID               #0
                       "Omega HH806AU",         #1
                       "Omega HH506RA",         #2
                       "CENTER 309",            #3
                       "CENTER 306",            #4
                       "CENTER 305",            #5
                       "CENTER 304",            #6
                       "CENTER 303",            #7
                       "CENTER 302",            #8
                       "CENTER 301",            #9
                       "CENTER 300",            #10
                       "VOLTCRAFT K204",        #11
                       "VOLTCRAFT K202",        #12
                       "VOLTCRAFT 300K",        #13
                       "VOLTCRAFT 302KJ",       #14
                       "EXTECH 421509",         #15
                       "Omega HH802U",          #16
                       "Omega HH309",           #17
                       "NONE",                  #18
                       "-ARDUINOTC4",           #19
                       "TE VA18B",              #20
                       "+309_34",               #21
                       "+FUJI DUTY %",          #22
                       "Omega HHM28[6]",        #23
                       "+204_34",               #24
                       "+Virtual",              #25
                       "-DTAtemperature",       #26
                       "Program",               #27
                       "+ArduinoTC4_34",        #28
                       "MODBUS",                #29
                       "VOLTCRAFT K201",        #30
                       "Amprobe TMD-56",        #31
                       "+ArduinoTC4_56",        #32
                       "+MODBUS_34",            #33
                       "-Omega HH806W"          #34 NOT WORKING 
                       ]

        #extra devices
        self.extradevices = []                                      # list with indexes for extra devices
        self.extratimex = []                                        # individual time for each extra device (more accurate). List of lists (2 dimension)
        self.extradevicecolor1 = []                                 # extra line 1 color. list with colors. 
        self.extradevicecolor2 = []                                 # extra line 2 color. list with colors.
        self.extratemp1,self.extratemp2 = [],[]                     # extra temp1, temp2. List of lists
        self.extrastemp1,self.extrastemp2 = [],[]                   # smoothed extra temp1, temp2. List of lists
        self.extratemp1lines,self.extratemp2lines = [],[]           # lists with extra lines for speed drawing
        self.extraname1,self.extraname2 = [],[]                     # name of labels for line (like ET or BT) - legend
        self.extramathexpression1,self.extramathexpression2 = [],[]           # list with user defined math evaluating strings. Example "2*cos(x)"
        self.extralinestyles1,self.extralinestyles2 = [],[]         # list of extra curve line styles
        self.extradrawstyles1,self.extradrawstyles2 = [],[]         # list of extra curve drawing styles
        self.extralinewidths1,self.extralinewidths2 = [],[]         # list of extra curve linewidth
        self.extramarkers1,self.extramarkers2 = [],[]               # list of extra curve marker styles
        self.extramarkersizes1,self.extramarkersizes2 = [],[]       # list of extra curve marker size

        #holds math expressions to plot
        self.plotcurves=["", "", "", "", "", ""]
        self.plotcurvecolor = ["black","black","black","black","black","black"]
 
        self.fig = Figure(tight_layout=True,frameon=True)
        # with tight_layout=True, the matplotlib canvas expands to the maximum using figure.autolayout

        #figure back color
        if platf == 'Darwin':
            self.backcolor ="#EEEEEE"
        else:
            self.backcolor = "white"
        self.fig.patch.set_facecolor(self.backcolor)
        self.fig.patch.set_edgecolor(self.backcolor)

        self.ax = self.fig.add_subplot(111, axisbg= self.palette["background"])
        self.delta_ax = self.ax.twinx()

        #legend location
        self.legendloc = 2
        self.fig.subplots_adjust(
            # all values in percent
            top=0.93, # the top of the subplots of the figure (default: 0.9)
            bottom=0.1, # the bottom of the subplots of the figure (default: 0.1)
            left=0.067, # the left side of the subplots of the figure (default: 0.125)
            right=.925) # the right side of the subplots of the figure (default: 0.9
        FigureCanvas.__init__(self, self.fig)

        self.fig.canvas.mpl_connect('button_press_event', self.onclick)

        # set the parent widget
        self.setParent(parent)
        # we define the widget as
        FigureCanvas.setSizePolicy(self,QSizePolicy.Expanding,QSizePolicy.Expanding)
        # notify the system of updated policy
        FigureCanvas.updateGeometry(self)

        # the rate of chage of temperature
        self.rateofchange1 = 0.0
        self.rateofchange2 = 0.0

        #read and plot on/off flag
        self.flagon = False  # Artisan turned on
        self.flagstart = False # Artisan logging
        self.flagstopping = False # Artisan got the signal to turn off logging,
#                                 # switched on by OffMonitor and cleared by sampling thread once sampling stopped
        #log flag that tells to log ET when using device 18 (manual mode)
        self.manuallogETflag = 0

        self.roastpropertiesflag = 1  #resets roast properties if not zero
        self.title = QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8)
        self.ambientTemp = 0.
        self.ambientTempSource = 0 # indicates the temperature curve that is used to automatically fill the ambient temperature on DROP
#                                  # 0 : None; 1 : ET, 2 : BT, 3 : 0xT1, 4 : 0xT2, ....
        self.ambient_humidity = 0.
        #relative humidity percentage [0], corresponding temperature [1], temperature unit [2]
        self.bag_humidity = [0.,0.]
        self.beansize = 0.0
        
        self.whole_color = 0
        self.ground_color = 0
        self.color_systems = ["","Moppette","Colorette","ColorTrack","Agtron"]
        self.color_system_idx = 0
        
        # roast property flags
        self.heavyFC_flag = False
        self.lowFC_flag = False
        self.lightCut_flag = False
        self.darkCut_flag = False
        self.drops_flag = False
        self.oily_flag = False        
        self.uneven_flag = False
        self.tipping_flag = False
        self.scorching_flag = False
        self.divots_flag = False

        #list to store the time of each reading. Most IMPORTANT variable.
        self.timex = []

        #lists to store temps and rates of change. Second most IMPORTANT variables. All need same dimension.
        #self.temp1 = ET ; self.temp2 = BT; self.delta1 = deltaMET; self.delta2 = deltaBT
        self.temp1,self.temp2,self.delta1, self.delta2 = [],[],[],[]
        self.stemp1,self.stemp2 = [],[] # smoothed versions of temp1/temp2 usind in redraw()
        self.unfiltereddelta1, self.unfiltereddelta2 = [],[] # used in sample()

        #indexes for START[0],DRYe[1],FCs[2],FCe[3],SCs[4],SCe[5],DROP[6] and COOLe[7]
        #Example: Use as self.timex[self.timeindex[1]] to get the time of DryEnd
        #Example: Use self.temp2[self.timeindex[4]] to get the BT temperature of SCs

        self.timeindex = [-1,0,0,0,0,0,0,0] #CHARGE index init set to -1 as 0 could be an actal index used

        #applies a Y(x) function to ET or BT 
        self.ETfunction,self.BTfunction = "","" 

        #put a "self.safesaveflag = True" whenever there is a change of a profile like at [DROP], edit properties Dialog, etc
        #prevents accidentally deleting a modified profile. 
        self.safesaveflag = False

        #background profile
        self.background = False
        self.backgroundDetails = False
        self.backgroundeventsflag = False
        self.backgroundpath = ""
        self.temp1B,self.temp2B,self.timeB = [],[],[]
        self.delta1B,self.delta2B = [],[]
        self.timeindexB = [-1,0,0,0,0,0,0,0]
        self.backgroundEvents = [] #indexes of background events
        self.backgroundEtypes = []
        self.backgroundEvalues = []
        self.backgroundEStrings = []
        self.backgroundalpha = 0.3
        self.backgroundmetcolor = self.palette["et"]
        self.backgroundbtcolor = self.palette["bt"]
        self.backgrounddeltaetcolor = self.palette["deltaet"]
        self.backgrounddeltabtcolor = self.palette["deltabt"]
        self.backmoveflag = 1
        self.detectBackgroundEventTime = 20 #seconds
        self.backgroundReproduce = False
        self.Betypes = [QApplication.translate("Scope Annotation", "Speed",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Scope Annotation", "Heater",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Scope Annotation", "Damper",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Scope Annotation", "Fan",None, QApplication.UnicodeUTF8),
                        "--"]
        self.backgroundFlavors = []
        self.flavorbackgroundflag = False
        #background by value
        self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
        self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
        self.l_backgroundeventtype1dots, = self.ax.plot(self.E1backgroundtimex, self.E1backgroundvalues, color="grey")
        self.l_backgroundeventtype2dots, = self.ax.plot(self.E2backgroundtimex, self.E2backgroundvalues, color="darkgrey")
        self.l_backgroundeventtype3dots, = self.ax.plot(self.E3backgroundtimex, self.E3backgroundvalues, color="slategrey")
        self.l_backgroundeventtype4dots, = self.ax.plot(self.E4backgroundtimex, self.E4backgroundvalues, color="slateblue")
        # background Deltas
        self.DeltaETBflag = False
        self.DeltaBTBflag = False

        # projection variables of change of rate
        self.HUDflag = False
        self.hudresizeflag = False
        self.ETtarget = 300
        self.ET2target = 350
        self.BTtarget = 200
        self.BT2target = 250
        self.hudETpid = [5,240,60]    # HUD pid: p = 20, i = 60, d = 13
        self.pidpreviouserror = 0  # temporary storage of pid error

        #General notes. Accessible through "edit graph properties" of graph menu. WYSIWYG viewer/editor.
        self.roastertype = ""
        self.operator = ""
        self.roastingnotes = ""
        self.cuppingnotes = ""
        self.roastdate = QDate.currentDate()
        self.beans = ""

        #flags to show projections, draw Delta ET, and draw Delta BT
        self.projectFlag = False
        self.ETcurve = True
        self.BTcurve = True
        self.ETlcd = True
        self.BTlcd = True
        self.DeltaETflag = False
        self.DeltaBTflag = False
        self.DeltaETlcdflag = True
        self.DeltaBTlcdflag = True
        self.deltafilter = 9
        self.curvefilter = 7

        #variables to configure the 8 default buttons
        # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END
        self.buttonvisibility = [True]*8
        self.buttonactions = [0]*8
        self.buttonactionstrings = [""]*8

        #flag to activate the automatic marking of the CHARGE and DROP events
        self.autoChargeDropFlag = False
        #autodetected CHARGE and DROP index
        self.autoChargeIdx = 0
        self.autoDropIdx = 0

        # projection variables of change of rate
        self.projectionconstant = 1
        self.projectionmode = 0     # 0 = linear; 1 = newton

        #[0]weight in, [1]weight out, [2]units (string)
        self.weight = [0,0,"g"]
        #[0]volume in, [1]volume out, [2]units (string)
        self.volume = [0,0,"l"]
        #[0]probe weight, [1]weight unit, [2]probe volume, [3]volume unit
        self.density = [0,"g",0,"l"]

        #stores _indexes_ of self.timex to record events. Use as self.timex[self.specialevents[x]] to get the time of an event
        # use self.temp2[self.specialevents[x]] to get the BT temperature of an event.
        self.specialevents = []
        #ComboBox text event types. They can be modified in eventsDlg()
        self.etypes = [QApplication.translate("ComboBox", "Speed",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Power",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Damper",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Fan",None, QApplication.UnicodeUTF8),
                       "--"]
        #default etype settings to restore 
        self.etypesdefault = [QApplication.translate("ComboBox", "Speed",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox", "Power",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox", "Damper",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox", "Fan",None, QApplication.UnicodeUTF8),
                              "--"]
        #stores the type of each event as index of self.etypes. None = 0, Power = 1, etc.
        self.specialeventstype = []
        #stores text string descriptions for each event.
        self.specialeventsStrings = []
        #event values are from 0-10
        #stores the value for each event
        self.specialeventsvalue = []
        #flag that makes the events location type bars (horizontal bars) appear on the plot. flag read on redraw()
        # 0 = no event bars; 1 = type bars (4 bars); 2 = value bars (10 bars)
        self.eventsGraphflag = 0
        #flag that shows events in the graph
        self.eventsshowflag = 0
        #plot events by value
        self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
        self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
        self.EvalueColor = ["brown","blue","purple","grey"]
        self.EvalueMarker = ["o","s","h","D"]
        self.EvalueMarkerSize = [8,8,8,8]
        self.Evaluelinethickness = [2,2,2,2]
        self.Evaluealpha = [.8,.8,.8,.8]
        #the event value position bars are calculated at redraw()
        self.eventpositionbars = [0.]*12

        #curve styles
        self.linestyle_default = "-"
        self.drawstyle_default = "default"
        self.linewidth_default = 2
        self.marker_default = None
        self.markersize_default = 6

        self.BTlinestyle = self.linestyle_default
        self.BTdrawstyle = self.drawstyle_default
        self.BTlinewidth = self.linewidth_default
        self.BTmarker = self.marker_default
        self.BTmarkersize = self.markersize_default
        self.ETlinestyle = self.linestyle_default
        self.ETdrawstyle = self.drawstyle_default
        self.ETlinewidth = self.linewidth_default
        self.ETmarker = self.marker_default
        self.ETmarkersize = self.markersize_default
        self.BTdeltalinestyle = self.linestyle_default
        self.BTdeltadrawstyle = self.drawstyle_default
        self.BTdeltalinewidth = self.linewidth_default
        self.BTdeltamarker = self.marker_default
        self.BTdeltamarkersize = self.markersize_default
        self.ETdeltalinestyle = self.linestyle_default
        self.ETdeltadrawstyle = self.drawstyle_default
        self.ETdeltalinewidth = self.linewidth_default
        self.ETdeltamarker = self.marker_default
        self.ETdeltamarkersize = self.markersize_default
        self.BTbacklinestyle = self.linestyle_default
        self.BTbackdrawstyle = self.drawstyle_default
        self.BTbacklinewidth = self.linewidth_default
        self.BTbackmarker = self.marker_default
        self.BTbackmarkersize = self.markersize_default
        self.ETbacklinestyle = self.linestyle_default
        self.ETbackdrawstyle = self.drawstyle_default
        self.ETbacklinewidth = self.linewidth_default
        self.ETbackmarker = self.marker_default
        self.ETbackmarkersize = self.markersize_default        
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default        
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default

        #Temperature Alarms lists. Data is writen in  alarmDlg 
        self.alarmflag = []    # 0 = OFF; 1 = ON flags
        self.alarmguard = []   # points to another alarm by index that has to be triggered before; -1 indicates no guard
        self.alarmtime = []    # times after which each alarm becomes efective. Usage: self.timeindex[self.alarmtime[i]]
#                              # -1 equals None
        self.alarmoffset = []  # the for timed alarms, the seconds after alarmtime the alarm is triggered
        self.alarmtime2menuidx = [1,3,4,5,6,7,8,9,2,0] # maps menu idx to self.alarmtime index (to move TP in menu from index 9 to 2)
        self.menuidx2alarmtime = [-1,0,8,1,2,3,4,5,6,7] # inverse of above (note that those two are only inverse in one direction!)
        self.alarmcond = []    # 0 = falls below; 1 = rises above
        # alarmstate is set to 'not triggered' on reset()
        self.alarmstate = []   # 1=triggered, 0=not triggered. Needed so that the user does not have to turn the alarms ON next roast after alarm being used once.
        self.alarmsource = []   # -3=None, -2=DeltaET, -1=DeltaBT, 0=ET , 1=BT, 2=extratemp1[0], 3=extratemp2[0], 4=extratemp2[1],....
        self.alarmtemperature = []  # set temperature number (example 500)
        self.alarmaction = []       # -1 = no action; 0 = open a window; 1 = call program with a filepath equal to alarmstring; 2 = activate button with number given in description; 
                                    # 3,4,5,6 = move slider with value given in description
        self.alarmstrings = []      # text descriptions, action to take, or filepath to call another program
        self.temporaryalarmflag = -3 #holds temporary index value of triggered alarm in updategraphics()
        self.TPalarmtimeindex = None # is set to the current  aw.qmc.timeindex by sample(), if alarms are defined and once the TP is detected

        # set initial limits for X and Y axes. But they change after reading the previous seetings at aw.settingsload()
        self.ylimit = 600
        self.ylimit_min = 0
        self.zlimit = 100
        self.zlimit_min = 0
        self.endofx = 60
        self.startofx = 0
        self.resetmaxtime = 60  #time when pressing reset
        self.fixmaxtime = False # if true, do not automatically extend the endofx by 3min if needed because the measurements get out of the x-axis
        self.xgrid = 60   #initial time separation; 60 = 1 minute
        self.ygrid = 100  #initial temperature separation
        self.zgrid = 10   #initial RoR separation
        self.gridstyles =    ["-","--","-.",":"," "]  #solid,dashed,dash-dot,dotted,None
        self.gridlinestyle = 0
        self.gridthickness = 1
        self.gridalpha = .3
        self.xrotation = 0
        
        #height of statistics bar
        self.statisticsheight = 650
        self.statisticsupper = 655
        self.statisticslower = 617

        # autosave
        self.autosaveflag = 0
        self.autosaveprefix = QApplication.translate("Directory", "edit text",None, QApplication.UnicodeUTF8)
        self.autosavepath = ""

        #used to place correct height of text to avoid placing text over text (annotations)
        self.ystep_down = 0
        self.ystep_up = 0

        self.ax.set_xlim(self.startofx, self.endofx)
        self.ax.set_ylim(self.ylimit_min,self.ylimit)

        self.delta_ax.set_xlim(self.startofx, self.endofx)
        self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
        self.delta_ax.set_autoscale_on(False)

        # disable figure autoscale
        self.ax.set_autoscale_on(False)

        #set grid + axle labels + title
        self.ax.grid(True,color=self.palette["grid"],linestyle = self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha)

        self.ax.set_xlabel('Time',size=16,color = self.palette["xlabel"])
        self.ax.set_ylabel(self.mode,size=16,color = self.palette["ylabel"])
        self.delta_ax.set_ylabel(u(QApplication.translate("Label", "deg/min", None, QApplication.UnicodeUTF8)),size=16,color = self.palette["ylabel"])
        self.ax.set_title(self.title,size=20,color=self.palette["title"])


        #change label colors
        for label in self.ax.yaxis.get_ticklabels():
            label.set_color(self.palette["ylabel"])

        for label in self.ax.xaxis.get_ticklabels():
            label.set_color(self.palette["xlabel"])


        # generates first "empty" plot (lists are empty) of temperature and deltaT
        self.l_temp1, = self.ax.plot(self.timex,self.temp1,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=u(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
        self.l_temp2, = self.ax.plot(self.timex,self.temp2,markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTlinestyle,color=self.palette["bt"],label=u(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))
        self.l_delta1, = self.ax.plot(self.timex,self.delta1,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],label=u(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))
        self.l_delta2, = self.ax.plot(self.timex,self.delta2,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],label=u(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))
        self.l_back1 = None
        self.l_back2 = None
        self.l_delta1B = None
        self.l_delta2B = None

        self.l_eventtype1dots, = self.ax.plot(self.E1timex, self.E1values, color=self.EvalueColor[0], marker=self.EvalueMarker[0])
        self.l_eventtype2dots, = self.ax.plot(self.E2timex, self.E2values, color=self.EvalueColor[1], marker=self.EvalueMarker[1])
        self.l_eventtype3dots, = self.ax.plot(self.E3timex, self.E3values, color=self.EvalueColor[2], marker=self.EvalueMarker[2])
        self.l_eventtype4dots, = self.ax.plot(self.E4timex, self.E4values, color=self.EvalueColor[3], marker=self.EvalueMarker[3])

        ###########################  TIME  CLOCK     ##########################
        # create an object time to measure and record time (in miliseconds)

        self.timeclock = QTime()
        self.timeclock.setHMS(0,0,0,0)

        ############################  Thread Server #################################################
        #server that spawns a thread dynamically to sample temperature (press button ON to make a thread press OFF button to kill it)
        self.threadserver = Athreadserver()

        ##########################     Designer variables       #################################
        self.designerflag = False
        self.designerconnections = [0,0,0,0]   #mouse event ids
        self.mousepress = None
        self.indexpoint = 0
        self.workingline = 2  #selects ET or BT
        self.eventtimecopy = []
        self.specialeventsStringscopy = []
        self.specialeventsvaluecopy = []
        self.specialeventstypecopy = []
        self.currentx = 0               #used to add point when right click
        self.currenty = 0               #used to add point when right click
        self.designertimeinit = [50,300,540,560,660,700,800,900]
        if self.mode == "C":
#                                     #CH, DE, Fcs,Fce,Scs,Sce,Drop
            self.designertemp1init = [290,290,290,290,290,290,290,290]
            self.designertemp2init = [200,150,200,210,220,225,240,240]   #CHARGE,DRY END,FCs, FCe,SCs,SCe,DROP,COOL
        elif self.mode == "F":
            self.designertemp1init = [500,500,500,500,500,500,500,500]
            self.designertemp2init = [380,300,390,395,410,412,420,420]
        self.BTsplinedegree = 3
        self.ETsplinedegree = 1
        self.reproducedesigner = 0      #flag to add events to help reproduce (replay) the profile: 0 = none; 1 = sv; 2 = ramp

        ###########################         filterDropOut variables     ################################

        # constants

        self.filterDropOut_replaceRoR_period = 3
        self.filterDropOut_spikeRoR_period = 3
        
        # defaults
        
        self.filterDropOut_tmin_C_default = 10
        self.filterDropOut_tmax_C_default = 300
        self.filterDropOut_tmin_F_default = 50
        self.filterDropOut_tmax_F_default = 572
        self.filterDropOut_spikeRoR_dRoR_limit_C_default = 4.2
        self.filterDropOut_spikeRoR_dRoR_limit_F_default = 7
        
        # variables
        
        self.filterDropOuts = True
        self.filterDropOut_tmin = self.filterDropOut_tmin_F_default
        self.filterDropOut_tmax = self.filterDropOut_tmax_F_default
        self.filterDropOut_spikeRoR_dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit_F_default # the limit of additional RoR in temp/sec compared to previous readings
        self.minmaxLimits = True
        self.dropSpikes = False

        ###########################         wheel graph variables     ################################
        self.wheelflag = False
        #data containers for wheel
        self.wheelnames,self.segmentlengths,self.segmentsalpha,self.wheellabelparent,self.wheelcolor = [],[],[],[],[]

        #crerate starting wheel
        wheels = [4,6,12,50]
        for i in range(len(wheels)):
            w,a,c,co = [],[],[],[]
            for x in range(wheels[i]):
                w.append("W%i %i"%(i+1,x+1))
                a.append(0.3)
                c.append(0)
                color = QColor()
                color.setHsv((360/wheels[i])*x,255,255,255)
                co.append(str(color.name()))

            self.wheelnames.append(w)
            self.segmentsalpha.append(a)
            self.segmentlengths.append([100./len(self.wheelnames[i])]*len(self.wheelnames[i]))
            self.wheellabelparent.append(c)
            self.wheelcolor.append(co)

        #properties
        #store radius of each circle as percentage(sum of all must at all times add up to 100.0%)
        self.wradii = [25.,20.,20.,35.]
        #starting angle for each circle (0-360). 
        self.startangle = [0,0,0,0]
        #text projection: 0 = Flat, 1 = perpendicular to center, 2 = radial from center
        self.projection = [0,1,1,2]
        self.wheeltextsize = [10,10,10,10]
        self.wheelcolorpattern = 0                  #pattern
        self.wheeledge = .02                        #overlaping decorative edge
        self.wheellinewidth = 1
        self.wheellinecolor = "black"               #initial color of lines
        self.wheelconnections = [0,0,0]
        self.wheelx,self.wheelz = 0,0                   #temp variables to pass index values
        self.wheellocationx,self.wheellocationz = 0.,0.  #temp vars to pass mouse location (angleX+radiusZ)
        self.wheelaspect = 1.0

        self.samplingsemaphore = QSemaphore(1)

        #flag to plot cross lines from mouse
        self.crossmarker = False
        self.crossmouseid = 0

        #########  temporary serial variables
        #temporary storage to pass values. Holds extra T3 and T4 values for center 309
        self.extra309T3 = -1
        self.extra309T4 = -1
        self.extra309TX = 0.
        
        #temporary storage to pass values. Holds extra T3 and T4 values for MODBUS connected devices
        self.extraMODBUSt3 = -1
        self.extraMODBUSt4 = -1
        self.extraMODBUStx = 0.

        #used by extra device +ArduinoTC4_XX to pass values
        self.extraArduinoT1 = 0.
        self.extraArduinoT2 = 0.
        self.extraArduinoT3 = 0.
        self.extraArduinoT4 = 0.
        self.arduino56active = False

        #temporary storage to pass values. Holds the power % ducty cycle of Fuji PIDs  and ET-BT
        self.dutycycle = 0.
        self.dutycycleTX = 0.
        self.fujiETBT = 0.
        self.currentpidsv = 0.
        
        self.linecount = None # linecount cache for resetlines(); has to be reseted if visibility of ET/BT or extra lines or background ET/BT changes
        self.deltalinecount = None # deltalinecoutn cache for resetdeltalines(); has to be reseted if visibility of deltaET/deltaBT or background deltaET/deltaBT

    #NOTE: empty Figure is initialy drawn at the end of aw.settingsload()
    #################################    FUNCTIONS    ###################################
    #####################################################################################

    def getetypes(self):
        if len(self.etypes) == 4:
            self.etypes.append("--")
        return self.etypes
        
    def etypesf(self, i):
        if len(self.etypes) == 4:
            self.etypes.append("--")
        return self.etypes[i]
            
    def Betypesf(self, i):
        if len(self.Betypes) == 4:
            self.Betypes.append("--")
        return self.Betypes[i]

    def ambientTempSourceAvg(self):
        res = None
        if self.ambientTempSource:
            if self.ambientTempSource == 1: # from ET
                res = numpy.mean(aw.qmc.temp1)
            elif self.ambientTempSource == 2: # from BT
                res = numpy.mean(aw.qmc.temp2)
            elif self.ambientTempSource > 2 and ((self.ambientTempSource - 3) < (2*len(aw.qmc.extradevices))): 
                # from an extra device
                if (self.ambientTempSource)%2==0:
                    res = numpy.mean(aw.qmc.extratemp2[(self.ambientTempSource - 3)//2])
                else:
                    res = numpy.mean(aw.qmc.extratemp1[(self.ambientTempSource - 3)//2])
        if res:
            res = aw.float2float(res)
        return res

    def updateAmbientTemp(self):
        res = aw.qmc.ambientTempSourceAvg()
        if res:
            aw.qmc.ambientTemp = res

    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0.0-10.0]
    # negative values are mapped to -1
    def eventsInternal2ExternalValue(self,v):
        if v == None:
            return -1
        else:
            if v < 1:
                return -1
        return int(v*10) - 10
        
    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0-10]
    # negative values are mapped to ""
    # 0.1 to "1"
    # ..
    # 1.0 to "10"
    # .. 
    # 10.0 to "100"
    def eventsvalues(self,v):
        value = self.eventsInternal2ExternalValue(v)
        if value < 0:
            return ""
        else:
            return u(value)

    # 100.0 to "10" and 10.1 to "1"
    def eventsvaluesShort(self,v):
        value = self.eventsInternal2ExternalValue(v)
        if value < 0:
            return ""
        else:
            return u(int(round(value / 10)))

    # the inverse to eventsvalues above (string -> value)
    def str2eventsvalue(self,s):
        st = s.strip()
        if st == None or len(st) == 0:
            return -1
        else:
            return aw.float2float(float(st)/10 + 1.0)

    def onclick(self,event):
        if event.button==3 and event.inaxes and not self.designerflag and not self.wheelflag and not self.flagon:
            timex = self.time2index(event.xdata)
            if timex > 0:
                if (len(self.temp2) > timex and self.temp2[timex] < event.ydata + 20) and (self.temp2[timex] > event.ydata - 20):
                    menu = QMenu(self) 
                    # populate menu
                    ac = QAction(menu)
                    ac.setText(u(QApplication.translate("Label", "at")) + u(" ") + self.stringfromseconds(event.xdata - + self.timex[self.timeindex[0]]))
                    ac.setEnabled(False)
                    menu.addAction(ac)
                    for k in [(u(QApplication.translate("Label","CHARGE")),0),
                              (u(QApplication.translate("Label","DRY END")),1),
                              (u(QApplication.translate("Label","FC START")),2),
                              (u(QApplication.translate("Label","FC END")),3),
                              (u(QApplication.translate("Label","SC START")),4),
                              (u(QApplication.translate("Label","SC END")),5),
                              (u(QApplication.translate("Label","DROP")),6)]:
                        idx_before = idx_after = 0
                        for i in range(k[1]):
                            if self.timeindex[i]:
                                idx_before = self.timeindex[i]
                        for i in range(6,k[1],-1) :
                            if self.timeindex[i]:
                                idx_after = self.timeindex[i]
                        if ((not idx_before) or timex > idx_before) and ((not idx_after) or timex < idx_after):
                            ac = QAction(menu)
                            ac.key = (k[1],timex)
                            ac.setText(" " + k[0])
                            menu.addAction(ac)
                    # add user EVENT entry
                    ac = QAction(menu)
                    ac.setText(u(" ") + u(QApplication.translate("Label", "EVENT")))
                    ac.key = (-1,timex)
                    menu.addAction(ac)
                    # show menu
                    menu.triggered.connect(self.event_popup_action)
                    menu.popup(QCursor.pos())

    def event_popup_action(self,action):
        if action.key[0] >= 0:
            self.timeindex[action.key[0]] = action.key[1]
        else:
            # add a special event at the current timepoint
            self.specialevents.append(action.key[1]) # absolut time index
            self.specialeventstype.append(4) # "--"
            self.specialeventsStrings.append("")
            self.specialeventsvalue.append(0)
        aw.qmc.safesaveflag = True
        self.redraw()

    # runs from GUI thread.
    # this function is called by a signal at the end of the thread sample()
    # during sample, updates to GUI widgets or anything GUI must be done here (never from thread)
    def updategraphics(self):
        try:
            if self.flagon:
                if len(self.timex):        
                    aw.lcd2.display("%.1f"%float(self.temp1[-1]))            # ET
                    aw.lcd3.display("%.1f"%float(self.temp2[-1]))            # BT
                    aw.lcd4.display("%.1f"%float(self.rateofchange1))        # rate of change MET (degress per minute)
                    aw.lcd5.display("%.1f"%float(self.rateofchange2))        # rate of change BT (degrees per minute)
                    
                    if self.device == 0 or self.device == 26:         #extra LCDs for Fuji or DTA pid  
                        aw.lcd6.display(self.currentpidsv)
                        aw.lcd7.display(self.dutycycle)

                    ndev = len(self.extradevices)
                    for i in range(ndev):
                        if i < aw.nLCDS:
                            if self.extratemp1[i]:
                                aw.extraLCD1[i].display("%.1f"%float(self.extratemp1[i][-1]))
                            if self.extratemp2[i]:
                                aw.extraLCD2[i].display("%.1f"%float(self.extratemp2[i][-1]))

                if self.flagstart:
                    #updated canvas
                    self.fig.canvas.draw()

                    #check if HUD is ON (done after self.fig.canvas.draw())
                    if self.HUDflag:
                        aw.showHUD[aw.HUDfunction]()

                    #auto mark CHARGE/DROP
                    if self.autoChargeIdx:
                        self.markCharge()
                        self.autoChargeIdx = 0 #otherwise it keep calling CHARGE
                    elif self.autoDropIdx:
                        self.markDrop()
                        self.autoDropIdx = 0

                    #check triggered alarms
                    if self.temporaryalarmflag > -3:
                        i = self.temporaryalarmflag  # reset self.temporaryalarmflag before calling alarm
                        self.temporaryalarmflag = -3 # self.setalarm(i) can take longer to run than the sampling interval 
                        self.setalarm(i)

        except Exception as e:
            self.flagon = False
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " updategraphics() %1").arg(str(e)),exc_tb.tb_lineno)

    def updateLCDtime(self):
        if self.flagon and self.flagstart:
            tx = self.timeclock.elapsed()/1000.
            if self.timeindex[0] != -1:
                ts = tx - self.timex[self.timeindex[0]]
            else:
                ts = tx
            nextreading = 1000. - 1000.*(tx%1.)

            # if more than max cool (from statistics) past DROP and not yet COOLend turn the time LCD red:
            if aw.qmc.timeindex[0]!=-1 and aw.qmc.timeindex[6] and not aw.qmc.timeindex[7] and (tx - aw.qmc.timex[aw.qmc.timeindex[6]]) > aw.qmc.statisticsconditions[7]:
                aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%("red",aw.lcdpaletteB["timer"]))

            aw.lcd1.display(QString(self.stringfromseconds(int(ts))))
            QTimer.singleShot(nextreading,self.updateLCDtime)

    def toggleHUD(self):
        aw.soundpop()
        #OFF
        if self.HUDflag:
            if aw.qmc.projectFlag:
                self.viewProjection()
            self.HUDflag = False
            aw.button_18.setStyleSheet("QPushButton { background-color: #b5baff }")
            aw.stack.setCurrentIndex(0)
            self.resetlines()
            aw.sendmessage(QApplication.translate("Message","HUD OFF", None, QApplication.UnicodeUTF8))
            
        #ON
        else:
            if len(self.temp2) > 1:  #Need this because viewProjections use rate of change (two values needed)
                #load
                img = QPixmap().grabWidget(self)
#                img = self.grab()
                aw.HUD.setPixmap(img)
                
                self.HUDflag = True
                aw.button_18.setStyleSheet("QPushButton { background-color: #60ffed }")
                aw.stack.setCurrentIndex(1)
                aw.sendmessage(QApplication.translate("Message","HUD ON", None, QApplication.UnicodeUTF8))
            else:
                aw.sendmessage(QApplication.translate("Message","Need some data for HUD to work", None, QApplication.UnicodeUTF8))


    def timealign(self,redraw=True,recompute=False):
        try:
            if self.timeindexB[0] != -1 and self.timeindex[0] != -1:
                ptime = self.timex[self.timeindex[0]]
                btime = self.timeB[self.timeindexB[0]]
                difference = ptime - btime
                if difference > 0:
                    self.movebackground("right",abs(difference))
                    if redraw:
                        self.redraw(recompute)
                elif difference < 0:
                    self.movebackground("left",abs(difference))
                    if redraw:
                        self.redraw(recompute)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " timealign() %1").arg(str(ex)),exc_tb.tb_lineno)

    def lenaxlines(self):
        active_curves = len(self.extratimex)
        curves = aw.extraCurveVisibility1[0:active_curves] + aw.extraCurveVisibility2[0:active_curves] + [aw.qmc.ETcurve,aw.qmc.BTcurve]
        c = curves.count(True)
        if aw.qmc.background:
            c += 2
        return c
    
    def lendeltaaxlines(self):
        linecount = 0 
        if self.DeltaETflag:
            linecount += 1
        if  self.DeltaBTflag:
            linecount += 1
        if aw.qmc.background:
            if self.DeltaETBflag:
                linecount += 1
            if self.DeltaBTBflag:
                linecount += 1
        return linecount
        
    def resetlinecountcaches(self):
        aw.qmc.linecount = None
        aw.qmc.deltalinecount = None
        
    def resetlines(self):
        #note: delta curves are now in self.delta_ax and have been removed from the count of resetlines()
        if self.linecount is None:
            self.linecount = self.lenaxlines()
        self.ax.lines = self.ax.lines[0:self.linecount]
        
    def resetdeltalines(self):
        if self.deltalinecount is None:
            self.deltalinecount = self.lendeltaaxlines()
        self.delta_ax.lines = self.delta_ax.lines[0:self.deltalinecount]
            
    def setalarm(self,alarmnumber):
        self.alarmstate[alarmnumber] = 1    #turn off flag as it has been read
        try:
            if self.alarmaction[alarmnumber] == 0:
                # alarm popup message
                QMessageBox.information(self,QApplication.translate("Message", "Alarm notice",None, QApplication.UnicodeUTF8),self.alarmstrings[alarmnumber])
                aw.soundpop()
            elif self.alarmaction[alarmnumber] == 1:
                # alarm call program
                fname = u(self.alarmstrings[alarmnumber])
                QDesktopServices.openUrl(QUrl("file:///" + u(QDir().current().absolutePath()) + "/" + fname, QUrl.TolerantMode))
                aw.sendmessage(QApplication.translate("Message","Alarm is calling: %1",None, QApplication.UnicodeUTF8).arg(u(self.alarmstrings[alarmnumber])))
            elif self.alarmaction[alarmnumber] == 2:
                # alarm event button
                button_number = None
                try:
                    button_number = int(str(self.alarmstrings[alarmnumber])) - 1 # the event buttons presented to the user are numbered from 1 on                
                except:
                    aw.sendmessage(QApplication.translate("Message","Alarm trigger button error, description '%1' not a number",None, QApplication.UnicodeUTF8).arg(str(self.alarmstrings[alarmnumber])))
                if button_number:
                    if button_number > -1 and button_number < len(aw.buttonlist):
                        aw.recordextraevent(button_number)
                    elif button_number == 0:
                        # special case: trigger build-in COOL event
                        aw.qmc.markCoolEnd()
            else:
                # alarm slider 1-4
                slidernr = None
                try:
                    slidervalue = int(str(self.alarmstrings[alarmnumber]))
                    if slidervalue < 0 or slidervalue > 100:
                        raise Exception()
                    if slidervalue:
                        if self.alarmaction[alarmnumber] == 3:
                            slidernr = 0
                        elif self.alarmaction[alarmnumber] == 4:
                            slidernr = 1
                        elif self.alarmaction[alarmnumber] == 5:
                            slidernr = 2
                        elif self.alarmaction[alarmnumber] == 6:
                            slidernr = 3
                        if slidernr:
                            aw.moveslider(slidernr,slidervalue)
                            aw.fireslideraction(slidernr)
                except:
                    aw.sendmessage(QApplication.translate("Message","Alarm trigger slider error, description '%1' not a valid number [0-100]",None, QApplication.UnicodeUTF8).arg(str(self.alarmstrings[alarmnumber])))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setalarm() %1").arg(str(ex)),exc_tb.tb_lineno)
                

    def playbackevent(self):
        #needed when using device NONE
        if len(self.timex):
            #find time distances
            for i in range(len(self.backgroundEvents)):
                timed = int(self.timeB[self.backgroundEvents[i]] - self.timeclock.elapsed()/1000.)                 
                if  timed > 0 and timed < self.detectBackgroundEventTime:
                    #write text message
                    message = "> " +  self.stringfromseconds(timed) + " [" + u(self.Betypesf(self.backgroundEtypes[i]))
                    message += "] [" + self.eventsvalues(self.backgroundEvalues[i]) + "] : " + self.backgroundEStrings[i]
                    #rotate colors to get attention
                    if timed%2:
                        aw.messagelabel.setStyleSheet("background-color:'transparent';")
                    else:
                        aw.messagelabel.setStyleSheet("background-color:'yellow';")
                        
                    aw.sendmessage(message)
                    break

                elif timed == 0:
                    #for devices that support automatic roaster control
                    #if Fuji PID
                    if self.device == 0:

                        # COMMAND SET STRINGS
                        #  (adjust the SV PID to the float VALUE1)
                        # SETRS::VALUE1::VALUE2::VALUE3  (VALUE1 = target SV. float VALUE2 = time to reach int VALUE 1 (ramp) in minutes. int VALUE3 = hold (soak) time in minutes)

                        # IMPORTANT: VALUES are for controlling ET only (not BT). The PID should control ET not BT. The PID should be connected to ET only.
                        # Therefore, these values don't reflect a BT defined profile. They define an ET profile.
                        # They reflect the changes in ET, which indirectly define BT after some time lag

                        # There are two ways to record a roast. One is by changing Set Values (SV) during the roast,
                        # the other is by using ramp/soaks segments (RS). 
                        # Examples:

                        # SETSV::560.3           sets an SV value of 560.3F in the PID at the time of the recorded background event

                        # SETRS::440.2::2::0     starts Ramp Soak mode so that it reaches 440.2F in 2 minutes and holds (soaks) 440.2F for zero minutes

                        # SETRS::300.0::2::3::SETRS::540.0::6::0::SETRS::560.0::4::0::SETRS::560::0::0
                        #       this command has 4 comsecutive commands inside (4 segments)
                        #       1 SETRS::300.0::2::3 reach 300.0F in 2 minutes and hold it for 3 minutes (ie. total dry phase time = 5 minutes)
                        #       2 SETRS::540.0::6::0 then reach 540.0F in 6 minutes and hold it there 0 minutes (ie. total mid phase time = 6 minutes )
                        #       3 SETRS::560.0::4::0 then reach 560.0F in 4 minutes and hold it there 0 minutes (ie. total finish phase time = 4 minutes)
                        #       4 SETRS::560::0::0 then do nothing (because ramp time and soak time are both 0)
                        #       END ramp soak mode
                        
                        
                        if "::" in self.backgroundEStrings[i]:
                            aw.fujipid.replay(self.backgroundEStrings[i])
                            libtime.sleep(.5)  #avoid possible close times (rounding off)

                    #future Arduino
                    #if self.device == 19:


                #delete message
                else:
                    text = str(aw.messagelabel.text())
                    if len(text):
                        if text[0] == ">":
                            aw.sendmessage("")
                            aw.messagelabel.setStyleSheet("background-color:'transparent';")

    #make a projection of change of rate of BT on the graph
    def viewProjection(self):

        self.resetlines()

        if self.timeindex[0] != -1:
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        if self.projectionmode == 0:
            #calculate the temperature endpoint at endofx acording to the latest rate of change
            BTprojection = self.temp2[-1] + self.rateofchange2*(self.endofx - self.timex[-1]+ starttime)/60.
            ETprojection = self.temp1[-1] + self.rateofchange1*(self.endofx - self.timex[-1]+ starttime)/60.
            #plot projections
            self.ax.plot([self.timex[-1],self.endofx + 120], [self.temp2[-1], BTprojection],color =  self.palette["bt"],
                             linestyle = '-.', linewidth= 8, alpha = .3)
            self.ax.plot([self.timex[-1],self.endofx + 120], [self.temp1[-1], ETprojection],color =  self.palette["et"],
                             linestyle = '-.', linewidth= 8, alpha = .3)

        elif self.projectionmode == 1:
            # Under Test. Newton's Law of Cooling
            # This comes from the formula of heating (with ET) a cool (colder) object (BT).
            # The difference equation (discrete with n elements) is: DeltaT = T(n+1) - T(n) = K*(ET - BT)
            # The formula is a natural decay towards ET. The closer BT to ET, the smaller the change in DeltaT
            # projectionconstant is a multiplier factor. It depends on
            # 1 Damper or fan. Heating by convection is _faster_ than heat by conduction,
            # 2 Mass of beans. The heavier the mass, the _slower_ the heating of BT
            # 3 Gas or electric power: gas heats BT _faster_ because of hoter air.
            # Every roaster will have a different constantN.

            den = self.temp1[-1] - self.temp2[-1]  #denominator ETn - BTn 
            if den > 0: # if ETn > BTn
                #get x points
                xpoints = list(numpy.arange(self.timex[-1],self.endofx + 120, self.delay/1000.))  #do two minutes after endofx (+ 120 seconds)
                #get y points
                ypoints = [self.temp2[-1]]                                  # start initializing with last BT
                K =  self.projectionconstant*self.rateofchange2/den/60.                 # multiplier
                for _ in range(len(xpoints)-1):                                     # create new points from previous points 
                    DeltaT = K*(self.temp1[-1]- ypoints[-1])                        # DeltaT = K*(ET - BT)
                    ypoints.append(ypoints[-1]+ DeltaT)                             # add DeltaT to the next ypoint

                #plot ET level (straight line) and BT curve
                self.ax.plot([self.timex[-1],self.endofx + 120], [self.temp1[-1], self.temp1[-1]],color =  self.palette["et"],
                             linestyle = '-.', linewidth= 3, alpha = .5)
                self.ax.plot(xpoints, ypoints, color =  self.palette["bt"],linestyle = '-.', linewidth= 3, alpha = .5)

    # this function is called from the HUD DLg and reports the linear time (straight line) it would take to reach a temperature target
    # acording to the current rate of change
    def getTargetTime(self):

        if self.rateofchange1 > 0:
            ETreachTime = (self.ETtarget - self.temp1[-1])/(self.rateofchange1/60.)
            ET2reachTime = (self.ET2target - self.temp1[-1])/(self.rateofchange1/60.)
        else:
            ETreachTime = -1
            ET2reachTime = -1
            
        if self.rateofchange2 > 0:
            BTreachTime = (self.BTtarget - self.temp2[-1])/(self.rateofchange2/60.)
            BT2reachTime = (self.BT2target - self.temp2[-1])/(self.rateofchange2/60.)
        else:
            BTreachTime = -1
            BT2reachTime = -1

        return ETreachTime, BTreachTime, ET2reachTime, BT2reachTime

    #single variable (x) mathematical expression evaluator for user defined functions to convert sensor readings from HHM28 multimeter
    #example: eval_math_expression("pow(e,2*cos(x))",.3) returns 6.75763501
    def eval_math_expression(self,mathexpression,x):
        if len(mathexpression) == 0 or x == -1:
            return x

        #Since eval() is very powerful, for security reasons, only the functions in this dictionary will be allowed
        mathdictionary = {"sin":math.sin,"cos":math.cos,"tan":math.tan,"pow":math.pow,"exp":math.exp,"pi":math.pi,"e":math.e,
                          "abs":abs,"acos":math.acos,"asin":math.asin,"atan":math.atan,"log":math.log,"radians":math.radians,
                          "sqrt":math.sqrt,"atan2":math.atan,"degrees":math.degrees}
        try:
            x = float(x)
            mathdictionary['x'] = x         #add x to the math dictionary assigning the key "x" to its float value
            #if Ys in expression
            if "Y" in mathexpression:
                #extract Ys
                Yval = []                   #extract value number example Y9 = 9
                mlen = len(mathexpression)
                for i in range(mlen):
                    if mathexpression[i] == "Y":
                        #find Y number
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                number = mathexpression[i+1]
                            else:
                                number = "1"
                        #check for double digit
                        if i+2 < mlen:
                            if mathexpression[i+2].isdigit() and mathexpression[i+1].isdigit():
                                number += mathexpression[i+2]
                        Yval.append(number)
                            
                #build Ys float values
                if len(self.timex) > 0:
                    Y = [self.temp1[-1],self.temp2[-1]]
                    for i in range(len(self.extradevices)):
                        try:
                            Y.append(self.extratemp1[i][-1])
                        except:
                            Y.append(-1)
                        try:
                            Y.append(self.extratemp2[i][-1])
                        except:
                            Y.append(-1)
                    #add Ys and their value to math dictionary 
                    for i in range(len(Yval)):
                        mathdictionary["Y"+ Yval[i]] = Y[int(Yval[i])-1]
                else:
                    for i in range(len(Yval)):
                        mathdictionary["Y"+ Yval[i]] = 0
            return round(eval(mathexpression,{"__builtins__":None},mathdictionary),3)

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " eval_math_expression() %1").arg(str(e)),exc_tb.tb_lineno)
            return 0

    #format X axis labels
    def xaxistosm(self):

        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        endtime = self.endofx + starttime
        self.ax.set_xlim(self.startofx,endtime)


        if not self.xgrid:
            self.xgrid = 60.

        mfactor1 =  round(float(2. + int(starttime)/int(self.xgrid)))
        mfactor2 =  round(float(2. + int(self.endofx)/int(self.xgrid)))

        majorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid)
        minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid/6.)

        list(map(round,majorloc))
        list(map(round,minorloc))

        #majorlocator = ticker.IndexLocator(self.xgrid, starttime)  #IndexLocator does not work right when updating (new value)self.endofx
        #majorlocator = ticker.MultipleLocator(self.xgrid)          #MultipleLocator does not provide an offset for startime
        majorlocator = ticker.FixedLocator(majorloc)   
        minorlocator = ticker.FixedLocator(minorloc)

        self.ax.xaxis.set_minor_locator(minorlocator)
        self.ax.xaxis.set_major_locator(majorlocator)

        formatter = ticker.FuncFormatter(self.formtime)
        self.ax.xaxis.set_major_formatter(formatter)

        #adjust the length of the major ticks
        for i in self.ax.get_xticklines() + self.ax.get_yticklines():
            i.set_markersize(10)
            #i.set_markeredgewidth(2)   #adjust the width

        #adjust the length of the minor ticks
        for i in self.ax.xaxis.get_minorticklines() + self.ax.yaxis.get_minorticklines():
            i.set_markersize(5)

        # check x labels rotation
        if self.xrotation:     
            for label in self.ax.xaxis.get_ticklabels():
                label.set_rotation(self.xrotation)

    #used by xaxistosm(). Provides also negative time
    def formtime(self,x,pos):
        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        if x >=  starttime:
            m,s = divmod((x - round(starttime)), 60)  #**NOTE**: divmod() returns here type numpy.float64, which could create problems
            #print type(m),type(s)                    #it is used in: formatter = ticker.FuncFormatter(self.formtime) in xaxistosm()
            s = int(round(s))
            m = int(m)

            if s >= 59:
                return '%d'%(m+1)
            elif abs(s - 30) < 1:
                return '%d.5'%m
            elif s > 1:
                return  '%d:%02d'%(m,s)
            else:
                return '%d'%m

        else:
            m,s = divmod(abs(x - round(starttime)), 60)
            s = int(round(s))
            m = int(m)
            
            if s >= 59:
                return '-%d'%(m+1)
            elif abs(s-30) < 1:
                return '-%d.5'%m
            elif s > 1:
                return  '-%d:%02d'%(m,s)
            else:
                return '-%d'%m

    # returns True if nothing to save, discard or save was selected and False if canceled by the user
    def checkSaved(self):
        #prevents deleting accidentally a finished roast
        if self.safesaveflag == True:
            string = QApplication.translate("Message","Save the profile, Discard the profile (Reset), or Cancel?", None, QApplication.UnicodeUTF8)
            reply = QMessageBox.warning(self,QApplication.translate("Message","Profile unsaved", None, QApplication.UnicodeUTF8),string,
                                QMessageBox.Discard |QMessageBox.Save|QMessageBox.Cancel)
            if reply == QMessageBox.Save:
                aw.fileSave(None)  #if accepted, makes safesaveflag = False
                return True
            elif reply == QMessageBox.Discard:
                return True
            elif reply == QMessageBox.Cancel:
                aw.sendmessage(QApplication.translate("Message","Action canceled",None, QApplication.UnicodeUTF8))
                return False
        else:
            # nothing to be saved
            return True

    def clearMeasurements(self):
        try:
            #### lock shared resources #####
            self.samplingsemaphore.acquire(1)
            self.safesaveflag = False  #now flag is cleared (OFF)
            self.rateofchange1 = 0.0
            self.rateofchange2 = 0.0
            self.temp1, self.temp2, self.delta1, self.delta2, self.timex, self.stemp1, self.stemp2 = [],[],[],[],[],[],[]
            self.unfiltereddelta1,self.unfiltereddelta2 = [],[]
            self.timeindex = [-1,0,0,0,0,0,0,0]
            #extra devices
            for i in range(min(len(self.extradevices),len(self.extratimex),len(self.extratemp1),len(self.extratemp2),len(self.extrastemp1),len(self.extrastemp2))):
                self.extratimex[i],self.extratemp1[i],self.extratemp2[i],self.extrastemp1[i],self.extrastemp2[i] = [],[],[],[],[]            #reset all variables that need to be reset (but for the actually measurements that will be treated separately at the end of this function)
            self.specialevents=[]
            aw.lcd1.display("00:00")
            aw.lcd2.display("0.0")
            aw.lcd3.display("0.0")
            aw.lcd4.display("0.0")
            aw.lcd5.display("0.0")
            aw.lcd6.display("0.0")
            aw.lcd7.display("0.0")
            for i in range(aw.nLCDS):
                aw.extraLCD1[i].display("0.0")
                aw.extraLCD2[i].display("0.0")
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " reset() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    #Resets graph. Called from reset button. Deletes all data. Calls redraw() at the end
    # returns False if action was canceled, True otherwise
    def reset(self,redraw=True,soundOn=True):
        if not self.checkSaved():
            return False
        else:
            try:
                if soundOn:
                    aw.soundpop()
                
                #### lock shared resources #####
                self.samplingsemaphore.acquire(1)
                if self.flagon:
                    self.OffMonitor()
        
                #reset time
                aw.qmc.timeclock.start()
        
        
                if self.HUDflag:
                    self.toggleHUD()
                self.hudresizeflag = False
        
#                self.ax.set_title(self.title,size=20,color=self.palette["title"])
        
    
                aw.sendmessage(QApplication.translate("Message","Scope has been reset",None, QApplication.UnicodeUTF8))
                aw.button_3.setDisabled(False)
                aw.button_4.setDisabled(False)
                aw.button_5.setDisabled(False)
                aw.button_6.setDisabled(False)
                aw.button_7.setDisabled(False)
                aw.button_8.setDisabled(False)
                aw.button_9.setDisabled(False)
                aw.button_19.setDisabled(False)
                aw.button_20.setDisabled(False)
        
                aw.button_3.setFlat(False)
                aw.button_4.setFlat(False)
                aw.button_5.setFlat(False)
                aw.button_6.setFlat(False)
                aw.button_7.setFlat(False)
                aw.button_8.setFlat(False)
                aw.button_9.setFlat(False)
                aw.button_19.setFlat(False)
                aw.button_20.setFlat(False)
                aw.button_1.setText(QApplication.translate("Button", "ON",None, QApplication.UnicodeUTF8)) 
                aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
                aw.button_2.setText(QApplication.translate("Button", "START",None, QApplication.UnicodeUTF8))
                aw.button_2.setStyleSheet(aw.pushbuttonstyles["OFF"])
        
                self.title = QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8)
                aw.setWindowTitle(aw.windowTitle)
        
                if self.roastpropertiesflag:
                    self.roastingnotes = ""
                    self.cuppingnotes = ""
                    self.beans = ""
                    self.weight = [0,0,"g"]
                    self.volume = [0,0,"l"]
                    self.ambientTemp = 0.
                    self.ambient_humidity = 0.
                    self.beansize = 0.
        
                self.roastdate = QDate.currentDate()
                self.errorlog = []
                aw.seriallog = []
        
                self.specialevents = []
                self.specialeventstype = []
                self.specialeventsStrings = []
                self.specialeventsvalue = []
                self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                aw.eNumberSpinBox.setValue(0)
                aw.lineEvent.setText("")
                aw.etypeComboBox.setCurrentIndex(0)
                aw.valueEdit.setText("")
                aw.curFile = None                 #current file name
                #used to find length of arms in annotations
                self.ystep_down = 0
                self.ystep_up = 0 
        
                self.startofx = 0
                self.endofx = self.resetmaxtime 
                if self.endofx < 1:
                    self.endofx = 60
                    
                #roast flags
                aw.qmc.heavyFC_flag = False
                aw.qmc.lowFC_flag = False
                aw.qmc.lightCut_flag = False
                aw.qmc.darkCut_flag = False
                aw.qmc.drops_flag = False
                aw.qmc.oily_flag = False
                aw.qmc.uneven_flag = False
                aw.qmc.tipping_flag = False
                aw.qmc.scorching_flag = False
                aw.qmc.divots_flag = False
                
                #color variables
                aw.qmc.whole_color = 0
                aw.qmc.ground_color = 0
        
                #Designer variables
                self.indexpoint = 0
                self.workingline = 2            #selects ET or BT
                self.currentx = 0               #used to add point when right click
                self.currenty = 0               #used to add point when right click
                self.designertemp1init = []
                self.designertemp2init = []
                if self.mode == "C":
        #                                     #CH, DE, Fcs,Fce,Scs,Sce,Drop
                    self.designertemp1init = [290,290,290,290,290,290,290]
                    self.designertemp2init = [200,150,200,210,220,225,240]
                elif self.mode == "F":
                    self.designertemp1init = [500,500,500,500,500,500,500]
                    self.designertemp2init = [380,300,390,395,410,412,420]
                self.disconnect_designer()  #sets designer flag false
                self.setCursor(Qt.ArrowCursor)
        
                self.temporaryalarmflag = -3
        
                #reset alarms that have been triggered
                self.alarmstate = [0]*len(self.alarmflag)  #0 = not triggered; 1 = triggered
                #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
                aw.qmc.TPalarmtimeindex = None
        
                #reset cupping flavor values
                self.flavors = [5.]*len(self.flavorlabels)
        
                #autodetected CHARGE and DROP index
                self.autoChargeIdx = 0
                self.autoDropIdx = 0
        
                aw.hideDefaultButtons()
                aw.hideExtraButtons()
                aw.hideLCDs()
                aw.hideSliders()
        
                self.wheelflag = False
                self.designerflag = False
        
                #check and turn off mouse cross marker
                if self.crossmarker:
                    self.togglecrosslines()
            except Exception as ex:
    #            import traceback
    #            traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " reset() %1").arg(str(ex)),exc_tb.tb_lineno)
            finally:
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)
            # now clear all measurements and redraw
            self.clearMeasurements()
            ### REDRAW  ##
            if redraw:
                self.redraw(False)
            return True
            
    def medfilt(self, x, k):
        """Apply a length-k median filter to a 1D array x.
        Boundaries are extended by repeating endpoints.
        """
        assert k % 2 == 1, "Median filter length must be odd."
        assert x.ndim == 1, "Input must be one-dimensional."
        k2 = (k - 1) // 2
        y = numpy.zeros ((len (x), k), dtype=x.dtype)
        y[:,k2] = x
        for i in range (k2):
            j = k2 - i
            y[j:,i] = x[:-j]
            y[:j,i] = x[0]
            y[:-j,-(i+1)] = x[j:]
            y[-j:,-(i+1)] = x[-1]
        return numpy.median(y, axis=1)
       
    # smoothes a list of values 'y' at taken at times indicated by the numbers in list 'x'
    # 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
    # 'flat' results in moving average
    # window_len should be odd
    # first applies a median filter to remove spikes if filterDropOuts is True
    def smooth(self, x, y, window_len=15, window='hanning'):
        try:
            if len(x) == len(y) and len(x) > 1:
                # filter spikes
                if aw.qmc.filterDropOuts:
                    y = self.medfilt(y,5) # k=3 seems not to catch all spikes in all cases
                if window_len > 2 and len(x) == len(y) and len(x) > 1:
                    # smooth curves
                    s = numpy.r_[2*x[0]-y[window_len:1:-1],y,2*y[-1]-y[-1:-window_len:-1]]
                    if window == 'flat': #moving average
                        w = numpy.ones(window_len,'d')
                    else:
                        w = eval('numpy.'+window+'(window_len)')
                    ys = numpy.convolve(w/w.sum(),s,mode='same')
                    res = (ys[window_len-1:-window_len+1])
    #                res = (ys[window_len-2:-window_len]) # this one seems to move the curve slightly to the right
                    res = numpy.concatenate((y[:window_len/2],res[window_len/2:]))
                    if len(res) != len(y):
                        return y
                    else:
                        return res
                else:
                    return y
            else:
                return y
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " smooth() %1").arg(str(ex)),exc_tb.tb_lineno)
            return x

    def smooth_list(self, a, b, window_len=7, window='hanning'):
        #pylint: disable=E1103
        if aw.qmc.timeindex[0] != -1: # if CHARGE is set, filter before and after CHARGE parts separately
            return numpy.concatenate((self.smooth(numpy.array(a[:aw.qmc.timeindex[0]]),numpy.array(b[:aw.qmc.timeindex[0]]),window_len,window),
                self.smooth(numpy.array(a[aw.qmc.timeindex[0]:]),numpy.array(b[aw.qmc.timeindex[0]:]),window_len,window))).tolist()
        else:
            return self.smooth(numpy.array(a),numpy.array(b),window_len,window).tolist()

    def annotate(self, temp, time_str, x, y, yup, ydown,e=0,a=1.):
        #annotate temp
        self.ax.annotate("%.1f"%(temp), xy=(x,y),xytext=(x+e,y + yup),
                            color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["text"],alpha=0.4),fontsize=10,alpha=a)
        #anotate time
        self.ax.annotate(time_str,xy=(x,y),xytext=(x+e,y - ydown),
                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["text"],alpha=0.4),fontsize=10,alpha=a)

    def place_annotations(self,d,timex,timeindex,temp,stemp,startB=0,time2=None,timeindex2=None):
        ystep_down = ystep_up = 0
        #Add markers for CHARGE
        try: 
            if timeindex[0] != -1 and len(timex) > timeindex[0]:
                t0idx = timeindex[0]
                t0 = timex[t0idx]
                y = stemp[t0idx]
                ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y,y,d)
                if startB:
                    st1 = str(self.stringfromseconds(t0 - startB))
                    t0 = startB
                    e = 40
                    a = 0.4
                else:
                    st1 = QApplication.translate("Scope Annotation", "START 00:00", None, QApplication.UnicodeUTF8)
                    e = 0
                    a = 1.                

                self.annotate(temp[t0idx],st1,t0,y,ystep_up,ystep_down,e,a)
                #Add Dry End markers
                if timeindex[1]:
                    tidx = timeindex[1]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[tidx],d)
                    st1 = QApplication.translate("Scope Annotation","DE %1", None, QApplication.UnicodeUTF8).arg(str(self.stringfromseconds(timex[tidx]-t0)))
                    if timeindex2 and timeindex2[1] and timex[timeindex[1]] < time2[timeindex2[1]]:
                        e = -80
                        a = 0.4
                    else:
                        e = 0
                        a = 1.
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                #Add 1Cs markers            
                if timeindex[2]:
                    tidx = timeindex[2]
                    if timeindex[1]: #if dryend
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[1]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = QApplication.translate("Scope Annotation","FCs %1", None, QApplication.UnicodeUTF8).arg(str(self.stringfromseconds(timex[tidx]-t0)))
                    if timeindex2 and timeindex2[2] and timex[timeindex[2]] < time2[timeindex2[2]]:
                        e = -80
                        a = 0.4
                    else:
                        e = 0
                        a = 1.
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                #Add 1Ce markers
                if timeindex[3]:
                    tidx = self.timeindex[3]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[self.timeindex[2]],stemp[tidx],d)
                    st1 = QApplication.translate("Scope Annotation","FCe %1", None, QApplication.UnicodeUTF8).arg(str(self.stringfromseconds(timex[tidx]-t0)))
                    if timeindex2 and timeindex2[3] and timex[timeindex[3]] < time2[timeindex2[3]]:
                        e = -80
                        a = 0.4
                    else:
                        e = 0
                        a = 1.
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                    #add a water mark if FCs
                    if timeindex[2] and not timeindex2:
                        self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                #Add 2Cs markers
                if timeindex[4]:
                    tidx = self.timeindex[4]
                    if timeindex[3]:
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[3]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = QApplication.translate("Scope Annotation","SCs %1", None, QApplication.UnicodeUTF8).arg(str(self.stringfromseconds(timex[tidx]-t0)))
                    if timeindex2 and timeindex2[4] and timex[timeindex[4]] < time2[timeindex2[4]]:
                        e = -80
                        a = 0.4
                    else:
                        e = 0
                        a = 1.
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                #Add 2Ce markers
                if timeindex[5]:
                    tidx = self.timeindex[5]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[4]],stemp[tidx],d)
                    st1 =  QApplication.translate("Scope Annotation","SCe %1", None, QApplication.UnicodeUTF8).arg(str(self.stringfromseconds(timex[tidx]-t0)))
                    if timeindex2 and timeindex2[5] and timex[timeindex[5]] < time2[timeindex2[5]]:
                        e = -80
                        a = 0.4
                    else:
                        e = 0
                        a = 1.
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                    #do water mark if SCs
                    if timeindex[4] and not timeindex2:
                        self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                #Add DROP markers
                if timeindex[6]:
                    tidx = timeindex[6]
                    if self.timeindex[5]:
                        tx = self.timeindex[5]
                    elif self.timeindex[4]:
                        tx = self.timeindex[4]
                    elif self.timeindex[3]:
                        tx = self.timeindex[3]
                    elif self.timeindex[2]:
                        tx = self.timeindex[2]
                    elif self.timeindex[1]:
                        tx = self.timeindex[1]
                    else:
                        tx = t0idx
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tx],stemp[tidx],d)
                    st1 = QApplication.translate("Scope Annotation","END %1", None, QApplication.UnicodeUTF8).arg(str(self.stringfromseconds(timex[tidx]-t0)))
                    if timeindex2 and timeindex2[6] and timex[timeindex[6]] < time2[timeindex2[6]]:
                        e = -80
                        a = 0.4
                    else:
                        e = 0
                        a = 1.
                    self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a)
                # add COOL mark
                if timeindex[7] and not timeindex2:
                    tidx = timeindex[7]
                    endidx = self.ax.get_xlim()[1] # or timex[-1]
                    self.ax.axvspan(timex[tidx],endidx, facecolor=self.palette["rect4"], ec='none', alpha=0.3, clip_on=False, clip_path=None, lw=None,lod=False)
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " place_annotations() %1").arg(str(e)),exc_tb.tb_lineno)


    #Redraws data
    # if recomputeAllDeltas, the delta arrays; if smooth the smoothed line arrays are recomputed
    def redraw(self, recomputeAllDeltas=True, smooth=False):
#        print("redraw",recomputeAllDeltas,smooth)
        try:
            #### lock shared resources   ####
            self.samplingsemaphore.acquire(1)

            self.fig.clf()   #wipe out figure. keep_observers=False

            self.ax = self.fig.add_subplot(111,axisbg=self.palette["background"])

            #Set axes same as in __init__
            if self.endofx == 0:            #fixes possible condition of endofx being ZERO when application starts (after aw.settingsload)
                self.endofx = 60
            self.ax.set_ylim(self.ylimit_min, self.ylimit)
            self.ax.set_autoscale_on(False)
            self.ax.grid(True,color=self.palette["grid"],linestyle=self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha)
            self.ax.set_ylabel(self.mode,size=16,color =self.palette["ylabel"],rotation=0)
            self.ax.set_xlabel(QApplication.translate("Label",'Time', None, QApplication.UnicodeUTF8),size=16,color = self.palette["xlabel"])
            self.ax.set_title(self.title,size=20,color=self.palette["title"])
#            self.fig.patch.set_facecolor(self.palette["background"]) # facecolor='lightgrey'
            two_ax_mode = (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag))) and not self.designerflag
            if two_ax_mode:
                #create a second set of axes in the same position as self.ax
                self.delta_ax = self.ax.twinx()
                self.ax.set_zorder(self.delta_ax.get_zorder()-1) # put ax in front of delta_ax
                self.ax.patch.set_visible(True)
                self.delta_ax.set_ylabel(u(QApplication.translate("Label", "deg/min", None, QApplication.UnicodeUTF8)),size=16,color = self.palette["ylabel"])
                self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                for i in self.delta_ax.get_yticklines():
                    i.set_markersize(10)
                for i in self.delta_ax.yaxis.get_minorticklines():
                    i.set_markersize(5)
            #put a right tick on the graph
            else:
                for tick in self.ax.yaxis.get_major_ticks():
                    tick.label2On = True
            self.ax.yaxis.set_major_locator(ticker.MultipleLocator(self.ygrid))
            self.ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
            for i in self.ax.get_yticklines():
                i.set_markersize(10)
            for i in self.ax.yaxis.get_minorticklines():
                i.set_markersize(5)

            #update X ticks, labels, and colors
            self.xaxistosm()

            trans = transforms.blended_transform_factory(self.ax.transAxes,self.ax.transData)
            
            #draw water marks for dry phase region, mid phase region, and finish phase region
            if aw.qmc.watermarksflag:
                rect1 = patches.Rectangle((0,self.phases[0]), width=1, height=(self.phases[1]-self.phases[0]),
                                          transform=trans, color=self.palette["rect1"],alpha=0.3)
                rect2 = patches.Rectangle((0,self.phases[1]), width=1, height=(self.phases[2]-self.phases[1]),
                                          transform=trans, color=self.palette["rect2"],alpha=0.3)
                rect3 = patches.Rectangle((0,self.phases[2]), width=1, height=(self.phases[3] - self.phases[2]),
                                          transform=trans, color=self.palette["rect3"],alpha=0.3)
                if (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag))) and not self.designerflag:
                    self.delta_ax.add_patch(rect1)
                    self.delta_ax.add_patch(rect2)
                    self.delta_ax.add_patch(rect3)
                else:
                    self.ax.add_patch(rect1)
                    self.ax.add_patch(rect2)
                    self.ax.add_patch(rect3)

            #if self.eventsGraphflag == 0 then that means don't plot event bars

            if self.eventsGraphflag == 1: #plot event bars by type
                # make blended transformations to help identify EVENT types
                if self.mode == "C":
                    step = 5
                    start = 20
                else:
                    step = 10
                    start = 60
                jump = 20
                for i in range(4):
                    rectEvent = patches.Rectangle((0,self.phases[0]-start-jump), width=1, height = step, transform=trans, color=self.palette["rect1"],alpha=.3)
                    self.ax.add_patch(rectEvent)
                    if self.mode == "C":
                        jump -= 10
                    else:
                        jump -= 20

            #plot events bars by value
            elif self.eventsGraphflag == 2:
                # make blended transformations to help identify EVENT types
                if self.mode == "C":
                    step = 2
                    start = 40
                else:
                    step = 5
                    start = 100
                jump = 20

                for i in range(12):
                    if i == 0:
                        color = self.palette["rect3"]
                    elif i%2:
                        color = self.palette["rect2"]
                    else:
                        color = self.palette["rect1"]
                    barposition = self.phases[0]-start-jump    
                    rectEvent = patches.Rectangle((0,barposition), width=1, height = step, transform=trans, color=color,alpha=.2)
                    self.ax.add_patch(rectEvent)
                    self.eventpositionbars[i] = barposition
                    if self.mode == "C":
                        jump -= 5
                    else:
                        jump -= 10

            ##### ET,BT curves
            if aw.qmc.ETcurve:
                if aw.qmc.flagon:
                    self.l_temp1, = self.ax.plot(self.timex,self.temp1,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=u(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
                else:
                    if smooth or len(self.stemp1) != len(self.timex):
                        self.stemp1 = self.smooth_list(self.timex,self.temp1,window_len=self.curvefilter)
                    self.l_temp1, = self.ax.plot(self.timex,self.stemp1,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=u(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
            if aw.qmc.BTcurve:
                if aw.qmc.flagon:
                    self.l_temp2, = self.ax.plot(self.timex,self.temp2,markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette["bt"],label=u(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))
                else:
                    if smooth or len(self.stemp2) != len(self.timex):
                        self.stemp2 = self.smooth_list(self.timex,self.temp2,window_len=self.curvefilter)
                    self.l_temp2, = self.ax.plot(self.timex,self.stemp2,markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette["bt"],label=u(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))

            ##### Extra devices-curves
            self.extratemp1lines,self.extratemp2lines = [],[]
            for i in range(min(len(self.extratimex),len(self.extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(self.extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                if aw.extraCurveVisibility1[i]:
                    if aw.qmc.flagon:
                        self.extratemp1lines.append(self.ax.plot(self.extratimex[i], self.extratemp1[i],color=self.extradevicecolor1[i],markersize=self.extramarkersizes1[i],marker=self.extramarkers1[i],linewidth=self.extralinewidths1[i],linestyle=self.extralinestyles1[i],drawstyle=self.extradrawstyles1[i],label= self.extraname1[i])[0])
                    else:                    
                        if smooth or len(self.extrastemp1[i]) != len(self.extratimex[i]):
                            self.extrastemp1[i] = self.smooth_list(self.extratimex[i],self.extratemp1[i],window_len=self.curvefilter)
                        self.extratemp1lines.append(self.ax.plot(self.extratimex[i], self.extrastemp1[i],color=self.extradevicecolor1[i],markersize=self.extramarkersizes1[i],marker=self.extramarkers1[i],linewidth=self.extralinewidths1[i],linestyle=self.extralinestyles1[i],drawstyle=self.extradrawstyles1[i],label= self.extraname1[i])[0])
                if aw.extraCurveVisibility2[i]:
                    if aw.qmc.flagon:
                        self.extratemp2lines.append(self.ax.plot(self.extratimex[i], self.extratemp2[i],color=self.extradevicecolor2[i],markersize=self.extramarkersizes2[i],marker=self.extramarkers2[i],linewidth=self.extralinewidths2[i],linestyle=self.extralinestyles2[i],drawstyle=self.extradrawstyles2[i],label= self.extraname2[i])[0])
                    else:
                        if smooth or len(self.extrastemp2[i]) != len(self.extratimex[i]):
                            self.extrastemp2[i] = self.smooth_list(self.extratimex[i],self.extratemp2[i],window_len=self.curvefilter)
                        self.extratemp2lines.append(self.ax.plot(self.extratimex[i], self.extrastemp2[i],color=self.extradevicecolor2[i],markersize=self.extramarkersizes2[i],marker=self.extramarkers2[i],linewidth=self.extralinewidths2[i],linestyle=self.extralinestyles2[i],drawstyle=self.extradrawstyles2[i],label= self.extraname2[i])[0])

            #check BACKGROUND flag
            if self.background: 
                #check to see if there is both a profile loaded and a background loaded
                if self.timeindex[0] != -1 and self.timeindexB[0] != -1 and self.backmoveflag:
                    if self.timex[self.timeindex[0]] != self.timeB[self.timeindexB[0]]:
                        #align the background profile so they both plot with the same CHARGE time
                        difference = self.timex[self.timeindex[0]] - self.timeB[self.timeindexB[0]]
                        if difference > 0:
                            self.movebackground("left",-difference)
                        elif difference < 0:
                            self.movebackground("right",difference)
                        self.backmoveflag = 0

                #draw background
                self.l_back1, = self.ax.plot(self.timeB, self.temp1B,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                             alpha=self.backgroundalpha,label=u(QApplication.translate("Label", "BackgroundET", None, QApplication.UnicodeUTF8)))
                self.l_back2, = self.ax.plot(self.timeB, self.temp2B,markersize=self.BTbackmarkersize,marker=self.BTbackmarker,linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                             alpha=self.backgroundalpha,label=u(QApplication.translate("Label", "BackgroundBT", None, QApplication.UnicodeUTF8)))

                #populate background delta ET (self.delta1B) and delta BT (self.delta2B)
                if self.DeltaETBflag or self.DeltaBTBflag:
                    if True or recomputeAllDeltas:
                        tx = numpy.array(self.timeB)
                        dtx = numpy.diff(self.timeB) / 60.
                        with numpy.errstate(divide='ignore'):
                            z1 = numpy.diff(self.temp1B) / dtx
                            z2 = numpy.diff(self.temp2B) / dtx
                        lt,ld1,ld2 = len(self.timeB),len(z1),len(z2)
                        if lt > ld1:
                            z1 = numpy.append(z1,[z1[-1] if ld1 else 0.]*(lt - ld1))
                        if lt > ld2:
                            z2 = numpy.append(z2,[z2[-1] if ld2 else 0.]*(lt - ld2))
                        self.delta1B = self.smooth(tx,z1,window_len=self.deltafilter).tolist()
                        self.delta2B = self.smooth(tx,z2,window_len=self.deltafilter).tolist()
                    ##### DeltaETB,DeltaBTB curves
                    if self.DeltaETBflag:
                        self.l_delta1B, = self.delta_ax.plot(self.timeB, self.delta1B,markersize=self.ETBdeltamarkersize,marker=self.ETBdeltamarker,linewidth=self.ETBdeltalinewidth,linestyle=self.ETBdeltalinestyle,drawstyle=self.ETBdeltadrawstyle,color=self.backgrounddeltaetcolor,alpha=self.backgroundalpha,label=u(QApplication.translate("Label", "BackgroundDeltaET", None, QApplication.UnicodeUTF8)))
                    if self.DeltaBTBflag:
                        self.l_delta2B, = self.delta_ax.plot(self.timeB, self.delta2B,markersize=self.BTBdeltamarkersize,marker=self.BTBdeltamarker,linewidth=self.BTBdeltalinewidth,linestyle=self.BTBdeltalinestyle,drawstyle=self.BTBdeltadrawstyle,color=self.backgrounddeltabtcolor,alpha=self.backgroundalpha,label=u(QApplication.translate("Label", "BackgroundDeltaBT", None, QApplication.UnicodeUTF8)))

                #check backgroundevents flag
                if self.backgroundeventsflag:
                    if self.eventsGraphflag != 2:
                        if self.mode == "F":
                            height = 50
                        else:
                            height = 20

                        for p in range(len(self.backgroundEvents)):
                            st1 = u(self.Betypesf(self.backgroundEtypes[p])[0] + self.eventsvaluesShort(self.backgroundEvalues[p]))
                            if self.temp1B[self.backgroundEvents[p]] > self.temp2B[self.backgroundEvents[p]]:
                                temp = self.temp1B[self.backgroundEvents[p]]
                            else:
                                temp = self.temp2B[self.backgroundEvents[p]]
                            self.ax.annotate(st1, xy=(self.timeB[self.backgroundEvents[p]], temp),
                                                xytext=(self.timeB[self.backgroundEvents[p]], temp+height),
                                                fontsize=10,color=self.palette["text"],arrowprops=dict(arrowstyle='wedge',color="yellow",
                                                alpha=self.backgroundalpha,relpos=(0,0)),alpha=self.backgroundalpha)
                    #background events by value
                    else:
                        self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
                        self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
                        for i in range(len(self.backgroundEvents)):
                            if self.backgroundEtypes[i] == 0:
                                self.E1backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E1backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])
                            elif self.backgroundEtypes[i] == 1:
                                self.E2backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E2backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])
                            elif self.backgroundEtypes[i] == 2:
                                self.E3backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E3backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])
                            elif self.backgroundEtypes[i] == 3:
                                self.E4backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                self.E4backgroundvalues.append(self.eventpositionbars[int(self.backgroundEvalues[i])])

                        self.l_backgroundeventtype1dots, = self.ax.plot(self.E1backgroundtimex, self.E1backgroundvalues, color="slateblue", marker=self.EvalueMarker[0],markersize = self.EvalueMarkerSize[0],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[0],alpha = self.Evaluealpha[0])
                        self.l_backgroundeventtype2dots, = self.ax.plot(self.E2backgroundtimex, self.E2backgroundvalues, color="slategrey", marker=self.EvalueMarker[1],markersize = self.EvalueMarkerSize[1],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[1],alpha = self.Evaluealpha[1])
                        self.l_backgroundeventtype3dots, = self.ax.plot(self.E3backgroundtimex, self.E3backgroundvalues, color="grey", marker=self.EvalueMarker[2],markersize = self.EvalueMarkerSize[2],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[2],alpha = self.Evaluealpha[2])
                        self.l_backgroundeventtype4dots, = self.ax.plot(self.E4backgroundtimex, self.E4backgroundvalues, color="darkgrey", marker=self.EvalueMarker[3],markersize = self.EvalueMarkerSize[3],
                                                                        linestyle="steps-post",linewidth = self.Evaluelinethickness[3],alpha = self.Evaluealpha[3])

                #check backgroundDetails flag
                if self.backgroundDetails:
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min 
                    d = d - d/5
                    #if there is a profile loaded with CHARGE, then save time to get the relative time
                    if self.timeindex[0] != -1:   #verify it exists before loading it, otherwise the list could go out of index
                        startB = self.timex[self.timeindex[0]]
                    else:
                        startB = 0
                    self.place_annotations(d,self.timeB,self.timeindexB,self.temp2B,self.temp2B,startB,self.timex,self.timeindex)
                    
                #END of Background

            handles = []
            labels = []
            if aw.qmc.ETcurve:
                handles.append(self.l_temp1)
                labels.append(u(QApplication.translate("Label", "ET", None, QApplication.UnicodeUTF8)))
            if aw.qmc.BTcurve:
                handles.append(self.l_temp2)
                labels.append(u(QApplication.translate("Label", "BT", None, QApplication.UnicodeUTF8)))

            #populate delta ET (self.delta1) and delta BT (self.delta2)
            if self.DeltaETflag or self.DeltaBTflag:
                if recomputeAllDeltas:  
                    tx = numpy.array(self.timex)
                    dtx = numpy.diff(self.timex) / 60.
                    if aw.qmc.flagon:
                        with numpy.errstate(divide='ignore'):
                            z1 = numpy.diff(self.temp1) / dtx
                        with numpy.errstate(divide='ignore'):
                            z2 = numpy.diff(self.temp2) / dtx
                    else:
                        with numpy.errstate(divide='ignore'):
                            z1 = numpy.diff(self.stemp1) / dtx
                        with numpy.errstate(divide='ignore'):
                            z2 = numpy.diff(self.stemp2) / dtx
                    lt,ld1,ld2 = len(self.timex),len(z1),len(z2)
                    if lt > ld1:
                        z1 = numpy.append(z1,[z1[-1] if ld1 else 0.]*(lt - ld1))
                    if lt > ld2:
                        z2 = numpy.append(z2,[z2[-1] if ld2 else 0.]*(lt - ld2))
                    self.delta1 = self.smooth(tx,z1,window_len=self.deltafilter).tolist()
                    self.delta2 = self.smooth(tx,z2,window_len=self.deltafilter).tolist()

                ##### DeltaET,DeltaBT curves
                if self.DeltaETflag:
                    self.l_delta1, = self.delta_ax.plot(self.timex, self.delta1,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],label=u(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))
                    handles.append(self.l_delta1)
                    labels.append(u(QApplication.translate("Label", "DeltaET", None, QApplication.UnicodeUTF8)))
                    
                if self.DeltaBTflag:
                    self.l_delta2, = self.delta_ax.plot(self.timex, self.delta2,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],label=str(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))
                    handles.append(self.l_delta2)
                    labels.append(u(QApplication.translate("Label", "DeltaBT", None, QApplication.UnicodeUTF8)))


            nrdevices = len(self.extradevices)
            if nrdevices:
                xtmpl1idx = 0
                xtmpl2idx = 0
                for i in range(nrdevices):
                    if aw.extraCurveVisibility1[i]:
                        handles.append(self.extratemp1lines[xtmpl1idx])
                        xtmpl1idx = xtmpl1idx + 1
                        labels.append(self.extraname1[i])
                    if aw.extraCurveVisibility2[i]:
                        handles.append(self.extratemp2lines[xtmpl2idx])
                        xtmpl2idx = xtmpl2idx + 1
                        labels.append(self.extraname2[i])
                    
            if not self.designerflag and aw.qmc.BTcurve:
                if self.flagon: # no smoothed lines in this case, pass normal BT
                    self.place_annotations(aw.qmc.ylimit - aw.qmc.ylimit_min,self.timex,self.timeindex,self.temp2,self.temp2,0)
                else:
                    self.place_annotations(aw.qmc.ylimit - aw.qmc.ylimit_min,self.timex,self.timeindex,self.temp2,self.stemp2,0)
                    if self.timeindex[6]:
                        self.writestatistics()

            if self.eventsshowflag:
                Nevents = len(self.specialevents)
                #three modes of drawing events.
                # the first mode just places annotations. They are text annotations.
                # The second mode aligns the events types to a bar height so that they can be visually identified by type. They are text annotations
                # the third mode plots the events by value. They are not annotations but actual lines.

                if Nevents:
                    for i in range(Nevents):
                        if self.specialeventstype[i] == 4 or self.eventsGraphflag == 0:
                            if self.specialeventstype[i] < 4:
                                etype = self.etypesf(self.specialeventstype[i])
                                firstletter = u(etype[0])
                                secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                            else:
                                firstletter = "E"
                                secondletter = ""
                            if self.mode == "F":
                                height = 50
                            else:
                                height = 20
                            #some times ET is not drawn (ET = 0) when using device NONE
                            if self.temp1[int(self.specialevents[i])] > self.temp2[int(self.specialevents[i])] and aw.qmc.ETcurve:
                                if aw.qmc.flagon:
                                    temp = self.temp1[int(self.specialevents[i])]
                                else:
                                    temp = self.stemp1[int(self.specialevents[i])]
                            elif aw.qmc.BTcurve:
                                if aw.qmc.flagon:
                                    temp = self.temp2[int(self.specialevents[i])]
                                else:
                                    temp = self.stemp2[int(self.specialevents[i])]
                            else:
                                temp = None
                            if temp:
                                self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], temp),
                                             xytext=(self.timex[int(self.specialevents[i])],temp+height),alpha=0.9,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')

                if self.eventsGraphflag == 1 and Nevents:
                    char1 = self.etypes[0][0]
                    char2 = self.etypes[1][0]
                    char3 = self.etypes[2][0]
                    char4 = self.etypes[3][0]

                    if self.mode == "F":
                        row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                    else:
                        row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}

                    #draw lines of color between events of the same type to help identify areas of events.
                    #count (as length of the list) and collect their times for each different type. Each type will have a different plot heigh
                    netypes=[[],[],[],[]]
                    for i in range(Nevents):
                        if self.specialeventstype[i] == 0:
                            netypes[0].append(self.timex[self.specialevents[i]])
                        elif self.specialeventstype[i] == 1:
                            netypes[1].append(self.timex[self.specialevents[i]])
                        elif self.specialeventstype[i] == 2:
                            netypes[2].append(self.timex[self.specialevents[i]])
                        elif self.specialeventstype[i] == 3:
                            netypes[3].append(self.timex[self.specialevents[i]])
                            
                    letters = char1+char2+char3+char4   #"NPDF" fisrt letter for each type (None, Power, Damper, Fan)
                    colors = [self.palette["rect2"],self.palette["rect3"]] #rotating colors
                    for p in range(len(letters)):    
                        if len(netypes[p]) > 1:
                            for i in range(len(netypes[p])-1):
                                #draw differentiating color bars between events and place then in a different height acording with type
                                rect = patches.Rectangle((netypes[p][i], row[letters[p]]), width = (netypes[p][i+1]-netypes[p][i]), height = step, color = colors[i%2],alpha=0.5)
                                self.ax.add_patch(rect)

                    # annotate event
                    for i in range(Nevents):
                        if self.specialeventstype[i] > 3:
                            # a special event of type "--"
                            pass
                        else:
                            firstletter = self.etypes[self.specialeventstype[i]][0]
                            secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                            #some times ET is not drawn (ET = 0) when using device NONE
                            if self.temp1[int(self.specialevents[i])] >= self.temp2[int(self.specialevents[i])]:                            
                                if aw.qmc.flagon:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.temp1[int(self.specialevents[i])]),
                                                 xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                                else:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.stemp1[int(self.specialevents[i])]),
                                                 xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                            else:
                                if aw.qmc.flagon:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.temp2[int(self.specialevents[i])]),
                                             xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                                else:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], self.stemp2[int(self.specialevents[i])]),
                                             xytext=(self.timex[int(self.specialevents[i])],row[firstletter]),alpha=1.,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')

                elif self.eventsGraphflag == 2:
                    self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                    self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                    for i in range(Nevents):
                        if self.specialeventstype[i] == 0:           
                            self.E1timex.append(self.timex[self.specialevents[i]])
                            self.E1values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                        elif self.specialeventstype[i] == 1:
                            self.E2timex.append(self.timex[self.specialevents[i]])
                            self.E2values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                        elif self.specialeventstype[i] == 2:
                            self.E3timex.append(self.timex[self.specialevents[i]])
                            self.E3values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])
                        elif self.specialeventstype[i] == 3:
                            self.E4timex.append(self.timex[self.specialevents[i]])
                            self.E4values.append(self.eventpositionbars[int(self.specialeventsvalue[i])])

                    self.l_eventtype1dots, = self.ax.plot(self.E1timex, self.E1values, color=self.EvalueColor[0], marker=self.EvalueMarker[0],markersize = self.EvalueMarkerSize[0],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[0],alpha = self.Evaluealpha[0],label=self.etypesf(0))
                    self.l_eventtype2dots, = self.ax.plot(self.E2timex, self.E2values, color=self.EvalueColor[1], marker=self.EvalueMarker[1],markersize = self.EvalueMarkerSize[1],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[1],alpha = self.Evaluealpha[1],label=self.etypesf(1))
                    self.l_eventtype3dots, = self.ax.plot(self.E3timex, self.E3values, color=self.EvalueColor[2], marker=self.EvalueMarker[2],markersize = self.EvalueMarkerSize[2],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[2],alpha = self.Evaluealpha[2],label=self.etypesf(2))
                    self.l_eventtype4dots, = self.ax.plot(self.E4timex, self.E4values, color=self.EvalueColor[3], marker=self.EvalueMarker[3],markersize = self.EvalueMarkerSize[3],
                                                          linestyle="steps-post",linewidth = self.Evaluelinethickness[3],alpha = self.Evaluealpha[3],label=self.etypesf(3))

                    handles.extend([self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots])
                    labels.extend([self.etypesf(0),self.etypesf(1),self.etypesf(2),self.etypesf(3)])

                #if recorder on
                if self.flagon:
                    #update to last event
                    if Nevents:
                        aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                        aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                    else:
                        aw.etypeComboBox.setCurrentIndex(0)
                        aw.valueEdit.setText("")
                    aw.eNumberSpinBox.setValue(Nevents)

            #update Y label colors
            for label in self.ax.yaxis.get_ticklabels():
                label.set_color(self.palette["ylabel"])

            #write legend
            if self.legendloc:
                if two_ax_mode:
                    self.delta_ax.legend(handles,labels,loc=self.legendloc,ncol=4,prop=font_manager.FontProperties(size=10),fancybox=True)
                else:
                    self.ax.legend(handles,labels,loc=self.legendloc,ncol=4,prop=font_manager.FontProperties(size=10),fancybox=True)

            ############  ready to plot ############
            self.fig.canvas.draw()
            #######################################

            # if designer ON
            if self.designerflag:
                if self.background:
                    self.ax.lines = self.ax.lines[2:]
                if len(self.timex):
                    self.xaxistosm()
                    self.redrawdesigner()

            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)
            _, _, exc_tb = sys.exc_info()    
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " redraw() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    # adjusts height of annotations
    #supporting function for self.redraw() used to find best height of annotations in graph to avoid annotating over previous annotations (unreadable) when close to each other
    def findtextgap(self,ystep_down,ystep_up,height1,height2,dd=0):
        if dd <= 0:
            d = aw.qmc.ylimit - aw.qmc.ylimit_min
        else:
            d = dd
        init = int(d/15.0)
        gap = int(d/20.0)
        maxx = int(d/3.6)
        for i in range(init,maxx):
            if abs((height1 + ystep_up) - (height2+i)) > gap:
                break      
        for j in range(init,maxx):
            if abs((height1 - ystep_down) - (height2 - j)) > gap:
                break
        return j,i  #return height of arm

    # used to convert time from int seconds to string (like in the LCD clock timer). input int, output string xx:xx
    def stringfromseconds(self, seconds):
        if seconds >= 0:
            return "%02d:%02d"% divmod(seconds, 60)
        else:
            #usually the timex[timeindex[0]] is alreday taken away in seconds before calling stringfromseconds()
            negtime = abs(seconds)
            return "-%02d:%02d"% divmod(negtime, 60)

    #Converts a string into a seconds integer. Use for example to interpret times from Roaster Properties Dlg inputs
    #acepted formats: "00:00","-00:00"
    def stringtoseconds(self, string):
        timeparts = string.split(":")
        if len(timeparts) != 2:
            aw.sendmessage(QApplication.translate("Message","Time format error encountered", None, QApplication.UnicodeUTF8))
            return -1
        else:
            if timeparts[0][0] != "-":  #if number is positive
                seconds = int(timeparts[1])
                seconds += int(timeparts[0])*60
                return seconds
            else:
                seconds = int(timeparts[0])*60
                seconds -= int(timeparts[1])
                return seconds    #return negative number

    def fromFtoC(self,Ffloat):
        return (Ffloat-32.0)*(5.0/9.0)

    def fromCtoF(self,CFloat):
        return (CFloat*9.0/5.0)+32.0

    #sets the graph display in Fahrenheit mode
    def fahrenheitMode(self):
        # just set it to the defaults to avoid strange conversion issues
        self.ylimit = 600
        self.ylimit_min = 0
        self.ygrid = 100
        self.zlimit = 50
        self.zlimit_min = 0
        self.zgrid = 10

        #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
        for i in range(4):
            self.phases[i] = int(round(self.fromCtoF(self.phases[i])))
        self.ax.set_ylabel("F",size=16,color = self.palette["ylabel"]) #Write "F" on Y axis
        self.mode = "F"
        if aw: # during initialization aw is still None!
            aw.FahrenheitAction.setDisabled(True)
            aw.CelsiusAction.setEnabled(True)
            aw.ConvertToFahrenheitAction.setDisabled(True)
            aw.ConvertToCelsiusAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_F_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_F_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_F_default

    #sets the graph display in Celsius mode
    def celsiusMode(self):
        self.ylimit = 350
        self.ylimit_min = 0
        self.ygrid = 50
        self.zlimit = 50
        self.zlimit_min = 0
        self.zgrid = 10
        
        #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
        for i in range(4):
            self.phases[i] = int(round(self.fromFtoC(self.phases[i])))
        self.ax.set_ylabel("C",size=16,color = self.palette["ylabel"]) #Write "C" on Y axis
        self.mode = "C"
        if aw: # during initialization aw is still None
            aw.CelsiusAction.setDisabled(True)
            aw.FahrenheitAction.setEnabled(True)
            aw.ConvertToCelsiusAction.setDisabled(True)
            aw.ConvertToFahrenheitAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_C_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_C_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_C_default

    def fahrenheitModeRedraw(self):
        self.fahrenheitMode()
        self.redraw()

    def celsiusModeRedraw(self):
        self.celsiusMode()
        self.redraw()


    #converts a loaded profile to a different temperature scale. t input is the requested mode (F or C).
    def convertTemperature(self,t):
        #verify there is a loaded profile
        profilelength = len(self.timex)
        if profilelength > 0:
            if t == "F":
                string = QApplication.translate("Message", "Convert profile data to Fahrenheit?",None, QApplication.UnicodeUTF8)
                reply = QMessageBox.question(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),string,
                        QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                elif reply == QMessageBox.Yes:
                    if self.mode == "C":
                        aw.CelsiusAction.setDisabled(True)
                        aw.FahrenheitAction.setEnabled(True)
                        aw.ConvertToCelsiusAction.setDisabled(True)
                        aw.ConvertToFahrenheitAction.setEnabled(True)
                        for i in range(profilelength):
                            self.temp1[i] = self.fromCtoF(self.temp1[i])    #ET
                            self.temp2[i] = self.fromCtoF(self.temp2[i])    #BT
                            if len(self.delta1):
                                self.delta1[i] = self.fromCtoF(self.delta1[i])  #Delta ET
                            if len(self.delta2):
                                self.delta2[i] = self.fromCtoF(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)   
                            if nextra:
                                for e in range(nextra):
                                    aw.qmc.extratemp1[e][i] = self.fromCtoF(aw.qmc.extratemp1[e][i])
                                    aw.qmc.extratemp2[e][i] = self.fromCtoF(aw.qmc.extratemp2[e][i])

                        self.ambientTemp = self.fromCtoF(self.ambientTemp)  #ambient temperature
                        self.bag_humidity[1] = self.fromCtoF(self.bag_humidity[1]) #bag humidity temperature

                        #prevents accidentally deleting a modified profile. 
                        self.safesaveflag = True

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = self.fromCtoF(self.temp1B[i])
                            self.temp2B[i] = self.fromCtoF(self.temp2B[i])

                        self.fahrenheitMode()
                        aw.sendmessage(QApplication.translate("Message","Profile changed to Fahrenheit", None, QApplication.UnicodeUTF8))

                    else:
                        QMessageBox.information(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),
                                                QApplication.translate("Message", "Unable to comply. You already are in Fahrenheit", None, QApplication.UnicodeUTF8))
                        aw.sendmessage(QApplication.translate("Message","Profile not changed", None, QApplication.UnicodeUTF8))
                        return

            elif t == "C":
                string = QApplication.translate("Message", "Convert profile data to Celsius?",None, QApplication.UnicodeUTF8)
                reply = QMessageBox.question(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),string,
                        QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                elif reply == QMessageBox.Yes:
                    if self.mode == "F":    
                        aw.ConvertToFahrenheitAction.setDisabled(True)
                        aw.ConvertToCelsiusAction.setEnabled(True) 
                        aw.FahrenheitAction.setDisabled(True)
                        aw.CelsiusAction.setEnabled(True)   
                        for i in range(profilelength):
                            self.temp1[i] = self.fromFtoC(self.temp1[i])    #ET
                            self.temp2[i] = self.fromFtoC(self.temp2[i])    #BT
                            if self.device != 18:
                                self.delta1[i] = self.fromFtoC(self.delta1[i])  #Delta ET
                                self.delta2[i] = self.fromFtoC(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    aw.qmc.extratemp1[e][i] = self.fromFtoC(aw.qmc.extratemp1[e][i])
                                    aw.qmc.extratemp2[e][i] = self.fromFtoC(aw.qmc.extratemp2[e][i])

                        self.ambientTemp = self.fromFtoC(self.ambientTemp)  #ambient temperature
                        self.bag_humidity[1] = self.fromFtoC(self.bag_humidity[1])  #bag humidity temperature

                        for i in range(len(self.timeB)):
                            self.temp1B[i] = self.fromFtoC(self.temp1B[i]) #ET B
                            self.temp2B[i] = self.fromFtoC(self.temp2B[i]) #BT B

                    else:
                        QMessageBox.information(self,QApplication.translate("Message", "Convert Profile Temperature",None, QApplication.UnicodeUTF8),
                                                QApplication.translate("Message", "Unable to comply. You already are in Celsius",None, QApplication.UnicodeUTF8))
                        aw.sendmessage(QApplication.translate("Message","Profile not changed", None, QApplication.UnicodeUTF8))
                        return

                    self.celsiusMode()
                    aw.sendmessage(QApplication.translate("Message","Profile changed to Celsius", None, QApplication.UnicodeUTF8))

            self.redraw(recomputeAllDeltas=True,smooth=True)

        else:
            QMessageBox.information(self,QApplication.translate("Message", "Convert Profile Scale",None, QApplication.UnicodeUTF8),
                                          QApplication.translate("Message", "No profile data found",None, QApplication.UnicodeUTF8))


    #selects color mode: input 1=color mode; input 2=black and white mode (printing); input 3 = customize colors
    def changeGColor(self,color):
        #COLOR (option 1) Default
        palette1 = {"background":'white',"grid":'green',"ylabel":'black',"xlabel":'black',"title":'black',"rect1":'green',
                        "rect2":'orange',"rect3":'#996633',"rect4":'lightblue',"et":'red',"bt":'#00007f',"deltaet":'orange',
                        "deltabt":'blue',"markers":'black',"text":'black',"watermarks":'yellow',"Cline":'blue'}

        #BLACK & WHITE (option 2) best for printing
        palette2 = {"background":'white',"grid":'grey',"ylabel":'black',"xlabel":'black',"title":'black',"rect1":'lightgrey',
                   "rect2":'darkgrey',"rect3":'grey',"rect4":'lightgrey',"et":'black',"bt":'black',"deltaet":'grey',
                   "deltabt":'grey',"markers":'grey',"text":'black',"watermarks":'lightgrey',"Cline":'grey'}

        #load selected dictionary
        if color == 1:
            aw.sendmessage(QApplication.translate("Message","Colors set to defaults", None, QApplication.UnicodeUTF8))
            for key in list(palette1.keys()):
                self.palette[key] = palette1[key]
            
        if color == 2:
            aw.sendmessage(QApplication.translate("Message","Colors set to grey", None, QApplication.UnicodeUTF8))
            for key in list(palette1.keys()):
                self.palette[key] = palette2[key]
                
        if color == 3:
            dialog = graphColorDlg(self)
            if dialog.exec_():
                self.palette["background"] = str(dialog.backgroundLabel.text())
                self.palette["grid"] = str(dialog.gridLabel.text())
                self.palette["ylabel"] = str(dialog.yLabel.text())
                self.palette["xlabel"] = str(dialog.xLabel.text())
                self.palette["title"] = str(dialog.titleLabel.text())
                self.palette["rect1"] = str(dialog.rect1Label.text())
                self.palette["rect2"] = str(dialog.rect2Label.text())
                self.palette["rect3"] = str(dialog.rect3Label.text())
                self.palette["rect4"] = str(dialog.rect4Label.text())
                self.palette["et"] = str(dialog.metLabel.text())
                self.palette["bt"] = str(dialog.btLabel.text())
                self.palette["deltaet"] = str(dialog.deltametLabel.text())
                self.palette["deltabt"] = str(dialog.deltabtLabel.text())
                self.palette["markers"] = str(dialog.markersLabel.text())
                self.palette["text"] = str(dialog.textLabel.text())
                self.palette["watermarks"] = str(dialog.watermarksLabel.text())
                self.palette["Cline"] = str(dialog.ClineLabel.text())

        #update screen with new colors
        self.fig.canvas.redraw()

    #draws a polar star graph to score cupping. It does not delete any profile data.
    def flavorchart(self):

        pi = math.pi
        self.fig.clf()
        #create a new name ax1 instead of ax (ax is used when plotting profiles)

        self.ax1 = self.fig.add_subplot(111,projection='polar', axisbg=self.backcolor) #) radar green axisbg='#d5de9c'
        self.ax1.set_aspect(self.flavoraspect)

        #find number of divisions
        nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])

        g_angle = numpy.arange(self.flavorstartangle,(360.+self.flavorstartangle),(360./nflavors))  #angles in degree
        self.ax1.set_thetagrids(g_angle)
        self.ax1.set_rmax(1.)
        self.ax1.set_autoscale_on(False)
        self.ax1.grid(True,linewidth=1.,color='green', linestyle = "-",alpha=.3)

        #create water marks 6-7 anf 8-9
        self.ax1.bar(.1, .1, width=2.*pi, bottom=.6,color="green",linewidth=0.,alpha = .1)
        self.ax1.bar(.1, .1, width=2.*pi, bottom=.8,color="green",linewidth=0.,alpha = .1)

        #delete degrees ticks to anotate flavor characteristics 
        for tick in self.ax1.xaxis.get_major_ticks():
            tick.label1On = False

        #rename yaxis 
        locs = self.ax1.get_yticks()
        labels = []
        for i in range(len(locs)):
            stringlabel = str(locs[i]*10.)
            labels.append(stringlabel)              
        self.ax1.set_yticklabels(labels,color=self.palette["xlabel"])

        step = 2.*pi/nflavors
        angles = [math.radians(self.flavorstartangle)]   #angles in radians
        for i in range(nflavors-1): angles.append(angles[-1] + step)

        #To close circle we need one more element. angle and values need same dimension in order to plot. 
        plotf = self.flavors[:]
        plotf.append(self.flavors[0])
        #normalize flavor values to 0-1 range
        for i in range(len(plotf)):
            plotf[i] /= 10.
        angles.append(angles[-1]+step)
        
        #anotate labels
        for i in range(len(self.flavorlabels)):
            if angles[i] > 2.*pi or angles[i] < 0.:
                _,angles[i] = divmod(angles[i],(2.*pi))
            if angles[i] <= (pi/2.) or angles[i] >= (1.5*pi): #if < 90 or smaller than 270 degress
                ha = "left"
            else:
                ha = "right"
            self.ax1.annotate(self.flavorlabels[i] + " = " + str("%.2f"%self.flavors[i]),xy =(angles[i],.9),
                              xytext=(angles[i],1.1),horizontalalignment=ha,verticalalignment='bottom')

        score = 0.
        for i in range(nflavors):
            score += self.flavors[i]
        score /= (nflavors)
        score *= 10.

        txt = "%.2f" %score
        self.ax1.text(0.,0.,txt,fontsize=20,color="blue",horizontalalignment="center",bbox={"facecolor":"yellow", "alpha":0.3, "pad":10})

        #add background to plot if found
        if self.background:
            if self.flavorbackgroundflag:
                backgroundplotf = self.backgroundFlavors[:]
                backgroundplotf.append(self.backgroundFlavors[0])
                #normalize flavor values to 0-1 range
                for i in range(len(backgroundplotf)):
                    backgroundplotf[i] /= 10.

                self.ax1.plot(angles,backgroundplotf,color="orange",marker="o",alpha=.5)
                #needs matplotlib 1.0.0+
                if mpl.__version__.split(".")[0] == '1':
                    self.ax1.fill_between(angles,0,backgroundplotf, facecolor="yellow", alpha=0.1, interpolate=True)

        #add to plot
        self.ax1.plot(angles,plotf,color="blue",marker="o")
        
        #needs matplotlib 1.0.0+
        if mpl.__version__.split(".")[0] == '1':
            self.ax1.fill_between(angles,0,plotf, facecolor='green', alpha=0.1, interpolate=True)

        self.fig.canvas.draw()

    def OnMonitor(self):
        self.timeclock.start()   #set time to the current computer time
        self.flagon = True
        if self.designerflag: return
        aw.sendmessage(QApplication.translate("Message","Scope monitoring...", None, QApplication.UnicodeUTF8))
        #disable RESET button:
        aw.button_7.setEnabled(False)
        aw.button_7.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
        aw.button_1.setStyleSheet(aw.pushbuttonstyles["ON"])
        aw.button_1.setText(QApplication.translate("Button", "OFF",None, QApplication.UnicodeUTF8)) # text means click to turn OFF (it is ON)
        aw.button_1.setToolTip(QApplication.translate("Tooltip", "Stop monitoring", None, QApplication.UnicodeUTF8))
        aw.button_2.setEnabled(True) # ensure that the START button is enabled
        aw.showLCDs()
        aw.showSliders()
        aw.disableEditMenus()
        if aw.extraeventsbuttonsflag:
            aw.showExtraButtons()
        self.threadserver.createSampleThread()

    def OffMonitor(self):
        # first activate "Stopping Mode" to ensure that sample() is not reseting the timer now (independent of the flagstart state)
        if self.HUDflag:
            self.toggleHUD()
        # stop Recorder if still running
        if self.flagstart:
            self.OffRecorder()
        self.flagstopping = True
        self.flagon = False
        # now wait until the sampling thread successfully terminates
        while self.flagstopping:
            libtime.sleep(.3)
        # clear data from monitoring-only mode
        if len(self.timex) == 1:
            aw.qmc.clearMeasurements()
        #enable RESET button:
        aw.button_7.setStyleSheet(aw.pushbuttonstyles["RESET"])
        aw.button_7.setEnabled(True)
        aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
        aw.button_1.setToolTip(QApplication.translate("Tooltip", "Start monitoring", None, QApplication.UnicodeUTF8))
        aw.sendmessage(QApplication.translate("Message","Scope stopped", None, QApplication.UnicodeUTF8))
        aw.button_1.setText(QApplication.translate("Button", "ON",None, QApplication.UnicodeUTF8)) # text means click to turn OFF (it is ON)
        # reset time LCD color to the default (might have been changed to red due to long cooling!)
        aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        aw.lcd1.display("00:00")
        aw.hideLCDs()
        aw.hideSliders()
        aw.hideExtraButtons()
        aw.enableEditMenus()

    #Turns ON/OFF flag self.flagon to read and print values. Called from push button_1.
    def ToggleMonitor(self):
        #turn ON
        if not self.flagon:
            aw.soundpop()
            if self.timex != []:
                aw.qmc.reset(True,False)
            self.OnMonitor()
        #turn OFF
        else:
            aw.soundpop()
            self.OffMonitor()

    def OnRecorder(self):
        # start Monitor if not yet running
        if not self.flagon:
            self.OnMonitor()
        self.flagstart = True

        aw.disableSaveActions()

        aw.sendmessage(QApplication.translate("Message","Scope recording...", None, QApplication.UnicodeUTF8))
        aw.button_2.setEnabled(False)
        aw.button_2.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
        aw.button_1.setToolTip(QApplication.translate("Tooltip", "Stop recording", None, QApplication.UnicodeUTF8))
        aw.button_1.setEnabled(True) # ensure that the OFF button is enabled
        #disable RESET button:
        aw.button_7.setEnabled(False)
        aw.button_7.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
        aw.button_18.setEnabled(True)
        aw.button_18.setStyleSheet(aw.pushbuttonstyles["HUD_OFF"])
        self.updateLCDtime()
        aw.lowerbuttondialog.setVisible(True)
        aw.update_minieventline_visibility()

    def OffRecorder(self):
        aw.enableSaveActions()
        self.flagstart = False
        aw.button_2.setStyleSheet(aw.pushbuttonstyles["STOP"])
        aw.button_2.setEnabled(True)   
        #enable RESET button:
        aw.button_7.setStyleSheet(aw.pushbuttonstyles["RESET"]) 
        aw.button_7.setEnabled(True)
        aw.button_18.setStyleSheet(aw.pushbuttonstyles["DISABLED"])
        aw.button_18.setEnabled(False)
        self.updateLCDtime()
        self.redraw(smooth=True)
        #prevents accidentally deleting a modified profile.
        if len(self.timex) > 2:
            self.safesaveflag = True
        aw.sendmessage(QApplication.translate("Message","Scope recording stopped", None, QApplication.UnicodeUTF8))
        aw.button_2.setText(QApplication.translate("Button", "START",None, QApplication.UnicodeUTF8))
        aw.lowerbuttondialog.setVisible(False)
        aw.hideEventsMinieditor()

    #Turns START/STOP flag self.flagon to read and plot. Called from push button_2.
    def ToggleRecorder(self):
        #turn START
        if not self.flagstart:
            aw.soundpop()
            if self.flagon and len(self.timex) == 1:
                # we are already in monitoring mode, we just clear this first measurement and go
                aw.qmc.clearMeasurements()
            elif self.timex != []: # there is a profile loaded, we have to reset
                aw.qmc.reset(True,False)
            self.OnRecorder()
        #turn STOP
        else:
            aw.soundpop()
            self.OffRecorder()

    #Records charge (put beans in) marker. called from push button 'Charge'
    def markCharge(self):
        try:
            if self.flagon:
                aw.soundpop()
                #prevents accidentally deleting a modified profile.
                self.safesaveflag = True
                self.samplingsemaphore.acquire(1)
                if self.device != 18:
                    if self.autoChargeIdx:
                        self.timeindex[0] = self.autoChargeIdx
                    else:
                        if len(self.timex) > 0:
                            self.timeindex[0] = len(self.timex)-1
                        else:
                            message = QApplication.translate("Message","Not enough variables collected yet. Try again in a few seconds", None, QApplication.UnicodeUTF8)
                #device 18  = manual mode
                else:
                    tx,et,bt = aw.ser.NONE()
                    if bt != 1 and et != -1:  #cancel
                        self.drawmanual(et,bt,tx)
                        self.timeindex[0] = len(self.timex)-1
                    else:
                        if self.samplingsemaphore.available() < 1:
                            self.samplingsemaphore.release(1)
                        return
                self.xaxistosm() # not needed here? eventuell integrate this into timealign if shift happend
                d = aw.qmc.ylimit - aw.qmc.ylimit_min
                st1 = QApplication.translate("Scope Annotation", "START 00:00", None, QApplication.UnicodeUTF8)
                t2 = self.temp2[self.timeindex[0]]
                tx = self.timex[self.timeindex[0]]
                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,t2,t2,d)
                self.annotate(t2,st1,tx,t2,self.ystep_up,self.ystep_down)
                self.fig.canvas.draw()
                if self.samplingsemaphore.available() < 1:
                    self.samplingsemaphore.release(1)
                # redraw (within timealign) should not be called if semaphore is hold!
                aw.qmc.timealign(redraw=True,recompute=False)
                try:
                    a = aw.qmc.buttonactions[0]
                    aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[0])
                except:
                    pass
                aw.button_8.setDisabled(True)
                aw.button_8.setFlat(True)
                message = QApplication.translate("Message","Roast time starts now 00:00 BT = %1",None, QApplication.UnicodeUTF8).arg(str(self.temp2[self.timeindex[0]]) + self.mode)
                aw.sendmessage(message) 
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markCharge() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)


    def markDryEnd(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    if self.device != 18:
                        self.timeindex[1] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[1] = len(self.timex)-1
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    if aw.qmc.phasesbuttonflag:
                        self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
                    #calculate time elapsed since charge time
                    st1 = QApplication.translate("Scope Annotation","DE %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]]))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[1]],d)
                    self.annotate(self.temp2[self.timeindex[1]],st1,self.timex[self.timeindex[1]],self.temp2[self.timeindex[1]],self.ystep_up,self.ystep_down)
                    self.fig.canvas.draw()
                    st1 = self.stringfromseconds(self.timex[self.timeindex[1]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[1]] + self.mode
                    if self.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
                    aw.button_19.setDisabled(True) # deactivate DRY button
                    aw.button_19.setFlat(True)
                    aw.button_8.setDisabled(True) # also deactivate CHARGE button
                    aw.button_8.setFlat(True)
                    try:
                        a = aw.qmc.buttonactions[1]
                        aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[1])
                    except:
                        pass
                    message = QApplication.translate("Message","[DRY END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                    #set message at bottom
                    aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markDryEnd() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    #record 1C start markers of BT. called from push button_3 of application window
    def mark1Cstart(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    # record 1Cs only if Charge mark has been done
                    if self.device != 18:                
                        self.timeindex[2] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[2] = len(self.timex)-1
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    if aw.qmc.phasesbuttonflag:
                        self.phases[2] = int(round(self.temp2[self.timeindex[2]]))
                    #calculate time elapsed since charge time
                    st1 = QApplication.translate("Scope Annotation","FCs %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[2]]-self.timex[self.timeindex[0]]))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    if self.timeindex[1]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[2]],d)
                    else:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[2]],d)
                    self.annotate(self.temp2[self.timeindex[2]],st1,self.timex[self.timeindex[2]],self.temp2[self.timeindex[2]],self.ystep_up,self.ystep_down)
                    self.fig.canvas.draw()
                    st1 = self.stringfromseconds(self.timex[self.timeindex[2]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[2]] + self.mode
                    if self.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
                    aw.button_3.setDisabled(True) # deactivate FCs button
                    aw.button_3.setFlat(True)
                    aw.button_8.setDisabled(True) # also deactivate CHARGE button
                    aw.button_8.setFlat(True)
                    aw.button_19.setDisabled(True) # also deactivate DRY button
                    aw.button_19.setFlat(True)
                    try:
                        a = aw.qmc.buttonactions[2]
                        aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[2])
                    except:
                        pass
                    message = QApplication.translate("Message","[FC START] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                    aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark1Cstart() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    #record 1C end markers of BT. called from button_4 of application window
    def mark1Cend(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    if self.device != 18:
                        self.timeindex[3] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[3] = len(self.timex)-1
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    #calculate time elapsed since charge time
                    st1 = QApplication.translate("Scope Annotation","FCe %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[3]]-self.timex[self.timeindex[0]]))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[3]],d)
                    self.annotate(self.temp2[self.timeindex[3]],st1,self.timex[self.timeindex[3]],self.temp2[self.timeindex[3]],self.ystep_up,self.ystep_down)
                    self.fig.canvas.draw()
                    st1 = self.stringfromseconds(self.timex[self.timeindex[3]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[3]] + self.mode
                    if self.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
                    aw.button_4.setDisabled(True) # deactivate FCe button
                    aw.button_4.setFlat(True)
                    aw.button_8.setDisabled(True) # also deactivate CHARGE button
                    aw.button_8.setFlat(True)
                    aw.button_19.setDisabled(True) # also deactivate DRY button
                    aw.button_19.setFlat(True)
                    aw.button_3.setDisabled(True) # also deactivate FCs button
                    aw.button_3.setFlat(True)
                    try:
                        a = aw.qmc.buttonactions[3]
                        aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[3])
                    except:
                        pass
                    message = QApplication.translate("Message","[FC END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                    aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark1Cend() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    #record 2C start markers of BT. Called from button_5 of application window
    def mark2Cstart(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile. 
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    if self.device != 18:
                        self.timeindex[4] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[4] = len(self.timex)-1
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    st1 = QApplication.translate("Scope Annotation","SCs %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[4]]-self.timex[self.timeindex[0]]))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    if self.timeindex[3]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[4]],d)
                    else:
                        self.ystep_down,self.ystep_up = self.findtextgap(0,0,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[4]],d)
                    self.annotate(self.temp2[self.timeindex[4]],st1,self.timex[self.timeindex[4]],self.temp2[self.timeindex[4]],self.ystep_up,self.ystep_down)
                    self.fig.canvas.draw()
                    st1 = self.stringfromseconds(self.timex[self.timeindex[4]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[4]] + self.mode
                    if self.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
                    aw.button_5.setDisabled(True) # deactivate SCs button
                    aw.button_5.setFlat(True)
                    aw.button_8.setDisabled(True) # also deactivate CHARGE button
                    aw.button_8.setFlat(True)
                    aw.button_19.setDisabled(True) # also deactivate DRY button
                    aw.button_19.setFlat(True)
                    aw.button_3.setDisabled(True) # also deactivate FCs button
                    aw.button_3.setFlat(True)
                    aw.button_4.setDisabled(True) # also deactivate FCe button
                    aw.button_4.setFlat(True)
                    try:
                        a = aw.qmc.buttonactions[4]
                        aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[4])
                    except:
                        pass
                    message = QApplication.translate("Message","[SC START] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                    aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark2Cstart() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    #record 2C end markers of BT. Called from button_6  of application window
    def mark2Cend(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                   aw.soundpop()
                   #prevents accidentally deleting a modified profile.
                   self.safesaveflag = True
                   self.samplingsemaphore.acquire(1)
                   if self.device != 18:
                       self.timeindex[5] = len(self.timex)-1
                   else:
                       tx,et,bt = aw.ser.NONE()
                       if et != -1 and bt != -1:
                           self.drawmanual(et,bt,tx)
                           self.timeindex[5] = len(self.timex)-1
                       else:
                           if self.samplingsemaphore.available() < 1:
                               self.samplingsemaphore.release(1)
                           return
                   st1 =  QApplication.translate("Scope Annotation","SCe %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[5]]-self.timex[self.timeindex[0]]))
                   d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                   self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[5]],d)
                   self.annotate(self.temp2[self.timeindex[5]],st1,self.timex[self.timeindex[5]],self.temp2[self.timeindex[5]],self.ystep_up,self.ystep_down)
                   self.fig.canvas.draw()
                   st1 = self.stringfromseconds(self.timex[self.timeindex[5]]-self.timex[self.timeindex[0]])
                   st2 = "%.1f "%self.temp2[self.timeindex[5]] + self.mode
                   if self.samplingsemaphore.available() < 1:
                       self.samplingsemaphore.release(1)
                   aw.button_6.setDisabled(True) # deactivate SCe button
                   aw.button_6.setFlat(True)
                   aw.button_8.setDisabled(True) # also deactivate CHARGE button
                   aw.button_8.setFlat(True)
                   aw.button_19.setDisabled(True) # also deactivate DRY button
                   aw.button_19.setFlat(True)
                   aw.button_3.setDisabled(True) # also deactivate FCs button
                   aw.button_3.setFlat(True)
                   aw.button_4.setDisabled(True) # also deactivate FCe button
                   aw.button_4.setFlat(True)
                   aw.button_5.setDisabled(True) # also deactivate SCs button
                   aw.button_5.setFlat(True)
                   try:
                       a = aw.qmc.buttonactions[5]
                       aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[5])
                   except:
                       pass
                   message = QApplication.translate("Message","[SC END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                   aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " mark2Cend() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:            
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    #record end of roast (drop of beans). Called from push button 'Drop'
    def markDrop(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    if self.device != 18:
                        if self.autoDropIdx:
                            self.timeindex[6] = self.autoDropIdx
                        else:
                            self.timeindex[6] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[6] = len(self.timex)-1
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    st1 = QApplication.translate("Scope Annotation","END %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]))
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    if self.timeindex[5]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[5]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[4]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[3]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[2]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[6]],d)
                    elif self.timeindex[1]:
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[6]],d)
                    self.annotate(self.temp2[self.timeindex[6]],st1,self.timex[self.timeindex[6]],self.temp2[self.timeindex[6]],self.ystep_up,self.ystep_down)
                    self.fig.canvas.draw()
                    st1 = self.stringfromseconds(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[6]] + self.mode
                    if self.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
                    aw.button_9.setDisabled(True) # deactivate DROP button
                    aw.button_9.setFlat(True)
                    aw.button_8.setDisabled(True) # also deactivate CHARGE button
                    aw.button_8.setFlat(True)
                    aw.button_19.setDisabled(True) # also deactivate DRY button
                    aw.button_19.setFlat(True)
                    aw.button_3.setDisabled(True) # also deactivate FCs button
                    aw.button_3.setFlat(True)
                    aw.button_4.setDisabled(True) # also deactivate FCe button
                    aw.button_4.setFlat(True)
                    aw.button_5.setDisabled(True) # also deactivate SCs button
                    aw.button_5.setFlat(True)
                    aw.button_6.setDisabled(True) # also deactivate SCe button
                    aw.button_6.setFlat(True)
                    try:
                        # update ambient temperature if a ambient temperature source is configured and no value yet established
                        if aw.qmc.ambientTemp == 0.0:
                            aw.qmc.updateAmbientTemp()
                    except:
                        pass
                    try:
                        a = aw.qmc.buttonactions[6]
                        aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[6])
                    except:
                        pass
                    message = QApplication.translate("Message","Roast ended at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                    aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markDrop() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    def markCoolEnd(self):
        try:
            if self.flagon:
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    if self.device != 18:
                        self.timeindex[7] = len(self.timex)-1
                    else:
                        tx,et,bt = aw.ser.NONE()
                        if et != -1 and bt != -1:
                            self.drawmanual(et,bt,tx)
                            self.timeindex[7] = len(self.timex)-1
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    if aw.qmc.phasesbuttonflag:
                        self.phases[1] = int(round(self.temp2[self.timeindex[7]]))
                    #calculate time elapsed since charge time
                    st1 = QApplication.translate("Scope Annotation","CE %1", None, QApplication.UnicodeUTF8).arg(self.stringfromseconds(self.timex[self.timeindex[7]] - self.timex[self.timeindex[0]]))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[6]],self.temp2[self.timeindex[7]],d)
                    self.annotate(self.temp2[self.timeindex[7]],st1,self.timex[self.timeindex[7]],self.temp2[self.timeindex[7]],self.ystep_up,self.ystep_down)
                    self.fig.canvas.draw()
                    st1 = self.stringfromseconds(self.timex[self.timeindex[7]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[7]] + self.mode
                    if self.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
                    aw.button_20.setDisabled(True) # deactivate COOL button
                    aw.button_20.setFlat(True)
                    aw.button_8.setDisabled(True) # also deactivate CHARGE button
                    aw.button_8.setFlat(True)
                    aw.button_19.setDisabled(True) # also deactivate DRY button
                    aw.button_19.setFlat(True)
                    aw.button_3.setDisabled(True) # also deactivate FCs button
                    aw.button_3.setFlat(True)
                    aw.button_4.setDisabled(True) # also deactivate FCe button
                    aw.button_4.setFlat(True)
                    aw.button_5.setDisabled(True) # also deactivate SCs button
                    aw.button_5.setFlat(True)
                    aw.button_6.setDisabled(True) # also deactivate SCe button
                    aw.button_6.setFlat(True)
                    aw.button_9.setDisabled(True) # also deactivate DROP button
                    aw.button_9.setFlat(True)
                    try:
                        a = aw.qmc.buttonactions[7]
                        aw.eventaction((a if (a < 3) else a + 1),aw.qmc.buttonactionstrings[7])
                    except:
                        pass
                    message = QApplication.translate("Message","[COOL END] recorded at %1 BT = %2", None, QApplication.UnicodeUTF8).arg(st1).arg(st2)
                    #set message at bottom
                    aw.sendmessage(message)
            else:
                message = QApplication.translate("Message","Scope is OFF", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " markCoolEnd() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    def EventRecord(self,extraevent=None):
        try:
            if extraevent!=None:
                self.EventRecordAction(
                    extraevent=extraevent,
                    eventtype=aw.extraeventstypes[extraevent],
                    eventvalue=aw.extraeventsvalues[extraevent],
                    eventdescription=aw.extraeventsdescriptions[extraevent])
            else:
                self.EventRecordAction(extraevent=extraevent)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " EventRecord() %1").arg(str(e)),exc_tb.tb_lineno)

    #Marks location in graph of special events. For example change a fan setting.
    #Uses the position of the time index (variable self.timex) as location in time
    # extraevent is given when called from aw.recordextraevent() from an extra Event Button
    def EventRecordAction(self,extraevent=None,eventtype=None,eventvalue=None,eventdescription=""):
        try:
            if self.flagon:
                if len(self.timex) > 0 or self.device == 18:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.safesaveflag = True
                    self.samplingsemaphore.acquire(1)
                    Nevents = len(self.specialevents)
                    #if in manual mode record first the last point in self.timex[]
                    if self.device == 18:
                        tx,et,bt = aw.ser.NONE()
                        if bt != -1 or et != -1:
                            self.drawmanual(et,bt,tx)
                        else:
                            if self.samplingsemaphore.available() < 1:
                                self.samplingsemaphore.release(1)
                            return
                    #i = index number of the event (current length of the time list)
                    i = len(self.timex)-1
                    # if Desciption, Type and Value of the new event equals the last recorded one, we do not record this again!
                    if not(self.specialeventstype) or not(self.specialeventsvalue) or not(self.specialeventsStrings) or not(self.specialeventstype[-1] == eventtype and self.specialeventsvalue[-1] == eventvalue and self.specialeventsStrings[-1] == eventdescription):
                        self.specialevents.append(i)
                        self.specialeventstype.append(4)
                        self.specialeventsStrings.append(str(Nevents+1))
                        self.specialeventsvalue.append(0)
                        #if event was initiated by an Extra Event Button then change the type,value,and string 
                        if extraevent != None:
                            self.specialeventstype[-1] = eventtype
                            self.specialeventsvalue[-1] = eventvalue
                            self.specialeventsStrings[-1] = eventdescription
                        etype = self.specialeventstype[-1]
                        if etype == 0:
                            self.E1timex.append(self.timex[self.specialevents[-1]])
                            self.E1values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        elif etype == 1:
                            self.E2timex.append(self.timex[self.specialevents[-1]])
                            self.E2values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        elif etype == 2:
                            self.E3timex.append(self.timex[self.specialevents[-1]])
                            self.E3values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        elif etype == 3:
                            self.E4timex.append(self.timex[self.specialevents[-1]])
                            self.E4values.append(self.eventpositionbars[int(self.specialeventsvalue[-1])])
                        #write label in mini recorder if flag checked
                        if aw.minieventsflag:
                            aw.eNumberSpinBox.setValue(Nevents+1)
                            aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                            aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                            aw.lineEvent.setText(self.specialeventsStrings[Nevents])
                        #if Event show flag
                        if self.eventsshowflag:
                            index = self.specialevents[-1]
                            firstletter = self.etypesf(self.specialeventstype[-1])[0]
                            secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                            if self.eventsGraphflag == 0:
                                if self.mode == "F":
                                    height = 50
                                else:
                                    height = 20
                                #some times ET is not drawn (ET = 0) when using device NONE
                                if self.temp1[index] > self.temp2[index]:
                                    temp = self.temp1[index]
                                else:
                                    temp = self.temp2[index]
                                self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                            #if Event Type-Bars flag
                            elif self.eventsGraphflag == 1:
                                char1 = self.etypesf(0)[0]
                                char2 = self.etypesf(1)[0]
                                char3 = self.etypesf(2)[0]
                                char4 = self.etypesf(3)[0]
                                if self.mode == "F":
                                    row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                                else:
                                    row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}
                                #some times ET is not drawn (ET = 0) when using device NONE
                                if self.temp1[index] >= self.temp2[index]:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                                     color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                                else:
                                    self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                                 color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                            elif self.eventsGraphflag == 2:
                                # update lines data using the lists with new data
                                if etype == 0:
                                    self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                                elif etype == 1:
                                    self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                                elif etype == 2:
                                    self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                                elif etype == 3:
                                    self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                        self.fig.canvas.draw()
                        temp = "%.1f "%self.temp2[i]
                        timed = self.stringfromseconds(self.timex[i])
                        message = QApplication.translate("Message","Event # %1 recorded at BT = %2 Time = %3", None, QApplication.UnicodeUTF8).arg(str(Nevents+1)).arg(temp).arg(timed)
                        aw.sendmessage(message)
                if self.samplingsemaphore.available() < 1:
                    self.samplingsemaphore.release(1)
            else:
                aw.sendmessage(QApplication.translate("Message","Timer is OFF", None, QApplication.UnicodeUTF8))
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " EventRecordAction() %1").arg(str(e)),exc_tb.tb_lineno)
            return
        finally:            
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    #called from controlling devices when roasting to record steps (commands) and produce a profile later
    def DeviceEventRecord(self,command):
        try:
            if self.flagon:
                #prevents accidentally deleting a modified profile.
                self.safesaveflag = True
                self.samplingsemaphore.acquire(1)
                #number of events
                Nevents = len(self.specialevents)
                #index number            
                i = len(self.timex)-1
                if i > 0:
                    self.specialevents.append(i)                                     # store absolute time index
                    self.specialeventstype.append(0)                                 # set type (to the first index 0)
                    self.specialeventsStrings.append(command)                        # store the command in the string section of events (not a binary string)
                    self.specialeventsvalue.append(0)                                # empty
                    temp = str(self.temp2[i])
                    if self.timeindex[0] != -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    timed = self.stringfromseconds(self.timex[i]-start)
                    message = QApplication.translate("Message","Computer Event # %1 recorded at BT = %2 Time = %3", None, QApplication.UnicodeUTF8).arg(str(Nevents+1)).arg(temp).arg(timed)
                    aw.sendmessage(message)
                    #write label in mini recorder if flag checked
                    if aw.minieventsflag:
                        aw.eNumberSpinBox.setValue(Nevents+1)
                        aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                        aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                        aw.lineEvent.setText(self.specialeventsStrings[Nevents])
                #if Event show flag
                if self.eventsshowflag:
                    index = self.specialevents[-1]
                    firstletter = self.etypesf(self.specialeventstype[-1])[0]
                    secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                    if self.eventsGraphflag == 0:
                        if self.mode == "F":
                            height = 50
                        else:
                            height = 20
                        #some times ET is not drawn (ET = 0) when using device NONE
                        if self.temp1[index] > self.temp2[index]:
                            temp = self.temp1[index]
                        else:
                            temp = self.temp2[index]
                        self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                         color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                    #if Event Type-Bars flag
                    if self.eventsGraphflag == 1:
                        char1 = self.etypesf(0)[0]
                        char2 = self.etypesf(1)[0]
                        char3 = self.etypesf(2)[0]
                        char4 = self.etypesf(3)[0]
                        if self.mode == "F":
                            row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                        else:
                            row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}
                        #some times ET is not drawn (ET = 0) when using device NONE
                        if self.temp1[index] >= self.temp2[index]:
                            self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                        else:
                            self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[firstletter]),alpha=1.,
                                         color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),fontsize=8,backgroundcolor='yellow')
                    if self.eventsGraphflag == 2:
                        # update lines data using the lists with new data
                        etype = self.specialeventstype[-1]
                        if etype == 0:
                            self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                        elif etype == 1:
                            self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                        elif etype == 2:
                            self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                        elif etype == 3:
                            self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                    self.fig.canvas.draw()
                    if aw.qmc.samplingsemaphore.available() < 1:
                        self.samplingsemaphore.release(1)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " DeviceEventRecord() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)

    # Writes information about the finished profile in the graph
    def writestatistics(self):
        try:
            TP_index = aw.findTP()
            if self.timeindex[1] and self.phasesbuttonflag:
                #manual dryend available
                dryEndIndex = self.timeindex[1]
            else:
                #find when dry phase ends 
                dryEndIndex = aw.findDryEnd(TP_index)
            dryEndTime = self.timex[dryEndIndex]
    
            #if DROP
            if self.timeindex[6] and self.timeindex[2]:
                totaltime = int(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]])
                if totaltime == 0:
                    aw.sendmessage(QApplication.translate("Message","Statistics cancelled: need complete profile [CHARGE] + [DROP]", None, QApplication.UnicodeUTF8))
                    return
    
                self.statisticstimes[0] = totaltime
                dryphasetime = int(dryEndTime - self.timex[self.timeindex[0]])
                midphasetime = int(self.timex[self.timeindex[2]] - dryEndTime)
                finishphasetime = int(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])
    
                if self.timeindex[7]:
                    coolphasetime = int(self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]])
                else:
                    coolphasetime = 0
    
                self.statisticstimes[1] = dryphasetime
                self.statisticstimes[2] = midphasetime
                self.statisticstimes[3] = finishphasetime
                self.statisticstimes[4] = coolphasetime
                
                #dry time string
                st1 = self.stringfromseconds(dryphasetime)
    
                #mid time string
                st2 = self.stringfromseconds(midphasetime)
    
                #finish time string
                st3 = self.stringfromseconds(finishphasetime)
                
                if coolphasetime:
                    st4 = self.stringfromseconds(coolphasetime)
                else:
                    st4 = ""
    
                #calculate the positions for the statistics elements
                ydist = self.ylimit - self.ylimit_min
                statisticsbarheight = ydist/80
    
                if aw.qmc.legendloc in [1,2,9]:
                    # legend on top
                    statisticsheight = self.ylimit - (0.13 * ydist) # standard positioning
                else:
                    # legend not on top
                    statisticsheight = self.ylimit - (0.06 * ydist) 
                
                statisticsupper = statisticsheight + statisticsbarheight + 2
                statisticslower = statisticsheight - 2.3*statisticsbarheight
    
                if self.statisticsflags[1]:
    
                    #Draw cool phase rectangle
                    if self.timeindex[7]:
                        rect = patches.Rectangle((self.timex[self.timeindex[6]], statisticsheight), width = coolphasetime, height = statisticsbarheight,
                                                color = self.palette["rect4"],alpha=0.5)
                        self.ax.add_patch(rect)
    
                    if self.timeindex[2]: # only if FCs exists
                        #Draw finish phase rectangle
                        #check to see if end of 1C exists. If so, use half between start of 1C and end of 1C. Otherwise use only the start of 1C
                        rect = patches.Rectangle((self.timex[self.timeindex[2]], statisticsheight), width = finishphasetime, height = statisticsbarheight,
                                                color = self.palette["rect3"],alpha=0.5)
                        self.ax.add_patch(rect)
    
                        # Draw mid phase rectangle
                        rect = patches.Rectangle((self.timex[self.timeindex[0]]+dryphasetime, statisticsheight), width = midphasetime, height = statisticsbarheight,
                                              color = self.palette["rect2"],alpha=0.5)
                        self.ax.add_patch(rect)
    
                    # Draw dry phase rectangle
                    rect = patches.Rectangle((self.timex[self.timeindex[0]], statisticsheight), width = dryphasetime, height = statisticsbarheight,
                                              color = self.palette["rect1"],alpha=0.5)
                    self.ax.add_patch(rect)
    
                dryphaseP = dryphasetime*100/totaltime
                midphaseP = midphasetime*100/totaltime
                finishphaseP = finishphasetime*100/totaltime
                            
                #find Lowest Point in BT
                LP = 1000 
                if TP_index >= 0:
                    LP = self.temp2[TP_index]
    
    
                if self.statisticsflags[0]:
                    self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime/2.,statisticsupper,st1 + "  "+ str(int(dryphaseP))+"%",color=self.palette["text"],ha="center")
                    if self.timeindex[2]: # only if FCs exists
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime/2.,statisticsupper,st2+ "  " + str(int(midphaseP))+"%",color=self.palette["text"],ha="center")
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime+finishphasetime/2.,statisticsupper,st3 + "  " + str(int(finishphaseP))+ "%",color=self.palette["text"],ha="center")
                    if self.timeindex[7]: # only if COOL exists
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime+finishphasetime+coolphasetime/2.,statisticsupper,st4,color=self.palette["text"],ha="center")
    
                if self.statisticsflags[2]:
                    (st1,st2,st3,st4) = aw.defect_estimation()
                else:
                    st1 = st2 = st3 = st4 = ""
    
                if self.statisticsflags[4] or self.statisticsflags[5]:
                    rates_of_changes = aw.RoR(TP_index,dryEndIndex)
                    if self.statisticsflags[2]:
                        st1 = st1 + u(" (")
                        st2 = st2 + u(" (")
                        st3 = st3 + u(" (")
                    if self.statisticsflags[4]:
                        st1 = st1 + "%.1f"%rates_of_changes[0] + u(QApplication.translate("Label", "d/m",None, QApplication.UnicodeUTF8))
                        st2 = st2 + "%.1f"%rates_of_changes[1] + u(QApplication.translate("Label", "d/m",None, QApplication.UnicodeUTF8))
                        st3 = st3 + "%.1f"%rates_of_changes[2] + u(QApplication.translate("Label", "d/m",None, QApplication.UnicodeUTF8))
                    else:
                        ts1,ts1e,ts1b = aw.ts(self.timeindex[0],dryEndIndex)
                        ts2,ts2e,ts2b = aw.ts(dryEndIndex,self.timeindex[2])
                        ts3,ts3e,ts3b = aw.ts(self.timeindex[2],self.timeindex[6])
                        st1 += u(ts1) + u(self.mode) + u("m [" + str(ts1e) + "-" + str(ts1b) + "]")
                        st2 += u(ts2) + u(self.mode) + u("m [" + str(ts2e) + "-" + str(ts2b) + "]")
                        st3 += u(ts3) + u(self.mode) + u("m [" + str(ts3e) + "-" + str(ts3b) + "]")
                    if self.statisticsflags[2]:
                        st1 = st1 + u(")")
                        st2 = st2 + u(")")
                        st3 = st3 + u(")")
    
                if self.statisticsflags[2] or self.statisticsflags[4] or self.statisticsflags[5]:
                    #Write flavor estimation
                    self.ax.text(self.timex[self.timeindex[0]] + dryphasetime/2.,statisticslower,st1,color=self.palette["text"],ha="center",fontsize=11)
                    if self.timeindex[2]: # only if FCs exists
                        self.ax.text(self.timex[self.timeindex[0]] + dryphasetime+midphasetime/2.,statisticslower,st2,color=self.palette["text"],ha="center",fontsize=11)
                        self.ax.text(self.timex[self.timeindex[0]] + dryphasetime+midphasetime+finishphasetime/2.,statisticslower,st3,color=self.palette["text"],ha="center",fontsize=11)
                    if self.timeindex[7]: # only if COOL exists
                        self.ax.text(self.timex[self.timeindex[0]]+ dryphasetime+midphasetime+finishphasetime+max(coolphasetime/2.,coolphasetime/3.),statisticslower,st4,color=self.palette["text"],ha="center",fontsize=11)
                if self.statisticsflags[3] and self.timeindex[0]>-1 and self.temp1 and self.temp2 and self.temp1[self.timeindex[0]:self.timeindex[6]+1] and self.temp2[self.timeindex[0]:self.timeindex[6]+1]:
                    temp1_values = self.temp1[self.timeindex[0]:self.timeindex[6]+1]
                    temp2_values = self.temp2[self.timeindex[0]:self.timeindex[6]+1]
                    BTmin = min(temp1_values)
                    BTmax = max(temp1_values)
                    ETmin = min(temp2_values)
                    ETmax = max(temp2_values)
    
                    dTime = self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]
                    timez = self.stringfromseconds(dTime)
                    ror = "%.2f"%(((self.temp2[self.timeindex[6]]-LP)/(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]))*60.)
                    ts,tse,tsb = aw.ts()
    
                    #end temperature
                    strline = QApplication.translate("Label", "BT=%1-%2 (%3)   ET=%4-%5 (%6)   T=%7   RoR=%8d/m   ETBTa=%9 [%11-%12]", None,
                              QApplication.UnicodeUTF8).arg("%.1f"%BTmin + self.mode).arg("%.1f"%BTmax + self.mode).arg("%.1f"%abs(BTmax - BTmin)).arg("%.1f"%ETmin + self.mode).arg("%.1f"%ETmax + self.mode).arg("%.1f"%abs(ETmax - ETmin)).arg(timez).arg(ror).arg("%d%sm"%(ts,self.mode)).arg(tse).arg(tsb)
    
                    # even better: use xlabel
                    self.ax.set_xlabel(strline,size=11,color = aw.qmc.palette["text"])
                else:
                    self.ax.set_xlabel(QApplication.translate("Label", "Time",None, QApplication.UnicodeUTF8),size=16,color = self.palette["xlabel"])
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()    
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " writestatistics() %1").arg(str(ex)),exc_tb.tb_lineno)

    #used in EventRecord()
    def restorebutton_11(self):
        aw.button_11.setDisabled(False)
        aw.button_11.setFlat(False)

    #called from markdryen(), markcharge(), mark1Cstart(), etc when using device 18 (manual mode)
    def drawmanual(self,et,bt,tx):
        self.temp1.append(et)
        self.l_temp1.set_data(self.timex, self.temp1)
        self.temp2.append(bt)
        self.timex.append(tx)
        self.l_temp2.set_data(self.timex, self.temp2)

    def movebackground(self,direction,step):
        lt = len(self.timeB)
        le = len(self.temp1B)
        lb = len(self.temp2B)
        #all background curves must have same dimension in order to plot. Check just in case.
        if lt > 1 and lt == le and lb == le:
            if  direction == "up":
                for i in range(lt):
                    self.temp1B[i] += step
                    self.temp2B[i] += step

            elif direction == "left":
                for i in range(lt):
                    self.timeB[i] -= step
                                   
            elif direction == "right":
                for i in range(lt):
                    self.timeB[i] += step

            elif direction == "down":
                for i in range(lt):
                    self.temp1B[i] -= step
                    self.temp2B[i] -= step

        else:
            aw.sendmessage(QApplication.translate("Message","Unable to move background", None, QApplication.UnicodeUTF8))
            return

    #points are used to draw interpolation
    def findpoints(self):
        #if profile found
        if self.timeindex[0] != -1:
            Xpoints = []                        #make temporary lists to hold the values to return
            Ypoints = []

            #start point from begining of time
            Xpoints.append(self.timex[0])
            Ypoints.append(self.temp2[0])
            #input beans (CHARGE)
            Xpoints.append(self.timex[self.timeindex[0]])
            Ypoints.append(self.temp2[self.timeindex[0]])

            #find indexes of lowest point and dryend
            LPind = aw.findTP()
            DE = aw.findDryEnd()

            if LPind < DE:
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
            else:
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                
            if self.temp2[self.timeindex[1]] > self.timex[DE] and self.temp2[self.timeindex[1]] > self.timex[LPind]:
                Xpoints.append(self.timex[self.timeindex[1]])
                Ypoints.append(self.temp2[self.timeindex[1]])
            if self.timeindex[2]:
                Xpoints.append(self.timex[self.timeindex[2]])
                Ypoints.append(self.temp2[self.timeindex[2]])
            if self.timeindex[3]:
                Xpoints.append(self.timex[self.timeindex[3]])
                Ypoints.append(self.temp2[self.timeindex[3]])
            if self.timeindex[4]:
                Xpoints.append(self.timex[self.timeindex[4]])
                Ypoints.append(self.temp2[self.timeindex[4]])
            if self.timeindex[5]:
                Xpoints.append(self.timex[self.timeindex[5]])
                Ypoints.append(self.temp2[self.timeindex[5]])
            if self.timeindex[6]:
                Xpoints.append(self.timex[self.timeindex[6]])
                Ypoints.append(self.temp2[self.timeindex[6]])

            #end point
            if self.timex[self.timeindex[6]] != self.timex[-1]:
                Xpoints.append(self.timex[-1])
                Ypoints.append(self.temp2[-1])

            return Xpoints,Ypoints

        else:
            aw.sendmessage(QApplication.translate("Message","No finished profile found", None, QApplication.UnicodeUTF8))
            return [],[]

    #collects info about the univariate interpolation
    def univariateinfo(self):
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            Xpoints,Ypoints = self.findpoints()  #from lowest point to avoid many coeficients
            equ = UnivariateSpline(Xpoints, Ypoints)
            coeffs = equ.get_coeffs().tolist()
            knots = equ.get_knots().tolist()
            resid = equ.get_residual()
            roots = equ.roots().tolist()

            #interpretation of coefficients: http://www.sagenb.org/home/pub/1708/
            #spline=[ans[0,i]+(x-xi)*(ans[1,i]+(x-xi)*(ans[2,i]+(x-xi)*ans[3,i]/3)/2) for i,xi in enumerate(a[:-1])]
            
            string = "<b>" + u(QApplication.translate("Message","Polynomial coefficients (Horner form):",
                                                    None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(coeffs) + "<br><br>"
            string += "<b>" + u(QApplication.translate("Message","Knots:",
                                                     None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(knots) + "<br><br>"
            string += "<b>" + u(QApplication.translate("Message","Residual:",
                                                     None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(resid) + "<br><br>"      
            string += "<b>" + u(QApplication.translate("Message","Roots:",
                                                     None, QApplication.UnicodeUTF8)) + "</b><br><br>"
            string += str(roots)

            QMessageBox.information(self,QApplication.translate("Message","Profile information",None, QApplication.UnicodeUTF8),string)

        except ValueError as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " univariateinfo() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " univariateinfo() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    #interpolation type
    def univariate(self):
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            Xpoints,Ypoints = self.findpoints()

            func = UnivariateSpline(Xpoints, Ypoints)

            xa = numpy.array(self.timex)
            newX = func(xa).tolist()

            self.ax.plot(self.timex, newX, color="black", linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, "ro")

            self.fig.canvas.draw()

        except ValueError:
            aw.qmc.adderror(QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " univariate()")
            return

        except Exception:
            aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " univariate()")
            return

    def drawinterp(self,mode):
        try:
            #pylint: disable=E1101
            from scipy import interpolate as inter
            Xpoints,Ypoints = self.findpoints() #from 0 origin
            func = inter.interp1d(Xpoints, Ypoints, kind=mode)
            newY = func(self.timex)
            self.ax.plot(self.timex, newY, color="black", linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, "ro")

            self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " drawinterp() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " drawinterp() %1").arg(str(e)),exc_tb.tb_lineno)
            return
            
    def timearray2index(self,timearray,seconds):
        #find where given seconds crosses timearray
        if len(timearray):                           #check that timearray is not empty just in case
            #if input seconds longer than available time return last index
            if  seconds > timearray[-1]:
                return len(timearray)-1
            #if given input seconds smaller than first time return first index
            if seconds < timearray[0]:
                return 0
            i = numpy.searchsorted(timearray,seconds,side='left')
            if i < len(self.timex) - 1:
                #look around (check if the value of the next index is closer
                choice1 = abs(self.timex[i] - seconds)
                choice2 = abs(self.timex[i-1] - seconds)
                #return closest (smallest) index
                if choice2 < choice1:
                    i = i - 1
            return i         
        else:
            return -1

    #selects closest time INDEX in self.timex from a given input float seconds
    def time2index(self,seconds):
        #find where given seconds crosses aw.qmc.timex
        return self.timearray2index(self.timex,seconds)
            
    #selects closest time INDEX in self.timeB from a given input float seconds
    def backgroundtime2index(self,seconds):
        #find where given seconds crosses aw.qmc.timex
        return self.timearray2index(self.timeB,seconds)

    #updates list self.timeindex when found an _OLD_ profile without self.timeindex (new version)
    def timeindexupdate(self,times):
##        #          START            DRYEND          FCs             FCe         SCs         SCe         DROP
##        times = [self.startend[0],self.dryend[0],self.varC[0],self.varC[2],self.varC[4],self.varC[6],self.startend[2]]
        for i in range(len(times)):               
            if times[i]:
                self.timeindex[i] = self.time2index(times[i])
            else:
                self.timeindex[i] = 0


    #updates list self.timeindexB when found an _OLD_ profile without self.timeindexB 
    def timebackgroundindexupdate(self,times):
##        #          STARTB            DRYENDB          FCsB       FCeB         SCsB         SCeB               DROPB
##        times = [self.startendB[0],self.dryendB[0],self.varCB[0],self.varCB[2],self.varCB[4],self.varCB[6],self.startendB[2]]
        for i in range(len(times)):               
            if times[i]:
                self.timeindexB[i] = self.backgroundtime2index(times[i])
            else:
                self.timeindexB[i] = 0

    #adds errors
    def adderror(self,error,line=None):
        timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
        #keep a max of 500 errors
        if len(self.errorlog) > 499:
            self.errorlog = self.errorlog[1:]
        if line:
            error = error + "@line " + str(line)
        self.errorlog.append(timez + " " + error)
        aw.sendmessage(error)

    ####################  PROFILE DESIGNER   ###################################################################################
    #launches designer
    def designer(self):
        #disconnect mouse cross if ON
        if self.crossmarker:
            self.togglecrosslines()

        if len(self.timex):
            reply = QMessageBox.question(self,QApplication.translate("Message","Designer Start",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("Message","Importing a profile in to Designer will decimate\nall data except the main [points].\nContinue?",None, QApplication.UnicodeUTF8),
                                         QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Yes:
                self.initfromprofile()
                self.connect_designer()
                return
            elif reply == QMessageBox.Cancel:
                return #exit

        #if no profile found
        self.reset(redraw=False,soundOn=False)
        self.connect_designer()
        self.redraw(False)
        self.designerinit()
        
    #used to start designer from scratch (not from a loaded profile)
    def designerinit(self):
        #init start vars        #CH, DE,      Fcs,      Fce,       Scs,         Sce,         Drop,      COOL
        self.designertimeinit = [50,(5*60+50),(8*60+50),(10*60+50),(10.5*60+50),(11.5*60+50),(12*60+50),(16*60+50)]
        if self.mode == "C":   
            self.designertemp1init = [290.,290.,290.,290.,290.,290.,290.,290.]   #CHARGE,DE,FCs,FCe,SCs,SCe,Drop
            self.designertemp2init = [230.,150.,190.,210.,220.,225.,230.,230.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP
        elif self.mode == "F":
            self.designertemp1init = [500.,500.,500.,500.,500.,500.,500.,500.]
            self.designertemp2init = [440.,300.,385.,410.,430.,445.,460.,460.]

        #check x limits
        if self.endofx < 960:
            self.endofx = 960
            self.redraw()

        self.timex,self.temp1,self.temp2 = [],[],[]
        for i in range(len(self.timeindex)):
            self.timex.append(self.designertimeinit[i])
            self.temp1.append(self.designertemp1init[i])
            self.temp2.append(self.designertemp2init[i])
            self.timeindex[i] = i

        self.xaxistosm()
        self.redrawdesigner()

    #loads main points from a profile so that they can be edited
    def initfromprofile(self):
        if self.timeindex[0] == -1 or self.timeindex[6] == 0:
            QMessageBox.information(self,QApplication.translate("Message","Designer Init",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("Message","Unable to start designer.\nProfile missing [CHARGE] or [DROP]",None, QApplication.UnicodeUTF8))
            self.disconnect_designer()
            return()

        #save events. They will be deleted on qmc.reset()
        self.specialeventsStringscopy = self.specialeventsStrings[:]
        self.specialeventsvaluecopy = self.specialeventsvalue[:]
        self.specialeventstypecopy = self.specialeventstype[:]
        self.eventtimecopy = []
        for i in range(len(self.specialevents)):
            #save relative time of events
            self.eventtimecopy.append(self.timex[self.specialevents[i]]-self.timex[self.timeindex[0]])

        #find lowest point from profile to be converted
        lpindex = aw.findTP()
        if lpindex != -1 and not lpindex in self.timeindex:
            lptime = self.timex[lpindex]
            lptemp2 = self.temp2[lpindex]
        else:
            lpindex = -1

        timeindexhold = [self.timex[self.timeindex[0]],0,0,0,0,0,0,0]
        timez,t1,t2 = [self.timex[self.timeindex[0]]],[self.temp1[self.timeindex[0]]],[self.temp2[self.timeindex[0]]]    #first CHARGE point
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:                           # fill up empty lists with main points (FCs, etc). match from timeindex
                timez.append(self.timex[self.timeindex[i]])  #add time
                t1.append(self.temp1[self.timeindex[i]])    #add temp1
                t2.append(self.temp2[self.timeindex[i]])    #add temp2
                timeindexhold[i] =  self.timex[self.timeindex[i]]

        self.reset()                                            #erase screen

        self.timex,self.temp1,self.temp2 = timez[:],t1[:],t2[:]  #copy lists back after reset() with the main points

        self.timeindexupdate(timeindexhold) #create new timeindex[]

        #add lowest point as extra point
        if lpindex != -1:
            self.currentx = lptime
            self.currenty = lptemp2
            self.addpoint()

        self.xaxistosm()
        self.redrawdesigner()                                   #redraw the designer screen

    #redraws designer
    def redrawdesigner(self):
        if aw.qmc.designerflag:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            #reset (clear) plot
            if self.background:
                self.ax.lines = self.ax.lines[0:4]
            else:
                self.ax.lines = []
            
            #create statistics bar
            #calculate the positions for the statistics elements
            ydist = self.ylimit - self.ylimit_min
            statisticsheight = self.ylimit - (0.13 * ydist)
            
            #add statistics bar
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[1]]],[statisticsheight,statisticsheight],color = self.palette["rect1"],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[2]]],[statisticsheight,statisticsheight],color = self.palette["rect2"],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[6]]],[statisticsheight,statisticsheight],color = self.palette["rect3"],alpha=.5,linewidth=5)
            
            #add phase division lines
            ylist = [self.ylimit,0]
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[0]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[1]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[2]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[6]],self.timex[self.timeindex[6]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            
            if self.timex[-1] > self.endofx:
                self.endofx = self.timex[-1] + 120
                self.xaxistosm()
            
            if self.BTsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.BTsplinedegree = len(self.timex)-1
            
            if self.ETsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.ETsplinedegree = len(self.timex)-1
            
            func = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            func2 = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()
            #convert all time values to temperature
            btvals = func(timez).tolist()
            etvals = func2(timez).tolist()
            
            #add curves
            self.ax.plot(timez, btvals, color=self.palette["bt"], linestyle = '-', linewidth=2)
            self.ax.plot(timez, etvals, color=self.palette["et"], linestyle = '-', linewidth=2)
            
            #add markers (big circles) '0'
            self.ax.plot(self.timex,self.temp2,color = self.palette["bt"],marker = "o",picker=10,linestyle='',markersize=8)     #picker = 10 means 10 points tolerance
            self.ax.plot(self.timex,self.temp1,color = self.palette["et"],marker = "o",picker=10,linestyle='',markersize=8)
            
            #plot
            self.fig.canvas.draw()

    #CONTEXT MENU  = Right click
    def on_press(self,event):
        if event.inaxes != self.ax: return
        if event.button != 3: return   #select right click only

        self.releaseMouse()
        self.mousepress = False
        self.setCursor(Qt.OpenHandCursor)

        self.currentx = event.xdata 
        self.currenty = event.ydata

        designermenu = QMenu(self)

        createAction = QAction(QApplication.translate("Contextual Menu", "Create",None, QApplication.UnicodeUTF8),self)
        self.connect(createAction,SIGNAL("triggered()"),self.convert_designer)
        designermenu.addAction(createAction)

        configAction = QAction(QApplication.translate("Contextual Menu", "Config...",None, QApplication.UnicodeUTF8),self)
        self.connect(configAction,SIGNAL("triggered()"),self.desconfig)
        designermenu.addAction(configAction)

        backgroundAction = QAction(UIconst.ROAST_MENU_BACKGROUND,self)
        self.connect(backgroundAction,SIGNAL("triggered()"),aw.background)
        designermenu.addAction(backgroundAction)

        designermenu.addSeparator()

        addpointAction = QAction(QApplication.translate("Contextual Menu", "Add point",None, QApplication.UnicodeUTF8),self)
        self.connect(addpointAction,SIGNAL("triggered()"),self.addpoint)
        designermenu.addAction(addpointAction)
        
        removepointAction = QAction(QApplication.translate("Contextual Menu", "Remove point",None, QApplication.UnicodeUTF8),self)
        self.connect(removepointAction,SIGNAL("triggered()"),self.removepoint)
        designermenu.addAction(removepointAction)

        designermenu.addSeparator()

        resetAction = QAction(QApplication.translate("Contextual Menu", "Reset Designer",None, QApplication.UnicodeUTF8),self)
        self.connect(resetAction,SIGNAL("triggered()"),self.reset_designer)
        designermenu.addAction(resetAction)

        exitAction = QAction(QApplication.translate("Contextual Menu", "Exit Designer",None, QApplication.UnicodeUTF8),self)
        self.connect(exitAction,SIGNAL("triggered()"),aw.stopdesigner)
        designermenu.addAction(exitAction)

        designermenu.exec_(QCursor.pos())

    def on_pick(self,event):
        self.setCursor(Qt.ClosedHandCursor)

        self.indexpoint = event.ind
        self.mousepress = True

        line = event.artist
        #identify which line is being edited
        ydata = line.get_ydata()
        if ydata[1] == self.temp1[1]:
            self.workingline = 1
        else:
            self.workingline = 2

    #handles when releasing mouse
    def on_release(self,event):
        self.mousepress = False
        self.setCursor(Qt.OpenHandCursor)

    #handler for moving point
    def on_motion(self,event):
        if not event.inaxes: return
        try:
            if self.mousepress:                                 #if mouse clicked
                self.timex[self.indexpoint] = event.xdata
                if self.workingline == 1:
                    self.temp1[self.indexpoint] = event.ydata
                else:
                    self.temp2[self.indexpoint] = event.ydata

                #check point going over point
                #check to the left    
                if self.indexpoint > 0:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint - 1]) < 10.:
                        self.unrarefy_designer()
                        return
                #check to the right
                if self.indexpoint <= len(self.timex)-2:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint + 1]) < 10.:
                        self.unrarefy_designer()
                        return

                #check for possible CHARGE time moving
                if self.indexpoint == self.timeindex[0]:
                    self.xaxistosm()

                #redraw
                self.redrawdesigner()
                return

            if type(event.xdata):                       #outside graph type is None
                for i in range(len(self.timex)):
                    if abs(event.xdata - self.timex[i]) < 7.:
                        if i in self.timeindex:
                            if abs(self.temp2[i] - event.ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = "orange",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - event.ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = "orange",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            index = self.timeindex.index(i)
                            if index == 0:
                                timez = self.stringfromseconds(0)
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: #f07800\">" + u(QApplication.translate("Message", "[ CHARGE ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 1:
                                timez = self.stringfromseconds(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ DRY END ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 2:
                                timez = self.stringfromseconds(self.timex[self.timeindex[2]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ FC START ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 3:
                                timez = self.stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[0]])                                
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ FC END ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 4:
                                timez = self.stringfromseconds(self.timex[self.timeindex[4]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ SC START ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 5:
                                timez = self.stringfromseconds(self.timex[self.timeindex[5]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: orange\">" + u(QApplication.translate("Message", "[ SC END ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            elif index == 6:
                                timez = self.stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                                aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: #f07800\">" + u(QApplication.translate("Message", "[ DROP ]",None, QApplication.UnicodeUTF8)) + "</font> " + timez)
                            break
                        else:
                            if abs(self.temp2[i] - event.ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = "blue",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - event.ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = "blue",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            timez = self.stringfromseconds(self.timex[i] - self.timex[self.timeindex[0]])
                            aw.messagelabel.setText("<font style=\"BACKGROUND-COLOR: lightblue\">%s</font> "%timez)
                            break
                    else:
                        totaltime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]]
                        dryphasetime = self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]]
                        midphasetime = self.timex[self.timeindex[2]] - self.timex[self.timeindex[1]]
                        finishphasetime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]]

                        if totaltime:
                            dryphaseP = int(dryphasetime*100./totaltime)
                            midphaseP = int(midphasetime*100./totaltime)
                            finishphaseP = int(finishphasetime*100./totaltime)
                        else:
                            return

                        dryramp = self.temp2[self.timeindex[1]] - self.temp2[self.timeindex[0]]
                        midramp = self.temp2[self.timeindex[2]] - self.temp2[self.timeindex[1]]
                        finishramp = self.temp2[self.timeindex[6]] - self.temp2[self.timeindex[2]]

                        ts1,_,_ = aw.ts(self.timeindex[0],self.timeindex[1])
                        ts2,_,_ = aw.ts(self.timeindex[1],self.timeindex[2])
                        ts3,_,_ = aw.ts(self.timeindex[2],self.timeindex[6])
                        etbt1 = "%i%sm"%(ts1,self.mode)
                        etbt2 = "%i%sm"%(ts2,self.mode)
                        etbt3 = "%i%sm"%(ts3,self.mode)

                        if dryphasetime:
                            dryroc = " %.1f d/m"%((dryramp/dryphasetime)*60.)
                        else:
                            dryroc = " 0 d/m"

                        if midphasetime:
                            midroc = " %.1f d/m"%((midramp/midphasetime)*60.)
                        else:
                            midroc = " 0 d/m"

                        if finishphasetime:
                            finishroc = " %.1f d/m"%((finishramp/finishphasetime)*60.)
                        else:
                            finishroc = 0

                        margin = "&nbsp;&nbsp;&nbsp;"
                        string1 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect1"],
                                  margin,self.stringfromseconds(dryphasetime),margin, dryphaseP, margin,dryroc,margin,etbt1,margin)
                        string2 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect2"],
                                  margin,self.stringfromseconds(midphasetime),margin,midphaseP,margin,midroc,margin,etbt2,margin)
                        string3 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect3"],
                                  margin,self.stringfromseconds(finishphasetime),margin,finishphaseP,margin,finishroc,margin,etbt3,margin)
                        aw.messagelabel.setText(string1+string2+string3)

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " on_motion() %1").arg(str(e)),exc_tb.tb_lineno)
            self.unrarefy_designer()
            return

    #this is used in on_motion() to try to prevent points crossing over points
    def unrarefy_designer(self):
        for i in range(len(self.timex)-1):
            if abs(self.timex[i]-self.timex[i+1]) < 20:
                self.timex[i+1] = self.timex[i] + 20
            self.disconnect_designer()
            self.connect_designer()

    def addpoint(self):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()

            if self.currentx > self.timex[-1]:       #if point is beyond max timex (all the way to the right)
                #find closest line
                d1 = abs(self.temp1[-1] - self.currenty)
                d2 = abs(self.temp2[-1] - self.currenty)
                if d2 < d1:
                    self.temp2.append(self.currenty)
                    self.temp1.append(self.temp1[-1])
                else:
                    self.temp2.append(self.temp2[-1])
                    self.temp1.append(self.currenty)
                    
                self.timex.append(self.currentx)
                #no need to update time index

                self.redrawdesigner()
                return 0

            elif self.currentx < self.timex[0]:         #if point is bellow min timex (all the way to the left)
                #find closest line
                d1 = abs(self.temp1[0] - self.currenty)
                d2 = abs(self.temp2[0] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(0,self.currenty)
                    self.temp1.insert(0,self.temp1[0])
                else:
                    self.temp2.insert(0,self.temp2[0])
                    self.temp1.insert(0,self.currenty)

                self.timex.insert(0,self.currentx)

                #update timeindex
                if self.timeindex[0] != -1:   #we update timeindex[0] different
                    self.timeindex[0] += 1
                for u in range(1,len(self.timeindex)):
                    if self.timeindex[u]:
                        self.timeindex[u] += 1

                self.redrawdesigner()
                return len(self.timex)-1   #return index received from Designer Dialog Config to asign index to timeindex)

            else:                                           #mid range
                #find index
                for i in range(len(self.timex)):
                    if self.timex[i] > self.currentx:  
                        break
                #find closest line
                d1 = abs(self.temp1[i] - self.currenty)
                d2 = abs(self.temp2[i] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(i,self.currenty)
                    self.temp1.insert(i,self.temp1[i])
                else:
                    self.temp2.insert(i,self.temp2[i])
                    self.temp1.insert(i,self.currenty)

                self.timex.insert(i,self.currentx)

                #update timeindex
                for x in range(len(self.timeindex)):
                    if self.timeindex[x] >= i:
                        self.timeindex[x] += 1

                self.redrawdesigner()
                return i
            
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " addpoint() %1").arg(str(e)),exc_tb.tb_lineno)
            return 

    #removes point
    def removepoint(self):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            #find index
            for i in range(len(self.timex)):
                if self.timex[i] > self.currentx:
                    break
            #find closest point
            if abs(self.timex[i]- self.currentx) < abs(self.timex[i-1] - self.currentx):
                index = i
            else:
                index = i-1

            #check if if it is a landmark point
            if index in self.timeindex:
                whichone = self.timeindex.index(index)
                if whichone == 0 or whichone == 6:  #if charge or drop
                    return
                self.timeindex[whichone] = 0

            self.timex.pop(index)
            self.temp1.pop(index)
            self.temp2.pop(index)

            for x in range(len(self.timeindex)):
                if self.timeindex[x] > index: #decrease time index by one when above the index taken out
                    self.timeindex[x] -= 1

            self.redrawdesigner()

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " removepoint() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    #finds a proper index location for a time that does not exists yet.
    def designerfindindex(self,time):
        if time < aw.qmc.timex[0]:
            return 0
        elif time > aw.qmc.timex[-1]:
            return len(aw.qmc.timex)-1
        else:
            for i in range(len(aw.qmc.timex)):
                if time == aw.qmc.timex[i]:
                    return i
                if aw.qmc.timex[i] > time:
                    return i-1


    #converts from a designer profile to a normal profile
    def convert_designer(self): 
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            #prevents accidentally deleting a modified profile.
            self.safesaveflag = True
            #create functions
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            funcET = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)

            #create longer list of time values
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()

            #convert all time values to temperature
            btvals = funcBT(timez).tolist()
            etvals = funcET(timez).tolist()

            #find new indexes for events
            for i in range(len(self.specialevents)):
                for p in range(len(timez)):
                    if timez[p] > self.timex[self.specialevents[i]]:
                        self.specialevents[i] = p
                        break

            #save landmarks
            maintimes = []
            for i in range(len(self.timeindex)):
                maintimes.append(self.timex[self.timeindex[i]])

            self.timex = timez[:]
            self.temp1 = etvals[:]
            self.temp2 = btvals[:]

            self.timeindexupdate(maintimes)

            #check and restore carried over events
            if len(self.eventtimecopy):
                for i in range(len(self.eventtimecopy)):
                    self.specialevents.append(self.time2index(self.eventtimecopy[i] + self.timex[self.timeindex[0]]))
                self.specialeventsStrings = self.specialeventsStringscopy[:]
                self.specialeventsvalue = self.specialeventsvaluecopy[:]
                self.specialeventstype = self.specialeventstypecopy[:]

            #check for extra devices
            num = len(self.timex)
            for i in range(len(self.extradevices)):
                self.extratemp1[i] = [-1.]*num
                self.extratemp2[i] = [-1.]*num
                self.extratimex[i] = self.timex[:]

            self.disconnect_designer()

            #create playback events
            if self.reproducedesigner:
                functioncall = [0,
                                self.designer_create_BT_rateofchange,
                                self.designer_create_ET_rateofchange,
                                self.designer_create_sv_command,
                                self.designer_create_ramp_command]

                functioncall[self.reproducedesigner]()

            self.redraw()
            aw.sendmessage(QApplication.translate("Message", "New profile created",None, QApplication.UnicodeUTF8))

        except ValueError:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " createFromDesigner()",exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " createFromDesigner() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    #activates mouse events
    def connect_designer(self):
        if not self.designerflag:
            self.designerflag = True
            aw.designerAction.setChecked(True)
            self.setCursor(Qt.OpenHandCursor)
            self.mousepress = None
            #create mouse events. Note: keeping the ids inside a list helps protect against extrange python behaviour.
            self.designerconnections = [0,0,0,0]
            self.designerconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.on_pick) 
            self.designerconnections[1] = self.fig.canvas.mpl_connect('button_release_event', self.on_release)
            self.designerconnections[2] = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
            self.designerconnections[3] = self.fig.canvas.mpl_connect('button_press_event', self.on_press) #right click
            #this is needed to prevent complaints from UnivariateSpline() -used in redraw()- in extreme cases of difficulty
            warnings.simplefilter('ignore', UserWarning)

    #deactivates mouse events
    def disconnect_designer(self):
        for i in range(len(self.designerconnections)):
            if self.designerconnections[i]:
                self.fig.canvas.mpl_disconnect(self.designerconnections[i])
        self.setCursor(Qt.ArrowCursor)
        self.designerflag = False
        aw.designerAction.setChecked(False)
        warnings.simplefilter('default', UserWarning)

    #launches designer config Window
    def desconfig(self):
        dialog = designerconfigDlg(self)
        dialog.show()

    def reset_designer(self):
        self.reset()
        self.disconnect_designer()
        self.connect_designer()
        self.designerinit()

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_BT_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp2[self.timeindex[i]] - self.temp2[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = u(QApplication.translate("Label", "BT %1 d/m for %2",None, QApplication.UnicodeUTF8).arg("%.1f"%(difftemp/difftime)).arg(self.stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_ET_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp1[self.timeindex[i]] - self.temp1[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = u(QApplication.translate("Label", "ET %1 d/m for %2",None, QApplication.UnicodeUTF8).arg("%.1f"%(difftemp/difftime)).arg(self.stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    def deleteEvents(self):
        self.specialevents = []
        self.specialeventstype = []
        self.specialeventsStrings = []
        self.specialeventsvalue = []

    #this is used to create a string in pid language to reproduce the profile from Designer
    #NOTE: pid runs ET (temp1)    
    def designer_create_ramp_command(self):
        tempinits = []
        minutes_segments = []

        #ramp times in minutes
        minsDryPhase = str(int(abs(self.timex[self.timeindex[0]] - self.timex[self.timeindex[1]])/60))
        minsMidPhase = str(int(abs(self.timex[self.timeindex[1]] - self.timex[self.timeindex[2]])/60)) 
        minsFinishPhase = str(int(abs(self.timex[self.timeindex[2]] - self.timex[self.timeindex[6]])/60))

        #target temps for ET
        tempinits.append("%.1f"%self.temp1[self.timeindex[1]])
        tempinits.append("%.1f"%self.temp1[self.timeindex[2]])
        tempinits.append("%.1f"%self.temp1[self.timeindex[6]])

        minutes_segments.append(minsDryPhase)
        minutes_segments.append(minsMidPhase)
        minutes_segments.append(minsFinishPhase)

        command = ""
        for i in range(3):
            command += "SETRS::" + tempinits[i] + "::" + minutes_segments[i] + "::0::"
        command += "SETRS::" + tempinits[-1] + "::0::0"

        self.clean_old_pid_commands()

        #do only one event but with all segments
        self.specialevents.append(0)
        self.specialeventstype.append(0)
        self.specialeventsStrings.append(command)
        self.specialeventsvalue.append(0)

    #this is used to create a string in ET temp language to reproduce the profile from Designer
    def designer_create_sv_command(self):
        self.clean_old_pid_commands()
        for i in range(len(self.timeindex)-1):
            command = "SETSV::%.1f"%self.temp1[self.timeindex[i+1]]
            if i > 0 and self.timeindex[i]:
                self.specialevents.append(self.timeindex[i])
                self.specialeventstype.append(0)
                self.specialeventsStrings.append(command)
                self.specialeventsvalue.append(0)

    #verifies there are no previos machine commands on events
    def clean_old_pid_commands(self):
        #check for possible preloaded machine commands
        target = 0
        if len(self.specialevents):
            for i in range(len(self.specialevents)):
                if "::" in self.specialeventsStrings[i]:
                    self.specialevents.pop(i)
                    self.specialeventstype.pop(i)
                    self.specialeventsStrings.pop(i)
                    self.specialeventsvalue.pop(i)
                    target = 1
                    break     #break or the index i can become larger than the new shorted length of specialevents
        if target:
            self.clean_old_pid_commands()

    ###################################      WHEEL GRAPH  ####################################################

    def findCenterWheelTextAngle(self,t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if t == 360. or t == 0.:
            return 270.
        #check cuadrants
        elif t < 90. and t > 0. or t > 360.:        #quadrant 1
            return 270.+t
        elif t <= 180. and t >= 90.:                #quadrant 2
            return t-90.
        elif t < 270. and t > 180.:                 #quadrant 3
            return t+90.
        else:                                       #quadrant 4
            return t-270.

    def findRadialWheelTextAngle(self,t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)  
        if t <= 90. and t > 0. or t > 270.:
            return t
        else:
            return 180.+t

    def loadselectorwheel(self,path):
        string = "Wheels" + "\\" + path
        direct = QDir()
        pathDir = direct.toNativeSeparators(QString(string))
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Open Wheel Graph",None, QApplication.UnicodeUTF8),path=pathDir,ext="*.wg")
        if filename:
            self.connectWheel()
            aw.loadWheel(filename)
            self.drawWheel()

    def addTocuppingnotes(self):
        descriptor =  u(self.wheelnames[self.wheelx][self.wheelz]) 
        self.cuppingnotes += "\n" + descriptor 
        string = u(QApplication.translate("Message", " added to cupping notes",None, QApplication.UnicodeUTF8))
        aw.sendmessage(descriptor + string)

    def addToroastingnotes(self):
        descriptor =  u(self.wheelnames[self.wheelx][self.wheelz]) + " "
        self.roastingnotes +=  "\n" + descriptor + " "
        string = u(QApplication.translate("Message", " added to roasting notes",None, QApplication.UnicodeUTF8))
        aw.sendmessage(descriptor + string)

    def wheel_pick(self,event):
        rect =  event.artist
        loc = rect.get_url().split("-")
        x = int(loc[0])
        z = int(loc[1])
        self.wheelx = x
        self.wheelz = z
        aw.sendmessage(self.wheelnames[x][z])
        self.segmentsalpha[x][z] += .3
        self.drawWheel()

    def wheel_release(self,event):
        newlocz = event.xdata
        if newlocz:
            if newlocz != self.wheellocationz:
                diff = math.degrees(self.wheellocationx - newlocz)
                for i in range(len(self.startangle)):
                    self.startangle[i] -= diff
                self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection 
                self.drawWheel()

    def wheel_menu(self,event):
        if str(event.inaxes) != str(self.ax2): return
        if event.button == 1:                    #if left click
            self.wheellocationx = event.xdata
            self.wheellocationz = event.ydata

        elif event.button == 3:                  #if right click
            designermenu = QMenu(self)
            cuppingAction = QAction(QApplication.translate("Contextual Menu", "Add to Cupping Notes",None, QApplication.UnicodeUTF8),self)
            self.connect(cuppingAction,SIGNAL("triggered()"),self.addTocuppingnotes)
            designermenu.addAction(cuppingAction)

            roastingAction = QAction(QApplication.translate("Contextual Menu", "Add to Roasting Notes",None, QApplication.UnicodeUTF8),self)
            self.connect(roastingAction,SIGNAL("triggered()"),self.addToroastingnotes)
            designermenu.addAction(roastingAction)

            cancelwheelAction = QAction(QApplication.translate("Contextual Menu", "Cancel selection",None, QApplication.UnicodeUTF8),self)
            self.connect(cancelwheelAction,SIGNAL("triggered()"),self.cancelwheelselection)
            designermenu.addAction(cancelwheelAction)

            editAction = QAction(QApplication.translate("Contextual Menu", "Edit Mode",None, QApplication.UnicodeUTF8),self)
            self.connect(editAction,SIGNAL("triggered()"),self.editmode)
            designermenu.addAction(editAction)

            exitAction = QAction(QApplication.translate("Contextual Menu", "Exit",None, QApplication.UnicodeUTF8),self)
            self.connect(exitAction,SIGNAL("triggered()"),self.exitviewmode)
            designermenu.addAction(exitAction)
            
            designermenu.exec_(QCursor.pos())

    def cancelwheelselection(self):
        self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection
        self.drawWheel()

    def editmode(self):
        self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection
        self.disconnectWheel(buttomvisibility=False)
        aw.graphwheel()

    def exitviewmode(self):
        self.segmentsalpha[self.wheelx][self.wheelz] -= .3   #restore alpha in mouse selection 
        self.disconnectWheel()
        self.redraw(recomputeAllDeltas=False)

    def connectWheel(self):
        self.wheelflag = True
        self.setCursor(Qt.PointingHandCursor)
        self.wheelconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.wheel_pick)
        self.wheelconnections[1] = self.fig.canvas.mpl_connect('button_press_event', self.wheel_menu)           #right click menu context
        self.wheelconnections[2] = self.fig.canvas.mpl_connect('button_release_event', self.wheel_release)

    def disconnectWheel(self,buttomvisibility=True):
        self.wheelflag = False
        self.setCursor(Qt.ArrowCursor)
        self.fig.canvas.mpl_disconnect(self.wheelconnections[0])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[1])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[2])

    def drawWheel(self):
        try:
            ### var constants  #####
            pi = numpy.pi
            threesixty = 2.*pi
            div = threesixty/100.
            rad = 360./threesixty
            ########################
            # same as redraw but using different axes
            self.fig.clf()
            #create a new name ax1 instead of ax
            self.ax2 = self.fig.add_subplot(111, projection='polar', axisbg=self.backcolor)
            self.ax2.set_rmax(1.)
            self.ax2.set_aspect(self.wheelaspect)
            self.ax2.set_autoscale_on(True)
            self.ax2.grid(False)

            #delete degrees ticks to anotate flavor characteristics 
            for tick in self.ax2.xaxis.get_major_ticks():
                tick.label1On = False
            #delete yaxis 
            locs = self.ax2.get_yticks()
            labels = [""]*len(locs)           
            self.ax2.set_yticklabels(labels)

            names = self.wheelnames[:]
            Wradii = self.wradii[:]
            startangle = self.startangle[:]
            projection = self.projection[:]

            #calculate text orientation
            wheels = len(names)

            if not wheels:
                self.fig.canvas.draw()
                return
            
            n,textangles,textloc = [],[],[]
            for i in range(wheels):
                l,tloc = [],[]
                count = self.startangle[i]
                #calculate text orientation
                for p in range(len(names[i])):
                    if projection[i] == 0:
                        l.append(0)
                    elif projection[i] == 1:
                        l.append(self.findCenterWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    elif projection[i] == 2:
                        l.append(self.findRadialWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    tloc.append((3.6*self.segmentlengths[i][p]/2. + count)/rad)
                    count += self.segmentlengths[i][p]*3.6

                textloc.append(tloc)
                textangles.append(l)
                Wradii[i] = float(Wradii[i])/100.                   #convert radii to float between 0-1 range
                startangle[i] = startangle[i]/rad                   #convert angles to radians
                n.append(len(names[i]))                             #store the number of names for each wheel


            #store the absolute len-radius origin of each circle
            lbottom = [0.]
            count = 0.
            for i in range(wheels-1):
                count += Wradii[i]
                lbottom.append(count)

            Wradiitext = [Wradii[0]/2.]
            for i in range(wheels-1):
                Wradiitext.append(lbottom[i+1] + Wradii[i+1]/2.)     #store absolute len-radius for text in each circle
                Wradii[i] += self.wheeledge                          #create extra color edge between wheels by overlaping wheels
            #Generate Wheel graph
            bar = []                                                 #holds bar-graphs (wheels)
            for z in range(len(n)):
                #create wheel
                theta,segmentwidth,radii = [],[],[]
                count = startangle[z]
                for i in range(n[z]):
                    #negative number affect eventpicker
                    if count > threesixty:
                        count %= threesixty
                    elif count < 0.:
                        count += threesixty
                    theta.append(count)
                    count += div*self.segmentlengths[z][i]
                    segmentwidth.append(div*self.segmentlengths[z][i])
                    radii.append(Wradii[z])
                bar.append(self.ax2.bar(theta, radii, width=segmentwidth, bottom=lbottom[z],edgecolor=self.wheellinecolor,
                                        linewidth=self.wheellinewidth,picker=1))
                count = 0
                #set color, alpha, and text
                for _,bar[z] in zip(radii, bar[z]):
                    bar[z].set_facecolor(self.wheelcolor[z][count])
                    bar[z].set_alpha(self.segmentsalpha[z][count])
                    bar[z].set_url(str(z) + "-" + str(count))
                    self.ax2.annotate(names[z][count],xy=(textloc[z][count],Wradiitext[z]),xytext=(textloc[z][count],Wradiitext[z]),
                        rotation=textangles[z][count],horizontalalignment="center",verticalalignment="center",fontsize=self.wheeltextsize[z])
                    count += 1
            self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " drawWheel() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " drawWheel() %1").arg(str(e)),exc_tb.tb_lineno)
            return

    def makewheelcolorpattern(self):
        for x in range(len(self.wheelcolor)):
            wlen = len(self.wheelcolor[x])
            for i in range(wlen):
                color = QColor()
                color.setHsv((360/wlen)*i*self.wheelcolorpattern,255,255,255)
                self.wheelcolor[x][i] = str(color.name())

    # sets parent and corrects segment lengths so that child fits inside parent (multiple children can be set to same parent)
    # input: z = index of parent in previus wheel    # x = wheel number    # i = index of element in wheel x
    def setwheelchild(self,z,x,i):
        #set same start angle
        self.startangle[x] = self.startangle[x-1]
        self.wheellabelparent[x][i] = z

        #adjust lengths
        for x in range(1,len(self.segmentlengths)):
            nsegments = len(self.segmentlengths[x])
            parentanglecount = 0
            for i in range(nsegments):
                if  self.wheellabelparent[x][i]:                                                  #if parent selected (otherwise 0) 
                    parentindex = self.wheellabelparent[x][i]                                     #parent index
                    if self.wheellabelparent[x][i] == parentindex:                                #if match
                        parentangle = self.segmentlengths[x-1][self.wheellabelparent[x][i]-1]     #find parent angle (in %)
                        #find number of labels with same parent
                        count = self.wheellabelparent[x].count(parentindex)                       #count number of labels with same parent
                        self.segmentlengths[x][i] = parentangle/count                             #divide parent angle between children

                        #calculate last total angle
                        if i < nsegments-1:
                            parentanglecount += self.segmentlengths[x][i]

                        #adjust rest of angles to get 100 % coverage
                        for a in range(i+1,nsegments):
                            self.segmentlengths[x][a] = (100-parentanglecount)/(nsegments-(i+1))

    #adjusts size of all segements of the graph based on child parent relation
    #expects all segments to have a parent except in the first wheel
    def setWheelHierarchy(self):
        #check for not stablished relashionships (will cause graph plotting problems) and give warning
        for x in range(1,len(self.wheellabelparent)):
            for i in range(len(self.wheellabelparent[x])):
                if self.wheellabelparent[x][i] == 0:
                    QMessageBox.information(self,"Wheel Hierarchy Problem",
                    "Please assign a  a parent to wheel #%i element#%i: \n\n%s"%(x+1,i+1,self.wheelnames[x][i]))
                    return

        #adjust top wheel and make all segments equal
        for i in range(len(self.segmentlengths[-1])):
            self.segmentlengths[-1][i] = 100./len(self.segmentlengths[-1])

        #adjust lower wheels based on previous wheels
        for p in range(len(self.wheellabelparent)-1,0,-1):
            nsegments = len(self.wheellabelparent[p])
            nparentsegments = len(self.wheellabelparent[p-1])
            angles = [0]*nparentsegments
            for x in range(nparentsegments):
                for i in range(nsegments):
                    if self.wheellabelparent[p][i]-1 == x:
                        angles[x] += self.segmentlengths[p][i]

            #adjust angle length of parents proportionaly
            for i in range(nparentsegments):
                self.segmentlengths[p-1][i] = angles[i]

        self.drawWheel()

#############################     MOUSE CROSS     #############################

    def togglecrosslines(self):
        if self.crossmarker == False:  #if not projection flag
            if not self.designerflag:
                #turn ON
                self.crossmarker = True
                message = QApplication.translate("Message", "Mouse Cross ON: move mouse around",None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
                self.crossmouseid = self.fig.canvas.mpl_connect('motion_notify_event', self.drawcross)
        else:
            #turn OFF
            self.crossmarker = False
            if (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag))) and not self.designerflag:
                self.resetdeltalines()
            else:
                self.resetlines()
            self.fig.canvas.draw()
            message = QApplication.translate("Message", "Mouse cross OFF",None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
            self.fig.canvas.mpl_disconnect(self.crossmouseid)

    def drawcross(self,event):
        if event.inaxes == self.ax:
            x = event.xdata 
            y = event.ydata
            if x and y:
                self.resetlines()
                self.ax.plot([self.startofx,self.endofx*2], [y,y],color = self.palette["text"], linestyle = '-', linewidth= .5, alpha = 1.0)
                self.ax.plot([x,x], [self.ylimit_min,self.ylimit],color = self.palette["text"], linestyle = '-', linewidth= .5, alpha = 1.0)
                self.fig.canvas.draw()
        elif event.inaxes == self.delta_ax:
            x = event.xdata 
            y = event.ydata
            if x and y:
                self.resetdeltalines()
                self.delta_ax.plot([self.startofx,self.endofx*2], [y,y], color = self.palette["text"], linestyle = '-', linewidth = .5, alpha = 1.0)
                self.delta_ax.plot([x,x], [self.ylimit_min,self.ylimit], color = self.palette["text"], linestyle = '-', linewidth = .5, alpha = 1.0)
                self.fig.canvas.draw()


#######################################################################################
#####   temporary hack for windows till better solution found about toolbar icon problem with py2exe and svg
#######################################################################################

# changed "NavigationToolbar" for "VMToolbar" in ApplicationWindow

class VMToolbar(NavigationToolbar):
    def __init__(self, plotCanvas, parent):
        NavigationToolbar.__init__(self, plotCanvas, parent)

    def _icon(self, name):
        #dirty hack to prefer .svg over .png Toolbar icons
        p = os.path.join(self.basedir, name.replace('.png','.svg') )
        if os.path.exists(p):
            return QIcon(p)
        else:
            return QIcon(os.path.join(self.basedir, name))

    def edit_parameters(self):
        allaxes = self.canvas.figure.get_axes()
        if len(allaxes) == 1:
            axes = allaxes[0]
        else:
            titles = []
            for axes in allaxes:
                title = axes.get_title()
                ylabel = axes.get_ylabel()
                if title:
                    fmt = "Curves"
                    if ylabel:
                        fmt += " (%(ylabel)s)"
                elif ylabel:
                    fmt = "Delta Curves (%(ylabel)s)"
                else:
                    fmt = "%(axes_repr)s"
                titles.append(fmt % dict(title = title,
                                     ylabel = ylabel,
                                     axes_repr = repr(axes)))
            item, ok = QInputDialog.getItem(self, 'Customize',
                                                  'Select axes:', titles,
                                                  0, False)
            if ok:
                axes = allaxes[titles.index(str(item))]
            else:
                return
        figureoptions.figure_edit(axes, self)
        aw.fetchCurveStyles()
        # the redraw is mostly necessary to force a redraw of the legend to reflect the changed colors/styles/labels
        aw.qmc.redraw(recomputeAllDeltas=False)


########################################################################################
###     Sample thread
########################################################################################

class SampleThread(QThread):
    def __init__(self,parent = None):
        super(SampleThread,self).__init__(parent)
        self.afterTP = False

    # dropout filter
    # if temp (the actual reading) is outside of the interval [tmin,tmax] or
    # a spike is detected, the previous value is repeated or if that happend already before, -1 is returned
    # note that here we assume that the actual measured temperature time/temp was not already added to the list of previous measurements timex/tempx
    def filterDropOuts(self,timex,tempx,time,temp,BT=False):
        try:
            #########################
            # a) detect overflows
            wrong_reading = 0
            if aw.qmc.minmaxLimits and temp < aw.qmc.filterDropOut_tmin or temp > aw.qmc.filterDropOut_tmax:
                wrong_reading = 1
            #########################
            # b) detect spikes (on BT only after CHARGE if autoChargeDropFlag=True not to have a conflict here)
            n = aw.qmc.filterDropOut_spikeRoR_period
            dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit # the limit of additional RoR in temp/sec (4C for C / 7F for F) compared to previous readings
            if aw.qmc.dropSpikes and ((not aw.qmc.autoChargeDropFlag) or (not BT) or (aw.qmc.timeindex[0] != -1 and aw.qmc.timeindex[0] + n > len(timex))) and not wrong_reading and len(tempx) >= n:
                # no min/max overflow detected
                # check if RoR caused by actual measurement is way higher then the previous one
                # calc previous RoR (pRoR) taking the last n samples into account
                pdtemp = tempx[-1] - tempx[-n]
                pdtime = timex[-1] - timex[-n]
                pRoR = abs(pdtemp/pdtime)
                dtemp = tempx[-1] - temp
                dtime = timex[-1] - time
                RoR = abs(dtemp/dtime)
                if RoR > pRoR + dRoR_limit:
                    wrong_reading = 2
#            #########################
#            # c) handle outliers if it could be detected
            if wrong_reading:
#                if wrong_reading == 1:
#                    aw.sendmessage(QApplication.translate("Message","Overflow detected",None, QApplication.UnicodeUTF8))
#                    pass
#                elif wrong_reading == 2:
#                    aw.sendmessage(QApplication.translate("Message","Spike detected",None, QApplication.UnicodeUTF8))
#                # simple repeat strategy (should alternate between repeat-previous and keep-RoR strategy
                m = aw.qmc.filterDropOut_replaceRoR_period
                if len(tempx) > 0 and tempx[-1] != -1:
                    # repeate last correct reading if not done before in the last two fixes (min/max violation are always filtered)
                    if len(tempx) == 1 or wrong_reading == 1 or (len(tempx) > 3 and tempx[-1] != tempx[-2] and tempx[-2] != tempx[-3]):
                        return tempx[-1]
                    elif len(tempx) >= m and tempx[-1] != -1 and tempx[-m] != -1 and tempx[-1] != 0 and tempx[-m] != 0 and (len(tempx) < 4 or tempx[-4] != tempx[-3]):
                    # strategy based on previous RoR assuming a constant RoR [overly complex!]
                    # be careful with this RoR based filter as RoR might be very incorrect for short delta-times
                        # let's use the last m readings to compute the last RoR and
                        # replace the false reading by a computed one assuming that the
                        # RoR does not change
                        dtemp = tempx[-1] - tempx[-m] # dt is positive if RoR is
                        dtime = timex[-1] - timex[-m] # always positive
                        RoR = dtemp/dtime
                        return tempx[-1] + RoR * (time - timex[-1])
                    else:
                        # no way to correct this
                        return temp
                else:
                    # no way to correct this
                    return temp
            else:
                # try to improve a previously corrected reading timex/temp[-1] based on the current reading time/temp (just in this case the actual reading is not a drop)
                if len(tempx) > 2 and tempx[-1] == tempx[-2] and tempx[-2] != tempx[-3]: # previous reading was a drop and replaced by reading[-2], but -3 reading was different
                    tempx[-1] = (tempx[-2] + temp) / 2.0
                return temp                
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " filterDropOuts() %1").arg(str(e)),exc_tb.tb_lineno)            
            return temp

    # sample devices at interval self.delay miliseconds.
    # we can assume within the processing of sample() that flagon=True
    def sample(self):
        try:
            ##### lock resources  #########
            aw.qmc.samplingsemaphore.acquire(1)
            
            # duplicate system state flag flagstart locally and only refer to this copies within this function to make it behaving uniquely (either append or overwrite mode)
            local_flagstart = aw.qmc.flagstart
            
            # if we are not yet recording, but sampling we keep on reseting the timer (only if not already a profile was recorded)
            if not local_flagstart and len(aw.qmc.timex) < 2:
                aw.qmc.timeclock.start()
                
            #if using a meter (thermocouple device)
            if aw.qmc.device != 18: # not NONE device
                ##############  if using Extra devices
                nxdevices = len(aw.qmc.extradevices)
                if nxdevices:
                    les,led,let =  len(aw.extraser),len(aw.qmc.extradevices),len(aw.qmc.extratemp1)
                    if les == led == let:
                        xtra_dev_lines1 = 0
                        xtra_dev_lines2 = 0
                        for i in range(nxdevices):   
                            extratx,extrat2,extrat1 = aw.extraser[i].devicefunctionlist[aw.qmc.extradevices[i]]()
                            # ignore reading if both are off, otherwise process them
                            if extrat1 != -1 or extrat2 != -1:
                                if len(aw.qmc.extramathexpression1[i]):
                                    extrat1 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression1[i],extrat1)
                                    extrat1 = self.filterDropOuts(aw.qmc.extratimex[i],aw.qmc.extratemp1[i],extratx,extrat1)
                                if len(aw.qmc.extramathexpression2[i]):
                                    extrat2 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression2[i],extrat2)
                                    extrat2 = self.filterDropOuts(aw.qmc.extratimex[i],aw.qmc.extratemp2[i],extratx,extrat2)
                                if local_flagstart:
                                    aw.qmc.extratemp1[i].append(float(extrat1))
                                    aw.qmc.extratemp2[i].append(float(extrat2))
                                    aw.qmc.extratimex[i].append(extratx)
                                    # update extra lines
                                    if aw.extraCurveVisibility1[i]:
                                        aw.qmc.extratemp1lines[xtra_dev_lines1].set_data(aw.qmc.extratimex[i], aw.qmc.extratemp1[i])
                                        xtra_dev_lines1 = xtra_dev_lines1 + 1
                                    if aw.extraCurveVisibility2[i]:
                                        aw.qmc.extratemp2lines[xtra_dev_lines2].set_data(aw.qmc.extratimex[i], aw.qmc.extratemp2[i])
                                        xtra_dev_lines2 = xtra_dev_lines2 + 1
                                else:
                                    # we do not record, so we just replace the old last value
                                    if len(aw.qmc.extratemp1[i]) > 0:
                                        aw.qmc.extratemp1[i][-1] = float(extrat1)
                                    else:
                                        aw.qmc.extratemp1[i].append(float(extrat1))
                                    if len(aw.qmc.extratemp2[i]) > 0:
                                        aw.qmc.extratemp2[i][-1] = float(extrat2)
                                    else:
                                        aw.qmc.extratemp2[i].append(float(extrat2))
                                    if len(aw.qmc.extratimex[i]) <= 0:
                                        aw.qmc.extratimex[i].append(extratx)
                    #ERROR FOUND
                    else:
                        lengths = [les,led,let]
                        location = ["Extra-Serial","Extra-Devices","Extra-Temp"]
                        #find error
                        if (nxdevices-1) in lengths:
                            indexerror =  lengths.index(nxdevices-1)
                        elif (nxdevices+1) in lengths:
                            indexerror =  lengths.index(nxdevices+1)
                        else:
                            indexerror = 1000
                        if indexerror != 1000:
                            errormessage = "ERROR: length of %s (=%i) does not have the necessary length (=%i)"%(location[indexerror],lengths[indexerror],nxdevices)
                            errormessage += "\nPlease Reset: Extra devices"
                        else:
                            string = location[0] + "= " + str(lengths[0]) + " " + location[1] + "= " + str(lengths[1]) + " "
                            string += location[2] + "= " + str(lengths[2])
                            errormessage = "ERROR: extra devices lengths don't match: %s"%string
                            errormessage += "\nPlease Reset: Extra devices"
                        raise Exception(errormessage)
                #read time, ET (t1) and BT (t2) TEMPERATURE
                try:
                    tx,t1,t2 = aw.ser.devicefunctionlist[aw.qmc.device]()  #use a list of functions (a different one for each device) with index aw.qmc.device
                except:
                    tx = aw.qmc.timeclock.elapsed()/1000
                    t1 = t2 = -1
                if len(aw.qmc.ETfunction):
                    t1 = aw.qmc.eval_math_expression(aw.qmc.ETfunction,t1)
                if len(aw.qmc.BTfunction):
                    t2 = aw.qmc.eval_math_expression(aw.qmc.BTfunction,t2)
                t1 = self.filterDropOuts(aw.qmc.timex,aw.qmc.temp1,tx,t1)
                t2 = self.filterDropOuts(aw.qmc.timex,aw.qmc.temp2,tx,t2,True)
                length_of_qmc_timex = len(aw.qmc.timex)
                # ignore reading if both are off, otherwise process them
                if t1 != -1 or t2 != -1:
                    t1_final = t1
                    t2_final = t2
                    if local_flagstart:
                        aw.qmc.temp2.append(t2_final)
                        aw.qmc.temp1.append(t1_final)
                        aw.qmc.timex.append(tx)
                        length_of_qmc_timex += 1
                    else:
                        if len(aw.qmc.temp2) > 0:
                            aw.qmc.temp2[-1] = t2_final
                        else:                            
                            aw.qmc.temp2.append(t2_final)
                        if len(aw.qmc.temp1) > 0:
                            aw.qmc.temp1[-1] = t1_final
                        else:                            
                            aw.qmc.temp1.append(t1_final)
                        if length_of_qmc_timex <= 0:
                            aw.qmc.timex.append(tx)
                            length_of_qmc_timex += 1
                        else:
                            aw.qmc.timex[-1] = tx
                    # update lines data using the lists with new data
                    if local_flagstart:
                        aw.qmc.l_temp1.set_data(aw.qmc.timex, aw.qmc.temp1)
                        aw.qmc.l_temp2.set_data(aw.qmc.timex, aw.qmc.temp2)
                    #we need a minimum of two readings to calculate rate of change
                    if local_flagstart and length_of_qmc_timex > 2:
                        timed = aw.qmc.timex[-1] - aw.qmc.timex[-2]   #time difference between last two readings
                        #calculate Delta T = (changeTemp/ChangeTime)*60. =  degress per minute;
                        aw.qmc.rateofchange1 = ((aw.qmc.temp1[-1] - aw.qmc.temp1[-2])/timed)*60.  #delta ET (degress/minute)
                        aw.qmc.rateofchange2 = ((aw.qmc.temp2[-1] - aw.qmc.temp2[-2])/timed)*60.  #delta  BT (degress/minute)
                        aw.qmc.unfiltereddelta1.append(aw.qmc.rateofchange1)
                        aw.qmc.unfiltereddelta2.append(aw.qmc.rateofchange2)
                        #######   filter deltaBT deltaET
                        if aw.qmc.deltafilter:
                            if length_of_qmc_timex > aw.qmc.deltafilter:   #detafilter is an int = number of pads
                                if (len(aw.qmc.unfiltereddelta1) > aw.qmc.deltafilter) and (len(aw.qmc.unfiltereddelta2) > aw.qmc.deltafilter):
                                    a1,a2 = 0.,0.
                                    for k in range(aw.qmc.deltafilter):
                                        a1 += aw.qmc.unfiltereddelta1[-(k+1)]
                                        a2 += aw.qmc.unfiltereddelta2[-(k+1)]
                                    aw.qmc.rateofchange1 = a1/float(aw.qmc.deltafilter)
                                    aw.qmc.rateofchange2 = a2/float(aw.qmc.deltafilter)
                        rateofchange1plot = aw.qmc.rateofchange1
                        rateofchange2plot = aw.qmc.rateofchange2
                    else:
                        if local_flagstart:
                            aw.qmc.unfiltereddelta1.append(0.)
                            aw.qmc.unfiltereddelta2.append(0.)
                        else:
                            if len(aw.qmc.unfiltereddelta1) > 0:
                                aw.qmc.unfiltereddelta1[-1] = 0.
                            else:
                                aw.qmc.unfiltereddelta1.append(0.)
                            if len(aw.qmc.unfiltereddelta2) > 0:
                                aw.qmc.unfiltereddelta2[-1] = 0.
                            else:
                                aw.qmc.unfiltereddelta2.append(0.)
                        aw.qmc.rateofchange1,aw.qmc.rateofchange2,rateofchange1plot,rateofchange2plot = 0.,0.,0.,0.
                    # append new data to the rateofchange
                    if local_flagstart:
                        aw.qmc.delta1.append(rateofchange1plot)
                        aw.qmc.delta2.append(rateofchange2plot)
                    else:
                        if len(aw.qmc.delta1) > 0:
                            aw.qmc.delta1[-1] = rateofchange1plot
                        else:
                            aw.qmc.delta1.append(rateofchange1plot)
                        if len(aw.qmc.delta2) > 0:
                            aw.qmc.delta2[-1] = rateofchange2plot
                        else:
                            aw.qmc.delta2.append(rateofchange2plot)
                    if local_flagstart:
                        if aw.qmc.DeltaETflag:
                            aw.qmc.l_delta1.set_data(aw.qmc.timex, aw.qmc.delta1)
                        if aw.qmc.DeltaBTflag:
                            aw.qmc.l_delta2.set_data(aw.qmc.timex, aw.qmc.delta2)
                        #readjust xlimit of plot if needed
                        if  not aw.qmc.fixmaxtime and aw.qmc.timex[-1] > (aw.qmc.endofx - 45):            # if difference is smaller than 30 seconds
                            aw.qmc.endofx = int(aw.qmc.timex[-1] + 180.)         # increase x limit by 3 minutes
                            aw.qmc.xaxistosm()
                        if aw.qmc.projectFlag:
                            aw.qmc.viewProjection()
                        if aw.qmc.background and aw.qmc.backgroundReproduce:
                            aw.qmc.playbackevent()
                        # autodetect CHARGE event
                        # only if BT > 203F/95C
                        if not aw.qmc.autoChargeIdx and aw.qmc.autoChargeDropFlag and aw.qmc.timeindex[0] < 0 and length_of_qmc_timex >= 5 and \
                            ((aw.qmc.mode == "C" and aw.qmc.temp2[-1] > 95) or (aw.qmc.mode == "F" and aw.qmc.temp2[-1] > 203)):
                            if aw.BTbreak(length_of_qmc_timex - 1):
                                # we found a BT break at the current index minus 2
                                aw.qmc.autoChargeIdx = length_of_qmc_timex - 3
                        # autodetect DROP event
                        # only if 9min into roast and BT>180C/356F
                        elif not aw.qmc.autoDropIdx and aw.qmc.autoChargeDropFlag and aw.qmc.timeindex[0] > 0 and not aw.qmc.timeindex[6] and \
                            length_of_qmc_timex >= 5 and ((aw.qmc.mode == "C" and aw.qmc.temp2[-1] > 190) or (aw.qmc.mode == "F" and aw.qmc.temp2[-1] > 356)) and\
                            ((aw.qmc.timex[-1] - aw.qmc.timex[aw.qmc.timeindex[0]]) > 540):
                            if aw.BTbreak(length_of_qmc_timex - 1):
                                # we found a BT break at the current index minus 2
                                aw.qmc.autoDropIdx = length_of_qmc_timex - 3
                    if local_flagstart:
                        #check alarms 
                        # check for TP event if already CHARGEed and not yet recognized
                        if not aw.qmc.TPalarmtimeindex and len(aw.qmc.alarmflag) > 0 and aw.qmc.timeindex[0] > -1 and self.checkTPalarmtime():
                            aw.qmc.TPalarmtimeindex = len(aw.qmc.timex)-1
                        #check for each alarm that was not yet triggered
                        for i in range(len(aw.qmc.alarmflag)):
                            #if alarm on, and not triggered, and time is after set time:
                            # qmc.alarmtime = -1 (None == ON)
                            # qmc.alarmtime = 0 (CHARGE)
                            # ..
                            # Cases: (only between CHARGE and DRY we check for TP if alarmtime[i]=8)
                            # 1) the alarm is START
                            # 2) the alarm was not triggered yet
                            # 3) the alarm From is ON
                            # 4) the alarm From is CHARGE
                            # 5) the alarm From is any other event but TP
                            # 6) the alarm From is TP, it is CHARGED and the TP pattern is recognized
                            if aw.qmc.alarmflag[i] \
                              and not aw.qmc.alarmstate[i] \
                              and (aw.qmc.alarmguard[i] < 0 or (0 <= aw.qmc.alarmguard[i] < len(aw.qmc.alarmflag) and aw.qmc.alarmstate[aw.qmc.alarmguard[i]])) \
                              and ((aw.qmc.alarmtime[i] < 0) \
                              or (aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1) \
                              or (aw.qmc.alarmtime[i] > 0 and aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0) \
                              or (aw.qmc.alarmtime[i]==8 and aw.qmc.timeindex[0] > -1 \
                                    and aw.qmc.timeindex[1] < 1 and aw.qmc.TPalarmtimeindex)):
                                #########
                                # check alarmoffset (time after From event):
                                if aw.qmc.alarmoffset[i] > 0:
                                    alarm_time = aw.qmc.timeclock.elapsed()/1000.
                                    if aw.qmc.alarmtime[i] < 0: # time after START
                                        pass # the alarm_time is the clock time
                                    elif aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1: # time after CHARGE
                                        alarm_time = alarm_time - aw.qmc.timex[aw.qmc.timeindex[0]]
                                    elif aw.qmc.alarmtime[i] == 8 and aw.qmc.TPalarmtimeindex: # time after TP
                                        alarm_time = alarm_time - aw.qmc.timex[aw.qmc.TPalarmtimeindex]
                                    elif aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0: # time after any other event
                                        alarm_time = alarm_time - aw.qmc.timex[aw.qmc.timeindex[aw.qmc.alarmtime[i]]]
                                    if alarm_time >= aw.qmc.alarmoffset[i]:
                                        aw.qmc.temporaryalarmflag = i
                                #########
                                # check alarmtemp:
                                alarm_temp = None
                                if aw.qmc.alarmsource[i] == -2:                       #check DeltaET
                                    alarm_temp = aw.qmc.delta1[-1]
                                elif aw.qmc.alarmsource[i] == -1:                     #check DeltaBT
                                    alarm_temp = aw.qmc.delta2[-1]
                                elif aw.qmc.alarmsource[i] == 0:                      #check ET
                                    alarm_temp = aw.qmc.temp1[-1]
                                elif aw.qmc.alarmsource[i] == 1:                      #check BT
                                    alarm_temp = aw.qmc.temp2[-1]
                                elif aw.qmc.alarmsource[i] > 1 and ((aw.qmc.alarmsource[i] - 2) < (2*len(aw.qmc.extradevices))):
                                    if (aw.qmc.alarmsource[i])%2==0:
                                        alarm_temp = aw.qmc.extratemp1[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                    else:
                                        alarm_temp = aw.qmc.extratemp2[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                alarm_limit = aw.qmc.alarmtemperature[i]
                                if alarm_temp and ((aw.qmc.alarmcond[i] == 1 and alarm_temp > alarm_limit) or (aw.qmc.alarmcond[i] == 0 and alarm_temp < alarm_limit)):
                                    aw.qmc.temporaryalarmflag = i
            #############    if using DEVICE 18 (no device). Manual mode
            # temperatures are entered when pressing push buttons like for example at aw.qmc.markDryEnd()
            else:
                tx = int(aw.qmc.timeclock.elapsed()/1000.)
                #readjust xlimit of plot if needed
                if  tx > (aw.qmc.endofx - 45):            # if difference is smaller than 45 seconds
                    aw.qmc.endofx = tx + 180              # increase x limit by 3 minutes (180)
                    aw.qmc.ax.set_xlim(aw.qmc.startofx,aw.qmc.endofx)
                    aw.qmc.xaxistosm()
                aw.qmc.resetlines()
                #add to plot a vertical time line
                aw.qmc.ax.plot([tx,tx], [aw.qmc.ylimit_min,aw.qmc.ylimit],color = aw.qmc.palette["Cline"],linestyle = '-', linewidth= 1, alpha = .7)
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
            #update screen in main GUI thread
            self.emit(SIGNAL("updategraphics"))
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " sample() %1").arg(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    # returns true after BT passed the TP
    def checkTPalarmtime(self):
        # if v[-1] is the current temperature then check if
        #   len(BT) > 4
        # BT[-4] <= BT[-3] <= BT[-2] <= BT[-1] and BT[-4] < BT[-1]
        if not self.afterTP and len(aw.qmc.temp2) > 3 and aw.qmc.temp2[-4] <= aw.qmc.temp2[-3] <= aw.qmc.temp2[-2] <= aw.qmc.temp2[-1] and aw.qmc.temp2[-4] < aw.qmc.temp2[-1]:
            self.afterTP = True
        return self.afterTP

    def run(self):
        self.afterTP = False
        if not aw.qmc.flagon:
            return
        while True:
            if aw.qmc.flagon:
                #collect information
                tx = aw.qmc.timeclock.elapsed()
                self.sample()
                # calculate the time still to sleep based on the time the sampling took and the requested sampling interval (qmc.delay)
                dt = (max(1,(aw.qmc.delay - tx + aw.qmc.timeclock.elapsed()))) /1000.
                #apply sampling interval here
                libtime.sleep(dt)
            else:
                aw.qmc.flagstopping = False # we signal that we stopped sampling
                try:
                    if aw.ser.SP.isOpen():
                        aw.ser.closeport()
                    QApplication.processEvents()
                except:
                    pass
                self.quit()
                break  #thread ends

#########################################################################################################
###     Artisan thread Server
#########################################################################################################

class Athreadserver(QWidget):
    def __init__(self,parent = None):
        super(Athreadserver,self).__init__(parent)

    def createSampleThread(self):
        sthread = SampleThread(self)
        #QApplication.processEvents()

        #delete when finished to save memory 
        self.connect(sthread,SIGNAL("finished"),sthread,SLOT("deleteLater()"))
        #connect graphics to GUI thread
        self.connect(sthread, SIGNAL("updategraphics"),aw.qmc.updategraphics)
        sthread.start()
        sthread.wait(300)    #needed in some Win OS

########################################################################################
#################### MAIN APPLICATION WINDOW ###########################################
########################################################################################

class ApplicationWindow(QMainWindow):
    def __init__(self, parent = None):

        self.defaultAppearance = None
        # should be a font supporting unicode characters including arabic and which is available on all platforms
        self.defaultFont = "Times New Roman" # "Arial Unicode MS", "Times New Roman", "Tahoma", "Trebuchet MS"
        
        #############################  Define variables that need to exist before calling settingsload()
        self.curFile = None
        self.MaxRecentFiles = 10
        self.recentFileActs = []
        self.applicationDirectory =  QDir().current().absolutePath()
        super(ApplicationWindow, self).__init__(parent)

        #flag to reset Qsettings
        self.resetqsettings = 0

        # self.profilepath is obteined at dirstruct() and points to profiles/year/month file-open/save will point to profilepath
        self.profilepath = ""
        if platf == 'Darwin' or platf == 'Linux':
            self.profilepath = QDir().homePath().append(QString("/Documents/"))
        else:
            self.profilepath = QDir().homePath()
            
        # on the Mac preferences should be stored outside of applications in the users ~/Library/Preferences path
        if platf == 'Darwin':
            preference_path = QDir().homePath().append(QString("/Library/Preferences//"))
            preference_dir = QDir()
            preference_dir.setPath(preference_path)
            if not preference_dir.exists():
                QDir().mkpath(preference_path)
            QDir().setCurrent(preference_path)

        #checks executable directory. dirstruct() checks or creates: /profile/year/month directory to store profiles
        #self.dirstruct()        


        #defaults the users profile path to the standard profilepath (incl. month/year subdirectories)
        self.userprofilepath = self.profilepath

        self.printer = QPrinter()
#        self.printer.setPageSize(QPrinter.Letter)
        self.printer.setCreator("Artisan")

        self.main_widget = QWidget(self)
        #set a minimum size (main window can be bigger but never smaller)
        self.main_widget.setMinimumWidth(811)
        #self.main_widget.setMinimumHeight(670)

        ####      create Matplotlib canvas widget
        #resolution
        self.defaultdpi = 80
        self.dpi = self.defaultdpi
        self.qmc = tgraphcanvas(self.main_widget)
        #self.qmc.setAttribute(Qt.WA_NoSystemBackground)

        ####    HUD
        self.HUD = QLabel()  #main canvas for hud widget

        #This is a list of different HUD functions.
        self.showHUD = [self.showHUDmetrics, self.showHUDthermal]
        #this holds the index of the HUD functions above
        self.HUDfunction = 0

#        self.sound = soundcrack(QWidget)
        self.stack = QStackedWidget()
        self.stack.addWidget(self.qmc)
        self.stack.addWidget(self.HUD)
#        self.stack.addWidget(self.sound)
        self.stack.setCurrentIndex(0)
        self.stack.setContentsMargins(0,0,0,0)
        self.qmc.setContentsMargins(0,0,0,0)
        self.HUD.setContentsMargins(0,0,0,0)
#        self.sound.setContentsMargins(0,0,0,0)
        #events config
        self.eventsbuttonflag = 1
        self.minieventsflag = 0   #minieditor flag

        #create a serial port object (main ET BT device)
        self.ser = serialport()
        #create a modbus port object (main modbus device)
        self.modbus = modbusport()
        #create scale port object
        self.scale = scaleport()
        #list with extra serial ports (extra devices)
        self.extraser = []
        #extra comm port settings 
        self.extracomport,self.extrabaudrate,self.extrabytesize,self.extraparity,self.extrastopbits,self.extratimeout = [],[],[],[],[],[]

        # create a ET control objects
        self.fujipid = FujiPID()
        self.dtapid = DtaPID()
##        self.arduino = ArduinoTC4()

        self.soundflag = 0

        #lcd1 = time, lcd2 = met, lcd3 = bt, lcd4 = roc et, lcd5 = roc bt, lcd6 = sv (extra devices lcd same as sv seetings)
        self.lcdpaletteB = {"timer":'black',"et":'black',"bt":'black',"deltaet":'black',"deltabt":'black',"sv":'black'}
        self.lcdpaletteF = {"timer":'white',"et":'white',"bt":'white',"deltaet":'white',"deltabt":'white',"sv":'yellow'}

        #user defined event buttons
        self.extraeventsbuttonsflag = 1  #shows/hides rows of buttons  0/1
        self.extraeventslabels,self.extraeventsdescriptions, self.extraeventstypes,self.extraeventsvalues = [],[],[],[]  #hold string,string,index,index
        self.extraeventbuttoncolor,self.extraeventbuttontextcolor = [],[]
        self.extraeventsactionstrings,self.extraeventsactions,self.extraeventsvisibility = [],[],[] #hold string,index,index

        #event sliders
        self.eventslidervalues = [0,0,0,0]
        self.eventslidervisibilities = [0,0,0,0]
        self.eventslideractions = [0,0,0,0] # 0: None, 1: Serial Command, 2: Modbus Command, 3: DTA Command
        self.eventslidercommands = ["","","",""]
        self.eventslideroffsets = [0,0,0,0]
        self.eventsliderfactors = [1.0,1.0,1.0,1.0]

        # set window title
        self.windowTitle = "Artisan %s"%str(__version__)
        self.setWindowTitle(self.windowTitle)
        for i in range(self.MaxRecentFiles):
            self.recentFileActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentFile))

        #records serial comm (Help menu)
        self.seriallogflag = False
        self.seriallog = []

        #temp variable for text searches in Help menu artisan seetings
        self.searchtextartisansettings = ""

        #######################    MENUS SECTION ##################################################
        ###############  create Top MENUS

        self.fileMenu = self.menuBar().addMenu(UIconst.FILE_MENU)
        self.editMenu = self.menuBar().addMenu(UIconst.EDIT_MENU)
        self.GraphMenu = self.menuBar().addMenu(UIconst.ROAST_MENU)
        self.ConfMenu = self.menuBar().addMenu(UIconst.CONF_MENU)
        self.ToolkitMenu = self.menuBar().addMenu(UIconst.TOOLKIT_MENU)
        self.helpMenu = self.menuBar().addMenu(UIconst.HELP_MENU)

        #FILE menu
        newRoastAction = QAction(UIconst.FILE_MENU_NEW,self)

        newRoastAction.setShortcut(QKeySequence.New)
        self.connect(newRoastAction,SIGNAL("triggered()"),self.newRoast)
        self.fileMenu.addAction(newRoastAction)

        self.fileLoadAction = QAction(UIconst.FILE_MENU_OPEN,self)
        self.fileLoadAction.setShortcut(QKeySequence.Open)
        self.connect(self.fileLoadAction,SIGNAL("triggered()"),self.fileLoad)
        self.fileMenu.addAction(self.fileLoadAction)

        self.openRecentMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_OPENRECENT)
        for i in range(self.MaxRecentFiles):
            self.openRecentMenu.addAction(self.recentFileActs[i])
        self.updateRecentFileActions()

        self.importMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_IMPORT)

        fileImportCSVAction = QAction(QApplication.translate("Menu", "CSV...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileImportCSVAction,SIGNAL("triggered()"),self.fileImportCSV)
        self.importMenu.addAction(fileImportCSVAction)

        fileImportJSONAction = QAction(QApplication.translate("Menu", "JSON...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileImportJSONAction,SIGNAL("triggered()"),self.fileImportJSON)
        self.importMenu.addAction(fileImportJSONAction)

        fileImportRoastLoggerAction = QAction(QApplication.translate("Menu", "RoastLogger...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileImportRoastLoggerAction,SIGNAL("triggered()"),self.fileImportRoastLogger)
        self.importMenu.addAction(fileImportRoastLoggerAction)

        importHH506RAAction = QAction(QApplication.translate("Menu", "HH506RA...",None, QApplication.UnicodeUTF8),self)
        self.connect(importHH506RAAction,SIGNAL("triggered()"),self.importHH506RA)
        self.importMenu.addAction(importHH506RAAction)

        importK202Action = QAction(QApplication.translate("Menu", "K202...",None, QApplication.UnicodeUTF8),self)
        self.connect(importK202Action,SIGNAL("triggered()"),self.importK202)
        self.importMenu.addAction(importK202Action)

        importK204Action = QAction(QApplication.translate("Menu", "K204...",None, QApplication.UnicodeUTF8),self)
        self.connect(importK204Action,SIGNAL("triggered()"),self.importK204)
        self.importMenu.addAction(importK204Action)

        self.fileMenu.addMenu(self.importMenu)
        self.fileMenu.addSeparator()

        self.fileSaveAction = QAction(UIconst.FILE_MENU_SAVE,self)
        self.fileSaveAction.setShortcut(QKeySequence.Save)
        self.connect(self.fileSaveAction,SIGNAL("triggered()"),lambda b=0:self.fileSave(self.curFile))
        self.fileMenu.addAction(self.fileSaveAction)

        self.fileSaveAsAction = QAction(UIconst.FILE_MENU_SAVEAS,self)
        self.connect(self.fileSaveAsAction,SIGNAL("triggered()"),lambda b=0:self.fileSave(None))
        self.fileMenu.addAction(self.fileSaveAsAction)

        self.fileMenu.addSeparator()

        self.exportMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_EXPORT)

        fileExportCSVAction = QAction(QApplication.translate("Menu", "CSV...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileExportCSVAction,SIGNAL("triggered()"),self.fileExportCSV)
        self.exportMenu.addAction(fileExportCSVAction)

        fileExportJSONAction = QAction(QApplication.translate("Menu", "JSON...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileExportJSONAction,SIGNAL("triggered()"),self.fileExportJSON)
        self.exportMenu.addAction(fileExportJSONAction)

        fileExportRoastLoggerAction = QAction(QApplication.translate("Menu", "RoastLogger...",None, QApplication.UnicodeUTF8),self)
        self.connect(fileExportRoastLoggerAction,SIGNAL("triggered()"),self.fileExportRoastLogger)
        self.exportMenu.addAction(fileExportRoastLoggerAction)

        self.fileMenu.addSeparator()

        self.saveGraphMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_SAVEGRAPH)

        fullsizeAction = QAction(UIconst.FILE_MENU_SAVEGRAPH_FULL_SIZE,self)
        self.connect(fullsizeAction,SIGNAL("triggered()"),lambda x=0,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(fullsizeAction)

        KaffeeNetzAction = QAction("Kaffee-Netz.de (800x?)...",self)
        self.connect(KaffeeNetzAction,SIGNAL("triggered()"),lambda x=800,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(KaffeeNetzAction)

        HomeBaristaAction = QAction("Home-Barista.com (700x?)...",self)
        self.connect(HomeBaristaAction,SIGNAL("triggered()"),lambda x=700,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(HomeBaristaAction)

        RiktigtKaffeAction = QAction("RiktigtKaffe.se (620x?)...",self)
        self.connect(RiktigtKaffeAction,SIGNAL("triggered()"),lambda x=620,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(RiktigtKaffeAction)

        PlanetCafeAction = QAction("PlanetCafe.fr (600x?)...",self)
        self.connect(PlanetCafeAction,SIGNAL("triggered()"),lambda x=600,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(PlanetCafeAction)

        CoffeeGeekAction = QAction("CoffeeGeek.com (500x?)...",self)
        self.connect(CoffeeGeekAction,SIGNAL("triggered()"),lambda x=500,y=1:self.resize(x,y))
        self.saveGraphMenu.addAction(CoffeeGeekAction)
        
        SVGAction = QAction("SVG...",self)
        self.connect(SVGAction,SIGNAL("triggered()"),lambda _=None : self.saveVectorGraph(".svg"))
        self.saveGraphMenu.addAction(SVGAction)
        PDFAction = QAction("PDF...",self)
        self.connect(PDFAction,SIGNAL("triggered()"),lambda _=None : self.saveVectorGraph(".pdf"))
        self.saveGraphMenu.addAction(PDFAction)

        self.htmlAction = QAction(UIconst.FILE_MENU_HTMLREPORT,self)
        self.connect(self.htmlAction,SIGNAL("triggered()"),self.htmlReport)
        self.htmlAction.setShortcut("Ctrl+R")
        self.fileMenu.addAction(self.htmlAction)

        self.fileMenu.addSeparator()

        self.printAction = QAction(UIconst.FILE_MENU_PRINT,self)
        self.printAction.setShortcut(QKeySequence.Print)
        self.connect(self.printAction,SIGNAL("triggered()"),self.filePrint)
        self.fileMenu.addAction(self.printAction)
        
        self.quitAction = QAction("Quit",self)
        self.quitAction.setShortcut(QKeySequence.Quit)
        self.connect(self.quitAction,SIGNAL("triggered()"),self.fileQuit)
        self.fileMenu.addAction(self.quitAction)
        

        # EDIT menu
        self.cutAction = QAction(UIconst.EDIT_MENU_CUT,self)
        self.cutAction.setShortcut(QKeySequence.Cut)
        self.editMenu.addAction(self.cutAction)
        self.connect(self.cutAction,SIGNAL("triggered()"),self.on_actionCut_triggered)
        self.copyAction = QAction(UIconst.EDIT_MENU_COPY,self)
        self.copyAction.setShortcut(QKeySequence.Copy)
        self.editMenu.addAction(self.copyAction)
        self.connect(self.copyAction,SIGNAL("triggered()"),self.on_actionCopy_triggered)
        self.pasteAction = QAction(UIconst.EDIT_MENU_PASTE,self)
        self.pasteAction.setShortcut(QKeySequence.Paste)
        self.editMenu.addAction(self.pasteAction)
        self.connect(self.pasteAction,SIGNAL("triggered()"),self.on_actionPaste_triggered)

        # ROAST menu
        editGraphAction = QAction(UIconst.ROAST_MENU_PROPERTIES,self)
        self.connect(editGraphAction,SIGNAL("triggered()"),self.editgraph)
        self.GraphMenu.addAction(editGraphAction)

        backgroundAction = QAction(UIconst.ROAST_MENU_BACKGROUND,self)
        self.connect(backgroundAction,SIGNAL("triggered()"),self.background)
        self.GraphMenu.addAction(backgroundAction)  

        self.flavorAction = QAction(UIconst.ROAST_MENU_CUPPROFILE,self)
        self.connect(self.flavorAction ,SIGNAL("triggered()"),self.flavorchart)
        self.GraphMenu.addAction(self.flavorAction)

        self.GraphMenu.addSeparator()

        self.temperatureMenu = self.GraphMenu.addMenu(UIconst.ROAST_MENU_TEMPERATURE)

        self.ConvertToFahrenheitAction = QAction(UIconst.ROAST_MENU_CONVERT_TO_FAHRENHEIT,self)
        self.connect(self.ConvertToFahrenheitAction,SIGNAL("triggered()"),lambda t="F":self.qmc.convertTemperature(t))
        self.temperatureMenu.addAction(self.ConvertToFahrenheitAction)

        self.ConvertToCelsiusAction = QAction(UIconst.ROAST_MENU_CONVERT_TO_CELSIUS,self)
        self.connect(self.ConvertToCelsiusAction,SIGNAL("triggered()"),lambda t="C":self.qmc.convertTemperature(t))
        self.temperatureMenu.addAction(self.ConvertToCelsiusAction)

        self.FahrenheitAction = QAction(UIconst.ROAST_MENU_FAHRENHEIT_MODE,self)
        self.connect(self.FahrenheitAction,SIGNAL("triggered()"),self.qmc.fahrenheitModeRedraw)
        self.temperatureMenu.addAction(self.FahrenheitAction)

        self.CelsiusAction = QAction(UIconst.ROAST_MENU_CELSIUS_MODE,self)
        self.connect(self.CelsiusAction,SIGNAL("triggered()"),self.qmc.celsiusModeRedraw)
        self.temperatureMenu.addAction(self.CelsiusAction)

        if self.qmc.mode == "F":
            self.FahrenheitAction.setDisabled(True)
            self.ConvertToFahrenheitAction.setDisabled(True)
        else:
            self.CelsiusAction.setDisabled(True)
            self.ConvertToCelsiusAction.setDisabled(True)

        # CONFIGURATION menu
        deviceAction = QAction(UIconst.CONF_MENU_DEVICE, self)
        self.connect(deviceAction,SIGNAL("triggered()"),self.deviceassigment)
        self.ConfMenu.addAction(deviceAction)

        commportAction = QAction(UIconst.CONF_MENU_SERIALPORT,self)
        self.connect(commportAction,SIGNAL("triggered()"),self.setcommport)
        self.ConfMenu.addAction(commportAction)

        calibrateDelayAction = QAction(UIconst.CONF_MENU_SAMPLING,self)
        self.connect(calibrateDelayAction,SIGNAL("triggered()"),self.calibratedelay)
        self.ConfMenu.addAction(calibrateDelayAction)

        self.ConfMenu.addSeparator()

        eventsAction = QAction(UIconst.CONF_MENU_EVENTS,self)
        self.connect(eventsAction,SIGNAL("triggered()"),self.eventsconf)
        self.ConfMenu.addAction(eventsAction)

        alarmAction = QAction(UIconst.CONF_MENU_ALARMS,self)
        self.connect(alarmAction,SIGNAL("triggered()"),self.alarmconfig)
        self.ConfMenu.addAction(alarmAction) 

        self.ConfMenu.addSeparator()

        phasesGraphAction = QAction(UIconst.CONF_MENU_PHASES,self)
        self.connect(phasesGraphAction,SIGNAL("triggered()"),self.editphases)
        self.ConfMenu.addAction(phasesGraphAction)

        StatisticsAction = QAction(UIconst.CONF_MENU_STATISTICS,self)
        self.connect(StatisticsAction,SIGNAL("triggered()"),self.showstatistics)
        self.ConfMenu.addAction(StatisticsAction)

        WindowconfigAction = QAction(UIconst.CONF_MENU_AXES,self)
        self.connect(WindowconfigAction,SIGNAL("triggered()"),self.Windowconfig)
        self.ConfMenu.addAction(WindowconfigAction) 

        self.ConfMenu.addSeparator()

        colorsAction = QAction(UIconst.CONF_MENU_COLORS,self)
        self.connect(colorsAction,SIGNAL("triggered()"),lambda x=3:self.qmc.changeGColor(x))
        self.ConfMenu.addAction(colorsAction)

        autosaveAction = QAction(UIconst.CONF_MENU_AUTOSAVE,self)
        self.connect(autosaveAction,SIGNAL("triggered()"),self.autosaveconf)
        self.ConfMenu.addAction(autosaveAction)

        self.ConfMenu.addSeparator()

        self.languageMenu = self.ConfMenu.addMenu(UIconst.CONF_MENU_LANGUAGE)

        EnglishLanguage = QAction(UIconst.CONF_MENU_ENGLISH,self)
        self.connect(EnglishLanguage,SIGNAL("triggered()"),lambda lang="en":self.changelocale(lang))
        self.languageMenu.addAction(EnglishLanguage)

        GermanLanguage = QAction(UIconst.CONF_MENU_GERMAN,self)
        self.connect(GermanLanguage,SIGNAL("triggered()"),lambda lang="de":self.changelocale(lang))
        self.languageMenu.addAction(GermanLanguage)

        FrenchLanguage = QAction(UIconst.CONF_MENU_FRENCH,self)
        self.connect(FrenchLanguage,SIGNAL("triggered()"),lambda lang="fr":self.changelocale(lang))
        self.languageMenu.addAction(FrenchLanguage)

        SpanishLanguage = QAction(UIconst.CONF_MENU_SPANISH,self)
        self.connect(SpanishLanguage,SIGNAL("triggered()"),lambda lang="es":self.changelocale(lang))
        self.languageMenu.addAction(SpanishLanguage) 

        SwedishLanguage = QAction(UIconst.CONF_MENU_SWEDISH,self)
        self.connect(SwedishLanguage,SIGNAL("triggered()"),lambda lang="sv":self.changelocale(lang))
        self.languageMenu.addAction(SwedishLanguage) 
        
        ItalianLanguage = QAction(UIconst.CONF_MENU_ITALIAN,self)
        self.connect(ItalianLanguage,SIGNAL("triggered()"),lambda lang="it":self.changelocale(lang))
        self.languageMenu.addAction(ItalianLanguage) 

        ChineseChinaLanguage = QAction(UIconst.CONF_MENU_CHINESE_CN,self)
        self.connect(ChineseChinaLanguage,SIGNAL("triggered()"),lambda lang="zh_CN":self.changelocale(lang))
        self.languageMenu.addAction(ChineseChinaLanguage) 

        ChineseTaiwanLanguage = QAction(UIconst.CONF_MENU_CHINESE_TW,self)
        self.connect(ChineseTaiwanLanguage,SIGNAL("triggered()"),lambda lang="zh_TW":self.changelocale(lang))
        self.languageMenu.addAction(ChineseTaiwanLanguage) 

        GreekLanguage = QAction(UIconst.CONF_MENU_GREEK,self)
        self.connect(GreekLanguage,SIGNAL("triggered()"),lambda lang="el":self.changelocale(lang))
        self.languageMenu.addAction(GreekLanguage)

        NorwegianLanguage = QAction(UIconst.CONF_MENU_NORWEGIAN,self)
        self.connect(NorwegianLanguage,SIGNAL("triggered()"),lambda lang="no":self.changelocale(lang))
        self.languageMenu.addAction(NorwegianLanguage)

        DutchLanguage = QAction(UIconst.CONF_MENU_DUTCH,self)
        self.connect(DutchLanguage,SIGNAL("triggered()"),lambda lang="nl":self.changelocale(lang))
        self.languageMenu.addAction(DutchLanguage)

        KoreanLanguage = QAction(UIconst.CONF_MENU_KOREAN,self)
        self.connect(KoreanLanguage,SIGNAL("triggered()"),lambda lang="ko":self.changelocale(lang))
        self.languageMenu.addAction(KoreanLanguage)

        PortugueseLanguage = QAction(UIconst.CONF_MENU_PORTUGUESE,self)
        self.connect(PortugueseLanguage,SIGNAL("triggered()"),lambda lang="pt":self.changelocale(lang))
        self.languageMenu.addAction(PortugueseLanguage)

        RussianLanguage = QAction(UIconst.CONF_MENU_RUSSIAN,self)
        self.connect(RussianLanguage,SIGNAL("triggered()"),lambda lang="ru":self.changelocale(lang))
        self.languageMenu.addAction(RussianLanguage)

        ArabicLanguage = QAction(UIconst.CONF_MENU_ARABIC,self)
        self.connect(ArabicLanguage,SIGNAL("triggered()"),lambda lang="ar":self.changelocale(lang))
        self.languageMenu.addAction(ArabicLanguage)

        FinishLanguage = QAction(UIconst.CONF_MENU_FINISH,self)
        self.connect(FinishLanguage,SIGNAL("triggered()"),lambda lang="fi":self.changelocale(lang))
        self.languageMenu.addAction(FinishLanguage)

        TurkishLanguage = QAction(UIconst.CONF_MENU_TURKISH,self)
        self.connect(TurkishLanguage,SIGNAL("triggered()"),lambda lang="tr":self.changelocale(lang))
        self.languageMenu.addAction(TurkishLanguage)

        JapaneseLanguage = QAction(UIconst.CONF_MENU_JAPANESE,self)
        self.connect(JapaneseLanguage,SIGNAL("triggered()"),lambda lang="ja":self.changelocale(lang))
        self.languageMenu.addAction(JapaneseLanguage)
        

        # TOOLKIT menu
        self.designerAction = QAction(UIconst.TOOLKIT_MENU_DESIGNER,self)
        self.connect(self.designerAction ,SIGNAL("triggered()"),self.designerTriggered)
        self.designerAction.setCheckable(True)
        self.designerAction.setChecked(self.qmc.designerflag)
        self.ToolkitMenu.addAction(self.designerAction)

        calculatorAction = QAction(UIconst.TOOLKIT_MENU_CALCULATOR,self)
        self.connect(calculatorAction,SIGNAL("triggered()"),self.calculator)
        self.ToolkitMenu.addAction(calculatorAction)
        
        self.wheeleditorAction = QAction(UIconst.TOOLKIT_MENU_WHEELGRAPH,self)
        self.connect(self.wheeleditorAction,SIGNAL("triggered()"),self.graphwheel)
        self.ToolkitMenu.addAction(self.wheeleditorAction)

        self.ToolkitMenu.addSeparator()

        hudAction = QAction(UIconst.TOOLKIT_MENU_EXTRAS,self)
        self.connect(hudAction,SIGNAL("triggered()"),self.hudset)
        self.ToolkitMenu.addAction(hudAction)

        # HELP menu
        helpAboutAction = QAction(UIconst.HELP_MENU_ABOUT,self)
        self.connect(helpAboutAction,SIGNAL("triggered()"),self.helpAbout)
        self.helpMenu.addAction(helpAboutAction)

        helpDocumentationAction = QAction(UIconst.HELP_MENU_DOCUMENTATION,self)
        self.connect(helpDocumentationAction,SIGNAL("triggered()"),self.helpHelp)
        self.helpMenu.addAction(helpDocumentationAction)

        KshortCAction = QAction(UIconst.HELP_MENU_KEYBOARDSHORTCUTS,self)
        self.connect(KshortCAction,SIGNAL("triggered()"),self.viewKshortcuts)
        self.helpMenu.addAction(KshortCAction)

        self.helpMenu.addSeparator()

        errorAction = QAction(UIconst.HELP_MENU_ERRORS,self)
        self.connect(errorAction,SIGNAL("triggered()"),self.viewErrorLog)
        self.helpMenu.addAction(errorAction)

        messageAction = QAction(UIconst.HELP_MENU_MESSAGES,self)
        self.connect(messageAction,SIGNAL("triggered()"),self.viewMessageLog)
        self.helpMenu.addAction(messageAction)

        serialAction = QAction(UIconst.HELP_MENU_SERIAL,self)
        self.connect(serialAction,SIGNAL("triggered()"),self.viewSerialLog)
        self.helpMenu.addAction(serialAction)

        settingsAction = QAction(UIconst.HELP_MENU_SETTINGS,self)
        self.connect(settingsAction,SIGNAL("triggered()"),self.viewartisansettings)
        self.helpMenu.addAction(settingsAction)

        platformAction = QAction(UIconst.HELP_MENU_PLATFORM,self)
        self.connect(platformAction,SIGNAL("triggered()"),self.viewplatform)
        self.helpMenu.addAction(platformAction)

        self.helpMenu.addSeparator()

        self.resetAction = QAction(UIconst.HELP_MENU_RESET,self)
        self.connect(self.resetAction,SIGNAL("triggered()"),self.resetApplication)
        self.helpMenu.addAction(self.resetAction)

        ############################## WIDGETS SECTION ########################################

        #create a Label object to display program status information
        self.messagelabel = QLabel()
        self.messagelabel.setIndent(10)

        self.pushbuttonstyles = {"DISABLED":"QPushButton {font-size: 16pt; font-weight: normal; color: darkgrey; background-color: lightgrey}",
                                 "STOP":"QPushButton {font-size: 16pt; font-weight: bold; color: lightgrey; background-color: #43d300}",
                                 "START":"QPushButton {font-size: 16pt; font-weight: bold; color: yellow; background-color: red}",
                                 "OFF":"QPushButton {font-size: 16pt; font-weight: bold; color: lightgrey; background-color: #43d300}",
                                 "ON":"QPushButton {font-size: 16pt; font-weight: bold; color: yellow; background-color: red }",
                                 "COOL END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                 "DRY END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                 "CHARGE":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #f07800 }",
                                 "FC START":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange  }",
                                 "FC END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                 "SC START":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                 "SC END":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: orange }",
                                 "RESET":"QPushButton {font-size: 16pt; font-weight: bold; color: black; background-color: white }",
                                 "HUD_OFF":"QPushButton {font-size: 16pt; font-weight: bold; color: white; background-color: #b5baff  }",
                                 "HUD_ON":"QPushButton {font-size: 16pt; font-weight: bold; color: white; background-color: #60ffed   }",
                                 "EVENT":"QPushButton {font-size: 10pt; font-weight: bold; color: black; background-color: yellow }",
                                 "DROP":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #f07800 }",
                                 "PID":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #92C3FF }",
                                 "SV +":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: #ffaaff }",
                                 "SV -":"QPushButton {font-size: 10pt; font-weight: bold; color: white; background-color: lightblue }",
                                 "SELECTED":"QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: #6D4824 }"  #keyboard moves
                                 }

        #create ON/OFF buttons
        self.button_1 = QPushButton(QApplication.translate("Button", "ON", None, QApplication.UnicodeUTF8))
        self.button_1.setFocusPolicy(Qt.NoFocus)
        self.button_1.setToolTip(QApplication.translate("Tooltip", "Start monitoring", None, QApplication.UnicodeUTF8))
        self.button_1.setStyleSheet(self.pushbuttonstyles["OFF"])
        #self.button_1.setMinimumHeight(50)
        self.button_1.setMaximumSize(90, 45)
        self.connect(self.button_1, SIGNAL("clicked()"), self.qmc.ToggleMonitor)

        #create START/STOP buttons
        self.button_2 = QPushButton(QApplication.translate("Button", "START", None, QApplication.UnicodeUTF8))
        self.button_2.setFocusPolicy(Qt.NoFocus)
        self.button_2.setToolTip(QApplication.translate("Tooltip", "Start recording", None, QApplication.UnicodeUTF8))
        self.button_2.setStyleSheet(self.pushbuttonstyles["STOP"])
        #self.button_2.setMinimumHeight(50)
        self.button_2.setMaximumSize(90, 45)
        self.connect(self.button_2, SIGNAL("clicked()"), self.qmc.ToggleRecorder)

        #create 1C START, 1C END, 2C START and 2C END buttons
        self.button_3 = QPushButton(QApplication.translate("Button", "FC\nSTART", None, QApplication.UnicodeUTF8))
        self.button_3.setFocusPolicy(Qt.NoFocus)
        self.button_3.setStyleSheet(self.pushbuttonstyles["FC START"])
        self.button_3.setMinimumHeight(50)
        self.button_3.setToolTip(QApplication.translate("Tooltip", "Marks the begining of First Crack (FCs)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_3, SIGNAL("clicked()"), self.qmc.mark1Cstart)

        self.button_4 = QPushButton(QApplication.translate("Button", "FC\nEND", None, QApplication.UnicodeUTF8))
        self.button_4.setFocusPolicy(Qt.NoFocus)
        self.button_4.setStyleSheet(self.pushbuttonstyles["FC END"])
        self.button_4.setMinimumHeight(50)
        self.button_4.setToolTip(QApplication.translate("Tooltip", "Marks the end of First Crack (FCs)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_4, SIGNAL("clicked()"), self.qmc.mark1Cend)

        self.button_5 = QPushButton(QApplication.translate("Button", "SC\nSTART", None, QApplication.UnicodeUTF8))
        self.button_5.setFocusPolicy(Qt.NoFocus)
        self.button_5.setStyleSheet(self.pushbuttonstyles["SC START"])
        self.button_5.setMinimumHeight(50)
        self.button_5.setToolTip(QApplication.translate("Tooltip", "Marks the begining of Second Crack (SCs)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_5, SIGNAL("clicked()"), self.qmc.mark2Cstart)

        self.button_6 = QPushButton(QApplication.translate("Button", "SC\nEND", None, QApplication.UnicodeUTF8))
        self.button_6.setFocusPolicy(Qt.NoFocus)
        self.button_6.setStyleSheet(self.pushbuttonstyles["SC END"])
        self.button_6.setMinimumHeight(50)
        self.button_6.setToolTip(QApplication.translate("Tooltip", "Marks the end of Second Crack (SCe)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_6, SIGNAL("clicked()"), self.qmc.mark2Cend)

        #create RESET button
        self.button_7 = QPushButton(QApplication.translate("Button", "RESET", None, QApplication.UnicodeUTF8))
        self.button_7.setFocusPolicy(Qt.NoFocus)
        self.button_7.setStyleSheet(self.pushbuttonstyles["RESET"])
        self.button_7.setMaximumSize(90, 45)
        self.button_7.setToolTip(QApplication.translate("Tooltip", "Reset", None, QApplication.UnicodeUTF8))
        self.connect(self.button_7, SIGNAL("clicked()"), self.qmc.reset)

        #create CHARGE button
        self.button_8 = QPushButton(QApplication.translate("Button", "CHARGE", None, QApplication.UnicodeUTF8))
        self.button_8.setFocusPolicy(Qt.NoFocus)
        self.button_8.setStyleSheet(self.pushbuttonstyles["CHARGE"])
        self.button_8.setMinimumHeight(50)
        self.button_8.setToolTip(QApplication.translate("Tooltip", "Marks the begining of the roast (beans in)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_8, SIGNAL("clicked()"), self.qmc.markCharge)

        #create DROP button
        self.button_9 = QPushButton(QApplication.translate("Button", "DROP", None, QApplication.UnicodeUTF8))
        self.button_9.setFocusPolicy(Qt.NoFocus)
        self.button_9.setStyleSheet(self.pushbuttonstyles["DROP"])
        self.button_9.setMinimumHeight(50)
        self.button_9.setToolTip(QApplication.translate("Tooltip", "Marks the end of the roast (drop beans)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_9, SIGNAL("clicked()"), self.qmc.markDrop)

        #create PID control button
        self.button_10 = QPushButton(QApplication.translate("Button", "Control", None, QApplication.UnicodeUTF8))
        self.button_10.setFocusPolicy(Qt.NoFocus)
        self.button_10.setStyleSheet(self.pushbuttonstyles["PID"])
        self.button_10.setMaximumSize(90, 45)
        self.connect(self.button_10, SIGNAL("clicked()"), self.PIDcontrol)

        #create EVENT record button
        self.button_11 = QPushButton(QApplication.translate("Button", "EVENT", None, QApplication.UnicodeUTF8))
        self.button_11.setFocusPolicy(Qt.NoFocus)
        self.button_11.setStyleSheet(self.pushbuttonstyles["EVENT"])
        self.button_11.setMinimumHeight(50)
        self.button_11.setToolTip(QApplication.translate("Tooltip", "Marks an Event", None, QApplication.UnicodeUTF8))
        self.connect(self.button_11, SIGNAL("clicked()"), self.qmc.EventRecord)

        #create PID+5 button
        self.button_12 = QPushButton(QApplication.translate("Button", "SV +5", None, QApplication.UnicodeUTF8))
        self.button_12.setFocusPolicy(Qt.NoFocus)
        self.button_12.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_12.setMaximumSize(90, 50)
        self.button_12.setMinimumHeight(50)
        self.button_12.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 5", None, QApplication.UnicodeUTF8))

        #create PID+10 button
        self.button_13 = QPushButton(QApplication.translate("Button", "SV +10", None, QApplication.UnicodeUTF8))
        self.button_13.setFocusPolicy(Qt.NoFocus)
        self.button_13.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_13.setMaximumSize(90, 50)
        self.button_13.setMinimumHeight(50)
        self.button_13.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 10", None, QApplication.UnicodeUTF8))

        #create PID+20 button
        self.button_14 = QPushButton(QApplication.translate("Button", "SV +20", None, QApplication.UnicodeUTF8))
        self.button_14.setFocusPolicy(Qt.NoFocus)
        self.button_14.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_14.setMaximumSize(90, 50)
        self.button_14.setMinimumHeight(50)
        self.button_14.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 20", None, QApplication.UnicodeUTF8))

        #create PID-20 button
        self.button_15 = QPushButton(QApplication.translate("Button", "SV -20", None, QApplication.UnicodeUTF8))
        self.button_15.setFocusPolicy(Qt.NoFocus)
        self.button_15.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_15.setMaximumSize(90, 50)
        self.button_15.setMinimumHeight(50)
        self.button_15.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 20", None, QApplication.UnicodeUTF8))

        #create PID-10 button
        self.button_16 = QPushButton(QApplication.translate("Button", "SV -10", None, QApplication.UnicodeUTF8))
        self.button_16.setFocusPolicy(Qt.NoFocus)
        self.button_16.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_16.setMaximumSize(90, 50)
        self.button_16.setMinimumHeight(50)
        self.button_16.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 10", None, QApplication.UnicodeUTF8))

        #create PID-5 button
        self.button_17 = QPushButton(QApplication.translate("Button", "SV -5", None, QApplication.UnicodeUTF8))
        self.button_17.setFocusPolicy(Qt.NoFocus)
        self.button_17.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_17.setMaximumSize(90, 50)
        self.button_17.setMinimumHeight(50)
        self.button_17.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 5", None, QApplication.UnicodeUTF8))

        #create HUD button
        self.button_18 = QPushButton(QApplication.translate("Button", "HUD", None, QApplication.UnicodeUTF8))
        self.button_18.setFocusPolicy(Qt.NoFocus)
        self.button_18.setStyleSheet(self.pushbuttonstyles["DISABLED"])
        self.button_18.setMaximumSize(90, 45)
        self.button_18.setContentsMargins(0,0,0,0)
        self.connect(self.button_18, SIGNAL("clicked()"), self.qmc.toggleHUD)
        self.button_18.setToolTip(QApplication.translate("Tooltip", "Turns ON/OFF the HUD", None, QApplication.UnicodeUTF8))
        self.button_18.setEnabled(False)

        #create DRY button
        self.button_19 = QPushButton(QApplication.translate("Button", "DRY\nEND", None, QApplication.UnicodeUTF8))
        self.button_19.setFocusPolicy(Qt.NoFocus)
        self.button_19.setStyleSheet(self.pushbuttonstyles["DRY END"])
        #self.button_19.setMaximumSize(90, 50)
        self.button_19.setMinimumHeight(50)
        self.button_19.setToolTip(QApplication.translate("Tooltip", "Marks the end of the Drying phase (DRYEND)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_19, SIGNAL("clicked()"), self.qmc.markDryEnd)

        #create COOLe button
        self.button_20 = QPushButton(QApplication.translate("Button", "COOL\nEND", None, QApplication.UnicodeUTF8))
        self.button_20.setFocusPolicy(Qt.NoFocus)
        self.button_20.setStyleSheet(self.pushbuttonstyles["COOL END"])
        self.button_20.setMinimumHeight(50)
        self.button_20.setToolTip(QApplication.translate("Tooltip", "Marks the end of the Cooling phase (COOLEND)", None, QApplication.UnicodeUTF8))
        self.connect(self.button_20, SIGNAL("clicked()"), self.qmc.markCoolEnd)
 
 

        #connect PID sv easy buttons
        self.connect(self.button_12, SIGNAL("clicked()"),lambda x=5: self.fujipid.adjustsv(x))
        self.connect(self.button_13, SIGNAL("clicked()"),lambda x=10: self.fujipid.adjustsv(x))
        self.connect(self.button_14, SIGNAL("clicked()"),lambda x=20: self.fujipid.adjustsv(x))
        self.connect(self.button_15, SIGNAL("clicked()"),lambda x=-20: self.fujipid.adjustsv(x))
        self.connect(self.button_16, SIGNAL("clicked()"),lambda x=-10: self.fujipid.adjustsv(x))
        self.connect(self.button_17, SIGNAL("clicked()"),lambda x=-5: self.fujipid.adjustsv(x))

        # NavigationToolbar VMToolbar
        ntb = VMToolbar(self.qmc, self.main_widget)
        #ntb.setMinimumHeight(45)

        #create LCD displays
        #RIGHT COLUMN
        self.lcd1 = QLCDNumber() # time
        self.lcd1.setSegmentStyle(2)
        self.lcd1.setMinimumHeight(40)
        self.lcd1.setMinimumWidth(100)

        self.lcd2 = QLCDNumber() # Temperature MET
        self.lcd2.setSegmentStyle(2)   
        self.lcd3 = QLCDNumber() # Temperature BT
        self.lcd3.setSegmentStyle(2)
        self.lcd4 = QLCDNumber() # rate of change MET
        self.lcd4.setSegmentStyle(2)
        self.lcd5 = QLCDNumber() # rate of change BT
        self.lcd5.setSegmentStyle(2)
        self.lcd6 = QLCDNumber() # pid sv
        self.lcd6.setSegmentStyle(2)
        self.lcd7 = QLCDNumber() # pid power % duty cycle
        self.lcd7.setSegmentStyle(2)

        self.lcd1.display("00:00")
        self.lcd2.display("0.0")
        self.lcd3.display("0.0")
        self.lcd4.display("0.0")
        self.lcd5.display("0.0")
        self.lcd6.display("0.0")
        self.lcd7.display("0.0")

        self.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["timer"],self.lcdpaletteB["timer"]))
        self.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["et"],self.lcdpaletteB["et"]))
        self.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["bt"],self.lcdpaletteB["bt"]))
        self.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltaet"],self.lcdpaletteB["deltaet"]))
        self.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltabt"],self.lcdpaletteB["deltabt"]))
        self.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
        self.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
        
        self.lcd2.setMinimumSize(80,30)
        self.lcd3.setMinimumSize(80,30)
        self.lcd4.setMinimumSize(80,30)
        self.lcd5.setMinimumSize(80,30)
        self.lcd6.setMinimumSize(80,30)
        self.lcd7.setMinimumSize(80,30)

        self.lcd1.setToolTip(QApplication.translate("Tooltip", "Timer",None, QApplication.UnicodeUTF8))
        self.lcd2.setToolTip(QApplication.translate("Tooltip", "ET Temperature",None, QApplication.UnicodeUTF8))
        self.lcd3.setToolTip(QApplication.translate("Tooltip", "BT Temperature",None, QApplication.UnicodeUTF8))
        self.lcd4.setToolTip(QApplication.translate("Tooltip", "ET/time (degrees/min)",None, QApplication.UnicodeUTF8))
        self.lcd5.setToolTip(QApplication.translate("Tooltip", "BT/time (degrees/min)",None, QApplication.UnicodeUTF8))
        self.lcd6.setToolTip(QApplication.translate("Tooltip", "Value of SV in PID",None, QApplication.UnicodeUTF8))
        self.lcd7.setToolTip(QApplication.translate("Tooltip", "PID power %",None, QApplication.UnicodeUTF8))

        #MET
        self.label2 = QLabel()
        self.label2.setText(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8))
        self.label2.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        #BT
        self.label3 = QLabel()
        self.label3.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label3.setText("<b>" + u(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8)) + "<\b>")
        #DELTA MET
        self.label4 = QLabel()
        self.label4.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label4.setText("<b>" + u(QApplication.translate("Label", "DeltaET",None, QApplication.UnicodeUTF8)) + "<\b>")
        # DELTA BT
        self.label5 = QLabel()
        self.label5.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label5.setText("<b>" + u(QApplication.translate("Label", "DeltaBT",None, QApplication.UnicodeUTF8)) + "<\b>")
        # pid sv
        self.label6 = QLabel()
        self.label6.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label6.setText("<b>" + u(QApplication.translate("Label", "PID SV",None, QApplication.UnicodeUTF8)) + "<\b>")
        # pid power % duty cycle
        self.label7 = QLabel()
        self.label7.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label7.setText("<b>" + u(QApplication.translate("Label", "PID %",None, QApplication.UnicodeUTF8)) + "<\b>")

        #extra LCDs
        self.nLCDS = 10 # maximum number of LCDs and extra devices
        self.extraLCD1,self.extraLCD2 = [],[]
        self.extraLCDlabel1,self.extraLCDlabel2 = [],[]
        self.extraLCDframe1,self.extraLCDframe2 = [],[]
        self.extraLCDvisibility1,self.extraLCDvisibility2 = [False]*self.nLCDS,[False]*self.nLCDS
        self.extraCurveVisibility1,self.extraCurveVisibility2 = [True]*self.nLCDS,[True]*self.nLCDS
        for i in range(self.nLCDS):
            #configure LCDs
            self.extraLCDframe1.append(QFrame())
            self.extraLCD1.append(QLCDNumber())
            self.extraLCDlabel1.append(QLabel())
            self.extraLCDframe2.append(QFrame())
            self.extraLCD2.append(QLCDNumber())
            self.extraLCDlabel2.append(QLabel())
            self.extraLCD1[i].setSegmentStyle(2)
            self.extraLCD1[i].display("0.0")
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCD2[i].setSegmentStyle(2)
            self.extraLCD2[i].display("0.0")
            self.extraLCDframe2[i].setVisible(False)
            self.extraLCD1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.extraLCD2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            string1 = u(QApplication.translate("Tooltip", "Extra: %iA"%(i+1),None, QApplication.UnicodeUTF8))
            string2 = u(QApplication.translate("Tooltip", "Extra: %iB"%(i+1),None, QApplication.UnicodeUTF8))
            #configure Labels
            self.extraLCDlabel1[i].setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
            self.extraLCDlabel2[i].setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
            self.extraLCDlabel1[i].setText("<b>" + string1 + "</b>")
            self.extraLCDlabel1[i].setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
            self.extraLCDlabel2[i].setText("<b>" + string2 + "</b>")
            self.extraLCDlabel2[i].setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))

        # Stores messages up to 500
        self.messagehist = []

        #only leave operational the control button if the device is Fuji PID
        #the SV buttons are activated from the PID control panel 
        self.button_10.setVisible(False)
        self.label6.setVisible(False)
        self.lcd6.setVisible(False)
        self.label7.setVisible(False)
        self.lcd7.setVisible(False)

        self.button_12.setVisible(False)
        self.button_13.setVisible(False)
        self.button_14.setVisible(False)
        self.button_15.setVisible(False)
        self.button_16.setVisible(False)
        self.button_17.setVisible(False)

        #### EVENT MINI EDITOR: View&Edits events without opening roast properties Dlg.
        self.eventlabel = QLabel(QApplication.translate("Label","Event #<b>0 </b>", None, QApplication.UnicodeUTF8))
        self.eventlabel.setIndent(5)
        self.eNumberSpinBox = QSpinBox()

#        self.eNumberSpinBox.setFocusPolicy(Qt.NoFocus)
        self.eNumberSpinBox.setAlignment(Qt.AlignCenter)
        self.eNumberSpinBox.setToolTip(QApplication.translate("Tooltip", "Number of events found", None, QApplication.UnicodeUTF8))
        self.eNumberSpinBox.setRange(0,20)
        self.connect(self.eNumberSpinBox, SIGNAL("valueChanged(int)"),self.changeEventNumber)
        self.eNumberSpinBox.setMaximumWidth(40)
        self.lineEvent = QLineEdit()
#        self.lineEvent.setFocusPolicy(Qt.ClickFocus)
        self.lineEvent.setMinimumWidth(200)

        self.eventlabel.setStyleSheet("background-color:'yellow';")

        self.etypeComboBox = QComboBox()
        self.etypeComboBox.setToolTip(QApplication.translate("Tooltip", "Type of event", None, QApplication.UnicodeUTF8))
#        self.etypeComboBox.setFocusPolicy(Qt.NoFocus)
        self.etypeComboBox.addItems(self.qmc.etypes)

        regexvalue = QRegExp(r"^100|\d?\d?$")
        self.valueEdit = QLineEdit()
        self.valueEdit.setValidator(QRegExpValidator(regexvalue,self))
        self.valueEdit.setToolTip(QApplication.translate("Tooltip", "Value of event", None, QApplication.UnicodeUTF8))
#        self.valueEdit.setFocusPolicy(Qt.ClickFocus)
        self.valueEdit.setMaximumWidth(50)

        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.etimeline = QLineEdit()
        self.etimeline.setValidator(QRegExpValidator(regextime,self))
#        self.etimeline.setFocusPolicy(Qt.ClickFocus)
        self.etimeline.setMaximumWidth(50)

        #create EVENT mini button
        self.buttonminiEvent = QPushButton(QApplication.translate("Button", "Update", None, QApplication.UnicodeUTF8))
#        self.buttonminiEvent.setFocusPolicy(Qt.NoFocus)
        self.connect(self.buttonminiEvent, SIGNAL("clicked()"), self.miniEventRecord)
        self.buttonminiEvent.setToolTip(QApplication.translate("Tooltip", "Updates the event", None, QApplication.UnicodeUTF8))

        #### CUSTOM events buttons
        self.buttonlist = []
        self.buttonlistmaxlen = 11
        #10 palettes of buttons
        self.buttonpalette = [[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
        self.buttonpalettemaxlen = [0]*10  #keeps max len of each palette

        #Create LOWER BUTTONS Widget layout QDialogButtonBox to stack all lower buttons
        self.lowerbuttondialog = QDialogButtonBox(Qt.Horizontal)
        self.lowerbuttondialog.setContentsMargins(0,0,0,10)
        self.lowerbuttondialog.setVisible(False)
        self.lowerbuttondialog.setCenterButtons(True)
        #initiate configuration
        self.lowerbuttondialog.addButton(self.button_8,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_19,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_3,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_4,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_5,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_6,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_9,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_20,QDialogButtonBox.ActionRole)
        self.lowerbuttondialog.addButton(self.button_11,QDialogButtonBox.ActionRole)

        self.e1buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e1buttondialog.setCenterButtons(True)
        self.e2buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e2buttondialog.setCenterButtons(True)
        self.e3buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e3buttondialog.setCenterButtons(True)
        self.e4buttondialog = QDialogButtonBox(Qt.Horizontal)
        self.e4buttondialog.setCenterButtons(True)

        # set the focus on the main widget
        self.main_widget.setFocus()

        # set the central widget of MainWindow to main_widget
        self.setCentralWidget(self.main_widget)

        #list of functions to chose from (using left-right keyboard arrow)
        self.keyboardmove = [self.qmc.reset,self.qmc.toggleHUD,self.qmc.ToggleMonitor,self.qmc.markCharge,self.qmc.markDryEnd,self.qmc.mark1Cstart,self.qmc.mark1Cend,
                             self.qmc.mark2Cstart,self.qmc.mark2Cend,self.qmc.markDrop,self.qmc.markCoolEnd,self.qmc.EventRecord]
        # list of buttons that can be controlled via the keyboard
        # RESET -> HUD -> ON/OFF -> .. -> EVENT (RESET at index 0 is never used)
        self.keyboardButtonList = [self.button_7, self.button_18,self.button_1,self.button_8,self.button_19,self.button_3,self.button_4,self.button_5,self.button_6,self.button_9,self.button_20,self.button_11]
        self.keyboardButtonStyles = ["RESET","HUD_ON","ON","CHARGE","DRY END","FC START","FC END","SC START","SC END","DROP","COOL END","EVENT"]

        #current function above
        self.keyboardmoveindex = 0
        #state flag for above. It is initialized by pressing SPACE or left-right arrows
        self.keyboardmoveflag = 0
        #time stamp of last keyboard event SPACE to prevent multiple recognitions
        self.lastkeyboardcmd = 0


        ####################   APPLICATION WINDOW (AW) LAYOUT  ##############################################

        level1layout = QHBoxLayout()   # matplotlib toolbox + HUD button + reset button + LCD Timer

        level3layout = QHBoxLayout()   # PID buttons, graph, temperature LCDs

        pidbuttonLayout = QVBoxLayout()

        EventsLayout = QHBoxLayout()
        EventsLayout.setMargin(1)
        EventsLayout.setSpacing(0)

        #EVENT MINIEDITOR layout
        EventsLayout.addWidget(self.eventlabel)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etimeline)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.lineEvent)  
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etypeComboBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.valueEdit)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.eNumberSpinBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.buttonminiEvent)
        self.EventsGroupLayout = QGroupBox()     
        self.EventsGroupLayout.setLayout(EventsLayout)
        self.EventsGroupLayout.setVisible(False)

        LCDlayout = QVBoxLayout() 
        LCDlayout.setSpacing(0)
        LCDlayout.setContentsMargins(0,0,0,0)

        #place control buttons + LCDs inside vertical button layout manager
        self.LCD2frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label2,self.lcd2,self.LCD2frame))

        self.LCD3frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label3,self.lcd3,self.LCD3frame))

        self.LCD6frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label6,self.lcd6,self.LCD6frame))

        self.LCD7frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label7,self.lcd7,self.LCD7frame))

        self.LCD4frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label4,self.lcd4,self.LCD4frame))

        self.LCD5frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label5,self.lcd5,self.LCD5frame))

        #add extra LCDs
        for i in range(self.nLCDS):
            LCDlayout.addWidget(self.makeLCDbox(self.extraLCDlabel1[i],self.extraLCD1[i],self.extraLCDframe1[i]))
            LCDlayout.addWidget(self.makeLCDbox(self.extraLCDlabel2[i],self.extraLCD2[i],self.extraLCDframe2[i]))
        LCDlayout.addStretch()

        #PID Buttons
        pidbuttonLayout.addWidget(self.button_14)
        pidbuttonLayout.addWidget(self.button_13)
        pidbuttonLayout.addWidget(self.button_12)
        pidbuttonLayout.addWidget(self.button_17)
        pidbuttonLayout.addWidget(self.button_16)
        pidbuttonLayout.addWidget(self.button_15)

        #level 1
        level1layout.addWidget(ntb)
        level1layout.addSpacing(15)
        level1layout.addStretch()
        level1layout.addWidget(self.button_7)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_1)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_2)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_10)
        level1layout.addSpacing(15)
        level1layout.addWidget(self.button_18)
        level1layout.addSpacing(20)
        level1layout.addWidget(self.lcd1)
        level1layout.setMargin(0)
        level1layout.setSpacing(0)
        level1layout.setContentsMargins(0,0,0,0)

        #level 3
        level3layout.addLayout(pidbuttonLayout,0)
        level3layout.addWidget(self.stack,1)
        level3layout.setSpacing(0)
        level3layout.setMargin(0)
        level3layout.setContentsMargins(0,0,0,0)

        extrabuttonsLayout = QVBoxLayout()
        extrabuttonsLayout.setMargin(0)
        extrabuttonsLayout.setSpacing(0)
        extrabuttonsLayout.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e1buttondialog)
        self.e1buttondialog.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e2buttondialog)
        self.e2buttondialog.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e3buttondialog)
        self.e3buttondialog.setContentsMargins(0,0,0,0)
        extrabuttonsLayout.addWidget(self.e4buttondialog)
        self.e4buttondialog.setContentsMargins(0,0,0,0)
        self.extrabuttondialogs = QFrame()
        self.extrabuttondialogs.setLayout(extrabuttonsLayout)
        self.extrabuttondialogs.setVisible(False)
        self.extrabuttondialogs.setContentsMargins(0,0,0,0)

        midleftlayout = QVBoxLayout()
        midleftlayout.setSpacing(0)
        midleftlayout.setContentsMargins(0,0,0,0)
        midleftlayout.setMargin(0)
        midleftlayout.addWidget(self.messagelabel)
        midleftlayout.addLayout(level3layout)
        midleftlayout.addWidget(self.lowerbuttondialog)
        midleftlayout.addWidget(self.extrabuttondialogs) 
        midleftlayout.addWidget(self.EventsGroupLayout)

        self.slider1 = self.slider()
        self.sliderLCD1 = self.sliderLCD()
        self.sliderLCD1.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[0])
        self.sliderLCD1.display(self.slider1.value())
        sliderGrp1 = QVBoxLayout()
        sliderGrp1.addWidget(self.sliderLCD1)
        sliderGrp1.addWidget(self.slider1)
        sliderGrp1.setAlignment(Qt.AlignCenter)
        sliderGrp1.setMargin(2)
        self.sliderGrpBox1 = QGroupBox()        
        self.sliderGrpBox1.setLayout(sliderGrp1)
        self.sliderGrpBox1.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox1.setMinimumWidth(55) 
        self.sliderGrpBox1.setMaximumWidth(55)
        self.sliderGrpBox1.setVisible(False)
        self.connect(self.slider1, SIGNAL("valueChanged(int)"), lambda v=0:self.updateSliderLCD(0,v))
        self.connect(self.slider1, SIGNAL("sliderReleased()"), lambda:self.sliderReleased(0))

        self.slider2 = self.slider()
        self.sliderLCD2 = self.sliderLCD() 
        self.sliderLCD2.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[1])
        self.sliderLCD2.display(self.slider2.value())
        sliderGrp2 = QVBoxLayout()
        sliderGrp2.addWidget(self.sliderLCD2)
        sliderGrp2.addWidget(self.slider2)
        sliderGrp2.setAlignment(Qt.AlignCenter)
        sliderGrp2.setMargin(2)
        self.sliderGrpBox2 = QGroupBox()
        self.sliderGrpBox2.setLayout(sliderGrp2)
        self.sliderGrpBox2.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox2.setMinimumWidth(55) 
        self.sliderGrpBox2.setMaximumWidth(55) 
        self.sliderGrpBox2.setVisible(False)
        self.connect(self.slider2, SIGNAL("valueChanged(int)"), lambda v=0:self.updateSliderLCD(1,v))
        self.connect(self.slider2, SIGNAL("sliderReleased()"), lambda:self.sliderReleased(1))

        self.slider3 = self.slider()
        self.sliderLCD3 = self.sliderLCD()
        self.sliderLCD3.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[2])
        self.sliderLCD3.display(self.slider3.value())
        sliderGrp3 = QVBoxLayout()
        sliderGrp3.addWidget(self.sliderLCD3)
        sliderGrp3.addWidget(self.slider3)
        sliderGrp3.setAlignment(Qt.AlignCenter)
        sliderGrp3.setMargin(2)
        self.sliderGrpBox3 = QGroupBox()
        self.sliderGrpBox3.setLayout(sliderGrp3)
        self.sliderGrpBox3.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox3.setMinimumWidth(55) 
        self.sliderGrpBox3.setMaximumWidth(55) 
        self.sliderGrpBox3.setVisible(False)
        self.connect(self.slider3, SIGNAL("valueChanged(int)"), lambda v=0:self.updateSliderLCD(2,v))
        self.connect(self.slider3, SIGNAL("sliderReleased()"), lambda:self.sliderReleased(2))

        self.slider4 = self.slider()
        self.sliderLCD4 = self.sliderLCD()
        self.sliderLCD4.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[3])
        self.sliderLCD4.display(self.slider4.value())
        sliderGrp4 = QVBoxLayout()
        sliderGrp4.addWidget(self.sliderLCD4)
        sliderGrp4.addWidget(self.slider4)
        sliderGrp4.setAlignment(Qt.AlignCenter)
        sliderGrp4.setMargin(2)
        self.sliderGrpBox4 = QGroupBox()
        self.sliderGrpBox4.setLayout(sliderGrp4)
        self.sliderGrpBox4.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox4.setMinimumWidth(55) 
        self.sliderGrpBox4.setMaximumWidth(55) 
        self.sliderGrpBox4.setVisible(False)
        self.connect(self.slider4, SIGNAL("valueChanged(int)"), lambda v=0:self.updateSliderLCD(3,v))
        self.connect(self.slider4, SIGNAL("sliderReleased()"), lambda:self.sliderReleased(3))

        sliderGrp12 = QVBoxLayout()
        sliderGrp12.setSpacing(0)
        sliderGrp12.setContentsMargins(0,0,0,0)
        sliderGrp12.addWidget(self.sliderGrpBox1)
        sliderGrp12.addWidget(self.sliderGrpBox2)
        sliderGrp34 = QVBoxLayout()
        sliderGrp34.setSpacing(0)
        sliderGrp34.setContentsMargins(0,0,0,0)
        sliderGrp34.addWidget(self.sliderGrpBox3)
        sliderGrp34.addWidget(self.sliderGrpBox4)

        self.leftlayout = QHBoxLayout()
        self.leftlayout.setSpacing(0)
        self.leftlayout.setMargin(0)
        self.leftlayout.setContentsMargins(0,0,0,0)
        self.leftlayout.addLayout(sliderGrp12)
        self.leftlayout.addLayout(sliderGrp34)

        self.sliderFrame = QFrame()
        self.sliderFrame.setLayout(self.leftlayout)
        self.sliderFrame.setVisible(False)
        self.sliderFrame.setContentsMargins(0,0,0,0)

        self.lcdFrame = QFrame()
        self.lcdFrame.setLayout(LCDlayout)
        self.lcdFrame.setVisible(False)

        self.midlayout = QHBoxLayout()
        self.midlayout.addWidget(self.sliderFrame)
        self.midlayout.addLayout(midleftlayout)
        self.midlayout.addWidget(self.lcdFrame)
        self.midlayout.setSpacing(0)
        self.midlayout.setContentsMargins(0,0,0,0)

        mainlayout = QVBoxLayout(self.main_widget)
        mainlayout.addLayout(level1layout)
        mainlayout.addLayout(self.midlayout) 
        mainlayout.setContentsMargins(0,0,0,0)
        mainlayout.setSpacing(0)


###################################   APPLICATION WINDOW (AW) FUNCTIONS  ####################################

    def makeLCDbox(self,label,lcd,lcdframe):
        LCDbox = QVBoxLayout()
        LCDbox.setSpacing(0)
        LCDbox.addWidget(label)
        LCDbox.addWidget(lcd)
        LCDbox.setContentsMargins(0, 0, 0, 0)
        lcdframe.setContentsMargins(0, 10, 0, 0)
        lcdframe.setLayout(LCDbox)
        return lcdframe

    def sliderReleased(self,n):
        if n == 0:
            if self.slider1.value() != self.eventslidervalues[0]:
                self.eventslidervalues[0] = self.slider1.value()
                self.recordsliderevent(n)
        elif n == 1:
            if self.slider2.value() != self.eventslidervalues[1]:
                self.eventslidervalues[1] = self.slider2.value()
                self.recordsliderevent(n)
        elif n == 2:
            if self.slider3.value() != self.eventslidervalues[2]:
                self.eventslidervalues[2] = self.slider3.value()
                self.recordsliderevent(n)
        elif n == 3:
            if self.slider4.value() != self.eventslidervalues[3]:
                self.eventslidervalues[3] = self.slider4.value()
                self.recordsliderevent(n)

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    def fireslideraction(self,n):
        action = self.eventslideractions[n]   
        if action:
            try:
                action = (action+2 if action > 1 else action)
                value = int(round((self.eventsliderfactors[n] * self.eventslidervalues[n]) + self.eventslideroffsets[n]))
                cmd = self.eventslidercommands[n]
                cmd = cmd.format(value)
                self.eventaction(action,cmd)
            except:
                pass
            
    def recordsliderevent(self,n):
        if self.qmc.flagstart:
            value = aw.float2float((self.eventslidervalues[n] + 10.0) / 10.0)
            self.qmc.EventRecordAction(extraevent = 1,eventtype=n,eventvalue=value)
        self.fireslideraction(n)

    def updateSliderLCD(self,n,v):
        if n == 0:
            self.sliderLCD1.display(v)
        elif n == 1:
            self.sliderLCD2.display(v)
        elif n == 2:
            self.sliderLCD3.display(v)
        elif n == 3:
            self.sliderLCD4.display(v)

    def sliderLCD(self):
        slcd = QLCDNumber()
        slcd.setSegmentStyle(2)
        slcd.setNumDigits(3)
        slcd.setMinimumHeight(35)
        slcd.setMinimumWidth(50)
        slcd.setMaximumWidth(50)
        slcd.setFrameStyle(QFrame.Panel | QFrame.Sunken)
        slcd.setLineWidth(0)
        slcd.setContentsMargins(0,0,0,0)
        return slcd

    def slider(self):
        s = QSlider()
        s.setTickPosition(3)
        s.setTickInterval(10)
        s.setSingleStep(1)
        s.setPageStep(10)
        s.setMaximum(100)
        s.setMinimumWidth(50) 
        s.setMaximumWidth(50) 
        s.setContentsMargins(0,0,0,0)
        return s

    def setLabelColor(self,label,color):
        palette = QPalette(label.palette()) # make a copy of the palette
        palette.setColor(QPalette.Foreground, color)
        label.setPalette(palette) # assign new palette

    #adds errors
    def addserial(self,serialstring):
        timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
        #keep a max of 1000 comm strings
        if len(self.seriallog) > 999:
            self.seriallog = self.seriallog[1:]
        self.seriallog.append(timez + " " + serialstring)

    def resizeEvent(self, event):
        #if HUD is ON when resizing application. No drawing should be done inside this handler
        if self.qmc.HUDflag:
            self.qmc.hudresizeflag = True

    def setdpi(self,dpi):
        if aw:
            aw.dpi = dpi
            self.qmc.fig.set_dpi(dpi)
            #move widget to update display
            self.showFullScreen()
            self.showNormal()
            
    def enableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(True)
            self.fileSaveAsAction.setEnabled(True) 

    def disableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(False)
            self.fileSaveAsAction.setEnabled(False) 

    #actions: 0 = None; 1= Serial Command; 2= Call program; 3= Multiple Event; 4= Modbus Command; 5=DTA Command
    def eventaction(self,action,cmd):
        if action:
            cmd_str = str(cmd)
            if action == 1:
                cmd_str_bin = ""
                #example a2b_uu("Hello") sends Hello in binary format instead of ASCII
                if "a2b_uu" in cmd_str:
                    cmd_str = cmd_str[(len("a2b_uu")+1):][:1]  # removes function-name + char ( and )
                    cmd_str_bin = binascii.a2b_uu(cmd_str)
                if cmd_str_bin:
                    self.ser.sendTXcommand(cmd_str_bin)
                else:
                    self.ser.sendTXcommand(cmd_str)
                    if aw.seriallogflag:
                        settings = str(self.ser.comport) + "," + str(self.ser.baudrate) + "," + str(self.ser.bytesize)+ "," + str(self.ser.parity) + "," + str(self.ser.stopbits) + "," + str(self.ser.timeout)
                        aw.addserial("Serial Action :" + settings + " || Tx = " + str(cmd_str))
            elif action == 2:
                try:
                    QDesktopServices.openUrl(QUrl("file:///" + u(QDir().current().absolutePath()) + "/" + cmd_str, QUrl.TolerantMode))
                except Exception as e:
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " eventaction() %1").arg(str(e)),exc_tb.tb_lineno)
            elif action == 3:
                for i in range(len(cmd_str)):
                    buttonnumber = int(cmd_str[i])-1
                    if self.extraeventsactions[buttonnumber] != 3:   #avoid calling other buttons with multiple actions to avoid possible infinite loops
                        self.recordextraevent(buttonnumber)
            elif action == 4:
                if cmd_str.startswith('write'):
                    try:
                        cmds = eval(cmd_str[len('write'):])
                        if isinstance(cmds,tuple):
                            if len(cmds) == 3 and not isinstance(cmds[0],list):
                                # cmd has format "write(s,r,v)"
                                aw.modbus.writeSingleRegister(*cmds)
                            # cmd has format "write([s,r,v],..,[s,r,v])"
                            for cmd in cmds:
                                aw.modbus.writeSingleRegister(*cmd)
                        else:
                            # cmd has format "write([s,r,v])"
                            aw.modbus.writeSingleRegister(*cmds)
                    except:
                        pass
            elif action == 5:
                try:
                    DTAvalue=cmd_str.split(':')[1]
                    DTAaddress=cmd_str.split(':')[0]
                    aw.dtapid.writeDTE(DTAvalue,DTAaddress)
                except:
                    pass
                    
    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    def moveslider(self,n,v):
        if v >= 0 and v < 100:
            if n == 0:
                self.slider1.setValue(v)
            elif n == 1:
                self.slider2.setValue(v)
                self.slider3.setValue(20)
            elif n == 2:
                self.slider3.setValue(v)
            elif n == 3:
                self.slider4.setValue(v)

    #call from user configured event buttons
    def recordextraevent(self,ee):
        eventtype = self.extraeventstypes[ee]
        if eventtype < 4:  ## if eventtype == 4 we have an button event of type "--" that does not add an event
            if self.qmc.flagstart:
                self.qmc.EventRecord(extraevent = ee)
            value = (self.extraeventsvalues[ee] - 1)
            cmdvalue = int(round((self.eventsliderfactors[eventtype] * value) + self.eventslideroffsets[eventtype]))
            self.eventaction(self.extraeventsactions[ee],self.extraeventsactionstrings[ee].format(cmdvalue))
            # move corresponding slider to new value:
            self.moveslider(eventtype,aw.qmc.eventsInternal2ExternalValue(self.extraeventsvalues[ee]))
        else:
            # just issue the eventaction (no cmd substitution here)
            self.eventaction(self.extraeventsactions[ee],self.extraeventsactionstrings[ee])

    def resetApplication(self):
        string = QApplication.translate("Message","Do you want to reset all settings?", None, QApplication.UnicodeUTF8)
        reply = QMessageBox.warning(self,QApplication.translate("Message","Factory Reset", None, QApplication.UnicodeUTF8),string,
                            QMessageBox.Cancel | QMessageBox.Reset)
        if reply == QMessageBox.Reset :
            #raise flag. Next time app will open, the settings (bad settings) will not be loaded.
            self.resetqsettings = 1
            self.close()
        elif reply == QMessageBox.Cancel:
            return

    def on_actionCut_triggered(self,checked=None):
        try:
            app.activeWindow().focusWidget().cut()
        except:
            pass

    def on_actionCopy_triggered(self,checked=None):
        try:
            app.activeWindow().focusWidget().copy()
        except:
            pass

    def on_actionPaste_triggered(self,checked=None):
        try:
            app.activeWindow().focusWidget().paste()
        except:
            pass

    def sendmessage(self,message):
        #keep a max of 100 messages
        if len(self.messagehist) > 99:
            self.messagehist = self.messagehist[1:]
        timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz ")))    #zzz = miliseconds
        self.messagehist.append(timez + message)
        self.messagelabel.setText(message)

    def hideDefaultButtons(self):
        self.lowerbuttondialog.setVisible(False)

    def showDefaultButtons(self):
        self.lowerbuttondialog.setVisible(True)

    def hideExtraButtons(self):
        self.extrabuttondialogs.setVisible(False)

    def showExtraButtons(self):
        self.extrabuttondialogs.setVisible(True)

    def updateSliders(self):
        # update visibility (based on the app state)
        if self.qmc.flagon:
            self.showSliders()
        else:
            self.hideSliders()

    def hideSliders(self):
        self.sliderFrame.setVisible(False)

    def showSliders(self):
        self.sliderFrame.setVisible(True)
        
    def toggleSlidersVisibility(self):
        if self.sliderFrame.isVisible():
            self.hideSliders()
        else:
            self.showSliders()

    def updateSlidersProperties(self):
        # update slider properties
        aw.sliderGrpBox1.setVisible(bool(aw.eventslidervisibilities[0]))
        aw.sliderGrpBox2.setVisible(bool(aw.eventslidervisibilities[1]))
        aw.sliderGrpBox3.setVisible(bool(aw.eventslidervisibilities[2]))
        aw.sliderGrpBox4.setVisible(bool(aw.eventslidervisibilities[3]))
        # update event type names
        aw.sliderGrpBox1.setTitle(aw.qmc.etypesf(0))
        aw.sliderGrpBox2.setTitle(aw.qmc.etypesf(1))
        aw.sliderGrpBox3.setTitle(aw.qmc.etypesf(2))
        aw.sliderGrpBox4.setTitle(aw.qmc.etypesf(3))

    def hideLCDs(self):
        self.lcdFrame.setVisible(False)

    def showLCDs(self):
        self.lcdFrame.setVisible(True)

    def hideEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(False)

    def showEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(True)

    def updateLCDproperties(self):
        # set LCDframe visibilities and labels
        ndev = len(aw.qmc.extradevices)
        for i in range(ndev):
            aw.extraLCDframe1[i].setVisible(bool(aw.extraLCDvisibility1[i]))
            if i < len(aw.qmc.extraname1):
                aw.extraLCDlabel1[i].setText("<b>" + aw.qmc.extraname1[i] + "<\b>")
            aw.extraLCD1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            self.extraLCDframe2[i].setVisible(bool(aw.extraLCDvisibility2[i])) 
            if i < len(aw.qmc.extraname2):
                aw.extraLCDlabel2[i].setText("<b>" + aw.qmc.extraname2[i] + "<\b>")  
            aw.extraLCD2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        #hide the rest (just in case)
        for i in range(ndev,aw.nLCDS):
            aw.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)
        aw.LCD2frame.setVisible(aw.qmc.ETlcd)
        aw.LCD3frame.setVisible(aw.qmc.BTlcd)
        aw.LCD4frame.setVisible(aw.qmc.DeltaETlcdflag)
        aw.LCD5frame.setVisible(aw.qmc.DeltaBTlcdflag)
        if aw.qmc.device == 0 or aw.qmc.device == 26:         #extra LCDs for Fuji or DTA pid
            aw.LCD6frame.setVisible(True)
            aw.LCD7frame.setVisible(True)
        else:
            aw.LCD6frame.setVisible(False) 
            aw.LCD7frame.setVisible(False)

    def enableEditMenus(self):
        self.fileLoadAction.setEnabled(True) # open
        self.openRecentMenu.setEnabled(True) # open recent
        self.importMenu.setEnabled(True) # import
        self.fileSaveAction.setEnabled(True)
        self.fileSaveAsAction.setEnabled(True)
        self.exportMenu.setEnabled(True)
        self.saveGraphMenu.setEnabled(True)
        self.htmlAction.setEnabled(True)
        self.printAction.setEnabled(True)
        self.flavorAction.setEnabled(True)
        self.temperatureMenu.setEnabled(True)
        self.languageMenu.setEnabled(True)
        self.designerAction.setEnabled(True)
        self.wheeleditorAction.setEnabled(True)
        self.resetAction.setEnabled(True)

    def disableEditMenus(self):
        self.fileLoadAction.setEnabled(False) # open
        self.openRecentMenu.setEnabled(False) # open recent
        self.importMenu.setEnabled(False) # import
        self.fileSaveAction.setEnabled(False)
        self.fileSaveAsAction.setEnabled(False)
        self.exportMenu.setEnabled(False)
        self.saveGraphMenu.setEnabled(False)
        self.htmlAction.setEnabled(False)
        self.printAction.setEnabled(False)
        self.flavorAction.setEnabled(False)
        self.temperatureMenu.setEnabled(False)
        self.languageMenu.setEnabled(False)
        self.designerAction.setEnabled(False)
        self.wheeleditorAction.setEnabled(False)
        self.resetAction.setEnabled(False)

    def update_minieventline_visibility(self):
        if self.minieventsflag:
            self.EventsGroupLayout.setVisible(True)
        else:
            self.EventsGroupLayout.setVisible(False)

    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        key = int(event.key())
        #uncomment next line to find the integer value of a key
        #print(key)

        #keyboard move keys
        if key == 32:                       #SELECTS ACTIVE BUTTON
            self.moveKbutton("space")
        if key == 16777220:                 #TURN ON/OFF KEYBOARD MOVES
            self.releaseminieditor()
            self.moveKbutton("enter")
        if key == 16777216:                 #ESCAPE
            #if designer ON
            if self.qmc.designerflag:
                string = QApplication.translate("Message","Exit Designer?", None, QApplication.UnicodeUTF8)
                reply = QMessageBox.question(self,QApplication.translate("Message", "Designer Mode ON",None, QApplication.UnicodeUTF8),string,QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    self.stopdesigner()
                else:
                    return
            #if wheel graph ON
            elif self.qmc.wheelflag:
                self.qmc.disconnectWheel()
                self.qmc.redraw(recomputeAllDeltas=False)
            if self.minieventsflag:
                self.releaseminieditor()
        elif key == 16777234:               #MOVES CURRENT BUTTON LEFT
            self.moveKbutton("left")
        elif key == 16777236:               #MOVES CURRENT BUTTON RIGHT
            self.moveKbutton("right")
        elif key == 65:                     #letter A (automatic save)
            self.automaticsave()
        elif key == 83:                     #letter S (sliders)
            self.toggleSlidersVisibility()
        elif key == 84:                     #letter T (mouse cross)
            self.qmc.togglecrosslines()
        elif key == 66:                     #letter B hides/shows extra rows of event buttons
            if aw.qmc.flagon:
                self.toggleextraeventrows()
            else:
                # allow to use 'b' key als if OFF
                if aw.extrabuttondialogs.isVisible():
                    aw.hideExtraButtons()
                    aw.extraeventsbuttonsflag = False
                else:
                    aw.showExtraButtons()
                    aw.extraeventsbuttonsflag = True
        #Extra event buttons palette. Numerical keys [0,1,2,3,4,5,6,7,8,9]
        elif key > 47 and key < 58:
            button = [48,49,50,51,52,53,54,55,56,57] 
            palette = button.index(key)
            string = QApplication.translate("Message","Changing palettes will delete the present extra event buttons.\nRestore palette %i?"%palette,
                                            None, QApplication.UnicodeUTF8)
            reply = QMessageBox.question(self,QApplication.translate("Message", "Extra Event Button Palette",None, QApplication.UnicodeUTF8),
                                         string,QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Yes:
                self.setbuttonsfrom(button.index(key))
            else:
                return
        elif key == 58:
            self.desktopscreenshot()
        elif key == 59:
            self.applicationscreenshot() 
        elif key == 73:                     #letter I (get weight in from scale)
            self.retrieveWeightIn()
        elif key == 79:                     #letter O (get weight out from scale)
            self.retrieveWeightOut()
        else:
            QWidget.keyPressEvent(self, event)

    def releaseminieditor(self):
        if self.minieventsflag:
            self.eNumberSpinBox.releaseKeyboard()
            self.lineEvent.releaseKeyboard()
            self.etimeline.releaseKeyboard()
            self.etypeComboBox.releaseKeyboard()
            self.valueEdit.releaseKeyboard()
            self.lineEvent.clearFocus()
            self.valueEdit.clearFocus()
            self.etimeline.clearFocus()

    # this function respects the button visibility via aw.qmc.buttonvisibility and if button.isDisabled()
    # ON/OFF (2,self.button_1) -> CHARGE (3,self.button_8) -> DRYEND (4,self.button_19) -> FCs (5,self.button_3)
    # -> FCe (6,self.button_4) -> SCs (7,self.button_5) -> SCe (8,self.button_6) -> DROP (9,self.button_9) 
    # -> COOLend (10,self.button_20) -> EVENT (11,self.button_11) -> HUD (1,self.button_18) -> ON/OFF
    # currentButtonIndex is from [1-11]
    # buttons that trigger events and can be triggered only once
    def nextActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 11: # current: EVENT
            # the current button index is the event button, we move to the HUD button
            return 1 # next: HUD
        elif currentButtonIndex == 1: # current: HUD
            return 2 # next: ON/OFF
        elif currentButtonIndex == 10: # current: COOL
            # check if the EVENT button is active, else move to the HUD
            if aw.eventsbuttonflag:
                return 11 # next: EVENT
            else:
                return 1 # next: HUD
        else:
            # we check if the next button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
            # there is an offset of 3
            if aw.qmc.buttonvisibility[currentButtonIndex - 2] and self.keyboardButtonList[currentButtonIndex + 1].isEnabled():
                return currentButtonIndex + 1
            else:
                return self.nextActiveButton(currentButtonIndex + 1)
                
    def previousActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 2: # current: ON/OFF
            # the current button index is the ON/OFF button, we move to the HUD button
            return 1
        elif currentButtonIndex == 1: # current: HUD
            # check if the EVENT button is active, else move to the HUD
            if aw.eventsbuttonflag:
                return 11 # move to EVENT
            else:
                return self.previousActiveButton(10) # move to prev(EVENT)
        elif currentButtonIndex == 3: # current: CHARGE
            return 2 # next: ON/OFF
        else:
            # we check if the previous button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
            # there is an offset of 3
            if aw.qmc.buttonvisibility[currentButtonIndex - 4] and self.keyboardButtonList[currentButtonIndex - 1].isEnabled():
                return currentButtonIndex - 1
            else:
                return self.previousActiveButton(currentButtonIndex - 1)

    def moveKbutton(self,kcommand):
        #"Enter" toggles ON/OFF keyboard    
        if kcommand =="enter" and self.qmc.flagstart:
            if self.keyboardmoveflag == 0:
                #turn on
                self.keyboardmoveflag = 1
                self.keyboardmoveindex = 2
                self.sendmessage(QApplication.translate("Message","Keyboard moves turned ON", None, QApplication.UnicodeUTF8))
                self.button_1.setStyleSheet(self.pushbuttonstyles["SELECTED"])
                
            elif self.keyboardmoveflag == 1:
                # turn off 
                self.keyboardmoveflag = 0
                # clear all
                self.sendmessage(QApplication.translate("Message","Keyboard moves turned OFF", None, QApplication.UnicodeUTF8))
                if self.qmc.flagon:    
                    self.button_1.setStyleSheet(self.pushbuttonstyles["ON"])
                else:
                    self.button_1.setStyleSheet(self.pushbuttonstyles["OFF"])
                self.button_8.setStyleSheet(self.pushbuttonstyles["CHARGE"])
                self.button_19.setStyleSheet(self.pushbuttonstyles["DRY END"])
                self.button_20.setStyleSheet(self.pushbuttonstyles["COOL END"])
                self.button_3.setStyleSheet(self.pushbuttonstyles["FC START"])
                self.button_4.setStyleSheet(self.pushbuttonstyles["FC END"])
                self.button_5.setStyleSheet(self.pushbuttonstyles["SC START"])
                self.button_6.setStyleSheet(self.pushbuttonstyles["SC END"])
                self.button_9.setStyleSheet(self.pushbuttonstyles["DROP"])
                self.button_11.setStyleSheet(self.pushbuttonstyles["EVENT"])
                if self.qmc.flagstart:
                    if self.qmc.HUDflag:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_ON"])
                    else:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
                else:
                    aw.button_18.setStyleSheet(aw.pushbuttonstyles["DISABLED"])

        #if moves on
        if self.keyboardmoveflag:
            if kcommand == "space":
                now = libtime.time()
                if self.lastkeyboardcmd == 0 or (now > self.lastkeyboardcmd + 2): # accept SPACE keyboard cmds only every 2sec.
                    self.keyboardmove[self.keyboardmoveindex]()   #apply button command
                    #behaviour rules after pressing a button
                    #if less than EVENT jump forward to the right once automatically
                    if self.keyboardmoveindex > 1:
                        self.moveKbutton("right")
                    self.lastkeyboardcmd = now
                else: # we ignore this event
                    return
            else:
                if kcommand == "left":
                    nextcmd = self.previousActiveButton(self.keyboardmoveindex)
                else:
                    nextcmd = self.nextActiveButton(self.keyboardmoveindex)
                # activate the button at index nextcmd
                self.keyboardButtonList[nextcmd].setStyleSheet(self.pushbuttonstyles["SELECTED"])
                # deactivate the button at index self.keyboardmoveindex
                if self.keyboardmoveindex == 1: # we make an exception to respect the state of the HUD button
                    if self.qmc.HUDflag:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_ON"])
                    else:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
                else:
                    self.keyboardButtonList[self.keyboardmoveindex].setStyleSheet(self.pushbuttonstyles[self.keyboardButtonStyles[self.keyboardmoveindex]])
                # update self.keyboardmoveindex
                self.keyboardmoveindex = nextcmd
        # we enable keyboard event processing again

    #sound feedback when pressing a push button
    def soundpop(self):
        if self.soundflag:
            QApplication.beep()
# the following does not work on the Mac, nor under Python3
#            try:
#                import pyaudio
#            except ImportError:
#                return False
#
#            p = pyaudio.PyAudio()
#            stream = p.open(rate=44100, channels=1, format=pyaudio.paFloat32, output=True, input=False)
#            stream.write(array.array('b',(int(.25 * math.sin(i / 10.)) for i in range(44100))))
#            stream.close()
#            p.terminate()


    #automatation of filename when saving a file through keyboard shortcut. Speeds things up for batch roasting.
    def automaticsave(self):
        try:
            if self.qmc.autosavepath and self.qmc.autosaveflag:
                filename = self.qmc.autosaveprefix + "-"
                filename += str(QDateTime.currentDateTime().toString(QString("dd-MM-yy_hhmm")))
                filename += ".alog"
                oldDir = u(QDir.current())
                QDir.setCurrent(self.qmc.autosavepath)
                #write
                self.serialize(QString(filename),self.getProfile())
                #restore dirs
                QDir.setCurrent(oldDir)

                self.sendmessage(QApplication.translate("Message","Profile %1 saved in: %2", None, QApplication.UnicodeUTF8).arg(filename).arg(self.qmc.autosavepath))
                self.qmc.safesaveflag = False

                return filename

            else:
                self.sendmessage(QApplication.translate("Message","Empty path or box unchecked in Autosave", None, QApplication.UnicodeUTF8))
                self.autosaveconf()

        except IOError as e:
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " automaticsave() %1").arg(str(e)))

    def viewKshortcuts(self):
        string = u(QApplication.translate("Message", "<b>[ENTER]</b> = Turns ON/OFF Keyboard Shortcuts",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[SPACE]</b> = Choses current button",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[LEFT]</b> = Move to the left",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[RIGHT]</b> = Move to the right",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[a]</b> = Autosave",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[CRTL N]</b> = Autosave + Reset + START",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[t]</b> = Mouse cross lines",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[b]</b> = Shows/Hides Extra Event Buttons",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[s]</b> = Shows/Hides Event Sliders",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[i]</b> = Retrieve Weight In from Scale",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[o]</b> = Retrieve Weight Out from Scale",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[0-9]</b> = Changes Event Button Palettes",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[;]</b> = Application ScreenShot",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>[:]</b> = Desktop ScreenShot",None, QApplication.UnicodeUTF8)) + "<br><br>"

        QMessageBox.information(self,QApplication.translate("Message", "Keyboard Shotcuts",None, QApplication.UnicodeUTF8),string)

    #moves events in minieditor
    def changeEventNumber(self):
        if self.qmc.designerflag:
            return
        #check
        lenevents = len(self.qmc.specialevents)
        currentevent = self.eNumberSpinBox.value()
        self.eventlabel.setText(QApplication.translate("Label", "Event #<b>%1 </b>",None, QApplication.UnicodeUTF8).arg(currentevent))
        if currentevent == 0:
            self.lineEvent.setText("")
            self.valueEdit.setText("")
            self.etypeComboBox.setCurrentIndex(0)
            self.etimeline.setText("")
            self.qmc.resetlines()
            self.qmc.fig.canvas.draw()
            return
        if currentevent > lenevents:
            self.eNumberSpinBox.setValue(lenevents)
            return
        else:
            self.lineEvent.setText(self.qmc.specialeventsStrings[currentevent-1])
            timez = self.qmc.stringfromseconds(int(self.qmc.timex[self.qmc.specialevents[currentevent-1]]-self.qmc.timex[self.qmc.timeindex[0]]))
            self.etimeline.setText(timez)
            self.valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[currentevent-1]))
            self.etypeComboBox.setCurrentIndex(self.qmc.specialeventstype[currentevent-1])
            #plot little dot lines
            self.qmc.resetlines() #clear old
            etimeindex = self.qmc.specialevents[currentevent-1]
            if currentevent:
                x = [self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex]]
                y = [(self.qmc.ylimit_min-100),self.qmc.temp2[etimeindex],self.qmc.temp1[etimeindex],(self.qmc.ylimit+100)]
                self.qmc.ax.plot(x,y,marker ="o",markersize=12,color ="yellow",linestyle="-",linewidth = 7,alpha=.4)
                self.qmc.fig.canvas.draw()

    #updates events from mini edtitor
    def miniEventRecord(self):
        lenevents = self.eNumberSpinBox.value()
        if lenevents:
            self.qmc.specialeventstype[lenevents-1] = self.etypeComboBox.currentIndex()
            self.qmc.specialeventsvalue[lenevents-1] = aw.qmc.str2eventsvalue(str(self.valueEdit.text()))
            self.qmc.specialeventsStrings[lenevents-1] = str(self.lineEvent.text())
            self.qmc.specialevents[lenevents-1] = self.qmc.time2index(self.qmc.timex[self.qmc.timeindex[0]]+ self.qmc.stringtoseconds(str(self.etimeline.text())))

            self.lineEvent.clearFocus()
            self.eNumberSpinBox.clearFocus()
            self.etimeline.clearFocus()

            self.qmc.redraw(recomputeAllDeltas=False)

            #plot highest ET or BT (sometimes only BT is plot (et is zero))
            etimeindex = self.qmc.specialevents[lenevents-1]
            if self.qmc.temp1[etimeindex] > self.qmc.temp2[etimeindex]:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp1[etimeindex], "o", color = self.qmc.palette["et"])
            else:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp2[etimeindex], "o", color = self.qmc.palette["bt"])

            self.qmc.fig.canvas.draw()

            string = ""
            if len(self.qmc.specialeventsStrings[lenevents-1]) > 5:
                string += self.qmc.specialeventsStrings[lenevents-1][0:5]
                string += "..."

            message = u(QApplication.translate("Message","Event #%1:  %2 has been updated", None, QApplication.UnicodeUTF8).arg(str(lenevents)).arg(string))
            self.sendmessage(message)
        
    def strippedName(self, fullFileName):
        return u(QFileInfo(fullFileName).fileName())
        
    def strippedDir(self, fullFileName):
        return u(QFileInfo(fullFileName).dir().dirName())

    def setCurrentFile(self, fileName):
        self.curFile = fileName
        if self.curFile:
            self.setWindowTitle(("%s - " + self.windowTitle) % self.strippedName(self.curFile))
            settings = QSettings()
            files = settings.value('recentFileList').toStringList()
            try:
                files.removeAll(fileName)
            except ValueError:
                pass
            files.insert(0, fileName)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentFileList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentFileActions()
        else:
            self.setWindowTitle(self.windowTitle)
 
    def updateRecentFileActions(self):
        settings = QSettings()
        files = settings.value('recentFileList').toStringList()
        strippedNames = list(map(self.strippedName,files))
        numRecentFiles = min(len(files), self.MaxRecentFiles)
 
        for i in range(numRecentFiles):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = "&%s (%s)" % (strippedName, self.strippedDir(files[i]))
            else:
                text = "&%s" % strippedName
            self.recentFileActs[i].setText(text)
            self.recentFileActs[i].setData(files[i])
            self.recentFileActs[i].setVisible(True)
 
        for j in range(numRecentFiles, self.MaxRecentFiles):
            self.recentFileActs[j].setVisible(False)
 
    def openRecentFile(self):
        action = self.sender()
        if action:
            self.loadFile(action.data().toString())

    def getDefaultPath(self):
        userprofilepath_dir = QDir()
        userprofilepath_dir.setPath(self.userprofilepath)
        userprofilepath_elements = userprofilepath_dir.absolutePath().split("/") # directories as QStrings
        profilepath_dir = QDir()
        profilepath_dir.setPath(self.profilepath)
        profilepath_elements = profilepath_dir.absolutePath().split("/")
        #compare profilepath with userprofilepath (modulo the last two segments which are month/year respectively)
        if len(userprofilepath_elements) == len(profilepath_elements) and len(userprofilepath_elements) > 1 and freduce(lambda x,y: x and y, [x[0] == x[1] for x in zip(userprofilepath_elements[:-2],profilepath_elements[:-2])]):
            if platf == 'Darwin':
                return self.userprofilepath
            else:
                return self.profilepath
        else:
            return self.userprofilepath

    def setDefaultPath(self,f):
        if f:
            filepath_dir = QDir()
            filepath_dir.setPath(f)
            filepath_elements = filepath_dir.absolutePath().split("/")[:-1] # directories as QStrings (without the filename)
            self.userprofilepath = u(freduce(lambda x,y: x + '/' + y, filepath_elements) + "/")

    #the central OpenFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanOpenFileDialog(self,msg="Open",ext="*",path=None):
        if path == None:   
            path = self.getDefaultPath()
        f = u(QFileDialog.getOpenFileName(self,msg,path,ext))
        self.setDefaultPath(f)
        return f
 
    #the central SaveFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanSaveFileDialog(self,msg=QApplication.translate("Message","Save",None, QApplication.UnicodeUTF8),ext="*.alog",path=None):
        if path == None:
            path = self.getDefaultPath() 
        f = u(QFileDialog.getSaveFileName(self,msg,path,ext))
        self.setDefaultPath(f)
        return f
 
    #the central ExistingDirectoryDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanExistingDirectoryDialog(self,msg=QApplication.translate("Message","Select Directory",None, QApplication.UnicodeUTF8),path=None):
        if path == None:
            path = self.getDefaultPath() 
        f = u(QFileDialog.getExistingDirectory(self,msg,path))
        self.setDefaultPath(f)
        return f

    def newRoast(self):
        #####################################
        #IF there is an ongoing roast (if ON):
        #   (this block allows batch processing using the autosave feature)
        #   if no CHARGE found:
        #       return
        #   if no DROP found:
        #       use last data point as DROP (mark DROP)
        #   stop recording
        #   if there is an autosave path (from autosafe config) AND the autosave flag is ON:
        #       create filename using the autosavepath and date+time
        #   else:
        #       start autosave Dialog to set the name path
        #       return (nothing saved. Cancell New)
        #   reset  (delete everything)
        #   start new roast (START)
        #ELSE (if recording is stoped - OFF):
        #   if no profile present (no data present or profile loaded):
        #       start new roast (START)
        #   else:
        #       reset (reset offers three options: Save,Continue,Cancell)
        #       START
        #########################################
        if self.qmc.flagstart:
            if self.qmc.timeindex[0] == -1:
                self.sendmessage(QApplication.translate("Message","No profile found", None, QApplication.UnicodeUTF8))
                return
            #mark drop if not yet done
            if self.qmc.timeindex[6] == 0:
                self.qmc.markDrop()
            #invoke "OFF"
            self.qmc.OffMonitor()
            
            #store, reset and redraw
            if self.qmc.autosavepath and self.qmc.autosaveflag:
                #if autosave mode active we just save automatic
                filename = self.automaticsave()
            else:
                self.sendmessage(QApplication.translate("Message","Empty path or box unchecked in Autosave", None, QApplication.UnicodeUTF8))
                self.autosaveconf()
                return
            if self.qmc.reset():
                #start new roast
                self.qmc.ToggleRecorder()
                self.sendmessage(QApplication.translate("Message","%1 has been saved. New roast has started", None, QApplication.UnicodeUTF8).arg(filename))
        else:
            if not len(self.qmc.timex):
                self.qmc.ToggleRecorder()
            else:
                if self.qmc.reset():
                    self.qmc.ToggleRecorder()

    def fileLoad(self):
        try:
            fileName = self.ArtisanOpenFileDialog()
            if fileName:
                self.loadFile(fileName)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " fileLoad() %1").arg(str(ex)),exc_tb.tb_lineno)

    #loads stored profiles. Called from file menu
    def loadFile(self,filename):
        f = None
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            if self.qmc.reset(redraw=False): # operation not canceled by the user in the save dirty state dialog
                firstChar = stream.read(1)
                if firstChar == "{":
                    f.close()
                    res = self.setProfile(self.deserialize(filename))
                else:
                    self.sendmessage(QApplication.translate("Message","Invalid artisan format", None, QApplication.UnicodeUTF8))
                    res = False
                if res:
                    self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                    #change Title
                    self.qmc.ax.set_title(self.qmc.title, size=20, color= self.qmc.palette["title"])
                    #update etypes combo box
                    self.etypeComboBox.clear()
                    self.etypeComboBox.addItems(self.qmc.etypes)
                    #Plot everything
                    self.qmc.redraw()
                    message = u(QApplication.translate("Message","%1  loaded ", None, QApplication.UnicodeUTF8).arg(u(filename)))
                    self.sendmessage(message)
                    self.setCurrentFile(filename)
        except IOError as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " fileload() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except ValueError as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " fileload() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " loadFile() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()

    # Loads background profile
    def loadbackground(self,filename):
        try:        
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            
            firstChar = stream.read(1)
            if firstChar == "{":            
                f.close()
                profile = self.deserialize(filename)
                tb = profile["timex"]
                b1 = self.qmc.smooth_list(tb,profile["temp1"],window_len=self.qmc.curvefilter)
                b2 = self.qmc.smooth_list(tb,profile["temp2"],window_len=self.qmc.curvefilter)
                # NOTE: parallel assignment after time intensive smoothing is necessary to avoid redraw failure!
                self.qmc.temp1B,self.qmc.temp2B,self.qmc.timeB = b1,b2,tb
                self.qmc.backgroundEvents = profile["specialevents"]
                self.qmc.backgroundEtypes = profile["specialeventstype"]
                self.qmc.backgroundEvalues = profile["specialeventsvalue"]
                self.qmc.backgroundEStrings = profile["specialeventsStrings"]
                self.qmc.backgroundFlavors = profile["flavors"]
                #if old format < 0.5.0 version  (identified by numbers less than 1.). convert
                if self.qmc.backgroundFlavors[0] < 1. and self.qmc.backgroundFlavors[-1] < 1.:
                    l = len(self.qmc.backgroundFlavors)
                    for i in range(l):
                        self.qmc.backgroundFlavors[i] *= 10.
                    self.qmc.backgroundFlavors = self.qmc.backgroundFlavors[:(l-1)]
                if "etypes" in profile:
                    self.qmc.Betypes = profile["etypes"]
                if "timeindex" in profile:
                    self.qmc.timeindexB = profile["timeindex"]          #if new profile found with variable timeindex
                else:            
                    if "startend" in profile:
                        startendB = profile["startend"]
                        varCB = profile["cracks"]
                        if "dryend" in profile:
                            dryendB = profile["dryend"]
                        else:
                            dryendB = [0,0]
                        times = []
                        times.append(startendB[0])
                        times.append(dryendB[0])
                        times.append(varCB[0])
                        times.append(varCB[2])
                        times.append(varCB[4])
                        times.append(varCB[6])
                        times.append(startendB[2])
                        self.qmc.timebackgroundindexupdate(times[:])
                self.qmc.timeindexB = self.qmc.timeindexB + [0 for i in range(8-len(self.qmc.timeindexB))]
                message =  u(QApplication.translate("Message", "Background %1 loaded successfully %2",None, QApplication.UnicodeUTF8).arg(u(filename)).arg(str(self.qmc.stringfromseconds(self.qmc.timeB[self.qmc.timeindexB[6]]))))
                self.sendmessage(message)
            else:
                self.sendmessage(QApplication.translate("Message", "Invalid artisan format",None, QApplication.UnicodeUTF8))
        except IOError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " loadbackground() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None, QApplication.UnicodeUTF8) + " loadbackground() %1").arg(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " loadbackground() %1").arg(str(e)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()

    def eventtime2string(self,time):
        if time == 0.0:
            return ""
        else:
            return "%02d:%02d"% divmod(time,60)

    #read Artisan CSV
    def importCSV(self,filename):
        try:
            import csv
            import io
            csvFile = io.open(filename, 'r', encoding='utf-8')
            data = csv.reader(csvFile,delimiter='\t')
            #read file header
            header = next(data)
            self.qmc.roastdate = QDate.fromString(header[0].split('Date:')[1],"dd'.'MM'.'yyyy")
            unit = header[1].split('Unit:')[1]
            #set temperature mode
            if unit == "F" and self.qmc.mode == "C":
                self.qmc.fahrenheitMode()
            if unit == "C" and self.qmc.mode == "F":
                self.qmc.celsiusMode()
            #read column headers
            fields = next(data) 
            extra_fields = fields[5:] # colums after 'Event'
            # add devices if needed
            for i in range(max(0,(len(extra_fields) / 2) - len(self.qmc.extradevices))):
                self.addDevice()
            # set extra device names # NOTE: eventuelly we want to set/change the names only for devices that were just added in the line above!?
            for i in range(len(extra_fields)):
                if i % 2 == 1:
                    # odd
                    self.qmc.extraname2[int(i/2)] = extra_fields[i]
                else:
                    # even
                    self.qmc.extraname1[int(i/2)] = extra_fields[i]
            #read data
            last_time = None
            for row in data:
                items = list(zip(fields, row))
                item = {}
                for (name, value) in items:
                    item[name] = value.strip()
                #add one measurement
                timez = float(self.qmc.stringtoseconds(item['Time1']))
                if not last_time or last_time < timez:
                    self.qmc.timex.append(timez)
                    self.qmc.temp1.append(float(item['ET']))
                    self.qmc.temp2.append(float(item['BT']))
                    for j in range(len(extra_fields)):
                        if j % 2 == 1:
                            # odd
                            self.qmc.extratemp2[int(j/2)].append(float(item[extra_fields[j]]))
                        else:
                            # even
                            self.qmc.extratimex[int(j/2)].append(timez)
                            self.qmc.extratemp1[int(j/2)].append(float(item[extra_fields[j]]))
                last_time = timez
            csvFile.close()
            #swap temperature curves if needed such that BT is the lower and ET the upper one
            if len(self.qmc.temp2) > 0 and len(self.qmc.temp1) > 0 and (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                tmp = self.qmc.temp1
                self.qmc.temp1 = self.qmc.temp2
                self.qmc.temp2 = tmp
            #set events
            CHARGE = self.qmc.stringtoseconds(header[2].split('CHARGE:')[1])
            if CHARGE > 0:
                self.qmc.timeindex[0] = self.time2index(CHARGE)
            DRYe = self.qmc.stringtoseconds(header[4].split('DRYe:')[1])
            if DRYe > 0:
                self.qmc.timeindex[1] = self.time2index(DRYe)
            FCs = self.qmc.stringtoseconds(header[5].split('FCs:')[1])
            if FCs > 0:
                self.qmc.timeindex[2] = self.time2index(FCs)
            FCe = self.qmc.stringtoseconds(header[6].split('FCe:')[1])
            if FCe > 0:
                self.qmc.timeindex[3] = self.time2index(FCe)
            SCs = self.qmc.stringtoseconds(header[7].split('SCs:')[1])
            if SCs > 0:
                self.qmc.timeindex[4] = self.time2index(SCs)
            SCe = self.qmc.stringtoseconds(header[8].split('SCe:')[1])
            if SCe> 0:
                self.qmc.timeindex[5] = self.time2index(SCe) 
            DROP = self.qmc.stringtoseconds(header[9].split('DROP:')[1])
            if DROP > 0:
                self.qmc.timeindex[6] = self.time2index(DROP)
            COOL = self.qmc.stringtoseconds(header[10].split('COOL:')[1])
            if COOL > 0:
                self.qmc.timeindex[7] = self.time2index(COOL)
            self.qmc.endofx = self.qmc.timex[-1]
            self.sendmessage(QApplication.translate("Message","Artisan CSV file loaded successfully", None, QApplication.UnicodeUTF8))
            self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importCSV() %1").arg(str(ex)),exc_tb.tb_lineno)

    def addSerialPort(self):
        self.extraser.append(serialport()) 
        self.extracomport.append("COM1")
        self.extrabaudrate.append(9600)
        self.extrabytesize.append(8)
        self.extraparity.append("E")
        self.extrastopbits.append(1)
        self.extratimeout.append(1)

    def addDevice(self):
        try:
            self.qmc.extradevices.append(1)
            self.qmc.extradevicecolor1.append("black") #init color to black
            self.qmc.extradevicecolor2.append("black")
            self.qmc.extraname1.append("Extra 1")
            self.qmc.extraname2.append("Extra 2")
            self.qmc.extramathexpression1.append("")
            self.qmc.extramathexpression2.append("")
            
            # ensure that the curves and LCDs of the new device are visible:
            n = len(self.qmc.extradevices)
            self.extraLCDvisibility1[n-1] = False
            self.extraLCDvisibility2[n-1] = False
            self.extraCurveVisibility1[n-1] = True
            self.extraCurveVisibility2[n-1] = True

            #create new serial port (but don't open it yet). Store initial settings
            self.addSerialPort()

            #add new line variables
            self.qmc.extratimex.append([])
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2.append([])
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2.append([])

            #add new style variables
            self.qmc.extralinestyles1.append(self.qmc.linestyle_default)
            self.qmc.extralinestyles2.append(self.qmc.linestyle_default)
            self.qmc.extradrawstyles1.append(self.qmc.drawstyle_default)
            self.qmc.extradrawstyles2.append(self.qmc.drawstyle_default)
            self.qmc.extralinewidths1.append(self.qmc.linewidth_default)
            self.qmc.extralinewidths2.append(self.qmc.linewidth_default)
            self.qmc.extramarkers1.append(self.qmc.marker_default)
            self.qmc.extramarkers2.append(self.qmc.marker_default)
            self.qmc.extramarkersizes1.append(self.qmc.markersize_default)
            self.qmc.extramarkersizes2.append(self.qmc.markersize_default)

            #add two extra lines in figure for extra ET and extra BT
            l = len(self.qmc.extradevices)-1  #new line index
            self.qmc.extratemp1lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp1[l],color=self.qmc.extradevicecolor1[l],markersize=self.qmc.extramarkersizes1[l],marker=self.qmc.extramarkers1[l],linewidth=self.qmc.extralinewidths1[l],linestyle=self.qmc.extralinestyles1[l],drawstyle=self.qmc.extradrawstyles1[l],label=self.qmc.extraname1[l])[0])
            self.qmc.extratemp2lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp2[l],color=self.qmc.extradevicecolor2[l],markersize=self.qmc.extramarkersizes2[l],marker=self.qmc.extramarkers2[l],linewidth=self.qmc.extralinewidths2[l],linestyle=self.qmc.extralinestyles2[l],drawstyle=self.qmc.extradrawstyles2[l],label=self.qmc.extraname2[l])[0])

            self.updateExtraLCDvisibility()
        except Exception:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            pass

    #Write readings to Artisan JSON file
    def exportJSON(self,filename):
        try:
            outfile = open(filename, 'w')
            json.dump(self.getProfile(), outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
        except Exception as ex:
#            import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " exportJSON() %1").arg(str(ex)),exc_tb.tb_lineno)

    #Write readings to RoastLogger CSV file
    def exportRoastLogger(self,filename):
        outfile = open(filename, 'w')
        try:
            outfile.write("Log created at 09:00:00 "+ self.qmc.roastdate.toString("dd'/'MM'/'yyyy") + "\n")
            outfile.write("Use Options|Set template for new log to modify this template.\n")
            outfile.write("------------------------------------------------------\n")
            outfile.write("Bean/Blend name:\n")
            outfile.write("\n")
            outfile.write("Profile description:\n")
            outfile.write("\n")
            outfile.write("Roast notes:\n")
            outfile.write("\n")
            outfile.write("Cupping results:\n")
            outfile.write("\n")
            outfile.write("Roast Logger Copyright ? T. R. Coxon (GreenBean TMC).\n")
            outfile.write("Roast started at 09:00:00 " + self.qmc.roastdate.toString("dd'/'MM'/'yyyy") + "\n")
            if len(self.qmc.timex) > 0:
                CHARGE = aw.qmc.timex[aw.qmc.timeindex[0]] 
            else:
                CHARGE = 0
            import csv
            writer= csv.writer(outfile,delimiter=',')
            writer.writerow(["Elapsed time "," T1 "," T2 "," Event type"])
            for i in range(len(aw.qmc.timex)):
                if i == aw.qmc.timeindex[0]:
                    kind = "Beans loaded"
                elif i!=0 and i == aw.qmc.timeindex[2]:
                    kind = "First crack start"
                elif i!=0 and i == aw.qmc.timeindex[3]:
                    kind = "First crack end"
                elif i!=0 and i == aw.qmc.timeindex[4]:
                    kind = "Second crack start"
                elif i!=0 and i == aw.qmc.timeindex[6]:
                    kind = "Beans ejected"
                else:
                    kind = "timer"
                writer.writerow([aw.qmc.stringfromseconds(aw.qmc.timex[i]-CHARGE),"%.1f"%float(aw.qmc.temp2[i]),"%.1f"%float(aw.qmc.temp1[i]),kind])
            outfile.write("\n")
            outfile.write("@actionT1Table\n")
            outfile.write("120|null|30\n")
            outfile.write("178|65|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("\n")
            outfile.write("@actionSecsFCTable\n")
            outfile.write("60|50|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("\n")
            outfile.write("@actionResetTable\n")
            outfile.write("100|0\n")
            outfile.write("\n")
            outfile.write("@loadBeansTable\n")
            outfile.write("146\n")
            outfile.write("\n")
            outfile.close()
        except Exception as ex:
#           import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " exportRoastLogger() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            outfile.close()

    def importJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            obj = json.load(infile)
            res = self.setProfile(obj)
            infile.close()
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #change Title
                self.qmc.ax.set_title(self.qmc.title, size=20, color= self.qmc.palette["title"])
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importJSON() %1").arg(str(ex)),exc_tb.tb_lineno)

    def importRoastLogger(self,filename):
        try:
            # use io.open instead of open to have encoding support on Python 2
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            obj = {}
            obj["mode"] = "C"
            obj["title"] = u(QFileInfo(filename).fileName())
            import csv
            obj["roastdate"] = e(QDate.currentDate().toString())
            # read roastdate from file
            while True:
                l = infile.readline()
                if l.startswith("Roast started at "):
                    #extract roast date
                    roastdate = QDate.fromString(l.split(" ")[-1][0:10],"dd'/'MM'/'yyyy")
                    if not roastdate.isNull():
                        obj["roastdate"] = e(roastdate.toString())
                    break
                if l == '':
                    break
            timeindex = [-1,0,0,0,0,0,0,0]
            timex = []
            temp1 = []
            temp2 = []
            data = csv.reader(infile,delimiter=',')
            #read file header
            next(data) # we do not use the labels
            #header = list(map(lambda s:s.strip(),next(data)))
            while True:
                fields = next(data)
                if len(fields) == 0:
                    break
                else:
                    timex.append(float(self.qmc.stringtoseconds(fields[0])))
                    temp1.append(float(fields[1]))
                    temp2.append(float(fields[2]))
                    event = fields[3]
                    if event == "Beans loaded":
                        timeindex[0] = len(timex) - 1
                    elif event == "First crack start":
                        timeindex[2] = len(timex) - 1
                    elif event == "First crack end":
                        timeindex[3] = len(timex) - 1
                    elif event == "Second crack start":
                        timeindex[4] = len(timex) - 1
                    elif event == "Beans ejected":
                        timeindex[6] = len(timex) - 1
            obj["timeindex"] = timeindex
            obj["timex"] = timex
            obj["temp1"] = temp2
            obj["temp2"] = temp1
            res = self.setProfile(obj)
            infile.close()
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #change Title
                self.qmc.ax.set_title(self.qmc.title, size=20, color= self.qmc.palette["title"])
                self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importRoastLogger() %1").arg(str(ex)),exc_tb.tb_lineno)

    #Write readings to Artisan csv file
    def exportCSV(self,filename):
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]] 
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    #manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                else:
                    #we use the dryEndIndex respecting the dry phase
                    if dryEndIndex < len(self.qmc.timex):
                        DRYe = self.qmc.timex[dryEndIndex]
                    else:
                        DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [     
                    [CHARGE,"Charge",False],
                    [TP,"TP",False],      
                    [DRYe,"Dry End",False], 
                    [FCs,"FCs",False],
                    [FCe,"FCe",False],
                    [SCs,"SCs",False],
                    [SCe,"SCe",False],
                    [DROP, "Drop",False],
                    [COOL, "COOL",False],
                    ]
                import csv
                outfile = open(filename, 'w')
                writer= csv.writer(outfile,delimiter='\t')
                writer.writerow([
                    u("Date:" + self.qmc.roastdate.toString("dd'.'MM'.'yyyy")),
                    u("Unit:" + self.qmc.mode),
                    u("CHARGE:" + self.eventtime2string(CHARGE)),
                    u("TP:" + self.eventtime2string(TP)),
                    u("DRYe:" + self.eventtime2string(DRYe)),
                    u("FCs:" + self.eventtime2string(FCs)),
                    u("FCe:" + self.eventtime2string(FCe)),
                    u("SCs:" + self.eventtime2string(SCs)),
                    u("SCe:" + self.eventtime2string(SCe)),
                    u("DROP:" + self.eventtime2string(DROP)),
                    u("COOL:" + self.eventtime2string(COOL))])
                writer.writerow([u('Time1'),u('Time2'),u('BT'),u('ET'),u('Event')] + freduce(lambda x,y: x + [u(str(y[0])),u(str(y[1]))], list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],self.qmc.extraname2[0:len(self.qmc.extradevices)])),[]))
                last_time = None
                for i in range(len(self.qmc.timex)):
                    if CHARGE > 0. and self.qmc.timex[i] >= CHARGE:
                        time2 = "%02d:%02d"% divmod(self.qmc.timex[i] - CHARGE, 60)
                    else:
                        time2 = "" 
                    event = ""               
                    for e in range(len(events)):
                        if not events[e][2] and int(round(self.qmc.timex[i])) == int(round(events[e][0])):
                            event = events[e][1]
                            events[e][2] = True
                            break
                    time1 = "%02d:%02d"% divmod(self.qmc.timex[i],60)
                    if not last_time or last_time != time1:
                        extratemps = []
                        for j in range(len(self.qmc.extradevices)):
                            extratemps.append(u(self.qmc.extratemp1[j][i]))
                            extratemps.append(u(self.qmc.extratemp2[j][i]))
                        writer.writerow([u(time1),u(time2),u(self.qmc.temp2[i]),u(self.qmc.temp1[i]),u(event)] + extratemps)
                    last_time = time1
                outfile.close()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " exportCSV() %1").arg(str(ex)),exc_tb.tb_lineno)

    #Write object to file
    def serialize(self,filename,obj):
        f = codecs.open(u(filename), 'w+', encoding='utf-8')
        f.write(repr(obj))
        f.close()

    #Read object from file 
    def deserialize(self,filename):
        obj = None
        if os.path.exists(u(filename)):
            f = codecs.open(u(filename), 'rb', encoding='utf-8')
            obj=eval(f.read())
            f.close()
        return obj

    #used by fileLoad()
    def setProfile(self,profile):
        try:
            #extra devices load and check   
            if "extratimex" in profile:   
                if "extradevices" in profile:
                    if self.qmc.extradevices != profile["extradevices"]:
                        string = u(QApplication.translate("Message","To load this profile the extra devices configuration needs to be changed.\nContinue?", None, QApplication.UnicodeUTF8))
                        reply = QMessageBox.question(self,QApplication.translate("Message", "Found a different number of curves",None, QApplication.UnicodeUTF8),string,QMessageBox.Yes|QMessageBox.Cancel)
                        if reply == QMessageBox.Yes:
                            aw.qmc.resetlinecountcaches()
                            self.qmc.extradevices = profile["extradevices"]
                        else:
                            return False
                        
                # adjust extra serial device table
                # a) remove superfluous extra serial settings
                self.extraser = self.extraser[:len(self.qmc.extradevices)]
                self.extracomport = self.extracomport[:len(self.qmc.extradevices)]
                self.extrabaudrate = self.extrabaudrate[:len(self.qmc.extradevices)]
                self.extrabytesize = self.extrabytesize[:len(self.qmc.extradevices)]
                self.extraparity = self.extraparity[:len(self.qmc.extradevices)]
                self.extrastopbits = self.extrastopbits[:len(self.qmc.extradevices)]
                self.extratimeout = self.extratimeout[:len(self.qmc.extradevices)]
                # b) add missing extra serial settings
                for i in range(len(self.qmc.extradevices) - len(self.extraser)):
                    self.addSerialPort()
                # c) set extra temp curves and prepare empty extra smoothed temp curves
                if "extratimex" in profile:
                    self.qmc.extratimex = profile["extratimex"]
                if "extratemp1" in profile:
                    self.qmc.extratemp1 = profile["extratemp1"]
                    self.qmc.extrastemp1 = [[]]*len(self.qmc.extratemp1)
                if "extratemp2" in profile:
                    self.qmc.extratemp2 = profile["extratemp2"]
                    self.qmc.extrastemp2 = [[]]*len(self.qmc.extratemp2)
                # d) set other extra curve attribute lists
                if "extraname1" in profile:
                    self.qmc.extraname1 = profile["extraname1"]
                if "extraname2" in profile:
                    self.qmc.extraname2 = profile["extraname2"]
                if "extramathexpression1" in profile:
                    self.qmc.extramathexpression1 = profile["extramathexpression1"]
                if "extramathexpression2" in profile:
                    self.qmc.extramathexpression2 = profile["extramathexpression2"]
                if "extradevicecolor1" in profile:
                    self.qmc.extradevicecolor1 = [d(x) for x in profile["extradevicecolor1"]]
                if "extradevicecolor2" in profile:
                    self.qmc.extradevicecolor2 = [d(x) for x in profile["extradevicecolor2"]]
                if "extramarkersizes1" in profile:
                    self.qmc.extramarkersizes1 = profile["extramarkersizes1"]
                else:
                    self.qmc.extramarkersizes1 = [self.qmc.markersize_default]*len(self.qmc.extratemp1)
                if "extramarkersizes2" in profile:
                    self.qmc.extramarkersizes2 = profile["extramarkersizes2"]
                else:
                    self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*len(self.qmc.extratemp2)
                if "extramarkers1" in profile:
                    self.qmc.extramarkers1 = [d(x) for x in profile["extramarkers1"]]
                else:
                    self.qmc.extramarkers1 = [self.qmc.marker_default]*len(self.qmc.extratemp1)
                if "extramarkers2" in profile:
                    self.qmc.extramarkers2 = [d(x) for x in profile["extramarkers2"]]
                else:
                    self.qmc.extramarkers2 = [self.qmc.marker_default]*len(self.qmc.extratemp2)
                if "extralinewidths1" in profile:
                    self.qmc.extralinewidths1 = profile["extralinewidths1"]
                else:
                    self.qmc.extralinewidths1 = [self.qmc.linewidth_default]*len(self.qmc.extratemp1)
                if "extralinewidths2" in profile:
                    self.qmc.extralinewidths2 = profile["extralinewidths2"]
                else:
                    self.qmc.extralinewidths2 = [self.qmc.linewidth_default]*len(self.qmc.extratemp2)
                if "extralinestyles1" in profile:
                    self.qmc.extralinestyles1 = [d(x) for x in profile["extralinestyles1"]]
                else:
                    self.qmc.extralinestyles1 = [self.qmc.linestyle_default]*len(self.qmc.extratemp1)
                if "extralinestyles2" in profile:
                    self.qmc.extralinestyles2 = [d(x) for x in profile["extralinestyles2"]]
                else:
                    self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*len(self.qmc.extratemp2)
                if "extradrawstyles1" in profile:
                    self.qmc.extradrawstyles1 = [d(x) for x in profile["extradrawstyles1"]]
                else:
                    self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp1)
                if "extradrawstyles2" in profile:
                    self.qmc.extradrawstyles2 = [d(x) for x in profile["extradrawstyles2"]]
                else:
                    self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp2)
                self.updateExtraLCDvisibility()
    
            old_mode = self.qmc.mode
            if "mode" in profile:
                self.qmc.mode = str(profile["mode"])
            #convert modes only if needed comparing the new uploaded mode to the old one.
            #otherwise it would incorrectly convert the uploaded phases
            if self.qmc.mode == "F" and old_mode == "C":
                self.qmc.fahrenheitMode()
            if self.qmc.mode == "C" and old_mode == "F":
                self.qmc.celsiusMode()
            if "flavors" in profile:
                self.qmc.flavors = [float(fl) for fl in profile["flavors"]]
            #if old format < 0.5.0 version  (identified by numbers less than 1.). convert
            if self.qmc.flavors[0] < 1. and self.qmc.flavors[-1] < 1.:
                l = len(self.qmc.flavors)
                for i in range(l):
                    self.qmc.flavors[i] *= 10.
                self.qmc.flavors = self.qmc.flavors[:(l-1)]
            if "flavorlabels" in profile:
                self.qmc.flavorlabels = QStringList([d(x) for x in profile["flavorlabels"]])
            for i in range(len(self.qmc.flavorlabels)):
                self.qmc.flavorlabels[i] = self.qmc.flavorlabels[i]
            if "flavorstartangle" in profile:
                self.qmc.flavorstartangle = int(profile["flavorstartangle"])
            if "flavoraspect" in profile:
                self.qmc.flavoraspect = float(profile["flavoraspect"])
            else:
                self.qmc.flavoraspect = 1.
            if "title" in profile:
                self.qmc.title = d(profile["title"])
            else:            
                self.qmc.title = QApplication.translate("Scope Title", "Roaster Scope",None, QApplication.UnicodeUTF8)
            if "beans" in profile:
                self.qmc.beans = d(profile["beans"])
            else:
                self.qmc.beans = ""
            if "weight" in profile:
                self.qmc.weight = [profile["weight"][0],profile["weight"][1],d(profile["weight"][2])]
            else:
                self.qmc.weight = [0,0,"g"]
            if "volume" in profile:
                self.qmc.volume = profile["volume"]
            else:
                self.qmc.volume = [0,0,"l"]
            if "density" in profile:
                self.qmc.density = [profile["density"][0],d(profile["density"][1]),profile["density"][2],d(profile["density"][3])]
            else:
                self.qmc.density = [0,"g",0,"l"]
            if "roastertype" in profile:
                self.qmc.roastertype = d(profile["roastertype"])
            else:
                self.qmc.roastertype = ""
            if "operator" in profile:
                self.qmc.operator = d(profile["operator"])
            else:
                self.qmc.operator = ""
            if "beansize" in profile:
                self.qmc.beansize = float(profile["beansize"])
            else:
                self.qmc.beansize = 0.0
            if "heavyFC" in profile:
                self.qmc.heavyFC_flag = profile["heavyFC"]
            if "lowFC" in profile:
                self.qmc.lowFC_flag = profile["lowFC"]
            if "lightCut" in profile:
                self.qmc.lightCut_flag = profile["lightCut"]
            if "darkCut" in profile:
                self.qmc.darkCut_flag = profile["darkCut"]
            if "drops" in profile:
                self.qmc.drops_flag = profile["drops"]
            if "oily" in profile:
                self.qmc.oily_flag = profile["oily"]
            if "uneven" in profile:
                self.qmc.uneven_flag = profile["uneven"]
            if "tipping" in profile:
                self.qmc.tipping_flag = profile["tipping"]
            if "scorching" in profile:
                self.qmc.scorching_flag = profile["scorching"]
            if "divots" in profile:
                self.qmc.divots_flag = profile["divots"]
            # color
            if "whole_color" in profile:
                self.qmc.whole_color = profile["whole_color"]
            if "ground_color" in profile:
                self.qmc.ground_color = profile["ground_color"]
            if "color_system" in profile and profile["color_system"] in self.qmc.color_systems:
                self.qmc.color_system_idx = self.qmc.color_systems.index(profile["color_system"])
            # for compatibility with older profiles:
            if "roastdate" in profile:
                try:
                    self.qmc.roastdate = QDate.fromString(d(profile["roastdate"]))
                except Exception:
                    pass
            # the new dates have the locale independent isodate format:
            if "roastisodate" in profile:
                try:
                    self.qmc.roastdate = QDate.fromString(d(profile["roastisodate"],Qt.ISODate))
                except Exception:
                    pass
            if "specialevents" in profile:
                self.qmc.specialevents = profile["specialevents"]
            else:
                self.qmc.specialevents = []
            if "specialeventstype" in profile:
                self.qmc.specialeventstype = profile["specialeventstype"]
            else:  
                self.qmc.specialeventstype = []
            if "specialeventsvalue" in profile:
                self.qmc.specialeventsvalue = profile["specialeventsvalue"]
            else:
                self.qmc.specialeventsvalue = []          
            if "specialeventsStrings" in profile:
                self.qmc.specialeventsStrings = [d(x) for x in profile["specialeventsStrings"]]
            else:
                self.qmc.specialeventsStrings = []
            if "etypes" in profile:
                self.qmc.etypes = [d(x) for x in profile["etypes"]]
                
            if "roastingnotes" in profile:
                self.qmc.roastingnotes = d(profile["roastingnotes"])
            else:
                self.qmc.roastingnotes = ""
            if "cuppingnotes" in profile:
                self.qmc.cuppingnotes = d(profile["cuppingnotes"])
            else:
                self.qmc.cuppingnotes = ""
            if "timex" in profile:
                self.qmc.timex = profile["timex"]
            if "temp1" in profile:
                self.qmc.temp1 = profile["temp1"]
            if "temp2" in profile:
                self.qmc.temp2 = profile["temp2"]
            if "phases" in profile:
                self.qmc.phases = profile["phases"]
    # don't let the users y/z min/max axis limits be overwritten by loading a profile
    #        if "zmax" in profile:
    #            self.qmc.zlimit = min(int(profile["zmax"]),500)
    #        if "zmin" in profile:
    #            self.qmc.zlimit_min = max(min(int(profile["zmin"]),self.qmc.zlimit),-200)
    #        if "ymax" in profile:
    #            self.qmc.ylimit = min(int(profile["ymax"]),850)
    #        if "ymin" in profile:
    #            self.qmc.ylimit_min = max(min(int(profile["ymin"]),self.qmc.ylimit),-150)
            if "xmin" in profile:
                self.qmc.startofx = int(profile["xmin"])
            if "xmax" in profile:
                self.qmc.endofx = int(profile["xmax"])
            else:
                #Set the xlimits
                if self.qmc.timex:
                    self.qmc.endofx = self.qmc.timex[-1] + 40
            if "ambientTemp" in profile:
                self.qmc.ambientTemp = profile["ambientTemp"]    
            if "ambient_humidity" in profile:
                self.qmc.ambientTemp = profile["ambient_humidity"]
            if "bag_humidity" in profile:
                self.qmc.bag_humidity = profile["bag_humidity"]   
            else:
                self.qmc.bag_humidity = [0.,0.]
            if "externalprogram" in profile:
                self.ser.externalprogram = d(profile["externalprogram"])
            if "extraname1" in profile:
                self.qmc.extraname1 = [d(n) for n in profile["extraname1"]]
            if "extraname2" in profile:
                self.qmc.extraname2 = [d(n) for n in profile["extraname2"]]
            if "timeindex" in profile:
                self.qmc.timeindex = profile["timeindex"]
            else:
                ###########      OLD PROFILE FORMAT
                if "startend" in profile:
                    startend = [float(fl) for fl in profile["startend"]]  
                else:
                    startend = [0.,0.,0.,0.]
                if "dryend" in profile:
                    dryend = profile["dryend"]
                else:
                    dryend = [0.,0.]
                if "cracks" in profile:
                    varC = [float(fl) for fl in profile["cracks"]]
                else:
                    varC = [0.,0.,0.,0.,0.,0.,0.,0.]
                times = []
                times.append(startend[0])
                times.append(dryend[0])
                times.append(varC[0])
                times.append(varC[2])
                times.append(varC[4])
                times.append(varC[6])
                times.append(startend[2])
                #convert to new profile
                self.qmc.timeindexupdate(times)
            # ensure that timeindex has the proper length
            self.qmc.timeindex = self.qmc.timeindex + [0 for i in range(8-len(self.qmc.timeindex))]
            # reset linecount caches
            aw.qmc.resetlinecountcaches()
            return True
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            # we don't report errors on settingsLoad
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setProfile()",str(ex),exc_tb.tb_lineno)

    # the int n specifies the number of digits
    def float2float(self,f,n=1):
        if n==0:
            return int(round(f))
        else:
            return float(("%." + str(n) + "f")%f)

    # returns data that is computed by Artisan out of raw profile data using some formulas 
    # and displayed to users e.g. as part of the Report to users and stored along profiles to be used by external programs
    # in case a value cannot be computed the corresponding entry is missing in the resulting dict
    def computedProfileInformation(self):
        computedProfile = {}
        try:
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
                computedProfile["CHARGE_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[0]])
                computedProfile["CHARGE_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[0]])
            else:
                start = 0
            ######### TP #########
            # calc TP_time_idx (index of TP; is None if unknown)
            TP_index = self.findTP() # could return -1
            if TP_index > 0 and len(self.qmc.timex) > 0:
                TP_time_idx = TP_index
            else:
                TP_time_idx = None
            if TP_time_idx:
                computedProfile["TP_time"] = self.float2float(self.qmc.timex[TP_time_idx] - start)
                computedProfile["TP_ET"] = self.float2float(self.qmc.temp1[TP_time_idx])
                computedProfile["TP_BT"] = self.float2float(self.qmc.temp2[TP_time_idx])
            ######### DRY #########
            # calc DRY_time_idx (index of TP; is None if unknown)
            if self.qmc.timeindex[1] and aw.qmc.phasesbuttonflag:
                #manual dryend available
                DRY_time_idx = self.qmc.timeindex[1]
            else:
                dryEndIndex = self.findDryEnd(TP_index)  # use TP_index to avoid recomputation of TP if it failed before
                #we use the dryEndIndex respecting the dry phase
                if dryEndIndex > 0 and dryEndIndex < len(self.qmc.timex):
                    DRY_time_idx = dryEndIndex 
                else:
                    DRY_time_idx = None
            if DRY_time_idx:
                computedProfile["DRY_time"] = self.float2float(self.qmc.timex[DRY_time_idx] - start)
                computedProfile["DRY_ET"] = self.float2float(self.qmc.temp1[DRY_time_idx])
                computedProfile["DRY_BT"] = self.float2float(self.qmc.temp2[DRY_time_idx])
            ######### FC #########
            if self.qmc.timeindex[2]:
                computedProfile["FCs_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[2]] - start)
                computedProfile["FCs_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[2]])
                computedProfile["FCs_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[2]])
            if self.qmc.timeindex[3]:
                computedProfile["FCe_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[3]] - start)
                computedProfile["FCe_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[3]])
                computedProfile["FCe_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[3]])
            ######### SC #########
            if self.qmc.timeindex[4]:
                computedProfile["SCs_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[4]] - start)
                computedProfile["SCs_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[4]])
                computedProfile["SCs_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[4]])
            if self.qmc.timeindex[5]:
                computedProfile["SCe_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[5]] - start)
                computedProfile["SCe_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[5]])
                computedProfile["SCe_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[5]])
            ######### DROP #########
            if self.qmc.timeindex[6]:
                computedProfile["DROP_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[6]] - start)
                computedProfile["DROP_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[6]])
                computedProfile["DROP_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[6]])
            ######### COOL #########
            if self.qmc.timeindex[7]:
                computedProfile["COOL_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[7]] - start)
                computedProfile["COOL_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[7]])
                computedProfile["COOL_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[7]])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)        
        ######### Phases #########
        try:
            if self.qmc.statisticstimes[0]:
                computedProfile["totaltime"] = self.qmc.statisticstimes[0]
            if self.qmc.statisticstimes[1]:
                computedProfile["dryphasetime"] = self.qmc.statisticstimes[1]
            if self.qmc.statisticstimes[2]:
                computedProfile["midphasetime"] = self.qmc.statisticstimes[2]
            if self.qmc.statisticstimes[3]:
                computedProfile["finishphasetime"] = self.qmc.statisticstimes[3]
            if self.qmc.statisticstimes[4]:
                computedProfile["coolphasetime"] = self.qmc.statisticstimes[4]
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### Evaluations #########
        try:
            evaluations = self.defect_estimation()
            computedProfile["dryphaseeval"] = u(evaluations[0])
            computedProfile["midphaseeval"] = u(evaluations[1])
            computedProfile["finishphaseeval"] = u(evaluations[2])
            computedProfile["coolphaseeval"] = u(evaluations[3])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### RoR ######### 
        try:
            if TP_time_idx and DRY_time_idx:
                ror = self.RoR(TP_time_idx,DRY_time_idx)
                computedProfile["dry_phase_ror"] = self.float2float(ror[0])
                computedProfile["mid_phase_ror"] = self.float2float(ror[1])
                computedProfile["finish_phase_ror"] = self.float2float(ror[2])
                if "TP_BT" in computedProfile and "TP_time" in computedProfile and "DROP_BT" in computedProfile and "DROP_time" in computedProfile:
                    computedProfile["total_ror"] = self.float2float(((computedProfile["DROP_BT"]-computedProfile["TP_BT"])/(computedProfile["DROP_time"]-computedProfile["TP_time"]))*60.)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        ######### ETBTarea #########
        try:
            ts,tse,tsb = aw.ts(self.qmc.timeindex[0],self.qmc.timeindex[6])
            computedProfile["total_ts"] = self.float2float(ts,0)
            computedProfile["total_ts_ET"] = self.float2float(tse,0)
            computedProfile["total_ts_BT"] = self.float2float(tsb,0)
        except:
            pass
        try:
            ts1,ts1e,ts1b = aw.ts(self.qmc.timeindex[0],DRY_time_idx)
            computedProfile["dry_phase_ts"] = self.float2float(ts1,0)
            computedProfile["dry_phase_ts_ET"] = self.float2float(ts1e,0)
            computedProfile["dry_phase_ts_BT"] = self.float2float(ts1b,0)
        except:
            pass
        try:
            ts2,ts2e,ts2b = aw.ts(DRY_time_idx,self.qmc.timeindex[2])
            computedProfile["mid_phase_ts"] = self.float2float(ts2,0)
            computedProfile["mid_phase_ts_ET"] = self.float2float(ts2e,0)
            computedProfile["mid_phase_ts_BT"] = self.float2float(ts2b,0)
        except:
            pass
        try:
            ts3,ts3e,ts3b = aw.ts(self.qmc.timeindex[2],self.qmc.timeindex[6])
            computedProfile["finish_phase_ts"] = self.float2float(ts3,0)
            computedProfile["finish_phase_ts_ET"] = self.float2float(ts3e,0)
            computedProfile["finish_phase_ts_BT"] = self.float2float(ts3b,0)
        except:
            pass
        ######### Weight, Volume, Loss, Gain, Density #########
        try:
            volumein = self.qmc.volume[0]
            volumeout = self.qmc.volume[1]
            weightin = self.qmc.weight[0]
            weightout = self.qmc.weight[1]
            weight_loss =self.weight_loss(weightin,weightout)
            volume_gain = self.weight_loss(volumeout,volumein)
            if weight_loss:
                computedProfile["weight_loss"] = self.float2float(weight_loss)
            if volume_gain:
                computedProfile["volume_gain"] = self.float2float(volume_gain)
            din = dout = 0
            if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
                if self.qmc.volume[2] == "ml" :
                    volumein = volumein / 1000.0
                    volumeout = volumeout / 1000.0
                if self.qmc.weight[2] != "g":
                    weightin = weightin * 1000.0
                    weightout = weightout * 1000.0
                din = (weightin / volumein) 
                dout = (weightout / volumeout)
            if din > 1:
                computedProfile["green_density"] = self.float2float(din)
            if din > 1:
                computedProfile["roasted_density"] = self.float2float(dout)
                
            if (aw.qmc.density[0] != 0.0 and aw.qmc.density[2] != 0.0):
                setdensity = aw.qmc.density[0] /  aw.qmc.density[2]
                if aw.qmc.density[1] != "g":
                    setdensity = setdensity / 1000.0
                if aw.qmc.density[3] != "l":
                    setdensity = setdensity * 1000.0
                computedProfile["set_density"] = self.float2float(setdensity)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)                
        ######### Humidity #########
        try:
            if aw.qmc.bag_humidity[0] != 0.0:
                computedProfile["bag_humidity"] = self.float2float(aw.qmc.bag_humidity[0])
            if aw.qmc.bag_humidity[1] != 0.0:
                computedProfile["bag_temperature"] = self.float2float(aw.qmc.bag_humidity[1])
            if aw.qmc.ambient_humidity != 0.0:
                computedProfile["ambient_humidity"] = self.float2float(aw.qmc.ambient_humidity)
            if aw.qmc.ambientTemp != 0.0:
                computedProfile["ambient_temperature"] = self.float2float(aw.qmc.ambientTemp)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " computedProfileInformation() %1").arg(str(ex)),exc_tb.tb_lineno)
        return computedProfile

    #used by filesave()
    #wrap values in unicode(.) if and only if those are of type string
    def getProfile(self):
        try:
            profile = {}
            profile["version"] = str(__version__)
            profile["revision"] = str(__revision__)
            profile["mode"] = self.qmc.mode
            profile["timeindex"] = self.qmc.timeindex
            profile["flavors"] = self.qmc.flavors
            profile["flavorlabels"] = [e(fl) for fl in self.qmc.flavorlabels]
            profile["flavorstartangle"] = self.qmc.flavorstartangle
            profile["flavoraspect"] = self.qmc.flavoraspect
            profile["title"] = e(self.qmc.title)
            profile["beans"] = e(self.qmc.beans)
            profile["weight"] = [self.qmc.weight[0],self.qmc.weight[1],e(self.qmc.weight[2])]
            profile["volume"] = self.qmc.volume
            profile["density"] = [self.qmc.density[0],e(self.qmc.density[1]),self.qmc.density[2],e(self.qmc.density[3])]
            profile["roastertype"] = e(self.qmc.roastertype)
            profile["operator"] = e(self.qmc.operator)
            profile["heavyFC"] = self.qmc.heavyFC_flag
            profile["lowFC"] = self.qmc.lowFC_flag
            profile["lightCut"] = self.qmc.lightCut_flag
            profile["darkCut"] = self.qmc.darkCut_flag
            profile["drops"] = self.qmc.drops_flag
            profile["oily"] = self.qmc.oily_flag
            profile["uneven"] = self.qmc.uneven_flag
            profile["tipping"] = self.qmc.tipping_flag
            profile["scorching"] = self.qmc.scorching_flag
            profile["divots"] = self.qmc.divots_flag
            profile["whole_color"] = self.qmc.whole_color
            profile["ground_color"] = self.qmc.ground_color
            profile["color_system"] = self.qmc.color_systems[self.qmc.color_system_idx]
            # write roastdate that respects locale and potential cannot be read in under a different locale (just for compatibility to older versions)
            try:
                profile["roastdate"] = e(self.qmc.roastdate.toString())
            except:
                pass
            # write roast date 
            try:
                profile["roastisodate"] = e(self.qmc.roastdate.toString(Qt.ISODate))
            except:
                pass            
            profile["beansize"] = str(self.qmc.beansize)
            profile["specialevents"] = self.qmc.specialevents
            profile["specialeventstype"] = self.qmc.specialeventstype
            profile["specialeventsvalue"] = self.qmc.specialeventsvalue
            profile["specialeventsStrings"] = [e(ses) for ses in self.qmc.specialeventsStrings]
            profile["etypes"] = [e(et) for et in self.qmc.etypes]
            profile["roastingnotes"] = e(self.qmc.roastingnotes)
            profile["cuppingnotes"] = e(self.qmc.cuppingnotes)
            profile["timex"] = self.qmc.timex
            profile["temp1"] = self.qmc.temp1
            profile["temp2"] = self.qmc.temp2
            profile["phases"] = self.qmc.phases
            profile["zmax"] = self.qmc.zlimit
            profile["zmin"] = self.qmc.zlimit_min
            profile["ymax"] = self.qmc.ylimit
            profile["ymin"] = self.qmc.ylimit_min
            profile["xmin"] = self.qmc.startofx
            profile["xmax"] = self.qmc.endofx
            profile["ambientTemp"] = self.qmc.ambientTemp
            profile["ambient_humidity"] = self.qmc.ambient_humidity
            profile["bag_humidity"] = self.qmc.bag_humidity
            profile["extradevices"] = self.qmc.extradevices
            profile["extraname1"] = [e(n) for n in self.qmc.extraname1]
            profile["extraname2"] = [e(n) for n in self.qmc.extraname2]
            profile["extratimex"] = self.qmc.extratimex
            profile["extratemp1"] = self.qmc.extratemp1
            profile["extratemp2"] = self.qmc.extratemp2      
            profile["extramathexpression1"] = self.qmc.extramathexpression1
            profile["extramathexpression2"] = self.qmc.extramathexpression2  
            profile["extradevicecolor1"] = [e(x) for x in self.qmc.extradevicecolor1]
            profile["extradevicecolor2"] = [e(x) for x in self.qmc.extradevicecolor2]
            profile["extramarkersizes1"] = self.qmc.extramarkersizes1
            profile["extramarkersizes2"] = self.qmc.extramarkersizes2
            profile["extramarkers1"] = [e(x) for x in self.qmc.extramarkers1]
            profile["extramarkers2"] = [e(x) for x in self.qmc.extramarkers2]
            profile["extralinewidths1"] = self.qmc.extralinewidths1
            profile["extralinewidths2"] = self.qmc.extralinewidths2
            profile["extralinestyles1"] = [e(x) for x in self.qmc.extralinestyles1]
            profile["extralinestyles2"] = [e(x) for x in self.qmc.extralinestyles2]
            profile["extradrawstyles1"] = [e(x) for x in self.qmc.extradrawstyles1]
            profile["extradrawstyles2"] = [e(x) for x in self.qmc.extradrawstyles2]
            profile["externalprogram"] = e(self.ser.externalprogram)
            #write only:
            profile["samplinginterval"] = self.qmc.delay / 1000.
            try:
                ds = list(self.qmc.extradevices)
                ds.insert(0,self.qmc.device)
                profile["devices"] = [self.qmc.devices[d-1] for d in ds]
            except Exception as ex:
                pass
            profile["computed"] = self.computedProfileInformation()
            return profile
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " getProfile(): %1").arg(str(ex)),exc_tb.tb_lineno)


    #saves recorded profile in hard drive. Called from file menu 
    def fileSave(self,fname):
        try:
            filename = fname
            if not filename:
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Profile",None, QApplication.UnicodeUTF8)) 
            if filename:
                #write
                self.serialize(filename,self.getProfile())
                self.setCurrentFile(filename)
                self.sendmessage(QApplication.translate("Message","Profile saved", None, QApplication.UnicodeUTF8))
                self.qmc.safesaveflag = False
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " filesave(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def fileExport(self,msg,ext,dumper):
        try:
            filename = self.ArtisanSaveFileDialog(msg=msg,ext=ext)
            if filename:
                dumper(filename)
                self.sendmessage(QApplication.translate("Message","Readings exported", None, QApplication.UnicodeUTF8))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
        except Exception as ex:
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " fileExport(): %1").arg(str(ex)))
            return

    def fileExportCSV(self):
        self.fileExport(QApplication.translate("Message", "Export CSV",None, QApplication.UnicodeUTF8),"*.csv",self.exportCSV)

    def fileExportJSON(self):
        self.fileExport(QApplication.translate("Message", "Export JSON",None, QApplication.UnicodeUTF8),"*.json",self.exportJSON)

    def fileExportRoastLogger(self):
        self.fileExport(QApplication.translate("Message", "Export RoastLogger",None, QApplication.UnicodeUTF8),"*.csv",self.exportRoastLogger)

    def fileImport(self,msg,loader):
        try:
            filename = self.ArtisanOpenFileDialog(msg=msg)
            if filename:
                loader(filename)
                self.sendmessage(QApplication.translate("Message","Readings imported", None, QApplication.UnicodeUTF8))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None, QApplication.UnicodeUTF8))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " fileImport(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def fileImportCSV(self):
        self.fileImport(QApplication.translate("Message", "Import CSV",None, QApplication.UnicodeUTF8),self.importCSV)

    def fileImportJSON(self):
        self.fileImport(QApplication.translate("Message", "Import JSON",None, QApplication.UnicodeUTF8),self.importJSON)

    def fileImportRoastLogger(self):
        self.fileImport(QApplication.translate("Message", "Import RoastLogger",None, QApplication.UnicodeUTF8),self.importRoastLogger)

    #loads the settings at the start of application. See the oppposite closeEvent()
    def settingsLoad(self):
        try: 
            settings = QSettings()
            if settings.contains("resetqsettings"):
                self.resetqsettings = settings.value("resetqsettings",self.resetqsettings).toInt()[0]
                if self.resetqsettings:
                    self.resetqsettings = 0
                    self.qmc.redraw()
                    return  #don't load any more settings. They could be bad (corrupted). Stop here.
            #restore geometry
            self.restoreGeometry(settings.value("Geometry").toByteArray())
            #restore mode
            old_mode = self.qmc.mode
            self.qmc.mode = str(settings.value("Mode",self.qmc.mode).toString())
            #convert modes only if needed comparing the new uploaded mode to the old one.
            #otherwise it would incorrectly convert the uploaded phases
            if self.qmc.mode == "F" and old_mode == "C":
                self.qmc.fahrenheitMode()
            if self.qmc.mode == "C" and old_mode == "F":
                self.qmc.celsiusMode()
            #restore device
            settings.beginGroup("Device")
            self.qmc.device = settings.value("id",self.qmc.device).toInt()[0]
            # activate CONTROL BUTTON
            if self.qmc.device == 0:
                self.button_10.setVisible(True) #CONTROL BUTTON
                self.label6.setVisible(True)    #PID SV LABEL
                self.lcd6.setVisible(True)      #PID SV LCD
                self.label7.setVisible(True)    #PID DUTYCYLE LABEL
                self.lcd7.setVisible(True)      #PID DUTYCYCLE LCD
# Control button for Arduino does not have any useful function yet, so hide it for now                
            elif self.qmc.device == 26: # or self.qmc.device == 19:   #DEVICE 26 = DTA; DEVICE 19 = ARDUINOTC4
                self.button_10.setVisible(True) #CONTROL BUTTON
            if settings.contains("controlETpid"):
                self.ser.controlETpid = [x.toInt()[0] for x in settings.value("controlETpid").toList()]
            if settings.contains("readBTpid"):
                self.ser.readBTpid = [x.toInt()[0] for x in settings.value("readBTpid").toList()]
            if settings.contains("arduinoETChannel"):
                self.ser.arduinoETChannel = str(settings.value("arduinoETChannel").toString())
            if settings.contains("arduinoBTChannel"):
                self.ser.arduinoBTChannel = str(settings.value("arduinoBTChannel").toString())
            if settings.contains("arduino56active"):
                self.qmc.arduino56active = settings.value("arduino56active").toBool()
            settings.endGroup()
            #restore phases
            if settings.contains("Phases"):
                self.qmc.phases = [x.toInt()[0] for x in settings.value("Phases").toList()]
            if settings.contains("phasesbuttonflag"):
                self.qmc.phasesbuttonflag = settings.value("phasesbuttonflag",self.qmc.phasesbuttonflag).toBool()
            if settings.contains("watermarks"):
                self.qmc.watermarksflag = settings.value("watermarks",self.qmc.watermarksflag).toBool()
            #restore Events settings
            settings.beginGroup("events")
            self.eventsbuttonflag = settings.value("eventsbuttonflag",int(self.eventsbuttonflag)).toInt()[0]
            self.minieventsflag = settings.value("minieventsflag",int(self.minieventsflag)).toInt()[0]
            self.qmc.eventsGraphflag = settings.value("eventsGraphflag",int(self.qmc.eventsGraphflag)).toInt()[0]
            if settings.contains("etypes"):
                self.qmc.etypes = settings.value("etypes",self.qmc.etypes).toStringList()
            if settings.contains("eventsshowflag"):
                self.qmc.eventsshowflag = settings.value("eventsshowflag",int(self.qmc.eventsshowflag)).toInt()[0]
            if settings.contains("autoChargeDrop"):
                self.qmc.autoChargeDropFlag = settings.value("autoChargeDrop",self.qmc.autoChargeDropFlag).toBool()
            if settings.contains("EvalueColor"):
                self.qmc.EvalueColor = list(map(str,list(settings.value("EvalueColor",self.qmc.EvalueColor).toStringList())))
                self.qmc.EvalueMarker = list(map(str,list(settings.value("EvalueMarker",self.qmc.EvalueMarker).toStringList())))
            if settings.contains("Evaluelinethickness"):
                self.qmc.Evaluelinethickness = [x.toInt()[0] for x in settings.value("Evaluelinethickness").toList()]
                self.qmc.Evaluealpha = [x.toDouble()[0] for x in settings.value("Evaluealpha").toList()]
            if settings.contains("EvalueMarkerSize"):
                self.qmc.EvalueMarkerSize = [x.toInt()[0] for x in settings.value("EvalueMarkerSize").toList()]
            settings.endGroup()
            #restore statistics
            if settings.contains("Statistics"):
                self.qmc.statisticsflags = [x.toInt()[0] for x in settings.value("Statistics").toList()]
                # extend statisticsflag len to the full size (for backward compatibility)
                for i in range(6 - len(self.qmc.statisticsflags)):
                    self.qmc.statisticsflags.append(0)
            if settings.contains("StatisticsConds"):
                tmpconds = [x.toInt()[0] for x in settings.value("StatisticsConds").toList()]
                for i in range(len(tmpconds),len(self.qmc.statisticsconditions)):
                    tmpconds.append(self.qmc.statisticsconditions[i])
                self.qmc.statisticsconditions = tmpconds
            #restore ambient temperature source
            if settings.contains("AmbientTempSource"):
                aw.qmc.ambientTempSource = settings.value("AmbientTempSource",int()).toInt()[0]
            #restore delay
            self.qmc.delay = settings.value("Delay",int(self.qmc.delay)).toInt()[0]
            if not self.qmc.delay:
                self.qmc.delay = 3000
            #restore colors
            for (k, v) in list(settings.value("Colors").toMap().items()):
                self.qmc.palette[str(k)] = str(v.toString())
            if self.qmc.palette["et"]:
                self.setLabelColor(aw.label2,QColor(self.qmc.palette["et"]))
            if self.qmc.palette["bt"]:    
                self.setLabelColor(aw.label3,QColor(self.qmc.palette["bt"]))
            if self.qmc.palette["deltaet"]:    
                self.setLabelColor(aw.label4,QColor(self.qmc.palette["deltaet"]))
            if self.qmc.palette["deltabt"]:    
                self.setLabelColor(aw.label5,QColor(self.qmc.palette["deltabt"]))
            if settings.contains("ETBColor"):
                self.qmc.backgroundmetcolor = str(settings.value("ETBColor",self.qmc.backgroundmetcolor).toString())
            if settings.contains("BTBColor"):
                self.qmc.backgroundbtcolor = str(settings.value("BTBColor",self.qmc.backgroundbtcolor).toString())
            if settings.contains("ETBdeltaColor"):
                self.qmc.backgrounddeltaetcolor = str(settings.value("ETBdeltaColor",self.qmc.backgrounddeltaetcolor).toString())
            if settings.contains("BTBdeltaColor"):
                self.qmc.backgrounddeltabtcolor = str(settings.value("BTBdeltaColor",self.qmc.backgrounddeltabtcolor).toString())
            if settings.contains("LCDColors"):
                for (k, v) in list(settings.value("LCDColors").toMap().items()):
                    self.lcdpaletteB[str(k)] = str(v.toString())
            if settings.contains("LEDColors"):
                for (k, v) in list(settings.value("LEDColors").toMap().items()):
                    self.lcdpaletteF[str(k)] = str(v.toString())
            #restore colors
            self.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["timer"],self.lcdpaletteB["timer"]))
            self.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["et"],self.lcdpaletteB["et"]))
            self.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["bt"],self.lcdpaletteB["bt"]))
            self.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltaet"],self.lcdpaletteB["deltaet"]))
            self.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["deltabt"],self.lcdpaletteB["deltabt"]))
            self.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            #restore flavors
            self.qmc.flavorlabels = settings.value("Flavors",self.qmc.flavorlabels).toStringList()
            self.qmc.flavors = [5.]*len(self.qmc.flavorlabels)
            if settings.contains("flavorstartangle"):
                self.qmc.flavorstartangle = settings.value("flavorstartangle",int(self.qmc.flavorstartangle)).toInt()[0]
            #restore roast color system
            if settings.contains("colorsystem"):
                self.qmc.color_system_idx = settings.value("colorsystem",int(self.qmc.color_system_idx)).toInt()[0]
            #restore serial port
            settings.beginGroup("SerialPort")
            self.ser.comport = str(settings.value("comport",self.ser.comport).toString())
            self.ser.baudrate = settings.value("baudrate",int(self.ser.baudrate)).toInt()[0]
            self.ser.bytesize = settings.value("bytesize",self.ser.bytesize).toInt()[0]
            self.ser.stopbits = settings.value("stopbits",self.ser.stopbits).toInt()[0]
            self.ser.parity = str(settings.value("parity",self.ser.parity).toString())
            self.ser.timeout = settings.value("timeout",self.ser.timeout).toInt()[0]
            settings.endGroup()
            #restore modbus port
            settings.beginGroup("Modbus")
            self.modbus.comport = str(settings.value("comport",self.modbus.comport).toString())
            self.modbus.baudrate = settings.value("baudrate",int(self.modbus.baudrate)).toInt()[0]
            self.modbus.bytesize = settings.value("bytesize",self.modbus.bytesize).toInt()[0]
            self.modbus.stopbits = settings.value("stopbits",self.modbus.stopbits).toInt()[0]
            self.modbus.parity = str(settings.value("parity",self.modbus.parity).toString())
            self.modbus.timeout = settings.value("timeout",self.modbus.timeout).toInt()[0]
            self.modbus.input1slave = settings.value("input1slave",self.modbus.input1slave).toInt()[0]
            self.modbus.input1register = settings.value("input1register",self.modbus.input1register).toInt()[0]
            self.modbus.input2slave = settings.value("input2slave",self.modbus.input2slave).toInt()[0]
            self.modbus.input2register = settings.value("input2register",self.modbus.input2register).toInt()[0]
            self.modbus.input3slave = settings.value("input3slave",self.modbus.input3slave).toInt()[0]
            self.modbus.input3register = settings.value("input3register",self.modbus.input3register).toInt()[0]
            self.modbus.input4slave = settings.value("input4slave",self.modbus.input4slave).toInt()[0]
            self.modbus.input4register = settings.value("input4register",self.modbus.input4register).toInt()[0]
            if settings.contains("input1float"):
                self.modbus.input1float = settings.value("input1float",self.modbus.input1float).toBool()
                self.modbus.input1code = settings.value("input1code",self.modbus.input1code).toInt()[0]
                self.modbus.input2float = settings.value("input2float",self.modbus.input2float).toBool()
                self.modbus.input2code = settings.value("input2code",self.modbus.input2code).toInt()[0]
                self.modbus.input3float = settings.value("input3float",self.modbus.input3float).toBool()
                self.modbus.input3code = settings.value("input3code",self.modbus.input3code).toInt()[0]
                self.modbus.input4float = settings.value("input4float",self.modbus.input4float).toBool()
                self.modbus.input4code = settings.value("input4code",self.modbus.input4code).toInt()[0]
                self.modbus.littleEndianFloats = settings.value("littleEndianFloats",self.modbus.littleEndianFloats).toBool()                
                # switch to little-endian if needed (HACK!!)
                if self.modbus.littleEndianFloats:
                    try:
                        minimalmodbus._bytestringToFloat = littleEndianBytestringToFloat
                    except:
                        pass
            settings.endGroup()
            #restore scale port
            settings.beginGroup("Scale")
#            self.scale.device = str(settings.value("device",self.scale.device).toString())
            self.scale.device_id = settings.value("device_id",self.scale.device_id).toInt()[0]
            self.scale.comport = str(settings.value("comport",self.scale.comport).toString())
            self.scale.baudrate = settings.value("baudrate",int(self.scale.baudrate)).toInt()[0]
            self.scale.bytesize = settings.value("bytesize",self.scale.bytesize).toInt()[0]
            self.scale.stopbits = settings.value("stopbits",self.scale.stopbits).toInt()[0]
            self.scale.parity = str(settings.value("parity",self.scale.parity).toString())
            self.scale.timeout = settings.value("timeout",self.scale.timeout).toInt()[0]
            settings.endGroup()
            #restore alarms
            settings.beginGroup("Alarms")
            if settings.contains("alarmtime"):
                self.qmc.alarmflag = [x.toInt()[0] for x in settings.value("alarmflag").toList()]
                if settings.contains("alarmguard"):
                    self.qmc.alarmguard = [x.toInt()[0] for x in settings.value("alarmguard").toList()]
                else:
                    self.qmc.alarmguard = [-1]*len(self.qmc.alarmflag)
                self.qmc.alarmtime = [x.toInt()[0] for x in settings.value("alarmtime").toList()]  
                if settings.contains("alarmoffset"):
                    self.qmc.alarmoffset = [max(0,x.toInt()[0]) for x in settings.value("alarmoffset").toList()]
                else:
                    self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmcond"):
                    self.qmc.alarmcond = [x.toInt()[0] for x in settings.value("alarmcond").toList()]
                else:
                    self.qmc.alarmguard = [1]*len(self.qmc.alarmflag)
                self.qmc.alarmsource = [x.toInt()[0] for x in settings.value("alarmsource").toList()]
                self.qmc.alarmtemperature = [x.toInt()[0] for x in settings.value("alarmtemperature").toList()]
                self.qmc.alarmaction = [x.toInt()[0] for x in settings.value("alarmaction").toList()]
                self.qmc.alarmstrings = list(settings.value("alarmstrings",self.qmc.alarmstrings).toStringList())
                self.qmc.alarmstate = [0]*len(self.qmc.alarmflag)
            settings.endGroup()
            #restore pid settings
            settings.beginGroup("PXR")
            for key in list(self.fujipid.PXR.keys()):
                if type(self.fujipid.PXR[key][0]) == type(float()):
                    self.fujipid.PXR[key][0] = settings.value(key,self.fujipid.PXR[key]).toDouble()[0]
                elif type(self.fujipid.PXR[key][0]) == type(int()):
                    self.fujipid.PXR[key][0] = settings.value(key,self.fujipid.PXR[key]).toInt()[0]
            settings.endGroup()
            settings.beginGroup("PXG4")
            for key in list(self.fujipid.PXG4.keys()):
                if type(self.fujipid.PXG4[key][0]) == type(float()):
                    self.fujipid.PXG4[key][0] = settings.value(key,self.fujipid.PXG4[key][0]).toDouble()[0]
                elif type(self.fujipid.PXG4[key][0]) == type(int()):
                    self.fujipid.PXG4[key][0] = settings.value(key,self.fujipid.PXG4[key][0]).toInt()[0]
            settings.endGroup()
            if settings.contains("deltaDTA"):
                settings.beginGroup("deltaDTA")
                for key in list(self.dtapid.dtamem.keys()):
                    if type(self.dtapid.dtamem[key][0]) == type(float()):
                        self.dtapid.dtamem[key][0] = settings.value(key,self.dtapid.dtamem[key][0]).toDouble()[0]
                    elif type(self.dtapid.dtamem[key][0]) == type(int()):
                        self.dtapid.dtamem[key][0] = settings.value(key,self.dtapid.dtamem[key][0]).toInt()[0]
                settings.endGroup()
            if settings.contains("filterDropOuts"):
                self.qmc.filterDropOuts = settings.value("filterDropOuts",self.qmc.filterDropOuts).toBool()
            if settings.contains("dropSpikes"):
                self.qmc.dropSpikes = settings.value("dropSpikes",self.qmc.dropSpikes).toBool()
            if settings.contains("minmaxLimits"):
                self.qmc.minmaxLimits = settings.value("minmaxLimits",self.qmc.minmaxLimits).toBool()
                self.qmc.filterDropOut_tmin = settings.value("minLimit",self.qmc.filterDropOut_tmin).toInt()[0]
                self.qmc.filterDropOut_tmax = settings.value("maxLimit",self.qmc.filterDropOut_tmax).toInt()[0]
            settings.beginGroup("RoC")
            self.qmc.DeltaETflag = settings.value("DeltaET",self.qmc.DeltaETflag).toBool()
            self.qmc.DeltaBTflag = settings.value("DeltaBT",self.qmc.DeltaBTflag).toBool()
            self.qmc.deltafilter = settings.value("deltafilter",self.qmc.deltafilter).toInt()[0]
            if settings.contains("DeltaETlcd"):
                self.qmc.DeltaETlcdflag = settings.value("DeltaETlcd",self.qmc.DeltaETlcdflag).toBool()
            if settings.contains("DeltaBTlcd"):
                self.qmc.DeltaBTlcdflag = settings.value("DeltaBTlcd",self.qmc.DeltaBTlcdflag).toBool()
            settings.endGroup()
            if settings.contains("curvefilter"):
                self.qmc.curvefilter = settings.value("curvefilter",self.qmc.curvefilter).toInt()[0]
            if settings.contains("ETcurve"):
                self.qmc.ETcurve = settings.value("ETcurve",self.qmc.ETcurve).toBool()
            if settings.contains("BTcurve"):
                self.qmc.BTcurve = settings.value("BTcurve",self.qmc.BTcurve).toBool()
            if settings.contains("ETlcd"):
                self.qmc.ETlcd = settings.value("ETlcd",self.qmc.ETlcd).toBool()
            if settings.contains("BTlcd"):
                self.qmc.BTlcd = settings.value("BTlcd",self.qmc.BTlcd).toBool()
            settings.beginGroup("DefaultButtons")
            if settings.contains("buttonvisibility"):
                self.qmc.buttonvisibility = [x.toBool() for x in settings.value("buttonvisibility").toList()]
            if settings.contains("buttonactions"):
                self.qmc.buttonactions = [x.toInt()[0] for x in settings.value("buttonactions").toList()]
            if settings.contains("buttonactionstrings"):
                self.qmc.buttonactionstrings = list(map(str,list(settings.value("buttonactionstrings",self.qmc.buttonactionstrings).toStringList())))
            settings.endGroup()
            settings.beginGroup("HUD")
            self.qmc.projectFlag = settings.value("Projection",self.qmc.projectFlag).toBool()
            self.qmc.projectionmode = settings.value("ProjectionMode",self.qmc.projectionmode).toInt()[0]
            self.qmc.ETtarget = settings.value("ETtarget",self.qmc.ETtarget).toInt()[0]
            self.qmc.BTtarget = settings.value("BTtarget",self.qmc.BTtarget).toInt()[0]
            if settings.contains("ET2target"):
                self.qmc.ET2target = settings.value("ET2target",self.qmc.ET2target).toInt()[0]
            if settings.contains("BT2target"):
                self.qmc.BT2target = settings.value("BT2target",self.qmc.BT2target).toInt()[0]
            self.HUDfunction = settings.value("Mode",self.HUDfunction).toInt()[0]
            if settings.contains("hudETpid"):
                self.qmc.hudETpid = [x.toInt()[0] for x in settings.value("hudETpid").toList()]
            settings.endGroup()
            settings.beginGroup("Sound")
            self.soundflag = settings.value("Beep",self.soundflag).toInt()[0]
            settings.endGroup()
            #saves max-min temp limits of graph
            settings.beginGroup("Axis")
            self.qmc.startofx = settings.value("xmin",self.qmc.startofx).toInt()[0]
            self.qmc.endofx = settings.value("xmax",self.qmc.endofx).toInt()[0]
            #fixes Windows OS sometimes saving endofx as 0 
            if self.qmc.endofx < 60 or self.qmc.endofx > 1800:
                self.qmc.endofx = 60
            self.qmc.ylimit = min(settings.value("ymax",self.qmc.ylimit).toInt()[0],850)
            self.qmc.ylimit_min = max(min(settings.value("ymin",self.qmc.ylimit_min).toInt()[0],self.qmc.ylimit),-150)
            self.qmc.zlimit = min(settings.value("zmax",self.qmc.zlimit).toInt()[0],500)
            self.qmc.zlimit_min = max(min(settings.value("zmin",self.qmc.zlimit_min).toInt()[0],self.qmc.zlimit),-200)
            if settings.contains("resetmaxtime"):
                self.qmc.resetmaxtime = settings.value("resetmaxtime",self.qmc.resetmaxtime).toInt()[0]
            if settings.contains("lockmax"):
                self.qmc.fixmaxtime = settings.value("lockmax",self.qmc.fixmaxtime).toBool()
            self.qmc.legendloc = settings.value("legendloc",self.qmc.legendloc).toInt()[0]
            settings.endGroup()
            settings.beginGroup("RoastProperties")
            self.qmc.operator = u(settings.value("operator",self.qmc.operator).toString())
            self.qmc.roastertype = u(settings.value("roastertype",self.qmc.roastertype).toString())
            self.qmc.density[2] = settings.value("densitySampleVolume",self.qmc.density[2]).toInt()[0]
            self.qmc.density[3] = str(settings.value("densitySampleVolumeUnit",self.qmc.density[3]).toString())
            if settings.contains("beansize"):
                self.qmc.beansize = settings.value("beansize",self.qmc.beansize).toDouble()[0]
            settings.endGroup()
            self.userprofilepath = u(settings.value("profilepath",self.userprofilepath).toString())
            settings.beginGroup("ExtraDev")
            if settings.contains("extradevices"):
                self.qmc.extradevices = [x.toInt()[0] for x in settings.value("extradevices").toList()]
                self.qmc.extraname1 = list(map(str,list(settings.value("extraname1",self.qmc.extraname1).toStringList())))
                self.qmc.extraname2 = list(map(str,list(settings.value("extraname2",self.qmc.extraname2).toStringList())))
                self.qmc.extramathexpression1 = list(map(str,list(settings.value("extramathexpression1",self.qmc.extramathexpression1).toStringList())))
                self.qmc.extramathexpression2 = list(map(str,list(settings.value("extramathexpression2",self.qmc.extramathexpression2).toStringList())))
                self.qmc.extradevicecolor1 = list(map(str,list(settings.value("extradevicecolor1",self.qmc.extradevicecolor1).toStringList())))
                self.qmc.extradevicecolor2 = list(map(str,list(settings.value("extradevicecolor2",self.qmc.extradevicecolor2).toStringList())))
                if settings.contains("extraLCDvisibility1"):
                    self.extraLCDvisibility1 = [x.toBool() for x in settings.value("extraLCDvisibility1").toList()]
                if settings.contains("extraLCDvisibility2"):
                    self.extraLCDvisibility2 = [x.toBool() for x in settings.value("extraLCDvisibility2").toList()]
                if settings.contains("extraCurveVisibility1"):
                    self.extraCurveVisibility1 = [x.toBool() for x in settings.value("extraCurveVisibility1").toList()]
                if settings.contains("extraCurveVisibility2"):
                    self.extraCurveVisibility2 = [x.toBool() for x in settings.value("extraCurveVisibility2").toList()]
            #create empty containers
            settings.endGroup()
            #restore curve styles
            settings.beginGroup("CurveStyles")
            if settings.contains("BTlinestyle"):
                self.qmc.BTlinestyle = str(settings.value("BTlinestyle",self.qmc.BTlinestyle).toString())
                self.qmc.BTdrawstyle = str(settings.value("BTdrawstyle",self.qmc.BTdrawstyle).toString())
                self.qmc.BTlinewidth = settings.value("BTlinewidth",self.qmc.BTlinewidth).toInt()[0]
                self.qmc.BTmarker = str(settings.value("BTmarker",self.qmc.BTmarker).toString())
                self.qmc.BTmarkersize = settings.value("BTmarkersize",self.qmc.BTmarkersize).toInt()[0]
                self.qmc.ETlinestyle = str(settings.value("ETlinestyle",self.qmc.ETlinestyle).toString())
                self.qmc.ETdrawstyle = str(settings.value("ETdrawstyle",self.qmc.ETdrawstyle).toString())
                self.qmc.ETlinewidth = settings.value("ETlinewidth",self.qmc.ETlinewidth).toInt()[0]
                self.qmc.ETmarker = str(settings.value("ETmarker",self.qmc.ETmarker).toString())
                self.qmc.ETmarkersize = settings.value("ETmarkersize",self.qmc.ETmarkersize).toInt()[0]
                self.qmc.BTdeltalinestyle = str(settings.value("BTdeltalinestyle",self.qmc.BTdeltalinestyle).toString())
                self.qmc.BTdeltadrawstyle = str(settings.value("BTdeltadrawstyle",self.qmc.BTdeltadrawstyle).toString())
                self.qmc.BTdeltalinewidth = settings.value("BTdeltalinewidth",self.qmc.BTdeltalinewidth).toInt()[0]
                self.qmc.BTdeltamarker = str(settings.value("BTdeltamarker",self.qmc.BTdeltamarker).toString())
                self.qmc.BTdeltamarkersize = settings.value("BTdeltamarkersize",self.qmc.BTdeltamarkersize).toInt()[0]
                self.qmc.ETdeltalinestyle = str(settings.value("ETdeltalinestyle",self.qmc.ETdeltalinestyle).toString())
                self.qmc.ETdeltadrawstyle = str(settings.value("ETdeltadrawstyle",self.qmc.ETdeltadrawstyle).toString())
                self.qmc.ETdeltalinewidth = settings.value("ETdeltalinewidth",self.qmc.ETdeltalinewidth).toInt()[0]
                self.qmc.ETdeltamarker = str(settings.value("ETdeltamarker",self.qmc.ETdeltamarker).toString())
                self.qmc.ETdeltamarkersize = settings.value("ETdeltamarkersize",self.qmc.ETdeltamarkersize).toInt()[0]
                self.qmc.BTbacklinestyle = str(settings.value("BTbacklinestyle",self.qmc.BTbacklinestyle).toString())
                self.qmc.BTbackdrawstyle = str(settings.value("BTbackdrawstyle",self.qmc.BTbackdrawstyle).toString())
                self.qmc.BTbacklinewidth = settings.value("BTbacklinewidth",self.qmc.BTbacklinewidth).toInt()[0]
                self.qmc.BTbackmarker = str(settings.value("BTbackmarker",self.qmc.BTbackmarker).toString())
                self.qmc.BTbackmarkersize = settings.value("BTbackmarkersize",self.qmc.BTbackmarkersize).toInt()[0]
                self.qmc.ETbacklinestyle = str(settings.value("ETbacklinestyle",self.qmc.ETbacklinestyle).toString())
                self.qmc.ETbackdrawstyle = str(settings.value("ETbackdrawstyle",self.qmc.ETbackdrawstyle).toString())
                self.qmc.ETbacklinewidth = settings.value("ETbacklinewidth",self.qmc.ETbacklinewidth).toInt()[0]
                self.qmc.ETbackmarker = str(settings.value("ETbackmarker",self.qmc.ETbackmarker).toString())
                self.qmc.ETbackmarkersize = settings.value("ETbackmarkersize",self.qmc.ETbackmarkersize).toInt()[0]
                self.qmc.extralinestyles1 = list(map(str,list(settings.value("extralinestyles1",self.qmc.extralinestyles1).toStringList())))
                self.qmc.extralinestyles2 = list(map(str,list(settings.value("extralinestyles2",self.qmc.extralinestyles2).toStringList())))
                self.qmc.extradrawstyles1 = list(map(str,list(settings.value("extradrawstyles1",self.qmc.extradrawstyles1).toStringList())))
                self.qmc.extradrawstyles2 = list(map(str,list(settings.value("extradrawstyles2",self.qmc.extradrawstyles2).toStringList())))
                self.qmc.extralinewidths1 = [x.toInt()[0] for x in settings.value("extralinewidths1").toList()]
                self.qmc.extralinewidths2 = [x.toInt()[0] for x in settings.value("extralinewidths2").toList()]
                self.qmc.extramarkers1 = list(map(str,list(settings.value("extramarkers1",self.qmc.extramarkers1).toStringList())))
                self.qmc.extramarkers2 = list(map(str,list(settings.value("extramarkers2",self.qmc.extramarkers2).toStringList())))
                self.qmc.extramarkersizes1 = [x.toInt()[0] for x in settings.value("extramarkersizes1").toList()]
                self.qmc.extramarkersizes2 = [x.toInt()[0] for x in settings.value("extramarkersizes2").toList()]
                self.qmc.BTBdeltalinestyle = str(settings.value("BTBdeltalinestyle",self.qmc.BTBdeltalinestyle).toString())
                self.qmc.BTBdeltadrawstyle = str(settings.value("BTBdeltadrawstyle",self.qmc.BTBdeltadrawstyle).toString())
                self.qmc.BTBdeltalinewidth = settings.value("BTBdeltalinewidth",self.qmc.BTBdeltalinewidth).toInt()[0]
                self.qmc.BTBdeltamarker = str(settings.value("BTBdeltamarker",self.qmc.BTBdeltamarker).toString())
                self.qmc.BTBdeltamarkersize = settings.value("BTBdeltamarkersize",self.qmc.BTBdeltamarkersize).toInt()[0]
                self.qmc.ETBdeltalinestyle = str(settings.value("ETBdeltalinestyle",self.qmc.ETBdeltalinestyle).toString())
                self.qmc.ETBdeltadrawstyle = str(settings.value("ETBdeltadrawstyle",self.qmc.ETBdeltadrawstyle).toString())
                self.qmc.ETBdeltalinewidth = settings.value("ETBdeltalinewidth",self.qmc.ETBdeltalinewidth).toInt()[0]
                self.qmc.ETBdeltamarker = str(settings.value("ETBdeltamarker",self.qmc.ETBdeltamarker).toString())
                self.qmc.ETBdeltamarkersize = settings.value("ETBdeltamarkersize",self.qmc.ETBdeltamarkersize).toInt()[0]
            settings.endGroup()
            ndevices = len(self.qmc.extradevices)
            if ndevices != len(self.qmc.extralinestyles1) or \
               ndevices != len(self.qmc.extralinestyles2) or \
               ndevices != len(self.qmc.extradrawstyles1) or \
               ndevices != len(self.qmc.extradrawstyles2) or \
               ndevices != len(self.qmc.extralinewidths1) or \
               ndevices != len(self.qmc.extralinewidths2) or \
               ndevices != len(self.qmc.extramarkers1) or \
               ndevices != len(self.qmc.extramarkers2) or \
               ndevices != len(self.qmc.extramarkersizes1) or \
               ndevices != len(self.qmc.extramarkersizes2):
                self.qmc.extralinestyles1 = self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*ndevices
                self.qmc.extradrawstyles1 = self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*ndevices
                self.qmc.extralinewidths1 = self.qmc.extralinewidths2 = [self.qmc.linewidth_default]*ndevices
                self.qmc.extramarkers1 = self.qmc.extramarkers2 = [self.qmc.marker_default]*ndevices
                self.qmc.extramarkersizes1 = self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*ndevices
            for i in range(len(self.qmc.extradevices)):
                self.qmc.extratemp1.append([])
                self.qmc.extratemp2.append([])
                self.qmc.extratimex.append([])
                self.qmc.extrastemp1.append([])
                self.qmc.extrastemp2.append([])
            #extra LCDs
            self.updateLCDproperties()
            # set extraLCD colors
            for i in range(len(self.qmc.extradevices)):
                self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
                self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
            # Extra com ports
            settings.beginGroup("ExtraComm")
            if settings.contains("extracomport"):
                self.extracomport = list(map(str,list(settings.value("extracomport",self.extracomport).toStringList())))
                self.extrabaudrate = [x.toInt()[0] for x in settings.value("extrabaudrate").toList()]
                self.extrabytesize = [x.toInt()[0] for x in settings.value("extrabytesize").toList()]
                self.extraparity = list(map(str,list(settings.value("extraparity",self.extraparity).toStringList())))
                self.extrastopbits = [x.toInt()[0] for x in settings.value("extrastopbits").toList()]
                self.extratimeout = [x.toInt()[0] for x in settings.value("extratimeout").toList()]
                lenextraports = len(self.extracomport)
                self.extraser = [None]*lenextraports
                #populate aw.extraser
                for i in range(lenextraports):
                    self.extraser[i] = serialport()
                    self.extraser[i].comport = str(self.extracomport[i])
                    self.extraser[i].baudrate = self.extrabaudrate[i]
                    self.extraser[i].bytesize = self.extrabytesize[i]
                    self.extraser[i].parity = str(self.extraparity[i])
                    self.extraser[i].stopbits = self.extrastopbits[i]
                    self.extraser[i].timeout = self.extratimeout[i]
            settings.endGroup()
            if settings.contains("BTfunction"):
                self.qmc.BTfunction = str(settings.value("BTfunction",self.qmc.BTfunction).toString())
                self.qmc.ETfunction = str(settings.value("ETfunction",self.qmc.ETfunction).toString())
            if settings.contains("plotcurves"):
                self.qmc.plotcurves = list(settings.value("plotcurves",self.qmc.plotcurves).toStringList())
                self.qmc.plotcurvecolor = list(settings.value("plotcurvecolor",self.qmc.plotcurvecolor).toStringList())
                for i in range(len(self.qmc.plotcurves)):
                    self.qmc.plotcurves[i] = str(self.qmc.plotcurves[i])
                    self.qmc.plotcurvecolor[i] = str(self.qmc.plotcurvecolor[i])
            settings.beginGroup("grid")
            if settings.contains("xgrid"):
                self.qmc.xgrid = settings.value("xgrid",self.qmc.xgrid).toInt()[0]
                self.qmc.ygrid = settings.value("ygrid",self.qmc.ygrid).toInt()[0]
                self.qmc.zgrid = settings.value("zgrid",self.qmc.zgrid).toInt()[0]
                self.qmc.gridthickness = settings.value("gridthickness",self.qmc.gridthickness).toInt()[0]
                self.qmc.xrotation = settings.value("xrotation",self.qmc.xrotation).toInt()[0]
                self.qmc.gridlinestyle = settings.value("gridlinestyle",self.qmc.gridlinestyle).toInt()[0]
                self.qmc.gridalpha = settings.value("gridalpha",self.qmc.gridalpha).toDouble()[0]
            settings.endGroup()
            if settings.contains("roastpropertiesflag"):
                self.qmc.roastpropertiesflag = settings.value("roastpropertiesflag",self.qmc.roastpropertiesflag).toInt()[0]
            if settings.contains("customflavorlabels"):
                self.qmc.customflavorlabels = list(map(u,list(settings.value("customflavorlabels",self.qmc.customflavorlabels).toStringList())))
            #restore sliders
            settings.beginGroup("Sliders")
            if settings.contains("slidervisibilities"):
                self.eventslidervisibilities = [x.toInt()[0] for x in settings.value("slidervisibilities").toList()]
                self.eventslideractions = [x.toInt()[0] for x in settings.value("slideractions").toList()]
                self.eventslidercommands = list(map(str,list(settings.value("slidercommands",self.eventslidercommands).toStringList())))
                self.eventslideroffsets = [x.toInt()[0] for x in settings.value("slideroffsets").toList()]
                self.eventsliderfactors = [x.toDouble()[0] for x in settings.value("sliderfactors").toList()]
            settings.endGroup()
            self.updateSlidersProperties()
            #restore background profile settings
            settings.beginGroup("background")
            if settings.contains("backgrounddetails"):
                aw.qmc.backgroundDetails = settings.value("backgrounddetails",aw.qmc.backgroundDetails).toBool()
                aw.qmc.backgroundeventsflag = settings.value("backgroundevents",aw.qmc.backgroundeventsflag).toBool()
                aw.qmc.DeltaETBflag = settings.value("DeltaETB",aw.qmc.DeltaETBflag).toBool()
                aw.qmc.DeltaBTBflag = settings.value("DeltaBTB",aw.qmc.DeltaBTBflag).toBool()
            settings.endGroup()
            #restore buttons
            settings.beginGroup("ExtraEventButtons")
            if settings.contains("extraeventsactions"):
                if settings.contains("buttonlistmaxlen"):
                    self.buttonlistmaxlen = settings.value("buttonlistmaxlen",self.buttonlistmaxlen).toInt()[0]
                if settings.contains("extraeventsbuttonsflag"):
                    self.extraeventsbuttonsflag = settings.value("extraeventsbuttonsflag",self.extraeventsbuttonsflag).toInt()[0]
                self.extraeventstypes = [x.toInt()[0] for x in settings.value("extraeventstypes").toList()]
                self.extraeventsvalues = [x.toInt()[0] for x in settings.value("extraeventsvalues").toList()]
                self.extraeventsactions = [x.toInt()[0] for x in settings.value("extraeventsactions").toList()]
                self.extraeventsvisibility = [x.toInt()[0] for x in settings.value("extraeventsvisibility").toList()]
                self.extraeventsactionstrings = list(settings.value("extraeventsactionstrings",self.extraeventsactionstrings).toStringList())
                self.extraeventslabels = list(settings.value("extraeventslabels",self.extraeventslabels).toStringList())
                self.extraeventsdescriptions= list(settings.value("extraeventsdescriptions",self.extraeventsdescriptions).toStringList())
                if settings.contains("extraeventbuttoncolor"):
                    self.extraeventbuttoncolor = list(settings.value("extraeventbuttoncolor",self.extraeventbuttoncolor).toStringList())
                    self.extraeventbuttontextcolor = list(settings.value("extraeventbuttontextcolor",self.extraeventbuttontextcolor).toStringList())
                else:
                    self.extraeventbuttoncolor = ["yellow"]*len(self.extraeventstypes)
                    self.extraeventbuttontextcolor = ["black"]*len(self.extraeventstypes)
                if settings.contains("buttonpalette"):
                    self.buttonpalettemaxlen = [x.toInt()[0] for x in settings.value("buttonpalettemaxlen").toList()]
                    mlist = [x.toList() for x in settings.value("buttonpalette").toList()]
                    for i in range(len(mlist)):
                        if len(mlist[i]) == 9 or len(mlist[i]) == 14:
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][0].toList()])              #types
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][1].toList()])              #values
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][2].toList()])              #actions
                            self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][3].toList()])              #visibility
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][4].toList()]))) #strings
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][5].toList()]))) #labels
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][6].toList()]))) #descriptions
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][7].toList()]))) #color
                            self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][8].toList()]))) #textcolor
                            if len(mlist[i]) == 14:
                                self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][9].toList()])            #slider visibility
                                self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][10].toList()])            #slider actions
                                self.buttonpalette[i].append(list(map(str,[x.toString() for x in mlist[i][11].toList()]))) #sider commands
                                self.buttonpalette[i].append([x.toInt()[0] for x in mlist[i][12].toList()])            #slider offsets
                                self.buttonpalette[i].append([x.toDouble()[0] for x in mlist[i][13].toList()])         #slider factors                                
                            else:
                                self.buttonpalette[i].extend([[],[],[],[]])
                        else:
                            self.buttonpalette[i].extend([[],[],[],[],[],[],[],[],[],[],[],[],[]])
                for i in range(len(self.extraeventsactionstrings)):
                    self.extraeventsactionstrings[i] = u(self.extraeventsactionstrings[i])
                    self.extraeventslabels[i] = u(self.extraeventslabels[i])
                    self.extraeventsdescriptions[i] = u(self.extraeventsdescriptions[i])
                    self.extraeventbuttoncolor[i] = str(self.extraeventbuttoncolor[i])
                    self.extraeventbuttontextcolor[i] = str(self.extraeventbuttontextcolor[i])
                #update individual visibility of each buttons
                self.update_extraeventbuttons_visibility()
                self.realignbuttons()
            settings.endGroup()

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None, QApplication.UnicodeUTF8),QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "  settingsLoad()  @line " + str(exc_tb.tb_lineno))
   
#--------------------------------
        try: 
            #update visibility of main event button
            if self.eventsbuttonflag:
                self.button_11.setVisible(True)
            else:
                self.button_11.setVisible(False)
            #set default button visibility
            aw.button_8.setVisible(bool(aw.qmc.buttonvisibility[0]))
            aw.button_19.setVisible(bool(aw.qmc.buttonvisibility[1]))
            aw.button_3.setVisible(bool(aw.qmc.buttonvisibility[2]))
            aw.button_4.setVisible(bool(aw.qmc.buttonvisibility[3]))
            aw.button_5.setVisible(bool(aw.qmc.buttonvisibility[4]))
            aw.button_6.setVisible(bool(aw.qmc.buttonvisibility[5]))
            aw.button_9.setVisible(bool(aw.qmc.buttonvisibility[6]))
            aw.button_20.setVisible(bool(aw.qmc.buttonvisibility[7]))
            self.qmc.redraw()
            # set window appearances (style)
            if settings.contains("appearance"):
                try:
                    available = list(map(str, list(QStyleFactory.keys())))
                    i = list(map(lambda x:x.lower(),available)).index(str(settings.value("appearance").toString()))
                    app.setStyle(available[i])
                except:
                    pass
            # set dpi
            if settings.contains("dpi"):
                try:
                    aw.dpi = settings.value("dpi",aw.dpi).toInt()[0]
                    if aw.dpi != aw.defaultdpi:
                        aw.setdpi(aw.dpi)
                except:
                    pass
        except Exception:
            pass
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None, QApplication.UnicodeUTF8),QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " settingsLoad()  @line " + str(exc_tb.tb_lineno))

    def fetchCurveStyles(self):
        try:
            # get and set axis y limits
            yrange = aw.qmc.ax.get_ylim()
            yl_min = int(yrange[0])
            yl = int(yrange[1])
            if yl > yl_min + 10:
                aw.qmc.ylimit = yl
                aw.qmc.ylimit_min = yl_min
            delta_yrange = aw.qmc.delta_ax.get_ylim()
            zl_min = int(delta_yrange[0])
            zl = int(delta_yrange[1])
            if zl > zl_min + 5:
                aw.qmc.zlimit = zl
                aw.qmc.zlimit_min = zl_min
            if aw.qmc.l_temp1:
                self.qmc.ETlinestyle = aw.qmc.l_temp1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETlinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdrawstyle = aw.qmc.l_temp1.get_drawstyle()
                else:
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = aw.qmc.l_temp1.get_linewidth()
                self.qmc.ETmarker = aw.qmc.l_temp1.get_marker()
                self.qmc.ETmarkersize = aw.qmc.l_temp1.get_markersize()
                self.qmc.palette["et"] = aw.qmc.l_temp1.get_color()
            if aw.qmc.l_temp2:
                self.qmc.BTlinestyle = aw.qmc.l_temp2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTlinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdrawstyle = aw.qmc.l_temp2.get_drawstyle()
                else:
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = aw.qmc.l_temp2.get_linewidth()
                self.qmc.BTmarker = aw.qmc.l_temp2.get_marker()
                self.qmc.BTmarkersize = aw.qmc.l_temp2.get_markersize()
                self.qmc.palette["bt"] = aw.qmc.l_temp2.get_color()
            if aw.qmc.l_delta1:
                self.qmc.ETdeltalinestyle = aw.qmc.l_delta1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdeltadrawstyle = aw.qmc.l_delta1.get_drawstyle()
                else:
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = aw.qmc.l_delta1.get_linewidth()
                self.qmc.ETdeltamarker = aw.qmc.l_delta1.get_marker()
                self.qmc.ETdeltamarkersize = aw.qmc.l_delta1.get_markersize()
                self.qmc.palette["deltaet"] = aw.qmc.l_delta1.get_color()
            if aw.qmc.l_delta2:
                self.qmc.BTdeltalinestyle = aw.qmc.l_delta2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdeltadrawstyle = aw.qmc.l_delta2.get_drawstyle()
                else:
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = aw.qmc.l_delta2.get_linewidth()
                self.qmc.BTdeltamarker = aw.qmc.l_delta2.get_marker()
                self.qmc.BTdeltamarkersize = aw.qmc.l_delta2.get_markersize()  
                self.qmc.palette["deltabt"] = aw.qmc.l_delta2.get_color()
            if aw.qmc.l_back1:
                self.qmc.ETbacklinestyle = aw.qmc.l_back1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.ETbackdrawstyle = aw.qmc.l_back1.get_drawstyle()
                else:
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = aw.qmc.l_back1.get_linewidth()
                self.qmc.ETbackmarker = aw.qmc.l_back1.get_marker()
                self.qmc.ETbackmarkersize = aw.qmc.l_back1.get_markersize()
                self.qmc.backgroundmetcolor = aw.qmc.l_back1.get_color()
            if aw.qmc.l_back2:
                self.qmc.BTbacklinestyle = aw.qmc.l_back2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.BTbackdrawstyle = aw.qmc.l_back2.get_drawstyle()
                else:
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = aw.qmc.l_back2.get_linewidth()
                self.qmc.BTbackmarker = aw.qmc.l_back2.get_marker()
                self.qmc.BTbackmarkersize = aw.qmc.l_back2.get_markersize()
                self.qmc.backgroundbtcolor = aw.qmc.l_back2.get_color()
            if aw.qmc.l_delta1B:
                self.qmc.ETBdeltalinestyle = aw.qmc.l_delta1B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETBdeltadrawstyle = aw.qmc.l_delta1B.get_drawstyle()
                else:
                    self.qmc.ETBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETBdeltalinewidth = aw.qmc.l_delta1B.get_linewidth()
                self.qmc.ETBdeltamarker = aw.qmc.l_delta1B.get_marker()
                self.qmc.ETBdeltamarkersize = aw.qmc.l_delta1B.get_markersize()
                self.qmc.backgrounddeltaetcolor = aw.qmc.l_delta1B.get_color()
            if aw.qmc.l_delta2B:
                self.qmc.BTBdeltalinestyle = aw.qmc.l_delta2B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTBdeltadrawstyle = aw.qmc.l_delta2B.get_drawstyle()
                else:
                    self.qmc.BTBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTBdeltalinewidth = aw.qmc.l_delta2B.get_linewidth()
                self.qmc.BTBdeltamarker = aw.qmc.l_delta2B.get_marker()
                self.qmc.BTBdeltamarkersize = aw.qmc.l_delta2B.get_markersize()  
                self.qmc.backgrounddeltabtcolor = aw.qmc.l_delta2B.get_color()                
            x1 = x2 = 0
            for i in range(len(aw.qmc.extradevices)):
                if aw.extraCurveVisibility1[i]:
                    l1 = aw.qmc.extratemp1lines[x1]
                    self.qmc.extralinestyles1[i] = l1.get_linestyle()
                    if self.qmc.extralinestyles1[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles1[i] = l1.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles1[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths1[i] = l1.get_linewidth()
                    self.qmc.extramarkers1[i] = l1.get_marker()
                    self.qmc.extramarkersizes1[i] = l1.get_markersize()
                    aw.qmc.extradevicecolor1[i] = l1.get_color()
                    aw.setLabelColor(aw.extraLCDlabel1[i],QColor(l1.get_color()))
                    aw.qmc.extraname1[i] = l1.get_label()
                    x1 = x1 + 1
                if aw.extraCurveVisibility2[i]:
                    l2 = aw.qmc.extratemp2lines[x2]
                    self.qmc.extralinestyles2[i] = l2.get_linestyle()
                    if self.qmc.extralinestyles2[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles2[i] = l2.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles2[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths2[i] = l2.get_linewidth()
                    self.qmc.extramarkers2[i] = l2.get_marker()
                    self.qmc.extramarkersizes2[i] = l2.get_markersize()
                    aw.qmc.extradevicecolor2[i] = l2.get_color()
                    aw.setLabelColor(aw.extraLCDlabel2[i],QColor(l2.get_color()))
                    aw.qmc.extraname2[i] = l2.get_label()
                    x2 = x2 + 1
                if self.qmc.eventsGraphflag == 2:
                    self.qmc.EvalueMarker[0] = self.qmc.l_eventtype1dots.get_marker()
                    self.qmc.EvalueMarker[1] = self.qmc.l_eventtype2dots.get_marker()
                    self.qmc.EvalueMarker[2] = self.qmc.l_eventtype3dots.get_marker()
                    self.qmc.EvalueMarker[3] = self.qmc.l_eventtype4dots.get_marker()
                    self.qmc.EvalueMarkerSize[0] = self.qmc.l_eventtype1dots.get_markersize()
                    self.qmc.EvalueMarkerSize[1] = self.qmc.l_eventtype2dots.get_markersize()
                    self.qmc.EvalueMarkerSize[2] = self.qmc.l_eventtype3dots.get_markersize()
                    self.qmc.EvalueMarkerSize[3] = self.qmc.l_eventtype4dots.get_markersize()
                    self.qmc.EvalueColor[0] = self.qmc.l_eventtype1dots.get_color()
                    self.qmc.EvalueColor[1] = self.qmc.l_eventtype2dots.get_color()
                    self.qmc.EvalueColor[2] = self.qmc.l_eventtype3dots.get_color()
                    self.qmc.EvalueColor[3] = self.qmc.l_eventtype4dots.get_color()
                    self.qmc.Evaluelinethickness[0] = self.qmc.l_eventtype1dots.get_linewidth()
                    self.qmc.Evaluelinethickness[1] = self.qmc.l_eventtype2dots.get_linewidth()
                    self.qmc.Evaluelinethickness[2] = self.qmc.l_eventtype3dots.get_linewidth()
                    self.qmc.Evaluelinethickness[3] = self.qmc.l_eventtype4dots.get_linewidth()
                    self.qmc.etypes[0] = self.qmc.l_eventtype1dots.get_label()
                    self.qmc.etypes[1] = self.qmc.l_eventtype2dots.get_label()
                    self.qmc.etypes[2] = self.qmc.l_eventtype3dots.get_label()
                    self.qmc.etypes[3] = self.qmc.l_eventtype4dots.get_label()
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " fetchCurveStyles() %1").arg(str(e)),exc_tb.tb_lineno)


    #Saves the settings when closing application. See the oppposite settingsLoad()
    def closeEvent(self,_):
        #save window geometry and position. See QSettings documentation.
        #This information is often stored in the system registry on Windows,
        #and in XML preferences files on Mac OS X. On Unix systems, in the absence of a standard,
        #many applications (including the KDE applications) use INI text files
        try:
            settings = QSettings()
            #save window geometry
            settings.setValue("Geometry",QVariant(self.saveGeometry()))
            #save mode
            previous_mode = str(settings.value("Mode",self.qmc.mode).toString())
            settings.setValue("Mode",self.qmc.mode)
            #save device
            settings.beginGroup("Device")
            settings.setValue("id",self.qmc.device)
            settings.setValue("controlETpid",self.ser.controlETpid)
            settings.setValue("readBTpid",self.ser.readBTpid)
            settings.setValue("arduinoETChannel",self.ser.arduinoETChannel)
            settings.setValue("arduinoBTChannel",self.ser.arduinoBTChannel)
            settings.setValue("arduinoATChannel",self.ser.arduinoATChannel)
            settings.setValue("arduino56active",self.qmc.arduino56active)
            settings.endGroup()
            #save of phases is done in the phases dialog
            #only if mode was changed (and therefore the phases values have been converted)
            #we update the defaults here
            if previous_mode != self.qmc.mode:
                #save phases
                settings.setValue("Phases",self.qmc.phases)
            #save phasesbuttonflag
            settings.setValue("phasesbuttonflag",self.qmc.phasesbuttonflag)
            #save phases watermarks flag
            settings.setValue("watermarks",self.qmc.watermarksflag)
            #save statistics
            settings.setValue("Statistics",self.qmc.statisticsflags)
            settings.setValue("StatisticsConds",self.qmc.statisticsconditions)
            #save Events settings
            settings.beginGroup("events")
            settings.setValue("eventsbuttonflag",self.eventsbuttonflag)
            settings.setValue("minieventsflag",self.minieventsflag)
            settings.setValue("eventsGraphflag",self.qmc.eventsGraphflag)
            settings.setValue("etypes",self.qmc.etypes)
            settings.setValue("eventsshowflag",self.qmc.eventsshowflag)
            settings.setValue("autoChargeDrop",self.qmc.autoChargeDropFlag)
            settings.setValue("EvalueColor",self.qmc.EvalueColor)
            settings.setValue("EvalueMarker",self.qmc.EvalueMarker)
            settings.setValue("Evaluelinethickness",self.qmc.Evaluelinethickness)
            settings.setValue("EvalueMarkerSize",self.qmc.EvalueMarkerSize)
            settings.setValue("Evaluealpha",self.qmc.Evaluealpha)
            settings.endGroup()
            #save ambient temperature source
            settings.setValue("AmbientTempSource",aw.qmc.ambientTempSource)
            #save delay
            settings.setValue("Delay",self.qmc.delay)
            #save colors
            settings.setValue("Colors",self.qmc.palette)
            settings.setValue("LCDColors",self.lcdpaletteB)
            settings.setValue("LEDColors",self.lcdpaletteF)
            settings.setValue("ETBColor",self.qmc.backgroundmetcolor)
            settings.setValue("BTBColor",self.qmc.backgroundbtcolor)
            settings.setValue("ETBdeltaColor",self.qmc.backgrounddeltaetcolor)
            settings.setValue("BTBdeltaColor",self.qmc.backgrounddeltabtcolor)      
            #save flavors
            settings.setValue("Flavors",self.qmc.flavorlabels)
            settings.setValue("flavorstartangle",self.qmc.flavorstartangle)
            #save roast color system
            settings.setValue("colorsystem",self.qmc.color_system_idx)
            #soundflag
            settings.setValue("sound",self.soundflag)
            #save serial port
            settings.beginGroup("SerialPort")
            settings.setValue("comport",self.ser.comport)
            settings.setValue("baudrate",self.ser.baudrate)
            settings.setValue("bytesize",self.ser.bytesize)
            settings.setValue("stopbits",self.ser.stopbits)
            settings.setValue("parity",self.ser.parity)
            settings.setValue("timeout",self.ser.timeout)
            settings.endGroup()
            #save modbus port
            settings.beginGroup("Modbus")
            settings.setValue("comport",self.modbus.comport)
            settings.setValue("baudrate",self.modbus.baudrate)
            settings.setValue("bytesize",self.modbus.bytesize)
            settings.setValue("stopbits",self.modbus.stopbits)
            settings.setValue("parity",self.modbus.parity)
            settings.setValue("timeout",self.modbus.timeout)
            settings.setValue("input1slave",self.modbus.input1slave)
            settings.setValue("input1register",self.modbus.input1register)
            settings.setValue("input1float",self.modbus.input1float)
            settings.setValue("input1code",self.modbus.input1code)
            settings.setValue("input2slave",self.modbus.input2slave)
            settings.setValue("input2register",self.modbus.input2register)
            settings.setValue("input2float",self.modbus.input2float)
            settings.setValue("input2code",self.modbus.input2code)
            settings.setValue("input3slave",self.modbus.input3slave)
            settings.setValue("input3register",self.modbus.input3register)
            settings.setValue("input3float",self.modbus.input3float)
            settings.setValue("input3code",self.modbus.input3code)
            settings.setValue("input4slave",self.modbus.input4slave)
            settings.setValue("input4register",self.modbus.input4register)
            settings.setValue("input4float",self.modbus.input4float)
            settings.setValue("input4code",self.modbus.input4code)
            settings.setValue("littleEndianFloats",self.modbus.littleEndianFloats)
            settings.endGroup()
            #save scale port
            settings.beginGroup("Scale")
#            settings.setValue("device",self.scale.device)
            settings.setValue("device_id",self.scale.device_id)
            settings.setValue("comport",self.scale.comport)
            settings.setValue("baudrate",self.scale.baudrate)
            settings.setValue("bytesize",self.scale.bytesize)
            settings.setValue("stopbits",self.scale.stopbits)
            settings.setValue("parity",self.scale.parity)
            settings.setValue("timeout",self.scale.timeout)
            settings.endGroup()
            #save pid settings (only key and value[0])
            settings.beginGroup("PXR")
            for key in list(self.fujipid.PXR.keys()):
                settings.setValue(key,self.fujipid.PXR[key][0])
            settings.endGroup()
            settings.beginGroup("PXG4")
            for key in list(self.fujipid.PXG4.keys()):
                settings.setValue(key,self.fujipid.PXG4[key][0])
            settings.endGroup()
            settings.beginGroup("deltaDTA")
            for key in list(self.dtapid.dtamem.keys()):
                settings.setValue(key,self.dtapid.dtamem[key][0])
            settings.endGroup()
            settings.setValue("filterDropOuts",self.qmc.filterDropOuts)
            settings.setValue("dropSpikes",self.qmc.dropSpikes)
            settings.setValue("minmaxLimits",self.qmc.minmaxLimits)
            settings.setValue("minLimit",self.qmc.filterDropOut_tmin)
            settings.setValue("maxLimit",self.qmc.filterDropOut_tmax)
            settings.beginGroup("RoC")
            settings.setValue("DeltaET",self.qmc.DeltaETflag)
            settings.setValue("DeltaBT",self.qmc.DeltaBTflag)
            settings.setValue("DeltaETlcd",self.qmc.DeltaETlcdflag)
            settings.setValue("DeltaBTlcd",self.qmc.DeltaBTlcdflag)
            settings.setValue("deltafilter",self.qmc.deltafilter)
            settings.endGroup()
            settings.setValue("curvefilter",self.qmc.curvefilter)
            settings.setValue("ETcurve",self.qmc.ETcurve)
            settings.setValue("BTcurve",self.qmc.BTcurve)
            settings.setValue("ETlcd",self.qmc.ETlcd)
            settings.setValue("BTlcd",self.qmc.BTlcd)
            settings.beginGroup("DefaultButtons")
            settings.setValue("buttonvisibility",self.qmc.buttonvisibility)
            settings.setValue("buttonactions",self.qmc.buttonactions)
            settings.setValue("buttonactionstrings",self.qmc.buttonactionstrings)
            settings.endGroup()
            settings.beginGroup("HUD")
            settings.setValue("Projection",self.qmc.projectFlag)
            settings.setValue("ProjectionMode",self.qmc.projectionmode)
            settings.setValue("ETtarget",self.qmc.ETtarget)
            settings.setValue("BTtarget",self.qmc.BTtarget)
            settings.setValue("ET2target",self.qmc.ET2target)
            settings.setValue("BT2target",self.qmc.BT2target)
            settings.setValue("Mode",self.HUDfunction)
            settings.setValue("hudETpid",self.qmc.hudETpid)
            settings.endGroup()
            settings.beginGroup("Sound")
            settings.setValue("Beep",self.soundflag)
            settings.endGroup()
            settings.beginGroup("Axis")
            settings.setValue("xmin",self.qmc.startofx)
            settings.setValue("xmax",self.qmc.endofx)
            settings.setValue("ymax",self.qmc.ylimit)
            settings.setValue("ymin",self.qmc.ylimit_min)
            settings.setValue("zmax",self.qmc.zlimit)
            settings.setValue("zmin",self.qmc.zlimit_min)
            settings.setValue("resetmaxtime",self.qmc.resetmaxtime)
            settings.setValue("lockmax",self.qmc.fixmaxtime)
            settings.setValue("legendloc",self.qmc.legendloc)
            settings.endGroup()
            settings.beginGroup("RoastProperties")
            settings.setValue("operator",self.qmc.operator)
            settings.setValue("roastertype",self.qmc.roastertype)
            settings.setValue("beansize",self.qmc.beansize)
            settings.setValue("densitySampleVolume",self.qmc.density[2])
            settings.setValue("densitySampleVolumeUnit",self.qmc.density[3])
            settings.endGroup()
            #save alarms
            settings.beginGroup("Alarms")
            settings.setValue("alarmflag",self.qmc.alarmflag)  
            settings.setValue("alarmguard",self.qmc.alarmguard)
            settings.setValue("alarmtime",self.qmc.alarmtime)
            settings.setValue("alarmoffset",self.qmc.alarmoffset)
            settings.setValue("alarmcond",self.qmc.alarmcond)
            settings.setValue("alarmsource",self.qmc.alarmsource)
            settings.setValue("alarmtemperature",self.qmc.alarmtemperature)
            settings.setValue("alarmaction",self.qmc.alarmaction)
            settings.setValue("alarmstrings",self.qmc.alarmstrings)
            settings.endGroup()
            settings.setValue("profilepath",self.userprofilepath)
            #save extra devices
            settings.beginGroup("ExtraDev")
            settings.setValue("extradevices",self.qmc.extradevices)
            settings.setValue("extradevicecolor1",self.qmc.extradevicecolor1)
            settings.setValue("extradevicecolor2",self.qmc.extradevicecolor2)
            settings.setValue("extraname1",self.qmc.extraname1)
            settings.setValue("extraname2",self.qmc.extraname2)
            settings.setValue("extramathexpression1",self.qmc.extramathexpression1)
            settings.setValue("extramathexpression2",self.qmc.extramathexpression2)
            settings.setValue("extraLCDvisibility1",self.extraLCDvisibility1)
            settings.setValue("extraLCDvisibility2",self.extraLCDvisibility2)
            settings.setValue("extraCurveVisibility1",self.extraCurveVisibility1)
            settings.setValue("extraCurveVisibility2",self.extraCurveVisibility2)
            settings.endGroup()
            #save extra serial comm ports settings
            settings.beginGroup("ExtraComm")
            settings.setValue("extracomport",self.extracomport)
            settings.setValue("extrabaudrate",self.extrabaudrate)
            settings.setValue("extrabytesize",self.extrabytesize)
            settings.setValue("extraparity",self.extraparity)
            settings.setValue("extrastopbits",self.extrastopbits)
            settings.setValue("extratimeout",self.extratimeout)
            settings.endGroup()
            settings.setValue("BTfunction",self.qmc.BTfunction)
            settings.setValue("ETfunction",self.qmc.ETfunction)
            settings.setValue("resetqsettings",self.resetqsettings)
            settings.setValue("plotcurves",self.qmc.plotcurves)
            settings.setValue("plotcurvecolor",self.qmc.plotcurvecolor)
            #curve styles 
            settings.beginGroup("CurveStyles")
            settings.setValue("BTlinestyle",self.qmc.BTlinestyle)
            settings.setValue("BTdrawstyle",self.qmc.BTdrawstyle)
            settings.setValue("BTlinewidth",self.qmc.BTlinewidth)
            settings.setValue("BTmarker",self.qmc.BTmarker)
            settings.setValue("BTmarkersize",self.qmc.BTmarkersize)
            settings.setValue("ETlinestyle",self.qmc.ETlinestyle)
            settings.setValue("ETdrawstyle",self.qmc.ETdrawstyle)
            settings.setValue("ETlinewidth",self.qmc.ETlinewidth)
            settings.setValue("ETmarker",self.qmc.ETmarker)
            settings.setValue("ETmarkersize",self.qmc.ETmarkersize)
            settings.setValue("BTdeltalinestyle",self.qmc.BTdeltalinestyle)
            settings.setValue("BTdeltadrawstyle",self.qmc.BTdeltadrawstyle)
            settings.setValue("BTdeltalinewidth",self.qmc.BTdeltalinewidth)
            settings.setValue("BTdeltamarker",self.qmc.BTdeltamarker)
            settings.setValue("BTdeltamarkersize",self.qmc.BTdeltamarkersize)
            settings.setValue("ETdeltalinestyle",self.qmc.ETdeltalinestyle)
            settings.setValue("ETdeltadrawstyle",self.qmc.ETdeltadrawstyle)
            settings.setValue("ETdeltalinewidth",self.qmc.ETdeltalinewidth)
            settings.setValue("ETdeltamarker",self.qmc.ETdeltamarker)
            settings.setValue("ETdeltamarkersize",self.qmc.ETdeltamarkersize)
            settings.setValue("BTbacklinestyle",self.qmc.BTbacklinestyle)
            settings.setValue("BTbackdrawstyle",self.qmc.BTbackdrawstyle)
            settings.setValue("BTbacklinewidth",self.qmc.BTbacklinewidth)
            settings.setValue("BTbackmarker",self.qmc.BTbackmarker)
            settings.setValue("BTbackmarkersize",self.qmc.BTbackmarkersize)
            settings.setValue("ETbacklinestyle",self.qmc.ETbacklinestyle)
            settings.setValue("ETbackdrawstyle",self.qmc.ETbackdrawstyle)
            settings.setValue("ETbacklinewidth",self.qmc.ETbacklinewidth)
            settings.setValue("ETbackmarker",self.qmc.ETbackmarker)
            settings.setValue("ETbackmarkersize",self.qmc.ETbackmarkersize)
            settings.setValue("BTBdeltalinestyle",self.qmc.BTBdeltalinestyle)
            settings.setValue("BTBdeltadrawstyle",self.qmc.BTBdeltadrawstyle)
            settings.setValue("BTBdeltalinewidth",self.qmc.BTBdeltalinewidth)
            settings.setValue("BTBdeltamarker",self.qmc.BTBdeltamarker)
            settings.setValue("BTBdeltamarkersize",self.qmc.BTBdeltamarkersize)
            settings.setValue("ETBdeltalinestyle",self.qmc.ETBdeltalinestyle)
            settings.setValue("ETBdeltadrawstyle",self.qmc.ETBdeltadrawstyle)
            settings.setValue("ETBdeltalinewidth",self.qmc.ETBdeltalinewidth)
            settings.setValue("ETBdeltamarker",self.qmc.ETBdeltamarker)
            settings.setValue("ETBdeltamarkersize",self.qmc.ETBdeltamarkersize)
            settings.setValue("extralinestyles1",self.qmc.extralinestyles1)
            settings.setValue("extralinestyles2",self.qmc.extralinestyles2)
            settings.setValue("extradrawstyles1",self.qmc.extradrawstyles1)
            settings.setValue("extradrawstyles2",self.qmc.extradrawstyles2)
            settings.setValue("extralinewidths1",self.qmc.extralinewidths1)
            settings.setValue("extralinewidths2",self.qmc.extralinewidths2)
            settings.setValue("extramarkers1",self.qmc.extramarkers1)
            settings.setValue("extramarkers2",self.qmc.extramarkers2)
            settings.setValue("extramarkersizes1",self.qmc.extramarkersizes1)
            settings.setValue("extramarkersizes2",self.qmc.extramarkersizes2)
            settings.endGroup()
            #background settings
            settings.beginGroup("background")
            settings.setValue("backgrounddetails",aw.qmc.backgroundDetails)
            settings.setValue("backgroundevents",aw.qmc.backgroundeventsflag)
            settings.setValue("DeltaETB",aw.qmc.DeltaETBflag)
            settings.setValue("DeltaBTB",aw.qmc.DeltaBTBflag)
            settings.endGroup()
            #custom event buttons
            settings.beginGroup("ExtraEventButtons")
            settings.setValue("buttonlistmaxlen",self.buttonlistmaxlen)
            settings.setValue("extraeventstypes",self.extraeventstypes)
            settings.setValue("extraeventsvalues",self.extraeventsvalues)
            settings.setValue("extraeventsactionstrings",self.extraeventsactionstrings)
            settings.setValue("extraeventsactions",self.extraeventsactions)
            settings.setValue("extraeventsdescriptions",self.extraeventsdescriptions)
            settings.setValue("extraeventsvisibility",self.extraeventsvisibility)
            settings.setValue("extraeventslabels",self.extraeventslabels)
            settings.setValue("extraeventbuttoncolor",self.extraeventbuttoncolor)
            settings.setValue("extraeventbuttontextcolor",self.extraeventbuttontextcolor)
            settings.setValue("extraeventsbuttonsflag",self.extraeventsbuttonsflag)
            settings.setValue("buttonpalette",self.buttonpalette)
            settings.setValue("buttonpalettemaxlen",self.buttonpalettemaxlen)
            settings.endGroup()
            settings.beginGroup("grid")
            settings.setValue("xgrid",self.qmc.xgrid)
            settings.setValue("ygrid",self.qmc.ygrid)
            settings.setValue("zgrid",self.qmc.zgrid)
            settings.setValue("gridlinestyle",self.qmc.gridlinestyle)
            settings.setValue("gridthickness",self.qmc.gridthickness)
            settings.setValue("gridalpha",self.qmc.gridalpha)
            settings.setValue("xrotation",self.qmc.xrotation)
            settings.endGroup()
            settings.beginGroup("Sliders")
            settings.setValue("slidervisibilities",self.eventslidervisibilities)
            settings.setValue("slideractions",self.eventslideractions)
            settings.setValue("slidercommands",self.eventslidercommands)
            settings.setValue("slideroffsets",self.eventslideroffsets)
            settings.setValue("sliderfactors",self.eventsliderfactors)
            settings.endGroup()
            settings.setValue("roastpropertiesflag",self.qmc.roastpropertiesflag)
            settings.setValue("customflavorlabels",self.qmc.customflavorlabels)
            try:
                settings.setValue("appearance",str(aw.style().objectName()).lower())
            except:
                pass
            settings.setValue("dpi",aw.dpi)
            
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info() 
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None, QApplication.UnicodeUTF8),QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " closeEvent()  @line " + str(exc_tb.tb_lineno))


    #used for trouble shooting.
    def readartisansettings(self):
        general,device,phases,statistics,events,delay,colors,cupping,extras,serial,axes,roast,alarms = {},{},{},{},{},{},{},{},{},{},{},{},{}
        #read window geometry
        rect = self.geometry()
        height = str(rect.height())
        width = str(rect.width())
        general["geometry"] = height + "x" + width                #custom made string
        general["mode"] = str(self.qmc.mode)
        device["id"] = str(self.qmc.device)
        device["controlETpid"] = str(self.ser.controlETpid)
        device["readBTpid"] = str(self.ser.readBTpid)            
        device["arduinoETChannel"] = str(self.ser.arduinoETChannel)
        device["arduinoBTChannel"] = str(self.ser.arduinoBTChannel)
        device["arduinoATChannel"] = str(self.ser.arduinoATChannel)
        phases["Phases"] = str(self.qmc.phases)
        phases["phasesbuttonflag"] = str(self.qmc.phasesbuttonflag)
        statistics["Statistics"] = str(self.qmc.statisticsflags)
        statistics["StatisticsConds"] = str(self.qmc.statisticsconditions)
        events["eventsbuttonflag"] = str(self.eventsbuttonflag)
        events["minieventsflag"] = str(self.minieventsflag)
        events["eventsGraphflag"] = str(self.qmc.eventsGraphflag)
        events["etypes"] = u(list(map(u,self.qmc.etypes)))
        events["eventsshowflag"] = str(self.qmc.eventsshowflag)
        events["autoChargeDrop"] = str(self.qmc.autoChargeDropFlag)
        events["EvalueColor"] = str(self.qmc.EvalueColor)
        events["EvalueMarker"] = str(self.qmc.EvalueMarker)
        events["Evaluelinethickness"] = str(self.qmc.Evaluelinethickness)
        events["Evaluealpha"] = str(self.qmc.Evaluealpha)
        delay["Delay"] = str(self.qmc.delay)
        colors["Colors"] = str(self.qmc.palette)
        colors["LCDColors"] = str(self.lcdpaletteB)
        colors["LEDColors"] = str(self.lcdpaletteF)
        cupping["Flavors"] = u(list(map(u,self.qmc.flavorlabels)))
        cupping["flavorstartangle"] = str(self.qmc.flavorstartangle)
        serial["comport"] = str(self.ser.comport)
        serial["baudrate"] = str(self.ser.baudrate)
        serial["bytesize"]= str(self.ser.bytesize)
        serial["stopbits"]= str(self.ser.stopbits)
        serial["parity"]= str(self.ser.parity)
        serial["timeout"]= str(self.ser.timeout)
        for key in list(self.fujipid.PXR.keys()):
            device["PXR:" + key] = str(self.fujipid.PXR[key][0])   # key modified
        for key in list(self.fujipid.PXG4.keys()):            
            device["PXG:" + key] = str(self.fujipid.PXG4[key][0])  # key modified
        for key in list(self.dtapid.dtamem.keys()):            
            device["DTA:" + key] = str(self.dtapid.dtamem[key][0]) # key modified
        general["sound"]= str(self.soundflag)
        extras["DeltaET"]= str(self.qmc.DeltaETflag)
        extras["DeltaBT"]= str(self.qmc.DeltaBTflag)
        extras["DeltaETlcd"]= str(self.qmc.DeltaETlcdflag)
        extras["DeltaBTlcd"]= str(self.qmc.DeltaBTlcdflag)
        extras["deltafilter"]= str(self.qmc.deltafilter)
        extras["curvefilter"]= str(self.qmc.curvefilter)
        extras["Projection"]= str(self.qmc.projectFlag)
        extras["ProjectionMode"]= str(self.qmc.projectionmode)
        extras["ETtarget"]= str(self.qmc.ETtarget)
        extras["BTtarget"]= str(self.qmc.BTtarget)
        extras["ET2target"]= str(self.qmc.ET2target)
        extras["BT2target"]= str(self.qmc.BT2target)
        extras["HUDMode"]= str(self.HUDfunction)                      # key modified
        extras["hudETpid"]= str(self.qmc.hudETpid)
        extras["Beep"]= str(self.soundflag)
        axes["xmin"]= str(self.qmc.startofx)
        axes["xmax"]= str(self.qmc.endofx)
        axes["ymax"]= str(self.qmc.ylimit)
        axes["ymin"]= str(self.qmc.ylimit_min)
        axes["zmax"]= str(self.qmc.zlimit)
        axes["zmin"]= str(self.qmc.zlimit_min)
        axes["resetmaxtime"] = str(self.qmc.stringfromseconds(self.qmc.resetmaxtime))
        axes["legendloc"] = str(self.qmc.legendloc)
        roast["operator"]= u(self.qmc.operator)
        roast["roastertype"] = u(self.qmc.roastertype)
        roast["densitySampleVolume"] = str(self.qmc.density[2])
        roast["densitySampleVolumeUnit"]= str(self.qmc.density[3])
        roast["beansize"]= str(self.qmc.beansize)
        alarms["alarmflag"]= str(self.qmc.alarmflag) 
        alarms["alarmguard"]= str(self.qmc.alarmguard)
        alarms["alarmtime"]= str(self.qmc.alarmtime)
        alarms["alarmoffset"]= str(self.qmc.alarmoffset)
        alarms["alarmcond"]= str(self.qmc.alarmcond)
        alarms["alarmsource"]= u(self.qmc.alarmsource)
        alarms["alarmaction"]= u(self.qmc.alarmaction)
        alarms["alarmstrings"]= list(map(u,list(self.qmc.alarmstrings)))
        general["profilepath"]= u(self.userprofilepath)
        #save extra devices
        device["extradevices"]= str(self.qmc.extradevices)
        device["extradevicecolor1"]= str(self.qmc.extradevicecolor1)
        device["extradevicecolor2"]= str(self.qmc.extradevicecolor2)
        device["extraname1"]= u(self.qmc.extraname1)
        device["extraname2"]= u(self.qmc.extraname2)
        device["extramathexpression1"]= str(self.qmc.extramathexpression1)
        device["extramathexpression2"]= str(self.qmc.extramathexpression2)
        #save extra serial comm ports settings
        serial["extracomport"]= str(self.extracomport)
        serial["extrabaudrate"]= str(self.extrabaudrate)
        serial["extrabytesize"]= str(self.extrabytesize)
        serial["extraparity"]= str(self.extraparity)
        serial["extrastopbits"]= str(self.extrastopbits)
        serial["extratimeout"]= str(self.extratimeout)
        device["BTfunction"]= str(self.qmc.BTfunction)
        device["ETfunction"]= str(self.qmc.ETfunction)
        serial["extraserlength"]= str(len(self.extraser))
        general["resetqsettings"]= str(self.resetqsettings)
        extras["plotcurves"]= str(self.qmc.plotcurves)
        extras["plotcurvecolor"]= str(self.qmc.plotcurvecolor)
        #custom event buttons
        events["buttonlistmaxlen"]= str(self.buttonlistmaxlen)
        events["extraeventstypes"]= u(self.extraeventstypes)
        events["extraeventsvalues"]= str(self.extraeventsvalues)
        events["extraeventsactionstrings"]= str(self.extraeventsactionstrings)
        events["extraeventsactions"]= str(self.extraeventsactions)
        events["extraeventsdescriptions"]= u(self.extraeventsdescriptions)
        events["extraeventsvisibility"]= str(self.extraeventsvisibility)
        events["extraeventslabels"]= u(self.extraeventslabels)
        events["extraeventbuttoncolor"]= str(self.extraeventbuttoncolor)
        events["extraeventbuttontextcolor"]= str(self.extraeventbuttontextcolor)
        events["extraeventsbuttonsflag"]= str(self.extraeventsbuttonsflag)
        events["buttonpalettemaxlen"]= str(self.buttonpalettemaxlen)
        events["buttonpalette"]= str(self.buttonpalette)
        axes["xgrid"]= str(self.qmc.xgrid)
        axes["ygrid"]= str(self.qmc.ygrid)
        axes["zgrid"]= str(self.qmc.zgrid)
        axes["gridlinestyle"]= str(self.qmc.gridlinestyle)
        axes["gridthickness"]= str(self.qmc.gridthickness)
        axes["gridalpha"]= str(self.qmc.gridalpha)
        axes["xrotation"]= str(self.qmc.xrotation)
        general["extraLCDvisibility1"] = str(self.extraLCDvisibility1)
        general["extraLCDvisibility2"] = str(self.extraLCDvisibility2)
        general["extraCurveVisibility1"] = str(self.extraCurveVisibility1)
        general["extraCurveVisibility2"] = str(self.extraCurveVisibility2)
        settingsx = [general,device,phases,statistics,events,delay,colors,cupping,extras,serial,axes,roast,alarms]
        #keep same order
        settingsnames = ["general","device config","phases config","statistics config","events config","sampling interval","colors config",
                         "cupping config","extras config","serial config","axes config","roast properties","alarms config"]
        return settingsx,settingsnames

    def updateExtraLCDvisibility(self):
        n = len(self.qmc.extradevices)
        for i in range(n):
            if i < aw.nLCDS:
                if self.extraLCDvisibility1[i]:
                    if i < len(self.qmc.extraname1):
                        self.extraLCDlabel1[i].setText("<b>" + self.qmc.extraname1[i] + "<\b>")
                    self.extraLCDframe1[i].setVisible(True)
                    self.extraLCD1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
                else:
                    self.extraLCDframe1[i].setVisible(False)
                if self.extraLCDvisibility2[i]:
                    if i < len(self.qmc.extraname2):
                        self.extraLCDlabel2[i].setText("<b>" + self.qmc.extraname2[i] + "<\b>")
                    self.extraLCDframe2[i].setVisible(True)
                    self.extraLCD2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
                else:
                    self.extraLCDframe2[i].setVisible(False)
        #hide the rest (just in case)
        for i in range(n,aw.nLCDS):
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)

    def fileQuit(self):
        if aw.qmc.checkSaved(): # if not canceled
            self.closeEvent(None)
            QApplication.exit()

    def filePrint(self):
        image = QPixmap.grabWidget(aw.qmc).toImage()
#        image = aw.qmc().grab().toImage()
        
        if image.isNull():
            return
        if self.printer is None:
            self.printer = QPrinter(QPrinter.HighResolution)
            self.printer.setPageSize(QPrinter.Letter)
        form = QPrintDialog(self.printer, self)
        if form.exec_():
            painter = QPainter(self.printer)
            rect = painter.viewport()
            size = image.size()
            size.scale(rect.size(), Qt.KeepAspectRatio)
            painter.setViewport(rect.x(), rect.y(), size.width(),size.height())
            painter.setWindow(image.rect()) #scale to fit page
            if isinstance(image, QPixmap):
                painter.drawPixmap(0,0,image)
            else:
                painter.drawImage(0, 0, image)

    def htmlReport(self):
        HTML_REPORT_TEMPLATE = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>""" + u(QApplication.translate("HTML Report Template", "Roasting Report", None, QApplication.UnicodeUTF8)) + """</title>
<style type="text/css">
td { 
  vertical-align: top;
  padding: 0px 0px 0px 5px;
}
th {
  text-align: right;
  vertical-align: top;
}
</style>
</head>
<body>
<center>
<h1>$title</h1>

<table border="1" cellpadding="10" width="80%">
<tr>
<td>
<center>
<table>
<tr>
<td>
<table width="230">
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Date:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$datetime</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Beans:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$beans</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Size:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$size</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Weight:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$weight</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Degree:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$degree</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Volume:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$volume</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Density:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$density</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Humidity:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$humidity</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Roaster:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$roaster</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Operator:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$operator</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Cupping:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$cup</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Color:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$color</td>
</tr>
</table>
</td>
<td>
<table width="220">
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "CHARGE:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$charge</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "TP:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$TP</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "DRY:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$DRY</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "FCs:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$FCs</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "FCe:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$FCe</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "SCs:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$SCs</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "SCe:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$SCe</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "DROP:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$drop</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "COOL:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$cool</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "RoR:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$ror</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "ETBTa:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$etbta</td>
</tr>
</table>
</td>
<td>
<table width="250">
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Drying:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$dry_phase</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Maillard:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$mid_phase</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Development:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$finish_phase</td>
</tr>
<tr>
<th>""" + u(QApplication.translate("HTML Report Template", "Cooling:", None, QApplication.UnicodeUTF8)) + """</th>
<td>$cool_phase</td>
</tr>
</table>
</td>
</tr>
</table>
</center>
</td>
</tr>
<tr>
<td style="vertical-align:middle" align="center"><img alt='roast graph' width="650" src='$graph_image'/></td>
</tr>
<tr>
<td>
<center><b>""" + u(QApplication.translate("HTML Report Template", "Roasting Notes", None, QApplication.UnicodeUTF8)) + """</b></center>
$roasting_notes$roast_attributes
</td>
</tr>
</table>
<table border="1" cellpadding="10" style="page-break-inside:avoid"  width="80%">
<tr>
<td style="vertical-align:middle" align="center"><img alt='flavor graph' width="550" src='$flavor_image'/></td>
</tr>
<tr>
<td><center><b>""" + u(QApplication.translate("HTML Report Template", "Cupping Notes", None, QApplication.UnicodeUTF8)) + """</b></center>
$cupping_notes
</td>
</tr>
</table>
</center>
</body>
</html>
        """
        beans = cgi.escape(self.qmc.beans)
        if len(beans) > 43:
            beans = beans[:41] + "&hellip;"
            
        cp = aw.computedProfileInformation()
        
        if "CHARGE_ET" in cp and "CHARGE_BT" in cp:
            if self.qmc.mode == "F":
                charge = "BT %.1fF <br/>ET %.1fF"%(cp["CHARGE_BT"],cp["CHARGE_ET"])
            else:
                charge = "BT %.1f&deg;C <br/>ET %.1f&deg;C"%(cp["CHARGE_BT"],cp["CHARGE_ET"])
        else:
            charge = "--"
        dryphase, midphase, finishphase, coolphase = self.phases2html(cp)
        etbta = "--"
        if "total_ts" in cp and cp["total_ts"] != 0:
            etbta = "%d %sm"%(cp["total_ts"],self.qmc.mode) 
            if "total_ts_ET" in cp and "total_ts_BT" in cp:
                etbta += " [%d-%d]"%(cp["total_ts_ET"],cp["total_ts_BT"])
        graph_image = "roastlog-graph"
        if platf == 'Darwin':
            graph_image = graph_image + ".svg"
            try:
                os.remove(graph_image)
            except OSError:
                pass
            self.qmc.fig.savefig(graph_image)
        else:
            #resize GRAPH image to 650 pixels width
            image = QPixmap.grabWidget(aw.qmc).toImage()
#            image = aw.qmc.grab().toImage()
            image = image.scaledToWidth(650,1)
            #save GRAPH image
            graph_image = graph_image + ".png"
            try:
                os.remove(graph_image)
            except OSError:
                pass
            image.save(graph_image)
        #add some random number to force HTML reloading
        graph_image = graph_image + "?dummy=" + str(int(libtime.time()))
        #obtain flavor chart image
        self.qmc.flavorchart()
        flavor_image = "roastlog-flavor"
        if platf == 'Darwin':
            flavor_image = flavor_image + ".svg"
            self.qmc.fig.savefig(flavor_image)
        else:
            #resize FLAVOR image to 550 pixels width
            image = QPixmap.grabWidget(aw.qmc).toImage()
#            image = aw.qmc.grab().toImage()
            image = image.scaledToWidth(550,1)
            #save GRAPH image
            flavor_image = flavor_image + ".png"
            image.save(flavor_image)
        flavor_image = flavor_image + "?dummy=" + str(int(libtime.time()))
        #return screen to GRAPH profile mode
        self.qmc.redraw(recomputeAllDeltas=False)
        ror = "--"
        if "total_ror" in cp:
            ror = "%d%s"%(cp["total_ror"],QApplication.translate("Label", "d/m",None, QApplication.UnicodeUTF8))
        if "set_density" in cp:
            density = "%.1fg/l (set)"%cp["set_density"]
        else:
            density = "--"
        if  self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
            weight = self.volume_weight2html(self.qmc.weight[0],self.qmc.weight[1],self.qmc.weight[2],cp["weight_loss"])
        else:
            weight = "--"
        if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0:
            volume = self.volume_weight2html(self.qmc.volume[0],self.qmc.volume[1],self.qmc.volume[2],cp["volume_gain"])
        else:
            volume = "--"
        if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0 and self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
            degree = self.roast_degree(cp["weight_loss"])
            if "set_density" in cp:
                density = "%.1fg/l (set)<br/>%.1fg/l (green)<br/>%.1fg/l (roasted)"%(cp["set_density"],cp["green_density"],cp["roasted_density"])
            else:
                density = "%.1fg/l (green)<br/>%.1fg/l (roasted)"%(cp["green_density"],cp["roasted_density"])
        else:
            degree = "--"
        humidity = ""
        if "bag_humidity" in cp:
            humidity = "%d%%"%cp["bag_humidity"]
            if "bag_temperature" in cp:
                humidity += " at %d%s"%(cp["bag_temperature"],self.qmc.mode)
            humidity += " (bag)"
        if "ambient_humidity" in cp:
            if humidity != "":
                humidity += "<br/>"
            humidity += "%d%%"%cp["ambient_humidity"]
            if "ambient_temperature" in cp:
                humidity += " at %d%s"%(cp["ambient_temperature"],self.qmc.mode)
            humidity += " (ambient)"
        if len(humidity) == 0:
            humidity = "--"
        if self.qmc.whole_color or self.qmc.ground_color:
            color = str(self.qmc.whole_color) + "/" + str(self.qmc.ground_color)
            if self.qmc.color_system_idx:
                color = color + " (" + self.qmc.color_systems[self.qmc.color_system_idx] + ")"
        else:
            color = "--"
        html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            title=cgi.escape(self.qmc.title),
            datetime=u(self.qmc.roastdate.toString()), #alt: unicode(self.qmc.roastdate.toString('MM.dd.yyyy')),
            beans=beans,
            weight=weight,
            degree=degree,
            volume=volume,
            roaster=cgi.escape(self.qmc.roastertype),
            operator=cgi.escape(self.qmc.operator),
            cup=str(self.cuppingSum()),
            color=color,
            charge=charge,            
            size=("--" if aw.qmc.beansize == 0.0 else str(aw.qmc.beansize) + "mm"),
            density=density,
            humidity=humidity,
            TP=self.event2html(cp,"TP_time","TP_BT"),
            DRY=self.event2html(cp,"DRY_time","DRY_BT"),
            FCs=self.event2html(cp,"FCs_time","FCs_BT"),
            FCe=self.event2html(cp,"FCe_time","FCe_BT"),
            SCs=self.event2html(cp,"SCs_time","SCs_BT"),
            SCe=self.event2html(cp,"SCe_time","SCe_BT"),
            drop=self.event2html(cp,"DROP_time","DROP_BT"),
            cool=self.event2html(cp,"COOL_time",None,"DROP_time"),
            dry_phase=dryphase,
            mid_phase=midphase,
            finish_phase=finishphase,
            cool_phase=coolphase,
            ror= ror,
            etbta=etbta,
            roasting_notes=self.note2html(self.qmc.roastingnotes),
            roast_attributes=self.roastattributes(),
            graph_image=graph_image,
            flavor_image=flavor_image,
            specialevents=self.specialevents2html(),
            cupping_notes=self.note2html(self.qmc.cuppingnotes))
        f = None
        try:              
            filename = "Roastlog.html"
            f = codecs.open(filename, 'w', encoding='utf-8')
            for i in range(len(html)):
                f.write(html[i])
            f.close()
            full_path = "file:///" + u(QDir().current().absolutePath()) + "/" + filename
            QDesktopServices.openUrl(QUrl(full_path, QUrl.TolerantMode)) 
            
        except IOError as e:
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None, QApplication.UnicodeUTF8) + " htmlReport() %1").arg(str(e)))
            return
        finally:
            if f:
                f.close()
                
    # returns a string with all the activated roast attributes
    def roastattributes(self):
        res = []
        if aw.qmc.heavyFC_flag:
            res.append(u(QApplication.translate("CheckBox","Heavy FC", None, QApplication.UnicodeUTF8)))
        if aw.qmc.lowFC_flag:
            res.append(u(QApplication.translate("CheckBox","Low FC", None, QApplication.UnicodeUTF8)))
        if aw.qmc.lightCut_flag:
            res.append(u(QApplication.translate("CheckBox","Light Cut", None, QApplication.UnicodeUTF8)))
        if aw.qmc.darkCut_flag:
            res.append(u(QApplication.translate("CheckBox","Dark Cut", None, QApplication.UnicodeUTF8)))
        if aw.qmc.drops_flag:
            res.append(u(QApplication.translate("CheckBox","Drops", None, QApplication.UnicodeUTF8)))
        if aw.qmc.oily_flag:
            res.append(u(QApplication.translate("CheckBox","Oily", None, QApplication.UnicodeUTF8)))
        if aw.qmc.uneven_flag:
            res.append(u(QApplication.translate("CheckBox","Uneven", None, QApplication.UnicodeUTF8)))
        if aw.qmc.tipping_flag:
            res.append(u(QApplication.translate("CheckBox","Tipping", None, QApplication.UnicodeUTF8)))
        if aw.qmc.scorching_flag:
            res.append(u(QApplication.translate("CheckBox","Scorching", None, QApplication.UnicodeUTF8)))
        if aw.qmc.divots_flag:
            res.append(u(QApplication.translate("CheckBox","Divots", None, QApplication.UnicodeUTF8)))
        if len(res) > 0:
            return "\n<center><pre>" + ', '.join(res) + "</pre></center>"
        else:
            return ""

    def cuppingSum(self):
        score = 0.
        nflavors = len(self.qmc.flavors)
        for i in range(nflavors):   
            score += self.qmc.flavors[i]
        score /= (nflavors)
        score *= 10.
        return score

    def volume_weight2html(self,amount,out,unit,change):
        if amount:
            return str(amount) + unit + "<br/>" + str(out) + unit + " (" + "%.1f"%change + "%)"
        else:
            return "--"

    def phases2html(self,cp):
        dryphase = midphase = finishphase = coolphase = "--"
        if "totaltime" in cp:
            totaltime = cp["totaltime"]
            #dryphase
            if "dryphasetime" in cp:
                dryphasetime = cp["dryphasetime"]
                dryphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["dryphasetime"]),int(round(dryphasetime*100./totaltime)))
                if "dry_phase_ror" in cp:
                    dryphase += "<br/>%.1f deg/min"%cp["dry_phase_ror"]
                if "dry_phase_ts" in cp:
                    dryphase += "<br/>%d %sm"%(cp["dry_phase_ts"],self.qmc.mode)
                    if "dry_phase_ts_ET" in cp and "dry_phase_ts_BT" in cp:
                        dryphase += " [%d-%d]"%(cp["dry_phase_ts_ET"],cp["dry_phase_ts_BT"])
                    if "dryphaseeval" in cp:
                        dryphase += "<br/>" + cp["dryphaseeval"]
            #midphase
            if "midphasetime" in cp:
                midphasetime = cp["midphasetime"]
                midphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["midphasetime"]),int(round(midphasetime*100./totaltime)))
                if "mid_phase_ror" in cp:
                    midphase += "<br/>%.1f deg/min"%cp["mid_phase_ror"]
                if "mid_phase_ts" in cp:
                    midphase += "<br/>%d %sm"%(cp["mid_phase_ts"],self.qmc.mode)
                    if "mid_phase_ts_ET" in cp and "mid_phase_ts_BT" in cp:
                        midphase += " [%d-%d]"%(cp["mid_phase_ts_ET"],cp["mid_phase_ts_BT"])
                if "midphaseeval" in cp:
                    midphase += "<br/>" + cp["midphaseeval"]
            #finishphase
            if "finishphasetime" in cp:
                finishphasetime = cp["finishphasetime"]
                finishphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["finishphasetime"]),int(round(finishphasetime*100./totaltime)))
                if "finish_phase_ror" in cp:
                    finishphase += "<br/>%.1f deg/min"%cp["finish_phase_ror"]
                if "finish_phase_ts" in cp:
                    finishphase += "<br/>%d %sm"%(cp["finish_phase_ts"],self.qmc.mode)
                    if "finish_phase_ts_ET" in cp and "finish_phase_ts_BT" in cp:
                        finishphase += " [%d-%d]"%(cp["finish_phase_ts_ET"],cp["finish_phase_ts_BT"])
                if "finishphaseeval" in cp:
                    finishphase += "<br/>" + cp["finishphaseeval"]
            #coolphase
            if "coolphasetime" in cp:
                coolphasetime = cp["coolphasetime"]
                coolphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["coolphasetime"]),int(round(coolphasetime*100./totaltime)))
                if "coolphaseeval" in cp:
                    coolphase += "<br/>" + cp["coolphaseeval"]
        return dryphase, midphase, finishphase, coolphase

    def event2html(self,cp,time_key,BT_key=None,prev_time_key=None):
        res = "--"
        if prev_time_key and prev_time_key in cp and time_key in cp:
            res = self.qmc.stringfromseconds(cp[time_key]) + " (" + self.qmc.stringfromseconds(cp[time_key] - cp[prev_time_key]) + "m)"
        elif time_key in cp and BT_key in cp:
            res = self.qmc.stringfromseconds(cp[time_key])+ " (%.1f"%cp[BT_key] + "&deg;" + self.qmc.mode + ")"
        return res

    def specialevents2html(self):
        html = ""  
        if self.qmc.specialevents and len(self.qmc.specialevents) > 0:
            html += '<center>\n<table cellpadding="2">\n'
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
            else:
                start = 0
            # sort events by time/index
            sevents = sorted(self.qmc.specialevents)
            seventsString = []
            seventsType = [] 
            seventsValue = [] 
            for i in range(len(sevents)):
                sorted_pos = self.qmc.specialevents.index(sevents[i])
                seventsString.append(self.qmc.specialeventsStrings[sorted_pos])
                seventsType.append(self.qmc.specialeventstype[sorted_pos])
                seventsValue.append(self.qmc.specialeventsvalue[sorted_pos])
            for i in range(len(self.qmc.specialevents)):
                html += ("<tr>"+
                     "\n<td>" + str(i+1) + "</td><td>[" +
                     self.qmc.stringfromseconds(int(self.qmc.timex[sevents[i]] - start)) +
                     "</td><td>at " + "%.1f"%self.qmc.temp2[sevents[i]] + self.qmc.mode +
                     "]</td><td>" + seventsString[i] + "</td><td>(" + u(self.qmc.etypesf(seventsType[i])) + " to " + self.qmc.eventsvalues(seventsValue[i]) + ")</td></tr>\n")
            html += '</table>\n</center>'
        return html

    def note2html(self,notes):
        notes_html = ""
        for i in range(len(notes)):
            if ord(u(notes[i])) == 9:
                notes_html += " &nbsp&nbsp&nbsp&nbsp "
            elif u(notes[i]) == "\n":
                notes_html += "<br/>\n"
            else:           
                notes_html += u(notes[i])
        return notes_html

    #finds closest Bean Temperature in aw.qmc.temp2 given an input time. timex and temp2 always have same dimension
    def BTfromseconds(self,seconds):
        if len(self.qmc.timex):
            #find when input time crosses timex
            for i in range(len(self.qmc.timex)):
                if self.qmc.timex[i] > seconds:
                    break
            return float(self.qmc.temp2[i-1])           #return the BT temperature
        else:
            return 0.0

    #finds closest Environmental Temperature in aw.qmc.temp1 given an input time. timex and temp1 always have same dimension
    def ETfromseconds(self,seconds):
        if len(self.qmc.timex):
            #find when input time crosses timex
            for i in range(len(self.qmc.timex)):
                if self.qmc.timex[i] > seconds:
                    break
            return float(self.qmc.temp1[i-1])           #return the ET temperature
        else:
            return 0.0

    # converts times (values of timex) to indices
    def time2index(self,time):
        for i in range(len(self.qmc.timex)):
            if self.qmc.timex[i] > time:
                return i
        return -1

    #returns the index of the lowest point in BT; return -1 if no such value found
    def findTP(self):
        TP = 1000
        idx = 0
        start = 0
        end = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if EOR_index > start and EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[2]
        if FCs_index > start and FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0] 
        if SOR_index > start and SOR_index < end:
            start = SOR_index
        for i in range(end - 1, start -1, -1):
            if self.qmc.temp2[i] < TP:
                TP = self.qmc.temp2[i]
                idx = i
        return idx

    def defect_estimation_phase(self,phase_length,lower_limit,upper_limit,short_taste,optimal_taste,long_taste):
        result = optimal_taste
        third_of_optimal_phase = (upper_limit - lower_limit) / 3.0
        if phase_length < lower_limit:
            result = short_taste
        elif phase_length > upper_limit:
            result = long_taste
        elif phase_length < lower_limit + third_of_optimal_phase:
            result = short_taste + '/' + result
        elif phase_length > upper_limit - third_of_optimal_phase:
            result = result + '/' + long_taste
        return result

    #Flavor defect estimation chart for each leg. Thanks to Jim Schulman 
    def defect_estimation(self):
        dryphasetime = self.qmc.statisticstimes[1]
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        coolphasetime = self.qmc.statisticstimes[4]
        PerfectPhase = u(QApplication.translate("Flavor Scope Label", "OK",None, QApplication.UnicodeUTF8))
        ShortDryingPhase = u(QApplication.translate("Flavor Scope Label", "Grassy",None, QApplication.UnicodeUTF8))
        LongDryingPhase = u(QApplication.translate("Flavor Scope Label", "Leathery",None, QApplication.UnicodeUTF8))
        ShortTo1CPhase = u(QApplication.translate("Flavor Scope Label", "Toasty",None, QApplication.UnicodeUTF8))
        LongTo1CPhase = u(QApplication.translate("Flavor Scope Label", "Bready",None, QApplication.UnicodeUTF8))
        ShortFinishPhase = u(QApplication.translate("Flavor Scope Label", "Acidic",None, QApplication.UnicodeUTF8))
        LongFinishPhase = u(QApplication.translate("Flavor Scope Label", "Flat",None, QApplication.UnicodeUTF8))
        ShortCoolPhase = u(QApplication.translate("Flavor Scope Label", "Fracturing",None, QApplication.UnicodeUTF8))
        PerfectCoolPhase = u(QApplication.translate("Flavor Scope Label", "Sweet",None, QApplication.UnicodeUTF8))
        LongCoolPhase = u(QApplication.translate("Flavor Scope Label", "Less Sweet",None, QApplication.UnicodeUTF8))
        #CHECK CONDITIONS
        #if dry phase time < 3 mins (180 seconds) or less than 26% of the total time
        #  => ShortDryingPhase
        #if dry phase time > 6 mins or more than 40% of the total time
        #  => LongDryingPhase
        st1 = self.defect_estimation_phase(dryphasetime,self.qmc.statisticsconditions[0],self.qmc.statisticsconditions[1],ShortDryingPhase,PerfectPhase,LongDryingPhase)
        #if mid phase time < 5 minutes
        #  => ShortTo1CPhase
        #if mid phase time > 10 minutes
        #  => LongTo1CPhase
        st2 = self.defect_estimation_phase(midphasetime,self.qmc.statisticsconditions[2],self.qmc.statisticsconditions[3],ShortTo1CPhase,PerfectPhase,LongTo1CPhase)
        #if finish phase is less than 3 mins
        #  => ShortFinishPhase
        #if finish phase is over 6 minutes
        #  => LongFinishPhase
        st3 = self.defect_estimation_phase(finishphasetime,self.qmc.statisticsconditions[4],self.qmc.statisticsconditions[5],ShortFinishPhase,PerfectPhase,LongFinishPhase)
        #if cool phase is less than 2 mins
        #  => ShortCoolPhase
        #if cool phase is over 4 minutes
        #  => LongCoolPhase
        st4 = self.defect_estimation_phase(coolphasetime,self.qmc.statisticsconditions[6],self.qmc.statisticsconditions[7],ShortCoolPhase,PerfectCoolPhase,LongCoolPhase)
        return (st1,st2,st3,st4)

    #returns the index of the end of the dry phase (returns -1 if dry end cannot be determined)
    #if given, starts at TP_index and looks forward, otherwise it looks backwards from end of roast (EoR)
    #find index with smallest abs() difference between aw.qmc.phases[1] and BT (temp2)
    def findDryEnd(self,TP_index=None):
        sd = 1000
        nsd = 1000
        index = 0
        start = 0
        end = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if EOR_index > start and EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[6]
        if FCs_index > start and FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0] 
        if SOR_index > start and SOR_index < end:
            start = SOR_index
        # try to consider only indices from TP of roast on and not before
        TP = TP_index
        # if TP not yet computed, let's try to compute it
        if TP == None:
            TP = self.findTP()
        if TP > start and TP < end:
            start = TP
        for i in range(end -1, start -1, -1):
            nsd = abs(self.qmc.temp2[i]- self.qmc.phases[1])
            if nsd < sd:
                sd = nsd
                index = i
        return index

    # returns True if a BT break at i-2 is detected
    def BTbreak(self,i):
        if len(self.qmc.timex)>4 and i < len(self.qmc.timex):
            d1 = self.qmc.temp2[i-4] - self.qmc.temp2[i-3]
            d2 = self.qmc.temp2[i-3] - self.qmc.temp2[i-2]
            d3 = self.qmc.temp2[i-1] - self.qmc.temp2[i-2]
            d4 = self.qmc.temp2[i] - self.qmc.temp2[i-1]
            d = (abs(d1) + abs(d2)) / 2.0
            if d > 0 and d3 < 0 and d4 < 0 and ((abs(d3) + abs(d4)) / 2.0) > 2.0*d:
                return True
            else:
                return False
        else:
            return False

    # this can be used to find the CHARGE index as well as the DROP index by using
    # 0 or the DRY index as start index, respectively
    def findBTbreak(self,start_index=0,end_index=0):
        result = 0        
        # determine average deltaBT wrt. the two previous measurements
        # the deltaBT values wrt. the next two measurements must by twice as high and negative
        # then our current measurement is the one of CHARGE/DROP
        for i in range(start_index,len(self.qmc.timex)):
            if end_index and i > end_index:
                break
            if i>3:
                if self.BTbreak(i):
                    result = i - 2
                    break
        return result

    #calculate the AREA under BT and ET
    def ts(self,start=None,end=None):
        delta = ET = BT = 0.0
        if (start == 0 and end == 0) or (start and (start < 0 or (start == 0 and self.qmc.timeindex[0] < 0))):
            return 0,0,0
        else:
            try:
                for i in range((start or self.qmc.timeindex[0]),min(len(self.qmc.timex)-1,(end or self.qmc.timeindex[6]))):
                    e = (self.qmc.temp1[i] + self.qmc.temp1[i+1]) / 2.0
                    b = (self.qmc.temp2[i] + self.qmc.temp2[i+1]) / 2.0
                    dt = (self.qmc.timex[i+1] - self.qmc.timex[i])
                    delta += (e - b) * dt
                    ET += e * dt
                    BT += b * dt
            except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ts() %1").arg(str(e)),exc_tb.tb_lineno)
            return round(delta/60), round(ET/60), round(BT/60)                

    #Find rate of change of each phase. TP_index (by aw.findTP()) is the index of the TP and dryEndIndex that of the end of drying (by aw.findDryEnd())
    #Note: For the dryphase, the RoR for the dryphase is calculated for the segment starting from TP ending at DE
    def RoR(self,TP_index,dryEndIndex):
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        BTdrycross = None
        rc1 = rc2 = rc3 = 0.
        if dryEndIndex > -1 and dryEndIndex < len(self.qmc.temp2):
            BTdrycross = self.qmc.temp2[dryEndIndex]
        if BTdrycross and TP_index < 1000 and TP_index > -1 and dryEndIndex and TP_index < len(self.qmc.temp2):
            LP = self.qmc.temp2[TP_index]
            #avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[TP_index]
            if divisor:   
                rc1 = ((BTdrycross - LP) / divisor)*60.
            else:
                rc1 = 0
        if self.qmc.timeindex[2]:
            if midphasetime and BTdrycross:
                rc2 = ((self.qmc.temp2[self.qmc.timeindex[2]] - BTdrycross)/midphasetime)*60.
            if finishphasetime:
                rc3 = ((self.qmc.temp2[self.qmc.timeindex[6]]- self.qmc.temp2[self.qmc.timeindex[2]])/finishphasetime)*60.
        return (rc1,rc2,rc3)

    def viewErrorLog(self):
        error = errorDlg(self)
        error.show()

    def viewSerialLog(self):
        serialDLG = serialLogDlg(self)
        serialDLG.show()
        
    def viewartisansettings(self):
        settingsDLG = artisansettingsDlg(self)
        settingsDLG.show()

    def viewplatform(self):
        platformDLG = platformDlg(self)
        platformDLG.show()

    def viewMessageLog(self):
        message = messageDlg(self)
        message.show()

    def helpAbout(self):
        coredevelopers = "<br>Rafael Cobo <br> Marko Luther <br> Sebastien Delgrande"
        contributors =  u("<br>") + u(QApplication.translate("About", "%1, linux binary",None, QApplication.UnicodeUTF8).arg("Lukas Kolbe"))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, documentation",None, QApplication.UnicodeUTF8).arg("Rich Helms"))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, TEVA18B, DTA support",None, QApplication.UnicodeUTF8).arg("Markus Wagner"))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, DTA support",None, QApplication.UnicodeUTF8).arg("Markus Mayr-Svec"))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, Swedish localization",None, QApplication.UnicodeUTF8).arg("Martin Kral"))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, Spanish localization",None, QApplication.UnicodeUTF8).arg("Bluequijote"))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, Arduino/TC4",None, QApplication.UnicodeUTF8).arg("Jim G."))
        contributors += u("<br>") + u(QApplication.translate("About", "%1, Arduino/TC4",None, QApplication.UnicodeUTF8).arg("Marcio Carneiro"))
        box = QMessageBox(self)
        #create a html QString
        box.about(self,
                QApplication.translate("About", "About",None, QApplication.UnicodeUTF8),
                u("""<b>{0}</b> {1} ({2})
                <p>
                <b>Python:</b> [ {3} ]
                <b>Qt:</b> [ {4} ]
                <b>PyQt:</b> [ {5} ]
                <b>OS:</b/>[ {6} ]
                </p>
                <p>
                <b>{7}</b> {8}
                </p>
                <p>
                <b>{9}</b> {10}
                </p>""").format(
                QApplication.translate("About", "Version:",None, QApplication.UnicodeUTF8),
                str(__version__),
                str(__revision__),
                platform.python_version(),
                QT_VERSION_STR,
                PYQT_VERSION_STR,
                platf,
                QApplication.translate("About", "Core developers:",None, QApplication.UnicodeUTF8),
                coredevelopers,
                QApplication.translate("About", "Contributors:",None, QApplication.UnicodeUTF8),
                contributors))

    def helpHelp(self):
        QDesktopServices.openUrl(QUrl("http://coffeetroupe.com/artisandocs/", QUrl.TolerantMode))

    def applicationscreenshot(self):
        imag = QPixmap().grabWidget(self)
#        imag = self.grab()
        fmt = 'png'
        initialPath = QDir.currentPath() + "/ArtisanScreenshot." + fmt
        fileName = QFileDialog.getSaveFileName(self, "Artisan ScreenShot",
                initialPath,
                "%s Files (*.%s);;All Files (*)"%(fmt.upper(),fmt))
        if fileName:
            imag.save(fileName, fmt) 

    def retrieveWeightIn(self):
        v = aw.scale.readWeight() # read value from weight in 'g'
        if v and v > -1:
            if aw.qmc.weight[2] != 'g':
                v = v / 1000.0
            aw.qmc.weight[0] = v
            aw.qmc.weight[1] = 0

    def retrieveWeightOut(self):
        v = aw.scale.readWeight() # read value from weight in 'g'
        if v and v > -1:
            if aw.qmc.weight[2] != 'g':
                v = v / 1000.0
            if aw.qmc.weight[0] > v:
                aw.qmc.weight[1] = v

    def desktopscreenshot(self):
        imag = QPixmap.grabWindow(QApplication.desktop().winId())
        fmt = 'png'
        initialPath = QDir.currentPath() + "/DesktopScreenshot." + fmt
        fileName = QFileDialog.getSaveFileName(self, "Desktop ScreenShot",
                initialPath,
                "%s Files (*.%s);;All Files (*)"%(fmt.upper(),fmt))
        if fileName:
            imag.save(fileName, fmt)

    def calibratedelay(self):
        calSpinBox = QDoubleSpinBox()
        calSpinBox.setRange(1.,30.)
        calSpinBox.setValue(self.qmc.delay/1000.)
        calSpinBox.setAlignment(Qt.AlignRight)
        secondsdelay, ok = QInputDialog.getDouble(self,
                QApplication.translate("Message", "Sampling Interval",None, QApplication.UnicodeUTF8),
                QApplication.translate("Message", "Seconds",None, QApplication.UnicodeUTF8),
                calSpinBox.value(),1.,30.)
        if ok:
            self.qmc.delay = int(secondsdelay*1000.)

    def setcommport(self):
        dialog = comportDlg(self)
        if dialog.exec_():
            # set serial port
            self.ser.comport = str(dialog.comportEdit.currentText())                #unicode() changes QString to a python string
            self.ser.baudrate = int(str(dialog.baudrateComboBox.currentText()))              #int changes QString to int
            self.ser.bytesize = int(str(dialog.bytesizeComboBox.currentText()))
            self.ser.stopbits = int(str(dialog.stopbitsComboBox.currentText()))
            self.ser.parity = str(dialog.parityComboBox.currentText())
            self.ser.timeout = int(str(dialog.timeoutEdit.text()))
            # set modbus port
            self.modbus.comport = str(dialog.modbus_comportEdit.currentText())                #unicode() changes QString to a python string
            self.modbus.baudrate = int(str(dialog.modbus_baudrateComboBox.currentText()))              #int changes QString to int
            self.modbus.bytesize = int(str(dialog.modbus_bytesizeComboBox.currentText()))
            self.modbus.stopbits = int(str(dialog.modbus_stopbitsComboBox.currentText()))
            self.modbus.parity = str(dialog.modbus_parityComboBox.currentText())
            self.modbus.timeout = int(str(dialog.modbus_timeoutEdit.text()))
            self.modbus.input1slave = int(str(dialog.modbus_input1slaveEdit.text()))
            self.modbus.input1register = int(str(dialog.modbus_input1registerEdit.text()))
            self.modbus.input1code = int(str(dialog.modbus_input1code.currentText()))
            self.modbus.input1float = bool(dialog.modbus_input1float.isChecked())            
            self.modbus.input2slave = int(str(dialog.modbus_input2slaveEdit.text()))
            self.modbus.input2register = int(str(dialog.modbus_input2registerEdit.text()))
            self.modbus.input2code = int(str(dialog.modbus_input2code.currentText()))
            self.modbus.input2float = bool(dialog.modbus_input2float.isChecked())     
            self.modbus.input3slave = int(str(dialog.modbus_input3slaveEdit.text()))
            self.modbus.input3register = int(str(dialog.modbus_input3registerEdit.text()))
            self.modbus.input3code = int(str(dialog.modbus_input3code.currentText()))
            self.modbus.input3float = bool(dialog.modbus_input3float.isChecked())     
            self.modbus.input4slave = int(str(dialog.modbus_input4slaveEdit.text()))
            self.modbus.input4register = int(str(dialog.modbus_input4registerEdit.text()))
            self.modbus.input4code = int(str(dialog.modbus_input4code.currentText()))
            self.modbus.input4float = bool(dialog.modbus_input4float.isChecked())
            self.modbus.littleEndianFloats = bool(dialog.modbus_littleEndianFloats.isChecked())
            # switch to little-endian if needed (HACK!!)
            if self.modbus.littleEndianFloats:
                minimalmodbus._bytestringToFloat = littleEndianBytestringToFloat
            else:
                minimalmodbus._bytestringToFloat = bigEndianBytestringToFloat
            # set scale port
            self.scale.device = str(dialog.scale_deviceEdit.currentText())                #unicode() changes QString to a python string
            try:
                self.scale.device_id = list(aw.scale.devicefunctionlist.keys()).index(self.scale.device)
            except Exception as ex:
                self.scale.device_id = 0
            self.scale.comport = str(dialog.scale_comportEdit.currentText())                #unicode() changes QString to a python string
            self.scale.baudrate = int(str(dialog.scale_baudrateComboBox.currentText()))              #int changes QString to int
            self.scale.bytesize = int(str(dialog.scale_bytesizeComboBox.currentText()))
            self.scale.stopbits = int(str(dialog.scale_stopbitsComboBox.currentText()))
            self.scale.parity = str(dialog.scale_parityComboBox.currentText())
            self.scale.timeout = int(str(dialog.scale_timeoutEdit.text()))

    def PIDcontrol(self):
        #pid
        if self.qmc.device == 0 or self.qmc.device == 26:
            if self.ser.controlETpid[0] == 0:
                dialog = PXG4pidDlgControl(self)
            elif self.ser.controlETpid[0] == 1:
                dialog = PXRpidDlgControl(self)
            elif self.ser.controlETpid[0] == 2:
                dialog = DTApidDlgControl(self)
            #modeless style dialog 
            dialog.show()
        #arduino
#        elif self.qmc.device == 19:
#            dialog = ArduinoDlgControl(self)
#            #modeless style dialog 
#            dialog.show()

    def deviceassigment(self):
        dialog = DeviceAssignmentDlg(self)
        dialog.show()

    def showstatistics(self):
        dialog = StatisticsDlg(self)
        dialog.show()
        
    def Windowconfig(self):
        dialog = WindowsDlg(self)
        dialog.show()
        
    def autosaveconf(self):
        dialog = autosaveDlg(self)
        dialog.show()

    def calculator(self):
        dialog = calculatorDlg(self)
        dialog.show()

    def graphwheel(self):
        wheeldialog = WheelDlg(self)
        wheeldialog.show()

    def background(self):
        dialog = backgroundDlg(self)
        dialog.show()

    def flavorchart(self):
        dialog = flavorDlg(self)
        dialog.show()

    def designerTriggered(self):
        if self.qmc.designerflag:
            self.stopdesigner()
        else:
            self.startdesigner()

    def startdesigner(self):
        self.qmc.designer()

    def stopdesigner(self):
        self.qmc.reset()

    def editgraph(self):
        editgraphdialog = editGraphDlg(self)
        editgraphdialog.show()

    def editphases(self):
        dialog = phasesGraphDlg(self)
        dialog.show()
        
    def eventsconf(self):
        dialog = EventsDlg(self)
        dialog.exec_()

    def alarmconfig(self):
        if self.qmc.device != 18:
            dialog = AlarmDlg(self)
            dialog.show()
        else:
            QMessageBox.information(self,QApplication.translate("Message", "Alarm Config",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("Message", "Alarms are not available for device None",None, QApplication.UnicodeUTF8))

    def changelocale(self,languagelocale):
        settings = QSettings()
        settings.setValue('locale', languagelocale)
        QMessageBox.information(self,QApplication.translate("Message", "Switch Language",None, QApplication.UnicodeUTF8),
                                QApplication.translate("Message","Language successfully changed. Restart the application.",None, QApplication.UnicodeUTF8))

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    def weight_loss(self,green,roasted):
        if float(green) == 0.0 or float(green) < float(roasted):
            return 0.
        else:
            return 100. * ((float(green) - float(roasted)) / float(green))

    # from RoastMagazine (corrected by substracting 1% based on experience)
    # http://www.roastmagazine.com/resources/Roasting101_Articles/Roast_SeptOct05_LightRoasting.pdf
    def roast_degree(self,percent):
        if percent < 13.5:
            return ""
        elif percent < 14.5:
            return u(QApplication.translate("Label", "City",None, QApplication.UnicodeUTF8))
        elif percent < 15.5:
            return u(QApplication.translate("Label", "City+",None, QApplication.UnicodeUTF8))
        elif percent < 16.5:
            return u(QApplication.translate("Label", "Full City",None, QApplication.UnicodeUTF8))
        elif percent < 17.5:
            return u(QApplication.translate("Label", "Full City+",None, QApplication.UnicodeUTF8))
        elif percent < 18.5:
            return u(QApplication.translate("Label", "Light French",None, QApplication.UnicodeUTF8))
        else:
            return u(QApplication.translate("Label", "French",None, QApplication.UnicodeUTF8))

    def importK202(self):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import K202 CSV",None, QApplication.UnicodeUTF8))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                csvReader = csv.DictReader(csvFile,["Date","Time","T1","T1unit","T2","T2unit"],delimiter='\t')
                zero_t = None
                roastdate = None
                unit = None
                for item in csvReader:
                    try:
                        #set date
                        if not roastdate:
                            roastdate = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            self.qmc.roastdate = roastdate
                        #set zero
                        if not zero_t:
                            date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            zero = QDateTime()
                            zero.setDate(date)
                            zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            zero_t = zero.toTime_t()
                        #set temperature mode
                        if not unit:
                            unit = item['T1unit']
                            if unit == "F" and self.qmc.mode == "C":
                                self.qmc.fahrenheitMode()
                            if unit == "C" and self.qmc.mode == "F":
                                self.qmc.celsiusMode()
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        self.qmc.timex.append(float(dt.toTime_t() - zero_t))
                        self.qmc.temp1.append(float(item['T1'].replace(',','.')))
                        self.qmc.temp2.append(float(item['T2'].replace(',','.')))
                    except ValueError:
                        pass
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.sendmessage(QApplication.translate("Message","K202 file loaded successfully", None, QApplication.UnicodeUTF8))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " importK202(): %1").arg(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " importK202(): %1").arg(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importK202() %1").arg(str(ex)),exc_tb.tb_lineno)

    def importK204(self):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import K204 CSV",None, QApplication.UnicodeUTF8))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                csvReader = csv.DictReader(csvFile,["Date","Time","T1","T2","T3","T4"],delimiter='\t')
                zero_t = None
                roastdate = None
                # we add an extra device if needed
                if len(self.qmc.extradevices) == 0:
                    self.addDevice()
                for item in csvReader:
                    try:
                        #set date
                        if not roastdate:
                            roastdate = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            self.qmc.roastdate = roastdate
                        #set zero
                        if not zero_t:
                            date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            zero = QDateTime()
                            zero.setDate(date)
                            zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            zero_t = zero.toTime_t()
    # The K204 export does not contain a trace of the temperature mode.
    # We have to assume here that the mode was set correctly before the import.
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        tx = float(dt.toTime_t() - zero_t)
                        self.qmc.timex.append(tx)
                        t1 = float(item['T1'].replace(',','.'))
                        if t1 > 800 or t1 < 0.0:
                            t1 = 0.0
                        self.qmc.temp1.append(t1)
                        t2 = float(item['T2'].replace(',','.'))
                        if t2 > 800 or t2 < 0.0:
                            t2 = 0.0
                        self.qmc.temp2.append(t2)
                        if len(self.qmc.extradevices) > 0:
                            self.qmc.extratimex[0].append(tx)
                            t3 = float(item['T3'].replace(',','.'))
                            if t3 > 800 or t3 < 0.0:
                                t3 = 0.0
                            self.qmc.extratemp1[0].append(t3)
                            t4 = float(item['T4'].replace(',','.'))
                            if t4 > 800 or t4 < 0.0:
                                t2 = 0.0
                            self.qmc.extratemp2[0].append(t4)
                    except ValueError:
                        pass
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.sendmessage(QApplication.translate("Message","K204 file loaded successfully", None, QApplication.UnicodeUTF8))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " importK204(): %1").arg(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " importK204(): %1").arg(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importK204() %1").arg(str(ex)),exc_tb.tb_lineno)

    def importHH506RA(self):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import HH506RA CSV", None, QApplication.UnicodeUTF8))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                data = csv.reader(csvFile,delimiter='\t')
                #read file header
                header = next(data)
                zero = QDateTime()
                date = QDate.fromString(header[0].split('Date:')[1],"yyyy'/'MM'/'dd")
                self.qmc.roastdate = date
                zero.setDate(date)
                zero.setTime(QTime.fromString(header[1].split('Time:')[1],"hh':'mm':'ss"))
                zero_t = zero.toTime_t()
                #read column headers
                fields = next(data)
                unit = None
                #read data
                for row in data:
                    items = list(zip(fields, row))
                    item = {}
                    for (name, value) in items:
                        item[name] = value.strip()
                    #set temperature mode
                    if not unit:
                        unit = item['Unit']
                        if unit == "F" and self.qmc.mode == "C":
                            self.qmc.fahrenheitMode()
                        if unit == "C" and self.qmc.mode == "F":
                            self.qmc.celsiusMode()
                    #add one measurement
                    dt = QDateTime()
                    dt.setDate(QDate.fromString(item['Date'],"yyyy'/'MM'/'dd"))
                    dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                    self.qmc.timex.append(float(dt.toTime_t() - zero_t))
                    self.qmc.temp1.append(float(item['T1']))
                    self.qmc.temp2.append(float(item['T2']))
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.sendmessage(QApplication.translate("Message","HH506RA file loaded successfully", None, QApplication.UnicodeUTF8))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " importHH506RA(): %1").arg(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " importHH506RA(): %1").arg(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importHH506RA() %1").arg(str(ex)),exc_tb.tb_lineno)
            

    #checks or creates directory structure
    def dirstruct(self):
        currentdir = QDir().current()     #selects the current dir
        if not currentdir.exists(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8)):
            currentdir.mkdir(QApplication.translate("Directory","profiles",None, QApplication.UnicodeUTF8))
        #check/create 'other' directory inside profiles/
        otherpath = QString(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8) + "/" + QApplication.translate("Directory","other", None, QApplication.UnicodeUTF8))
        if not currentdir.exists(otherpath):
            currentdir.mkdir(otherpath)
        #find current year,month
        date =  QDate.currentDate()
        #check / create year dir 
        yearpath = QString(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8) + "/" + str(date.year()))
        if not currentdir.exists(yearpath):
            currentdir.mkdir(yearpath)
        #check /create month dir to store profiles
        monthpath = QString(QApplication.translate("Directory","profiles", None, QApplication.UnicodeUTF8) + "/" + str(date.year()) + "/" + str(date.month()))
        if not currentdir.exists(monthpath):
            currentdir.mkdir(monthpath)
        if len(self.profilepath) == 0:
            self.profilepath = monthpath

    #resizes and saves graph to a new width w 
    def resize(self,w,transformationmode):
        try: 
            image = QPixmap.grabWidget(aw.qmc)
#            image = aw.qmc.grab()
            if w != 0:
                image = image.scaledToWidth(w,transformationmode)
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as PNG", None, QApplication.UnicodeUTF8),ext="*.png")
            if filename:
                if ".png" not in filename:
                    filename += ".png"
                image.save(filename)
                x = image.width()
                y = image.height()
                self.sendmessage(QApplication.translate("Message","%1  size(%2,%3) saved", None, QApplication.UnicodeUTF8).arg(str(filename)).arg(str(x)).arg(str(y)))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " resize() %1").arg(str(ex)))
    
    def saveVectorGraph(self,extension=".pdf"):
        try: 
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as SVG", None, QApplication.UnicodeUTF8),ext=extension)
            if filename:
                if extension not in filename:
                    filename += extension
                aw.qmc.fig.savefig(filename)
                self.sendmessage(QApplication.translate("Message","%1 saved", None, QApplication.UnicodeUTF8).arg(str(filename)))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " saveVectorGraph() %1").arg(str(ex)))

    #displays Dialog for the setting of the HUD
    def hudset(self):
        hudDl = HUDDlg(self)
        hudDl.show()

    def showHUDmetrics(self):
        if self.qmc.hudresizeflag:
            #turn off
            self.qmc.toggleHUD()
            #turn back ON to adquire new size
            self.qmc.toggleHUD()
            self.qmc.hudresizeflag = False
        ETreachTime,BTreachTime,ET2reachTime,BT2reachTime = self.qmc.getTargetTime()
        if ETreachTime > 0 and ETreachTime < 2000:
            text1 = u(QApplication.translate("Label","%1 to reach ET target %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(ETreachTime))).arg(str(self.qmc.ETtarget) + self.qmc.mode))
            if self.qmc.timeindex[0]:
                text1 = text1 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+ETreachTime))))
        else:
            text1 = u(QApplication.translate("Label","%1 to reach ET target %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.ETtarget) + self.qmc.mode))
        if ET2reachTime > 0 and ET2reachTime < 2000:
            text2 = u(QApplication.translate("Label","%1 to reach ET target %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(ET2reachTime))).arg(str(self.qmc.ET2target) + self.qmc.mode))
            if self.qmc.timeindex[0]:
                text2 = text2 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+ET2reachTime))))
        else:
            text2 = u(QApplication.translate("Label","%1 to reach ET target %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.ET2target) + self.qmc.mode))
        if BTreachTime > 0 and BTreachTime < 2000:    
            text3 = u(QApplication.translate("Label","%1 to reach BT target %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(BTreachTime))).arg(str(self.qmc.BTtarget) + self.qmc.mode))
            if self.qmc.timeindex[0]:
                text3 = text2 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+BTreachTime))))
        else:
            text3 = u(QApplication.translate("Label","%1 to reach BT target %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.BTtarget) + self.qmc.mode))
        if BT2reachTime > 0 and BT2reachTime < 2000:
            text4 = u(QApplication.translate("Label","%1 to reach BT target %2", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(BT2reachTime))).arg(str(self.qmc.BT2target) + self.qmc.mode))
            if self.qmc.timeindex[0]:
                text4 = text4 + u(QApplication.translate("Label"," at %1", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+BT2reachTime))))        
        else:
            text4 = u(QApplication.translate("Label","%1 to reach BT target %2", None, QApplication.UnicodeUTF8).arg("xx:xx").arg(str(self.qmc.BT2target) + self.qmc.mode))
        ####  Phase Texts #####
        phasetext1 = u("") # lower textline
        phasetext2 = u("") # higher textline
        if self.qmc.timeindex[2]: # after FCs
            FCs_time = self.qmc.timex[self.qmc.timeindex[2]]
            afterFCs = self.qmc.timex[-1] - FCs_time
            phasetext1 = u(QApplication.translate("Label","%1 after FCs", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(afterFCs))))
        if self.qmc.timeindex[3]: # after FCe
            FCe_time = self.qmc.timex[self.qmc.timeindex[3]]
            afterFCe = self.qmc.timex[-1] - FCe_time
            phasetext2 = u(QApplication.translate("Label","%1 after FCe", None, QApplication.UnicodeUTF8).arg(self.qmc.stringfromseconds(int(afterFCe))))
            if self.qmc.timeindex[2]:
                phasetext2 = phasetext2 + u(" (") + u(self.qmc.stringfromseconds(int(FCe_time - self.qmc.timex[self.qmc.timeindex[2]]))) + u(" FC)")
        ####   ET pid    ######
        error = self.qmc.ETtarget - self.qmc.temp1[-1]
        differror = error - self.qmc.pidpreviouserror
        difftime = self.qmc.timex[-1] - self.qmc.timex[-2]
        if not difftime: difftime = 0.01
        proportionalterm = self.qmc.hudETpid[0]*error
        integralterm = self.qmc.hudETpid[1]*differror*difftime
        derivativeterm = self.qmc.hudETpid[2]*differror/difftime
        self.qmc.pidpreviouserror = error
        MV = proportionalterm + integralterm + derivativeterm   # Manipulated Variable
        if MV > 100.:MV = 100.
        elif MV < 0.:MV = 0.
        MVV = int(round(MV))
        pidstring = "ET pid = %i "%MVV
        ##### end of ET pid
        img = QPixmap().grabWidget(self.qmc)
#        img = self.qmc.grab()
        Wwidth = self.qmc.size().width()
        Wheight = self.qmc.size().height()
        #Draw begins
        p = QPainter(img)
        #chose font
        font = QFont('Utopia', 14, -1)
        p.setFont(font)
        p.setOpacity(0.8)
        p.setPen(QColor("slategrey"))
        p.drawText(QPoint(Wwidth/7,Wheight - Wheight/4.5),QString(text1))
        p.drawText(QPoint(Wwidth/7,Wheight - Wheight/5.3),QString(text2))
        p.drawText(QPoint(Wwidth/7,Wheight - Wheight/6.6),QString(text3))
        p.drawText(QPoint(Wwidth/7,Wheight - Wheight/8.5),QString(text4))
        #draw pid
        p.drawText(QPoint(Wwidth/7,Wheight - Wheight/3),QString(pidstring))
        p.drawRect(Wwidth/7+140, Wheight - Wheight/3-12, 100, 12)
        p.fillRect(Wwidth/7+140, Wheight - Wheight/3-12, MVV, 12, QColor("pink"))
        delta = u(QApplication.translate("Label","ET - BT = %1", None, QApplication.UnicodeUTF8).arg("%.1f"%(self.qmc.temp1[-1] - self.qmc.temp2[-1])))
        p.drawText(QPoint(Wwidth/7,Wheight - Wheight/3.5),QString(delta))
        #draw phase texts
        p.drawText(QPoint(Wwidth/2 + 100,Wheight - Wheight/6),QString(phasetext1))
        p.drawText(QPoint(Wwidth/2 + 100,Wheight - Wheight/8),QString(phasetext2))
        p.end()
        self.HUD.setPixmap(img)

    def showHUDthermal(self):
        if self.qmc.hudresizeflag:
            #turn off
            self.qmc.toggleHUD()
            #turn back ON to adquire new size
            self.qmc.toggleHUD()
            self.qmc.hudresizeflag = False
        img = QPixmap().grabWidget(self.qmc)
#        img = self.qmc.grab()
        p = QPainter(img)
        Wwidth= self.qmc.size().width()
        Wheight = self.qmc.size().height()
        p.setOpacity(1)
        p.setPen(QColor(96,255,237)) #color the rectangle the same as HUD button
        p.drawRect(10,10, Wwidth - 20, Wheight - 20)
        if self.qmc.mode == "F" and self.qmc.temp1:
            ETradius = int(self.qmc.temp1[-1]/3)
            BTradius = int(self.qmc.temp2[-1]/3)
        elif self.qmc.mode == "C" and self.qmc.temp1:
            ETradius = int(self.qmc.fromCtoF(self.qmc.temp1[-1]/3))
            BTradius = int(self.qmc.fromCtoF(self.qmc.temp2[-1]/3))
        else:
            ETradius = 50
            BTradius = 50
        Tradius = 300
        p.setOpacity(0.5)
        g = QRadialGradient(Wwidth/2, Wheight/2, ETradius)
        beanbright =  100 - ETradius
        if beanbright < 0: beanbright = 0
        g.setColorAt(0.0, QColor(240,255,beanbright))  #bean center
        g.setColorAt(.5, Qt.yellow)
        g.setColorAt(.8, Qt.red)
        g.setColorAt(1.,QColor("lightgrey"))
        p.setBrush(QBrush(g))
        #draw thermal circle
        p.setPen(0)
        p.drawEllipse(Wwidth/2 -Tradius/2 , Wheight/2 - Tradius/2 , Tradius,Tradius)
        #draw ET circle
        p.setBrush(0)
        p.setPen(QColor("black"))
        p.drawEllipse(Wwidth/2 -ETradius/2 , Wheight/2 - ETradius/2 , ETradius,ETradius)
        #draw BT circle
        p.drawEllipse(Wwidth/2 -BTradius/2 , Wheight/2 - BTradius/2 , BTradius,BTradius)
        delta = QApplication.translate("Label","ET - BT = %1%2", None, QApplication.UnicodeUTF8).arg("%.1f"%(self.qmc.temp1[-1] - self.qmc.temp2[-1])).arg(self.qmc.mode)
        p.setFont(QFont('Utopia', 14, -1))
        p.drawText(QPoint(Wwidth/2,Wheight/2),QString(delta))
        p.end()
        self.HUD.setPixmap(img)

    #used by WheelGraphDlg()
    #wrap values in unicode(.) if and only if those are of type string
    def getWheelGraph(self):
        wheel = {}
        #convert labels to unicode
        for i in range(len(self.qmc.wheelnames)):
            for x in range(len(self.qmc.wheelnames[i])):
                self.qmc.wheelnames[i][x]= u(self.qmc.wheelnames[i][x])
        #two dimension lists        
        wheel["wheelnames"] = self.qmc.wheelnames
        wheel["segmentlengths"] = self.qmc.segmentlengths
        wheel["segmentsalpha"] = self.qmc.segmentsalpha
        wheel["wradii"] = self.qmc.wradii
        wheel["startangle"] = self.qmc.startangle
        wheel["projection"] = self.qmc.projection
        wheel["wheeltextsize"] = self.qmc.wheeltextsize 
        wheel["wheelcolor"] = self.qmc.wheelcolor
        wheel["wheelparent"] = self.qmc.wheellabelparent
        wheel["wheeledge"] = self.qmc.wheeledge
        wheel["wheellinewidth"] = self.qmc.wheellinewidth
        wheel["wheellinecolor"] = self.qmc.wheellinecolor
        wheel["wheelaspect"] = self.qmc.wheelaspect
        return wheel  

    def loadWheel(self,filename):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                wheel = self.deserialize(filename)
                self.qmc.wheelnames = wheel["wheelnames"]
                self.qmc.segmentlengths = wheel["segmentlengths"]
                self.qmc.segmentsalpha = wheel["segmentsalpha"]
                self.qmc.wradii = wheel["wradii"]
                self.qmc.startangle = wheel["startangle"]
                self.qmc.projection = wheel["projection"]
                self.qmc.wheeltextsize = wheel["wheeltextsize"] 
                self.qmc.wheelcolor = wheel["wheelcolor"]
                self.qmc.wheellabelparent = wheel["wheelparent"]
                self.qmc.wheeledge = wheel["wheeledge"]
                self.qmc.wheellinewidth = wheel["wheellinewidth"]
                self.qmc.wheellinecolor = wheel["wheellinecolor"]
                if "wheelaspect" in wheel:
                    self.qmc.wheelaspect = wheel["wheelaspect"]
                else:
                    self.qmc.wheelaspect = 1.0   
            else:
                message = QApplication.translate("Message","Invalid Wheel graph format", None, QApplication.UnicodeUTF8)
                self.sendmessage(message)
                return
            message =QApplication.translate("Message","Wheel Graph succesfully open", None, QApplication.UnicodeUTF8)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " loadWheel() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except ValueError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None, QApplication.UnicodeUTF8) + " loadWheel() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None, QApplication.UnicodeUTF8) + " loadWheel() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()

    def showSymbolicHelp(self):
        string1 = "<UL><LI><b>abs(x)</b> " + u(QApplication.translate("Message","Return the absolute value of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>acos(x)</b> " + u(QApplication.translate("Message","Return the arc cosine (measured in radians) of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>asin(x)</b> " + u(QApplication.translate("Message","Return the arc sine (measured in radians) of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>atan(x)</b> " + u(QApplication.translate("Message","Return the arc tangent (measured in radians) of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>cos(x)</b> " + u(QApplication.translate("Message","Return the cosine of x (measured in radians).",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>degrees(x)</b> " + u(QApplication.translate("Message", "Convert angle x from radians to degrees.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>exp(x)</b> " + u(QApplication.translate("Message", "Return e raised to the power of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>log(x[, base])</b> " + u(QApplication.translate("Message", "Return the logarithm of x to the given base. ",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>log10(x)</b> " + u(QApplication.translate("Message", "Return the base 10 logarithm of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>pow(x, y)</b> " + u(QApplication.translate("Message", "Return x**y (x to the power of y).",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>radians(x)</b> " + u(QApplication.translate("Message", "Convert angle x from degrees to radians.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>sin(x)</b> " + u(QApplication.translate("Message", "Return the sine of x (measured in radians).",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>sqrt(x)</b> " + u(QApplication.translate("Message", "Return the square root of x.",None, QApplication.UnicodeUTF8))
        string1 += "<LI><b>tan(x)</b> " + u(QApplication.translate("Message", "Return the tangent of x (measured in radians).",None, QApplication.UnicodeUTF8))
        string1 += "</UL>"
        string2 = "<UL><LI><b>x current curve value</b>"
        string2 += "<LI><b>Y1</b> " + u(QApplication.translate("Message", "previous ET value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y2</b> " + u(QApplication.translate("Message", "previous BT value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y3</b> " + u(QApplication.translate("Message", "previous Extra #1 T1 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y4</b> " + u(QApplication.translate("Message", "previous Extra #1 T2 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y5</b> " + u(QApplication.translate("Message", "previous Extra #2 T1 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>Y6</b> " + u(QApplication.translate("Message", "previous Extra #2 T2 value",None, QApplication.UnicodeUTF8))
        string2 += "<LI><b>...</b> "
        string2 += "</UL>"
        #format help
        string3 = "<TABLE  WIDTH=550><TR><TH>"
        string3 += QApplication.translate("Message",  "MATHEMATICAL FUNCTIONS",None, QApplication.UnicodeUTF8)
        string3 += "</TH><TH>"
        string3 += QApplication.translate("Message",  "SYMBOLIC VARIABLES",None, QApplication.UnicodeUTF8)
        string3 += "</TH></TR><TR><TD NOWRAP>" + string1 + "</TD><TD>" + string2 + "</TD></TR></TABLE>"
        QMessageBox.information(self,QApplication.translate("Message", "Symbolic Functions",None, QApplication.UnicodeUTF8),string3)

    def toggleextraeventrows(self):
        if self.extraeventsbuttonsflag:
            if aw.qmc.flagon:
                aw.hideExtraButtons()
            self.extraeventsbuttonsflag = 0
        else:
            if aw.qmc.flagon:
                aw.showExtraButtons()
            self.extraeventsbuttonsflag = 1

    #orders extra event buttons based on max number of buttons
    def realignbuttons(self):
        #clear buttons
#        mainbuttunslen = len(self.lowerbuttondialog.buttons())
#        diff = mainbuttunslen - 9
#        for i in range(diff):
#            self.lowerbuttondialog.removeButton(self.buttonlist[i])
        self.e1buttondialog.clear()
        self.e2buttondialog.clear()
        self.e3buttondialog.clear()
        self.e4buttondialog.clear()
        self.buttonlist = []
        for i in range(len(self.extraeventstypes)):
            self.buttonlist.append(QPushButton())
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(self.extraeventbuttontextcolor[i],self.extraeventbuttoncolor[i])
            self.buttonlist[i].setStyleSheet(style)
            self.buttonlist[i].setMinimumHeight(50)
            self.buttonlist[i].setText(self.extraeventslabels[i])
            self.buttonlist[i].setFocusPolicy(Qt.NoFocus)
            self.connect(self.buttonlist[i], SIGNAL("clicked()"), lambda ee=i:self.recordextraevent(ee))
            #add button to row (CHANGED: now never add extra buttons to default button set)
#            lowerbuttonvisiblebuttons = len(aw.lowerbuttondialog.buttons())
#            for i in range(len(aw.qmc.buttonvisibility)):
#                # remove the invisible ones
#                if not aw.qmc.buttonvisibility[i]:
#                    lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
#            if not self.eventsbuttonflag: # remove another count if EVENT button is invisible
#                lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
            if False: #lowerbuttonvisiblebuttons < self.buttonlistmaxlen:
                self.lowerbuttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
            elif len(self.e1buttondialog.buttons()) < self.buttonlistmaxlen:
                self.e1buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e1buttondialog.setContentsMargins(0,10,0,0)
            elif len(self.e2buttondialog.buttons()) < self.buttonlistmaxlen:
                self.e2buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e2buttondialog.setContentsMargins(0,10,0,0)
            elif len(self.e3buttondialog.buttons()) < self.buttonlistmaxlen:
                self.e3buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e3buttondialog.setContentsMargins(0,10,0,0)
            else:
                self.e4buttondialog.addButton(self.buttonlist[i],QDialogButtonBox.ActionRole)
#                self.e4buttondialog.setContentsMargins(0,10,0,0)
        self.settooltip()
        self.update_extraeventbuttons_visibility()

    #assigns tooltips to extra event buttons
    def settooltip(self):
        for i in range(len(self.buttonlist)):
            tip = u(QApplication.translate("Tooltip","<b>Label</b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventslabels[i]) + "<br>"
            tip += u(QApplication.translate("Tooltip","<b>Description </b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventsdescriptions[i]) + "<br>"
            if self.extraeventstypes[i] < 4:
                tip += u(QApplication.translate("Tooltip","<b>Type </b>= ", None, QApplication.UnicodeUTF8)) + u(self.qmc.etypesf(self.extraeventstypes[i])) + "<br>"
                tip += u(QApplication.translate("Tooltip","<b>Value </b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventsvalues[i]-1) + "<br>" 
            tip += u(QApplication.translate("Tooltip","<b>Documentation </b>= ", None, QApplication.UnicodeUTF8)) + u(self.extraeventsactionstrings[i]) + "<br>"
            tip += u(QApplication.translate("Tooltip","<b>Button# </b>= ", None, QApplication.UnicodeUTF8)) + str(i+1)
            self.buttonlist[i].setToolTip(tip) 

    def update_extraeventbuttons_visibility(self):
        for i in range(len(self.buttonlist)):
            if self.extraeventsvisibility[i]:
                self.buttonlist[i].setVisible(True)
            else:
                self.buttonlist[i].setVisible(False)

    #transfers a palette number to current buttons
    def transferbuttonsto(self,pindex):
        copy = []
        copy.append(self.extraeventstypes[:])
        copy.append(self.extraeventsvalues[:])
        copy.append(self.extraeventsactions[:])
        copy.append(self.extraeventsvisibility[:])
        copy.append(self.extraeventsactionstrings[:])
        copy.append(self.extraeventslabels[:])
        copy.append(self.extraeventsdescriptions[:])
        copy.append(self.extraeventbuttoncolor[:])
        copy.append(self.extraeventbuttontextcolor[:])
        # added slider settings
        copy.append(self.eventslidervisibilities[:])
        copy.append(self.eventslideractions[:])
        copy.append(self.eventslidercommands[:])
        copy.append(self.eventslideroffsets[:])
        copy.append(self.eventsliderfactors[:])
        self.buttonpalette[pindex] = copy[:] 
        self.buttonpalettemaxlen[pindex] = self.buttonlistmaxlen
        self.sendmessage(QApplication.translate("Message","Buttons copied to Palette #%i"%(pindex), None, QApplication.UnicodeUTF8))

    #stores a palette number from current buttons
    def setbuttonsfrom(self,pindex):
        copy = self.buttonpalette[pindex][:]
        if len(copy):
            self.extraeventstypes = copy[0][:]
            self.extraeventsvalues = copy[1][:]
            self.extraeventsactions = copy[2][:]
            self.extraeventsvisibility = copy[3][:]
            self.extraeventsactionstrings = copy[4][:]
            self.extraeventslabels = copy[5][:]
            self.extraeventsdescriptions = copy[6][:]
            self.extraeventbuttoncolor = copy[7][:]
            self.extraeventbuttontextcolor = copy[8][:]
            # added slider settings
            if len(copy[9]) == 4:
                self.eventslidervisibilities = copy[9][:]
            if len(copy[10]) == 4:
                self.eventslideractions = copy[10][:]
            if len(copy[11]) == 4:
                self.eventslidercommands = copy[11][:]
            if len(copy[12]) == 4:
                self.eventslideroffsets = copy[12][:]
            if len(copy[13]) == 4:
                self.eventsliderfactors = copy[13][:]
            self.buttonlistmaxlen = self.buttonpalettemaxlen[pindex]
            self.realignbuttons()
            self.sendmessage(QApplication.translate("Message","Palette #%i restored"%(pindex), None, QApplication.UnicodeUTF8))
            return 1  #success
        else:
            self.sendmessage(QApplication.translate("Message","Palette #%i empty"%(pindex), None, QApplication.UnicodeUTF8))
            return 0  #failed

    def backuppaletteeventbuttons(self):
        palette = {}
        #convert labels to unicode
        for i in range(len(self.buttonpalette)):
            key = str(i)
            palette[key] = self.buttonpalette[i]
        palette["maxlen"] = self.buttonpalettemaxlen
        try:
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Palettes",None, QApplication.UnicodeUTF8),ext="*.apal")
            if filename:
                #write
                self.serialize(filename,palette)
                self.sendmessage(QApplication.translate("Message","Palettes saved",None, QApplication.UnicodeUTF8))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:",None, QApplication.UnicodeUTF8) + " backuppaletteeventbuttons(): %1").arg(str(ex)))
            return

    def loadPalettes(self,filename):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                palette = self.deserialize(filename)
                self.buttonpalettemaxlen = list(map(int,palette["maxlen"]))
                for i in range(10):  #10 palettes (0-9)
                    key = str(i)
                    nextpalette = [[], [], [], [], [], [], [], [], [], [], [], [], [], []] 
                    if len(palette[key]):
                        for x in range(9):
                            if x < 4:
                                nextpalette[x] = list(map(int,palette[key][x]))     #  type int
                            else:
                                nextpalette[x] = list(map(str,palette[key][x])) #  type unicode
                        # read in extended palette data containing slider settings:
                        if len(palette[key])==14:
                            nextpalette[9] = list(map(int,palette[key][9]))     #  type int
                            nextpalette[10] = list(map(int,palette[key][10]))     #  type int
                            nextpalette[11] = list(map(str,palette[key][11])) #  type unicode
                            nextpalette[12] = list(map(int,palette[key][12]))     #  type int
                            nextpalette[13] = list(map(float,palette[key][13]))     #  type double
                        else:
                            nextpalette[9] = self.buttonpalette[9]
                            nextpalette[10] = self.buttonpalette[10]
                            nextpalette[11] = self.buttonpalette[11]
                            nextpalette[12] = self.buttonpalette[12]
                            nextpalette[13] = self.buttonpalette[13]
                    self.buttonpalette[i] = nextpalette[:]
            else:
                message = QApplication.translate("Message","Invalid palettes file format", None, QApplication.UnicodeUTF8)
                self.sendmessage(message)
                return
            message =QApplication.translate("Message","Palettes loaded", None, QApplication.UnicodeUTF8)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " loadPalettes() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None, QApplication.UnicodeUTF8) + " loadPalettes() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
            
    def restorepaletteeventbuttons(self):
        filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Palettes",None, QApplication.UnicodeUTF8),path=self.profilepath)
        if filename:
            self.loadPalettes(filename)
            
    def loadAlarms(self,filename):
        try:            
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            alarms = json.load(infile)
            infile.close()
            aw.qmc.alarmflag = alarms["alarmflags"]
            aw.qmc.alarmguard = alarms["alarmguards"]
            aw.qmc.alarmtime = alarms["alarmtimes"]
            aw.qmc.alarmoffset = alarms["alarmoffsets"]
            aw.qmc.alarmcond = alarms["alarmconds"]
            aw.qmc.alarmsource = alarms["alarmsources"]
            aw.qmc.alarmtemperature = alarms["alarmtemperatures"]
            aw.qmc.alarmaction = alarms["alarmactions"]
            aw.qmc.alarmstrings = alarms["alarmstrings"]
            message =QApplication.translate("Message","Alarms loaded", None, QApplication.UnicodeUTF8)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None, QApplication.UnicodeUTF8) + " loadAlarms() %1").arg(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None, QApplication.UnicodeUTF8) + " loadAlarms() %1").arg(str(ex)),exc_tb.tb_lineno)
            return


########################################################################################
#####################  Artisan QDialog Subclass  #######################################
########################################################################################

class ArtisanDialog(QDialog):
    def __init__(self, parent=None):
        super(ArtisanDialog,self).__init__(parent)

    def keyPressEvent(self,event):
        key = int(event.key())
        #uncomment next line to find the integer value of a key
        #print key
        if key == 16777216: #ESCAPE
            self.close()

##########################################################################
#####################     HUD  EDIT DLG     ##############################
##########################################################################

class HUDDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(HUDDlg,self).__init__(parent)
        
        self.setWindowTitle(QApplication.translate("Form Caption","Extras", None, QApplication.UnicodeUTF8))
        self.setModal(True)
        #### TAB 1
        # keep old values to be restored on Cancel
        self.org_DeltaET = aw.qmc.DeltaETflag
        self.org_DeltaBT = aw.qmc.DeltaBTflag
        self.org_DeltaETlcd = aw.qmc.DeltaETlcdflag
        self.org_DeltaBTlcd = aw.qmc.DeltaBTlcdflag
        self.org_Projection = aw.qmc.projectFlag
        ETLabel = QLabel(QApplication.translate("Label", "ET Target 1",None, QApplication.UnicodeUTF8))
        ETLabel.setAlignment(Qt.AlignRight)
        BTLabel = QLabel(QApplication.translate("Label", "BT Target 1",None, QApplication.UnicodeUTF8))
        BTLabel.setAlignment(Qt.AlignRight)        
        ET2Label = QLabel(QApplication.translate("Label", "ET Target 2",None, QApplication.UnicodeUTF8))
        ET2Label.setAlignment(Qt.AlignRight)
        BT2Label = QLabel(QApplication.translate("Label", "BT Target 2",None, QApplication.UnicodeUTF8))
        BT2Label.setAlignment(Qt.AlignRight)        
        modeLabel = QLabel(QApplication.translate("Label", "Mode",None, QApplication.UnicodeUTF8))
        modeLabel.setAlignment(Qt.AlignRight)
        ETPIDLabel = QLabel(QApplication.translate("Label", "ET p-i-d 1",None, QApplication.UnicodeUTF8))
        pidhelpButton = QPushButton(QApplication.translate("Button","PID Help",None, QApplication.UnicodeUTF8))
        pidhelpButton.setFocusPolicy(Qt.NoFocus)
        self.connect(pidhelpButton,SIGNAL("clicked()"),self.showpidhelp)
        #delta ET
        self.DeltaET = QCheckBox(QApplication.translate("CheckBox", "DeltaET",None, QApplication.UnicodeUTF8))
        self.DeltaET.setChecked(aw.qmc.DeltaETflag)
        #delta BT   
        self.DeltaBT = QCheckBox(QApplication.translate("CheckBox", "DeltaBT",None, QApplication.UnicodeUTF8))
        self.DeltaBT.setChecked(aw.qmc.DeltaBTflag)
        filterlabel = QLabel(QApplication.translate("Label", "Smooth Deltas",None, QApplication.UnicodeUTF8))
        #DeltaFilter holds the number of pads in filter
        self.DeltaFilter = QSpinBox()
        self.DeltaFilter.setSingleStep(1)
        self.DeltaFilter.setRange(0,40)
        self.DeltaFilter.setValue(aw.qmc.deltafilter - 2)
        self.connect(self.DeltaFilter ,SIGNAL("editingFinished()"),lambda x=0:self.changeDeltaFilter(0))
        curvefilterlabel = QLabel(QApplication.translate("Label", "Smooth Curves",None, QApplication.UnicodeUTF8))
        #Filter holds the number of pads in filter
        self.Filter = QSpinBox()
        self.Filter.setSingleStep(1)
        self.Filter.setRange(0,40)
        self.Filter.setValue(aw.qmc.curvefilter - 2)
        self.connect(self.Filter,SIGNAL("editingFinished()"),lambda x=0:self.changeFilter(0))
        #filterspikes
        self.FilterSpikes = QCheckBox(QApplication.translate("CheckBox", "Smooth Spikes",None, QApplication.UnicodeUTF8))
        self.FilterSpikes.setChecked(aw.qmc.filterDropOuts)
        self.connect(self.FilterSpikes,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDropFilter(i))
        #dropspikes
        self.DropSpikes = QCheckBox(QApplication.translate("CheckBox", "Drop Spikes",None, QApplication.UnicodeUTF8))
        self.DropSpikes.setChecked(aw.qmc.dropSpikes)
        self.connect(self.DropSpikes,SIGNAL("stateChanged(int)"),lambda i=0:self.changeSpikeFilter(i))
        #min-max-limits
        self.MinMaxLimits = QCheckBox(QApplication.translate("CheckBox", "Limits",None, QApplication.UnicodeUTF8))
        self.MinMaxLimits.setChecked(aw.qmc.minmaxLimits)
        self.connect(self.MinMaxLimits,SIGNAL("stateChanged(int)"),lambda i=0:self.changeMinMaxLimits(i))
        #limits
        minlabel = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxlabel = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))
        self.minLimit = QSpinBox()
        self.minLimit.setRange(0,1000)    #(min,max)
        self.minLimit.setAlignment(Qt.AlignRight)
        self.minLimit.setMinimumWidth(80)
        self.minLimit.setValue(aw.qmc.filterDropOut_tmin)
        self.maxLimit = QSpinBox()
        self.maxLimit.setRange(0,1000)
        self.maxLimit.setAlignment(Qt.AlignRight)
        self.maxLimit.setMinimumWidth(80)
        self.maxLimit.setValue(aw.qmc.filterDropOut_tmax)
        if aw.qmc.mode == "F":
            self.minLimit.setSuffix(" F")
            self.maxLimit.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.minLimit.setSuffix(" C")
            self.maxLimit.setSuffix(" C")
        #show projection
        self.projectCheck = QCheckBox(QApplication.translate("CheckBox", "Projection",None, QApplication.UnicodeUTF8))
        self.projectionmodeComboBox = QComboBox()
        self.projectionmodeComboBox.addItems([QApplication.translate("ComboBox","linear",None, QApplication.UnicodeUTF8),
                                              QApplication.translate("ComboBox","newton",None, QApplication.UnicodeUTF8)])
        self.projectionmodeComboBox.setCurrentIndex(aw.qmc.projectionmode)
        self.connect(self.projectionmodeComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.projectionmodeComboBox.currentIndex() :self.changeProjectionMode(i))
        self.projectCheck.setChecked(aw.qmc.projectFlag)
        self.connect(self.DeltaET,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaET(i))         #toggle
        self.connect(self.DeltaBT,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaBT(i))         #toggle
        self.connect(self.projectCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.changeProjection(i)) #toggle
        self.modeComboBox = QComboBox()
        self.modeComboBox.setMaximumWidth(100)
        self.modeComboBox.setMinimumWidth(55)
        self.modeComboBox.addItems([QApplication.translate("ComboBox","metrics",None, QApplication.UnicodeUTF8),
                                    QApplication.translate("ComboBox","thermal",None, QApplication.UnicodeUTF8)])
        self.modeComboBox.setCurrentIndex(aw.HUDfunction)
        self.ETlineEdit = QLineEdit(str(aw.qmc.ETtarget))
        self.BTlineEdit = QLineEdit(str(aw.qmc.BTtarget))
        self.ETlineEdit.setValidator(QIntValidator(0, 1000, self.ETlineEdit))
        self.BTlineEdit.setValidator(QIntValidator(0, 1000, self.BTlineEdit))
        self.ETlineEdit.setMaximumWidth(60)
        self.BTlineEdit.setMaximumWidth(60)
        self.ET2lineEdit = QLineEdit(str(aw.qmc.ET2target))
        self.BT2lineEdit = QLineEdit(str(aw.qmc.BT2target))
        self.ET2lineEdit.setValidator(QIntValidator(0, 1000, self.ET2lineEdit))
        self.BT2lineEdit.setValidator(QIntValidator(0, 1000, self.BT2lineEdit))
        self.ET2lineEdit.setMaximumWidth(60)
        self.BT2lineEdit.setMaximumWidth(60)
        self.ETpidP = QLineEdit(str(aw.qmc.hudETpid[0]))
        self.ETpidI = QLineEdit(str(aw.qmc.hudETpid[1]))
        self.ETpidD = QLineEdit(str(aw.qmc.hudETpid[2]))
        self.ETpidP.setValidator(QIntValidator(0, 1000, self.ETpidP))
        self.ETpidI.setValidator(QIntValidator(0, 1000, self.ETpidI))
        self.ETpidD.setValidator(QIntValidator(0, 1000, self.ETpidD))
        self.ETpidP.setMaximumWidth(60)
        self.ETpidI.setMaximumWidth(60)
        self.ETpidD.setMaximumWidth(60)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.updatetargets)
        hudLayout = QGridLayout()
        hudLayout.addWidget(BTLabel,0,0)
        hudLayout.addWidget(self.BTlineEdit,0,1)
        hudLayout.addWidget(BT2Label,0,2)
        hudLayout.addWidget(self.BT2lineEdit,0,3)
        hudLayout.addWidget(ETLabel,1,0)
        hudLayout.addWidget(self.ETlineEdit,1,1)
        hudLayout.addWidget(ET2Label,1,2)
        hudLayout.addWidget(self.ET2lineEdit,1,3)
        hudLayout.addWidget(ETPIDLabel,2,0)
        hudLayout.addWidget(self.ETpidP,2,1)
        hudLayout.addWidget(self.ETpidI,2,2)
        hudLayout.addWidget(self.ETpidD,2,3)
        hudLayout.addWidget(modeLabel,3,0)
        hudLayout.addWidget(self.modeComboBox,3,1)
        hudLayout.addWidget(pidhelpButton,3,3)
        rorLayout = QGridLayout()
        rorLayout.addWidget(self.projectCheck,0,0)
        rorLayout.addWidget(self.projectionmodeComboBox,0,1)
        rorLayout.addWidget(self.DeltaET,1,0)
        rorLayout.addWidget(self.DeltaBT,1,1)
        rorBoxLayout = QHBoxLayout()
        rorBoxLayout.addLayout(rorLayout)
        rorBoxLayout.addStretch()
        self.DeltaETlcd = QCheckBox(QApplication.translate("CheckBox", "DeltaET",None, QApplication.UnicodeUTF8))
        self.DeltaETlcd.setChecked(aw.qmc.DeltaETlcdflag)
        self.DeltaBTlcd = QCheckBox(QApplication.translate("CheckBox", "DeltaBT",None, QApplication.UnicodeUTF8))
        self.DeltaBTlcd.setChecked(aw.qmc.DeltaBTlcdflag)
        self.connect(self.DeltaETlcd,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaETlcd(i))         #toggle
        self.connect(self.DeltaBTlcd,SIGNAL("stateChanged(int)"),lambda i=0:self.changeDeltaBTlcd(i))         #toggle
        lcdsLayout = QHBoxLayout()
        lcdsLayout.addWidget(self.DeltaETlcd)
        lcdsLayout.addSpacing(15)
        lcdsLayout.addWidget(self.DeltaBTlcd)
        lcdsLayout.addStretch()
        sensitivityLayout = QHBoxLayout()
        sensitivityLayout.addWidget(curvefilterlabel)
        sensitivityLayout.addWidget(self.Filter)
        sensitivityLayout.addSpacing(30)
        sensitivityLayout.addWidget(filterlabel)
        sensitivityLayout.addWidget(self.DeltaFilter)
        sensitivityLayout.addStretch()
        spikesLayout = QHBoxLayout()
        spikesLayout.addWidget(self.FilterSpikes)
        spikesLayout.addWidget(self.DropSpikes)
        spikesLayout.addStretch()
        curvesLayout = QVBoxLayout()
        curvesLayout.addLayout(rorBoxLayout)
        curvesLayout.addLayout(sensitivityLayout)
        curvesLayout.addLayout(spikesLayout)
        rorGroupLayout = QGroupBox(QApplication.translate("GroupBox","Curves",None, QApplication.UnicodeUTF8))
        rorGroupLayout.setLayout(curvesLayout)
        rorLCDGroupLayout = QGroupBox(QApplication.translate("GroupBox","LCDs",None, QApplication.UnicodeUTF8))
        rorLCDGroupLayout.setLayout(lcdsLayout)
        hudGroupLayout = QGroupBox(QApplication.translate("GroupBox","HUD",None, QApplication.UnicodeUTF8))
        hudGroupLayout.setLayout(hudLayout)
        inputFilterGrid = QGridLayout()
        inputFilterGrid.setColumnMinimumWidth(3,20)
        inputFilterGrid.addWidget(self.MinMaxLimits,0,0)
        inputFilterGrid.addWidget(minlabel,0,1)
        inputFilterGrid.addWidget(self.minLimit,0,2)
        inputFilterGrid.addWidget(maxlabel,0,4)
        inputFilterGrid.addWidget(self.maxLimit,0,5)
        inputFilterGrid.addWidget(self.DropSpikes,2,0)
        inputFilterHBox = QHBoxLayout()
        inputFilterHBox.addLayout(inputFilterGrid)
        inputFilterHBox.addStretch()
        inputFilterGroupLayout = QGroupBox(QApplication.translate("GroupBox","Input Filters",None, QApplication.UnicodeUTF8))
        inputFilterGroupLayout.setLayout(inputFilterHBox)
        tab1Layout = QVBoxLayout()
        tab1Layout.addWidget(inputFilterGroupLayout)
        tab1Layout.addWidget(rorGroupLayout)
        tab1Layout.addWidget(rorLCDGroupLayout)
        tab1Layout.addWidget(hudGroupLayout)
        tab1Layout.addStretch()
        #tab2
        #Equation plotter
        equlabel = QLabel(QApplication.translate("Label", "Y(x)",None, QApplication.UnicodeUTF8))
        self.equedit1 = QLineEdit(aw.qmc.plotcurves[0])
        self.equedit2 = QLineEdit(aw.qmc.plotcurves[1])
        self.equedit3 = QLineEdit(aw.qmc.plotcurves[2])
        self.equedit4 = QLineEdit(aw.qmc.plotcurves[3])
        self.equedit5 = QLineEdit(aw.qmc.plotcurves[4])
        self.equedit6 = QLineEdit(aw.qmc.plotcurves[5])
        color1Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color1Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color1Button, SIGNAL("clicked()"),lambda x=0: self.setcurvecolor(x))
        color2Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color2Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color2Button, SIGNAL("clicked()"),lambda x=1: self.setcurvecolor(x))
        color3Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color3Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color3Button, SIGNAL("clicked()"),lambda x=2: self.setcurvecolor(x))
        color4Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color4Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color4Button, SIGNAL("clicked()"),lambda x=3: self.setcurvecolor(x))
        color5Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color5Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color5Button, SIGNAL("clicked()"),lambda x=4: self.setcurvecolor(x))
        color6Button = QPushButton(QApplication.translate("Button","Color",None, QApplication.UnicodeUTF8))
        color6Button.setFocusPolicy(Qt.NoFocus)
        self.connect(color6Button, SIGNAL("clicked()"),lambda x=5: self.setcurvecolor(x))
        equdrawbutton = QPushButton(QApplication.translate("Button","Plot",None, QApplication.UnicodeUTF8))
        equdrawbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(equdrawbutton,SIGNAL("clicked()"),self.plotequ)
        equbackgroundbutton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        equbackgroundbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(equbackgroundbutton ,SIGNAL("clicked()"),self.setbackgroundequ1)
        equvdevicebutton = QPushButton(QApplication.translate("Button","Virtual Device",None, QApplication.UnicodeUTF8))
        equvdevicebutton.setFocusPolicy(Qt.NoFocus)
        self.connect(equvdevicebutton ,SIGNAL("clicked()"),self.setvdevice)
        saveImgButton = QPushButton(QApplication.translate("Button","Save Image",None, QApplication.UnicodeUTF8))
        saveImgButton.setFocusPolicy(Qt.NoFocus)
        saveImgButton.setToolTip(QApplication.translate("Tooltip","Save image using current graph size to a png format",None, QApplication.UnicodeUTF8))
        self.connect(saveImgButton, SIGNAL("clicked()"),lambda x=0,i=1:aw.resize(x,i))
        helpcurveButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpcurveButton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpcurveButton, SIGNAL("clicked()"),aw.showSymbolicHelp)
        curve1Layout = QGridLayout()
        curve1Layout.addWidget(self.equedit1,0,0)
        curve1Layout.addWidget(color1Button,0,1)
        curve1Layout.addWidget(equbackgroundbutton,0,2)
        curve1Layout.addWidget(self.equedit2,1,0)
        curve1Layout.addWidget(color2Button,1,1)
        curve1Layout.addWidget(equvdevicebutton,1,2)
        plot1GroupBox = QGroupBox()
        plot1GroupBox.setLayout(curve1Layout)
        curveLayout = QGridLayout()
        curveLayout.addWidget(self.equedit3,0,0)
        curveLayout.addWidget(color3Button,0,1)
        curveLayout.addWidget(self.equedit4,1,0)
        curveLayout.addWidget(color4Button,1,1)
        curveLayout.addWidget(self.equedit5,2,0)
        curveLayout.addWidget(color5Button,2,1)
        curveLayout.addWidget(self.equedit6,3,0)
        curveLayout.addWidget(color6Button,3,1)
        curvebuttonlayout = QHBoxLayout()
        curvebuttonlayout.addWidget(equdrawbutton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(saveImgButton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(helpcurveButton)
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(equlabel)
        tab2Layout.addWidget(plot1GroupBox)
        tab2Layout.addLayout(curveLayout)
        tab2Layout.addLayout(curvebuttonlayout)
        tab2Layout.addStretch()
        ##### TAB 3
        self.interpCheck = QCheckBox(QApplication.translate("CheckBox","Show",None, QApplication.UnicodeUTF8))
        self.interpCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.interpCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.interpolation(i)) #toggle
        self.interpComboBox = QComboBox()
        self.interpComboBox.setMaximumWidth(100)
        self.interpComboBox.setMinimumWidth(55)
        self.interpComboBox.addItems([QApplication.translate("ComboBox","linear",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","cubic",None, QApplication.UnicodeUTF8),
                                      QApplication.translate("ComboBox","nearest",None, QApplication.UnicodeUTF8)])
        self.interpComboBox.setToolTip(QApplication.translate("Tooltip", "linear: linear interpolation\ncubic: 3rd order spline interpolation\nnearest: y value of the nearest point", None, QApplication.UnicodeUTF8))
        self.interpComboBox.setFocusPolicy(Qt.NoFocus)
        self.connect(self.interpComboBox,SIGNAL("currentIndexChanged(int)"),lambda i=self.interpComboBox.currentIndex() :self.changeInterpolationMode(i))
#         'linear'  : linear interpolation
#         'cubic'   : 3rd order spline interpolation
#         'nearest' : take the y value of the nearest point
        self.univarCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None, QApplication.UnicodeUTF8))
        self.univarCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.univarCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.univar(i)) #toggle
        univarButton = QPushButton(QApplication.translate("Button","Info",None, QApplication.UnicodeUTF8))
        univarButton.setFocusPolicy(Qt.NoFocus)
        univarButton.setMaximumSize(univarButton.sizeHint())
        univarButton.setMinimumSize(univarButton.minimumSizeHint()) 
        self.connect(univarButton,SIGNAL("clicked()"),self.showunivarinfo)
        tab3Layout = QVBoxLayout()
        interLayout = QHBoxLayout()
        interLayout.addWidget(self.interpCheck)
        interLayout.addStretch()
        interLayout.addWidget(self.interpComboBox)
        interGroupLayout = QGroupBox(QApplication.translate("GroupBox","Interpolate",None, QApplication.UnicodeUTF8))
        interGroupLayout.setLayout(interLayout)
        uniLayout = QHBoxLayout()
        uniLayout.addWidget(self.univarCheck)
        uniLayout.addStretch()
        uniLayout.addWidget(univarButton)
        univarGroupLayout = QGroupBox(QApplication.translate("GroupBox","Univariate",None, QApplication.UnicodeUTF8))
        univarGroupLayout.setLayout(uniLayout)
        tab3Layout.addWidget(interGroupLayout)
        tab3Layout.addWidget(univarGroupLayout)
        tab3Layout.addStretch()
        ##### TAB 4
        #### TAB 5
        self.styleComboBox = QComboBox()
        available = list(map(str, list(QStyleFactory.keys())))
        self.styleComboBox.addItems(available)
        self.styleComboBox.setFocusPolicy(Qt.NoFocus)
        try:
            #pylint: disable=E1102
            self.styleComboBox.setCurrentIndex(list(map(lambda x:x.lower(),available)).index(str(aw.style().objectName()).lower()))
        except:
            pass
        self.connect(self.styleComboBox,SIGNAL("currentIndexChanged(int)"),lambda i:self.setappearance())
        self.resolutionSpinBox = QSpinBox()
        self.resolutionSpinBox.setRange(40,120)
        self.resolutionSpinBox.setSingleStep(5)
        self.resolutionSpinBox.setValue(aw.dpi)
        self.resolutionSpinBox.setFocusPolicy(Qt.NoFocus)
        resButton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        resButton.setFocusPolicy(Qt.NoFocus)
        self.connect(resButton,SIGNAL("clicked()"),self.changedpi)
        defresButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        defresButton.setFocusPolicy(Qt.NoFocus)
        self.connect(defresButton,SIGNAL("clicked()"),self.setdefaults)
        appLayout = QHBoxLayout()
        appLayout.addStretch()
        appLayout.addWidget(self.styleComboBox)
        appearanceGroupWidget = QGroupBox(QApplication.translate("GroupBox","Appearance",None, QApplication.UnicodeUTF8))
        appearanceGroupWidget.setLayout(appLayout)
        setresLayout = QHBoxLayout()
        setresLayout.addStretch()
        setresLayout.addWidget(self.resolutionSpinBox)
        setresLayout.addWidget(resButton)
        resLayout = QVBoxLayout()
        resLayout.addLayout(setresLayout)
        resolutionGroupWidget = QGroupBox(QApplication.translate("GroupBox","Resolution",None, QApplication.UnicodeUTF8))
        resolutionGroupWidget.setLayout(resLayout)
        defresLayout = QHBoxLayout()
        defresLayout.addStretch()
        defresLayout.addWidget(defresButton)
        self.soundCheck = QCheckBox(QApplication.translate("CheckBox", "Beep",None, QApplication.UnicodeUTF8))
        self.soundCheck.setChecked(aw.soundflag) 
        self.soundCheck.setFocusPolicy(Qt.NoFocus)
        self.connect(self.soundCheck,SIGNAL("stateChanged(int)"),lambda i=0:self.soundset(i)) #toggle
        sLayout = QHBoxLayout()
        sLayout.addStretch()
        sLayout.addWidget(self.soundCheck)
        soundGroupWidget = QGroupBox(QApplication.translate("GroupBox","Sound",None, QApplication.UnicodeUTF8))
        soundGroupWidget.setLayout(sLayout)
        tab5Layout = QVBoxLayout()
        tab5Layout.addWidget(appearanceGroupWidget)
        tab5Layout.addWidget(resolutionGroupWidget)
        tab5Layout.addWidget(soundGroupWidget)
        tab5Layout.addStretch()
        tab5Layout.addLayout(defresLayout)

        ############################  TABS LAYOUT
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","HUD",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Plotter",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Math",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","UI",None, QApplication.UnicodeUTF8))
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(cancelButton)
        buttonsLayout.addWidget(okButton)
        #incorporate layouts
        Slayout = QVBoxLayout()
        Slayout.addWidget(TabWidget,1)
        Slayout.addStretch()
        Slayout.addLayout(buttonsLayout)
        Slayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(Slayout)

    def showpidhelp(self):
        QDesktopServices.openUrl(QUrl("http://en.wikipedia.org/wiki/PID_controller", QUrl.TolerantMode))

    def changedpi(self):
        try:
            value = self.resolutionSpinBox.value()
            aw.setdpi(value)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()   
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " changedpi(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setdefaults(self):
        self.resolutionSpinBox.setValue(80)
        self.changedpi()
        app.setStyle(aw.defaultAppearance)

    def setcurvecolor(self,x):
        try:
            colorf = QColorDialog.getColor(QColor(aw.qmc.plotcurvecolor[x]),self)
            if colorf.isValid():
                colorname = str(colorf.name())
                aw.qmc.plotcurvecolor[x] = colorname
            self.plotequ()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setcurvecolor(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setvdevice(self):
        # compute values
        EQU = [str(self.equedit1.text()),str(self.equedit2.text())]
        for e in range(2):
            #create y range
            y_range = []
            for i in range(len(aw.qmc.timex)):
                y_range.append(self.eval_curve_expression(EQU[e],aw.qmc.timex[i]))
            if e:
                extratemp2 = y_range
            else:
                extratemp1 = y_range
        # add device
        aw.addDevice() 
        aw.qmc.extradevices[-1] = 25
        
        # set colors
        aw.qmc.extradevicecolor1[-1] = aw.qmc.plotcurvecolor[0]
        aw.qmc.extradevicecolor2[-1] = aw.qmc.plotcurvecolor[1]
        # set expressions
        aw.qmc.extramathexpression1[-1] = str(self.equedit1.text())
        aw.qmc.extramathexpression2[-1] = str(self.equedit2.text())
        # set values       
        aw.qmc.extratemp1[-1] = extratemp1
        aw.qmc.extratemp2[-1] = extratemp2
        aw.qmc.extratimex[-1] = aw.qmc.timex[:]
        # redraw
        aw.qmc.redraw(recomputeAllDeltas=False)

    def setbackgroundequ1(self):
        try:
            equ = str(self.equedit1.text())
            aw.qmc.plotcurves[0] = equ
            if len(equ):
                aw.qmc.resetlines()
                #create x range
                x_range = list(range(aw.qmc.startofx,aw.qmc.endofx))
                #create y range
                y_range = []
                for i in range(len(x_range)):
                    y_range.append(self.eval_curve_expression(equ,x_range[i]))
            aw.qmc.timeB = x_range[:]
            aw.qmc.temp1B = y_range[:]
            aw.qmc.temp2B = [-100]*len(x_range)
            aw.qmc.background = True
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setbackgroundequ1(): %1").arg(str(e)),exc_tb.tb_lineno)

    def plotequ(self):
        try:
            EQU = [str(self.equedit1.text()),str(self.equedit2.text()),
                   str(self.equedit3.text()),str(self.equedit4.text()),
                   str(self.equedit5.text()),str(self.equedit6.text())]
            aw.qmc.plotcurves = EQU[:]
            aw.qmc.resetlines()
            for e in range(5):
                #create x range
                x_range = list(range(aw.qmc.startofx,aw.qmc.endofx))
                #create y range
                y_range = []
                for i in range(len(x_range)):
                    y_range.append(self.eval_curve_expression(EQU[e],x_range[i]))
                aw.qmc.ax.plot(x_range, y_range, color=aw.qmc.plotcurvecolor[e], linestyle = '-', linewidth=1)
            aw.qmc.fig.canvas.draw()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()    
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " plotequ(): %1").arg(str(e)),exc_tb.tb_lineno)

    def eval_curve_expression(self,mathexpression,x):
        if len(mathexpression):
            if mathexpression[0] == "#":
                return
            #Since eval() is very powerful, for security reasons, only the functions in this dictionary will be allowed
            mathdictionary = {"sin":math.sin,"cos":math.cos,"tan":math.tan,"pow":math.pow,"exp":math.exp,"pi":math.pi,"e":math.e,
                              "abs":abs,"acos":math.acos,"asin":math.asin,"atan":math.atan,"log":math.log,"radians":math.radians,
                              "sqrt":math.sqrt,"atan2":math.atan,"degrees":math.degrees}
            try:
                x = float(x)
                mathdictionary['x'] = x         #add x to the math dictionary assigning the key "x" to its float value
                #if Ys in expression
                if "Y" in mathexpression:
                    #extract Ys
                    Yval = []                   #extract value number example Y9 = 9
                    mlen = len(mathexpression)
                    for i in range(mlen):
                        if mathexpression[i] == "Y":
                            #find Y number
                            if i+1 < mlen:                          #check for out of range
                                if mathexpression[i+1].isdigit():
                                    number = mathexpression[i+1]
                                else:
                                    number = "1"
                            #check for double digit
                            if i+2 < mlen:
                                if mathexpression[i+2].isdigit() and mathexpression[i+1].isdigit():
                                    number += mathexpression[i+2]
                            Yval.append(number)
                                
                    #build Ys float values
                    if len(aw.qmc.timex) > 1:
                        index = aw.qmc.time2index(x)
                        Y = [aw.qmc.temp1[index],aw.qmc.temp2[index]]
                        if len(aw.qmc.extratimex):
                            if len(aw.qmc.extratimex[0]):
                                for i in range(len(aw.qmc.extradevices)):
                                    Y.append(aw.qmc.extratemp1[i][index])
                                    Y.append(aw.qmc.extratemp2[i][index])
                        #add Ys and their value to math dictionary 
                        for i in range(len(Yval)):
                            mathdictionary["Y"+ Yval[i]] = Y[int(Yval[i])-1]
                    else:
                        for i in range(len(Yval)):
                            mathdictionary["Y"+ Yval[i]] = 0
                return eval(mathexpression,{"__builtins__":None},mathdictionary)
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " Plotter: %1").arg(str(e)),exc_tb.tb_lineno)
                return 0

    def setappearance(self):
        try:
            app.setStyle(str(self.styleComboBox.currentText()))
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setappearance(): %1").arg(str(e)),exc_tb.tb_lineno)

#    def showsound(self):
#        try:
#            warnings.simplefilter('ignore', Warning) #for Complex warning 
#            aw.sendmessage(QApplication.translate("Message","Testing Mike...", None, QApplication.UnicodeUTF8))
#            aw.stack.setCurrentIndex(2)
#            aw.sound.opensound()
#            for i in range(80):
#                msg = str(80-i)
#                self.status.showMessage(msg,500)
#                aw.sound.blitsound()
#            aw.stack.setCurrentIndex(0)
#            aw.sound.closesound()
#            aw.sendmessage("")
#            warnings.simplefilter('default', Warning)
#        except Exception as e:
#            _, _, exc_tb = sys.exc_info()  
#            aw.qmc.adderror(QApplication.translate("Error Message", "showsound(): %1 ",None, QApplication.UnicodeUTF8).arg(str(e)),exc_tb.tb_lineno)

    def saveinterp(self):
        pass

    def showunivarinfo(self):
        if aw.qmc.timeindex[6]:
            aw.qmc.univariateinfo()
        else:
            aw.sendmessage(QApplication.translate("Univariate: no profile data available", None, QApplication.UnicodeUTF8))

    def univar(self,i):
        if self.univarCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[6]:
                aw.qmc.univariate()
            else:
                aw.sendmessage(QApplication.translate("Univariate: no profile data available", None, QApplication.UnicodeUTF8))
                self.univarCheck.setChecked(False)
        else:
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)

    def interpolation(self,i):
        mode = str(self.interpComboBox.currentText())
        if self.interpCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[6]:
                aw.qmc.drawinterp(mode)
            else:
                aw.sendmessage(QApplication.translate("Message","Interpolation failed: no profile available", None, QApplication.UnicodeUTF8))
                self.interpCheck.setChecked(False)
        else:
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)

    def soundset(self,i):
        if aw.soundflag == 0:
            aw.soundflag = 1
            aw.sendmessage(QApplication.translate("Message","Sound turned ON", None, QApplication.UnicodeUTF8))
            aw.soundpop()
        else:
            aw.soundflag = 0
            aw.sendmessage(QApplication.translate("Message","Sound turned OFF", None, QApplication.UnicodeUTF8))

    def changeDeltaET(self,i):
        aw.qmc.DeltaETflag = not aw.qmc.DeltaETflag
        aw.qmc.redraw(recomputeAllDeltas=True)

    def changeDeltaBT(self,i):
        aw.qmc.DeltaBTflag = not aw.qmc.DeltaBTflag
        aw.qmc.redraw(recomputeAllDeltas=True)

    def changeDeltaETlcd(self,i):
        aw.qmc.DeltaETlcdflag = not aw.qmc.DeltaETlcdflag
        aw.LCD4frame.setVisible(aw.qmc.DeltaETlcdflag)

    def changeDeltaBTlcd(self,i):
        aw.qmc.DeltaBTlcdflag = not aw.qmc.DeltaBTlcdflag
        aw.LCD5frame.setVisible(aw.qmc.DeltaBTlcdflag)

    def changeDeltaFilter(self,i):
        try:
            v = self.DeltaFilter.value() + 2
            if v != aw.qmc.deltafilter:
                self.DeltaFilter.setDisabled(True)
                aw.qmc.deltafilter = v
                aw.qmc.redraw(recomputeAllDeltas=True)
                self.DeltaFilter.setDisabled(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "changeDeltaFilter(): %1").arg(str(e)),exc_tb.tb_lineno)

    def changeDropFilter(self,i):
        aw.qmc.filterDropOuts = not aw.qmc.filterDropOuts
        aw.qmc.redraw(recomputeAllDeltas=False,smooth=True)

    def changeSpikeFilter(self,i):
        aw.qmc.dropSpikes = not aw.qmc.dropSpikes

    def changeMinMaxLimits(self,i):
        aw.qmc.minmaxLimits = not aw.qmc.minmaxLimits
        
    def changeFilter(self,i):
        try:
            v = self.Filter.value() + 2
            if v != aw.qmc.curvefilter:
                self.Filter.setDisabled(True)
                aw.qmc.curvefilter = v
                aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
                self.Filter.setDisabled(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " changeFilter(): %1").arg(str(e)),exc_tb.tb_lineno)

    def changeProjection(self,i):
        aw.qmc.projectFlag = not aw.qmc.projectFlag
        if not aw.qmc.projectFlag:
            #erase old projections
            aw.qmc.resetlines()

    def changeProjectionMode(self,i):
        aw.qmc.projectionmode = i

    def changeInterpolationMode(self,i):
        aw.qmc.resetlines()
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.interpolation(i)

    #cancel button
    def close(self):
        #restore settings
        aw.qmc.DeltaETflag = self.org_DeltaET
        aw.qmc.DeltaBTflag = self.org_DeltaBT
        aw.qmc.DeltaETlcdflag = self.org_DeltaETlcd
        aw.qmc.DeltaBTlcdflag = self.org_DeltaBTlcd
        if aw.qmc.flagon:
            aw.lcd4.setVisible(aw.qmc.DeltaETlcdflag)
            aw.label4.setVisible(aw.qmc.DeltaETlcdflag)
            aw.lcd5.setVisible(aw.qmc.DeltaBTlcdflag)
            aw.label5.setVisible(aw.qmc.DeltaBTlcdflag)
        aw.qmc.projectFlag = self.org_Projection
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.accept()

    #button OK
    def updatetargets(self):
        aw.qmc.filterDropOuts = self.FilterSpikes.isChecked()
        aw.qmc.dropSpikes = self.DropSpikes.isChecked()
        aw.qmc.minmaxLimits = self.MinMaxLimits.isChecked()
        aw.qmc.filterDropOut_tmin = int(self.minLimit.value())
        aw.qmc.filterDropOut_tmax = int(self.maxLimit.value())
        mode = u(self.modeComboBox.currentText())
        if mode == QApplication.translate("ComboBox","metrics", None, QApplication.UnicodeUTF8):
            aw.HUDfunction = 0
        elif mode == QApplication.translate("ComboBox","thermal", None, QApplication.UnicodeUTF8):
            aw.HUDfunction = 1
        aw.qmc.ETtarget = int(str(self.ETlineEdit.text()))
        aw.qmc.BTtarget = int(str(self.BTlineEdit.text()))
        aw.qmc.ET2target = int(str(self.ET2lineEdit.text()))
        aw.qmc.BT2target = int(str(self.BT2lineEdit.text()))
        if aw.qmc.ETtarget > aw.qmc.ET2target: # swap such that ETtarget < ET2target
            aw.qmc.ETtarget = int(str(self.ET2lineEdit.text()))
            aw.qmc.ET2target = int(str(self.ETlineEdit.text()))
        if aw.qmc.BTtarget > aw.qmc.BT2target: # swap such that BTtarget < BT2target
            aw.qmc.BTtarget = int(str(self.BT2lineEdit.text()))
            aw.qmc.BT2target = int(str(self.BTlineEdit.text()))            
        aw.qmc.hudETpid[0] = int(str(self.ETpidP.text()))
        aw.qmc.hudETpid[1] = int(str(self.ETpidI.text()))
        aw.qmc.hudETpid[2] = int(str(self.ETpidD.text()))
        string = u(QApplication.translate("Message","[ET target 1 = %1] [BT target 1 = %2] [ET target 2 = %3] [BT target 2 = %4]", None, QApplication.UnicodeUTF8).arg(str(aw.qmc.ETtarget)).arg(str(aw.qmc.BTtarget)).arg(str(aw.qmc.ET2target)).arg(str(aw.qmc.BT2target)))
        aw.sendmessage(string)
        aw.qmc.resetlinecountcaches()
        aw.qmc.resetdeltalines()
        aw.qmc.resetlines()
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.accept()


########################################################################################
#####################  ROAST PROPERTIES EDIT GRAPH DLG  ################################
########################################################################################

class editGraphDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(editGraphDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Properties",None, QApplication.UnicodeUTF8))
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #MARKERS
        chargelabel = QLabel("<b>" + u(QApplication.translate("Label", "CHARGE",None, QApplication.UnicodeUTF8)) + "</b>")
        chargelabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        chargelabel.setStyleSheet("background-color:'#f07800';")
        self.chargeedit = QLineEdit(aw.qmc.stringfromseconds(0))
        self.chargeedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.chargeeditcopy = aw.qmc.stringfromseconds(0)
        self.chargeedit.setValidator(QRegExpValidator(regextime,self))
        self.chargeedit.setMaximumWidth(50)
        self.chargeedit.setMinimumWidth(50)
        chargelabel.setBuddy(self.chargeedit)
        self.charge_idx = 0
        self.drop_idx = 0
        charge_str = ""
        drop_str = ""
        if len(aw.qmc.timex):
            TP_index = aw.findTP()
            if aw.qmc.timeindex[1]:
                #manual dryend available
                dryEndIndex = aw.qmc.timeindex[1]
            else:
                #find when dry phase ends 
                dryEndIndex = aw.findDryEnd(TP_index)
            self.charge_idx = aw.findBTbreak(0,dryEndIndex)
            self.drop_idx = aw.findBTbreak(dryEndIndex)
            if self.charge_idx != 0 and self.charge_idx != aw.qmc.timeindex[0]:
                charge_str = aw.qmc.stringfromseconds(int(aw.qmc.timex[self.charge_idx]))
            if self.drop_idx != 0 and self.drop_idx != aw.qmc.timeindex[6]:
                drop_str = aw.qmc.stringfromseconds(int(aw.qmc.timex[self.drop_idx]-aw.qmc.timex[aw.qmc.timeindex[0]]))
        self.chargeestimate = QLabel(charge_str)
        self.chargeestimate.setMaximumWidth(50)
        self.chargeestimate.setMinimumWidth(50)
        drylabel = QLabel("<b>" + u(QApplication.translate("Label", "DRY END",None, QApplication.UnicodeUTF8)) + "</b>")
        drylabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        drylabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[1]:
            t2 = int(aw.qmc.timex[aw.qmc.timeindex[1]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t2 = 0
        self.dryedit = QLineEdit(aw.qmc.stringfromseconds(t2))
        self.dryedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.dryeditcopy = aw.qmc.stringfromseconds(t2)
        self.dryedit.setValidator(QRegExpValidator(regextime,self))
        self.dryedit.setMaximumWidth(50)
        self.dryedit.setMinimumWidth(50)
        drylabel.setBuddy(self.dryedit)
        Cstartlabel = QLabel("<b>" + u(QApplication.translate("Label","FC START",None, QApplication.UnicodeUTF8)) + "</b>")
        Cstartlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        Cstartlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[2]:
            t3 = int(aw.qmc.timex[aw.qmc.timeindex[2]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t3 = 0
        self.Cstartedit = QLineEdit(aw.qmc.stringfromseconds(t3))
        self.Cstartedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.Cstarteditcopy = aw.qmc.stringfromseconds(t3)
        self.Cstartedit.setValidator(QRegExpValidator(regextime,self))
        self.Cstartedit.setMaximumWidth(50)
        self.Cstartedit.setMinimumWidth(50)
        Cstartlabel.setBuddy(self.Cstartedit)
        
        Cendlabel = QLabel("<b>" + u(QApplication.translate("Label","FC END",None, QApplication.UnicodeUTF8)) + "</b>")
        Cendlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        Cendlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[3]:
            t4 = int(aw.qmc.timex[aw.qmc.timeindex[3]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t4 = 0
        self.Cendedit = QLineEdit(aw.qmc.stringfromseconds(t4))
        self.Cendedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.Cendeditcopy = aw.qmc.stringfromseconds(t4)
        self.Cendedit.setValidator(QRegExpValidator(regextime,self))
        self.Cendedit.setMaximumWidth(50)
        self.Cendedit.setMinimumWidth(50)
        Cendlabel.setBuddy(self.Cendedit)
        CCstartlabel = QLabel("<b>" + u(QApplication.translate("Label","SC START",None, QApplication.UnicodeUTF8)) + "</b>")
        CCstartlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        CCstartlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[4]:
            t5 = int(aw.qmc.timex[aw.qmc.timeindex[4]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t5 = 0
        self.CCstartedit = QLineEdit(aw.qmc.stringfromseconds(t5))
        self.CCstartedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.CCstarteditcopy = aw.qmc.stringfromseconds(t5)
        self.CCstartedit.setValidator(QRegExpValidator(regextime,self))
        self.CCstartedit.setMaximumWidth(50)
        self.CCstartedit.setMinimumWidth(50)
        CCstartlabel.setBuddy(self.CCstartedit)
        CCendlabel = QLabel("<b>" + u(QApplication.translate("Label","SC END",None, QApplication.UnicodeUTF8)) + "</b>")
        CCendlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        CCendlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[5]:
            t6 = int(aw.qmc.timex[aw.qmc.timeindex[5]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t6 = 0
        self.CCendedit = QLineEdit(aw.qmc.stringfromseconds(t6))
        self.CCendedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.CCendeditcopy = aw.qmc.stringfromseconds(t6)
        self.CCendedit.setValidator(QRegExpValidator(regextime,self))
        self.CCendedit.setMaximumWidth(50)
        self.CCendedit.setMinimumWidth(50)
        CCendlabel.setBuddy(self.CCendedit)
        droplabel = QLabel("<b>" + u(QApplication.translate("Label", "DROP",None, QApplication.UnicodeUTF8)) + "</b>")
        droplabel.setStyleSheet("background-color:'#f07800';")
        droplabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        if aw.qmc.timeindex[6]:
            t7 = int(aw.qmc.timex[aw.qmc.timeindex[6]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t7 = 0
        self.dropedit = QLineEdit(aw.qmc.stringfromseconds(t7))
        self.dropedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.dropeditcopy = aw.qmc.stringfromseconds(t7)
        self.dropedit.setValidator(QRegExpValidator(regextime,self))
        self.dropedit.setMaximumWidth(50)
        self.dropedit.setMinimumWidth(50)
        droplabel.setBuddy(self.dropedit)
        self.dropestimate = QLabel(drop_str)
        self.dropestimate.setMaximumWidth(50)
        self.dropestimate.setMinimumWidth(50)
        coollabel = QLabel("<b>" + u(QApplication.translate("Label", "COOL",None, QApplication.UnicodeUTF8)) + "</b>")
        coollabel.setStyleSheet("background-color:'#6666ff';")
        coollabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        if aw.qmc.timeindex[7]:
            t8 = int(aw.qmc.timex[aw.qmc.timeindex[7]]-aw.qmc.timex[aw.qmc.timeindex[0]])
        else:
            t8 = 0
        self.cooledit = QLineEdit(aw.qmc.stringfromseconds(t8))
        self.cooledit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.cooleditcopy = aw.qmc.stringfromseconds(t8)
        self.cooledit.setValidator(QRegExpValidator(regextime,self))
        self.cooledit.setMaximumWidth(50)
        self.cooledit.setMinimumWidth(50)
        coollabel.setBuddy(self.cooledit)
        self.roastproperties = QCheckBox(QApplication.translate("CheckBox","Delete roast properties on RESET", None, QApplication.UnicodeUTF8))
        self.roastproperties.setChecked(bool(aw.qmc.roastpropertiesflag))
        self.connect(self.roastproperties,SIGNAL("stateChanged(int)"),self.roastpropertiesChanged)
        # EVENTS
        #table for showing events
        self.eventtable = QTableWidget()
        self.eventtable.setTabKeyNavigation(True)
        self.eventtablecopy = []
        self.createEventTable()
        self.ordereventTableButton = QPushButton(QApplication.translate("Button", "Order",None, QApplication.UnicodeUTF8))
        self.ordereventTableButton.setFocusPolicy(Qt.NoFocus)
        self.ordereventTableButton.setMaximumSize(self.ordereventTableButton.sizeHint())
        self.ordereventTableButton.setMinimumSize(self.ordereventTableButton.minimumSizeHint())
        self.connect(self.ordereventTableButton,SIGNAL("clicked()"),self.orderEventTable)
        self.neweventTableButton = QPushButton(QApplication.translate("Button", "Add",None, QApplication.UnicodeUTF8))
        self.neweventTableButton.setFocusPolicy(Qt.NoFocus)
        self.neweventTableButton.setMaximumSize(self.neweventTableButton.sizeHint())
        self.neweventTableButton.setMinimumSize(self.neweventTableButton.minimumSizeHint())
        self.connect(self.neweventTableButton,SIGNAL("clicked()"),self.addEventTable)
        self.deleventTableButton = QPushButton(QApplication.translate("Button", "Delete",None, QApplication.UnicodeUTF8))
        self.deleventTableButton.setFocusPolicy(Qt.NoFocus)
        self.deleventTableButton.setMaximumSize(self.deleventTableButton.sizeHint())
        self.deleventTableButton.setMinimumSize(self.deleventTableButton.minimumSizeHint())
        self.connect(self.deleventTableButton,SIGNAL("clicked()"),self.deleteEventTable)
        #DATA Table
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        self.createDataTable()        
        #TITLE
        titlelabel = QLabel("<b>" + u(QApplication.translate("Label", "Title",None, QApplication.UnicodeUTF8)) + "</b>")
        self.titleedit = QLineEdit(aw.qmc.title)
        #Date
        datelabel1 = QLabel("<b>" + u(QApplication.translate("Label", "Date",None, QApplication.UnicodeUTF8)) + "</b>")
        date = aw.qmc.roastdate.toString()
        dateedit = QLineEdit(date)
        dateedit.setReadOnly(True)
        dateedit.setStyleSheet("background-color:'lightgrey'")
        #Beans
        beanslabel = QLabel("<b>" + u(QApplication.translate("Label", "Beans",None, QApplication.UnicodeUTF8)) + "</b>")
        self.beansedit = QTextEdit()
        self.beansedit.setMaximumHeight(60)
        if aw.qmc.beans is not None:
            self.beansedit.setPlainText(QString(aw.qmc.beans))
        #roaster
        self.roaster = QLineEdit(aw.qmc.roastertype)
        #operator
        self.operator = QLineEdit(aw.qmc.operator)
        #weight
        weightlabel = QLabel("<b>" + u(QApplication.translate("Label", "Weight",None, QApplication.UnicodeUTF8)) + "</b>")
        weightinlabel = QLabel(QApplication.translate("Label", " in",None, QApplication.UnicodeUTF8))
        weightoutlabel = QLabel(QApplication.translate("Label", " out",None, QApplication.UnicodeUTF8))
        inw = str(aw.qmc.weight[0])
        outw = str(aw.qmc.weight[1])
        self.weightinedit = QLineEdit(inw)
        self.weightinedit.setValidator(QDoubleValidator(0., 9999., 1, self.weightinedit))
        self.weightinedit.setMinimumWidth(55)
        self.weightinedit.setMaximumWidth(55)
        self.weightinedit.setAlignment(Qt.AlignRight)
        self.weightoutedit = QLineEdit(outw)
        self.weightoutedit.setValidator(QDoubleValidator(0., 9999., 1, self.weightoutedit))
        self.weightoutedit.setMinimumWidth(55)
        self.weightoutedit.setMaximumWidth(55)
        self.weightoutedit.setAlignment(Qt.AlignRight)
        self.weightpercentlabel = QLabel(QApplication.translate("Label", " %",None, QApplication.UnicodeUTF8))
        self.weightpercentlabel.setMinimumWidth(45)
        self.weightpercentlabel.setMaximumWidth(45)
        self.roastdegreelabel = QLabel("")
        self.roastdegreelabel.setMinimumWidth(80)
        self.roastdegreelabel.setMaximumWidth(80)
        self.percent()
        self.connect(self.weightoutedit,SIGNAL("editingFinished()"),self.percent)
        self.connect(self.weightinedit,SIGNAL("editingFinished()"),self.percent)
        self.unitsComboBox = QComboBox()
        self.unitsComboBox.setMaximumWidth(60)
        self.unitsComboBox.setMinimumWidth(60)
        self.unitsComboBox.addItems([QApplication.translate("ComboBox", "g", None, QApplication.UnicodeUTF8),
                                     QApplication.translate("ComboBox", "Kg", None, QApplication.UnicodeUTF8)])
        if aw.qmc.weight[2] == QApplication.translate("ComboBox", "g", None, QApplication.UnicodeUTF8):
            self.unitsComboBox.setCurrentIndex(0)
        else:
            self.unitsComboBox.setCurrentIndex(1)
        #volume
        volumelabel = QLabel("<b>" + u(QApplication.translate("Label", "Volume",None, QApplication.UnicodeUTF8)) + "</b>")
        volumeinlabel = QLabel(QApplication.translate("Label", " in",None, QApplication.UnicodeUTF8))
        volumeoutlabel = QLabel(QApplication.translate("Label", " out",None, QApplication.UnicodeUTF8))
        inv = str(aw.qmc.volume[0])
        outv = str(aw.qmc.volume[1])
        self.volumeinedit = QLineEdit(inv)
        self.volumeinedit.setValidator(QDoubleValidator(0., 9999., 1, self.volumeinedit))
        self.volumeinedit.setMinimumWidth(55)
        self.volumeinedit.setMaximumWidth(55)
        self.volumeinedit.setAlignment(Qt.AlignRight)
        self.volumeoutedit = QLineEdit(outv)
        self.volumeoutedit.setValidator(QDoubleValidator(0., 9999., 1, self.volumeoutedit))
        self.volumeoutedit.setMinimumWidth(55)
        self.volumeoutedit.setMaximumWidth(55)
        self.volumeoutedit.setAlignment(Qt.AlignRight)
        self.volumepercentlabel = QLabel(QApplication.translate("Label", " %",None, QApplication.UnicodeUTF8))
        self.volumepercentlabel.setMinimumWidth(45)
        self.volumepercentlabel.setMaximumWidth(45)
        self.volume_percent()
        self.connect(self.volumeoutedit,SIGNAL("editingFinished()"),self.volume_percent)
        self.connect(self.volumeinedit,SIGNAL("editingFinished()"),self.volume_percent)
        self.volumeUnitsComboBox = QComboBox()
        self.volumeUnitsComboBox.setMaximumWidth(60)
        self.volumeUnitsComboBox.setMinimumWidth(60)
        self.volumeUnitsComboBox.addItems([QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8),
                                           QApplication.translate("ComboBox", "l",None, QApplication.UnicodeUTF8)])
        if aw.qmc.volume[2] == QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8):
            self.volumeUnitsComboBox.setCurrentIndex(0)
        else:
            self.volumeUnitsComboBox.setCurrentIndex(1)
        self.calculateddensitylabel = QLabel("")
        self.connect(self.weightoutedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.weightinedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.volumeoutedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.volumeinedit,SIGNAL("editingFinished()"),self.calculated_density)
        self.connect(self.volumeUnitsComboBox,SIGNAL("currentIndexChanged(int)"),self.calculated_density)
        self.connect(self.unitsComboBox,SIGNAL("currentIndexChanged(int)"),self.calculated_density)
        #density
        bean_density_label = QLabel("<b>" + u(QApplication.translate("Label", "Density",None, QApplication.UnicodeUTF8)) + "</b>")
        self.bean_density_weight_edit = QLineEdit(str(aw.qmc.density[0]))
        self.bean_density_weight_edit.setValidator(QDoubleValidator(0., 9999., 1,self.bean_density_weight_edit))
        self.bean_density_weight_edit.setMinimumWidth(55)
        self.bean_density_weight_edit.setMaximumWidth(55)
        self.bean_density_weight_edit.setAlignment(Qt.AlignRight)
        self.bean_density_weightUnitsComboBox = QComboBox()
        self.bean_density_weightUnitsComboBox.setMaximumWidth(60)
        self.bean_density_weightUnitsComboBox.setMinimumWidth(60)
        self.bean_density_weightUnitsComboBox.addItems([QApplication.translate("ComboBox", "g",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("ComboBox", "Kg",None, QApplication.UnicodeUTF8)])
        if aw.qmc.density[1] == QApplication.translate("ComboBox", "g",None, QApplication.UnicodeUTF8):
            self.bean_density_weightUnitsComboBox.setCurrentIndex(0)
        else:
            self.bean_density_weightUnitsComboBox.setCurrentIndex(1)
        bean_density_per_label = QLabel(QApplication.translate("Label", "per",None, QApplication.UnicodeUTF8))
        self.bean_density_volume_edit = QLineEdit(str(aw.qmc.density[2]))
        self.bean_density_volume_edit.setValidator(QDoubleValidator(0., 9999., 1,self.bean_density_volume_edit))
        self.bean_density_volume_edit.setMinimumWidth(55)
        self.bean_density_volume_edit.setMaximumWidth(55)
        self.bean_density_volume_edit.setAlignment(Qt.AlignRight)
        self.bean_density_volumeUnitsComboBox = QComboBox()
        self.bean_density_volumeUnitsComboBox.setMaximumWidth(60)
        self.bean_density_volumeUnitsComboBox.setMinimumWidth(60)
        self.bean_density_volumeUnitsComboBox.addItems([QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("ComboBox", "l",None, QApplication.UnicodeUTF8)])
        if aw.qmc.density[3] == QApplication.translate("ComboBox", "ml",None, QApplication.UnicodeUTF8):
            self.bean_density_volumeUnitsComboBox.setCurrentIndex(0)
        else:
            self.bean_density_volumeUnitsComboBox.setCurrentIndex(1)
        self.standarddensitylabel = QLabel("")
        self.standard_density()
        self.connect(self.bean_density_volume_edit,SIGNAL("editingFinished()"),self.standard_density)
        self.connect(self.bean_density_weight_edit,SIGNAL("editingFinished()"),self.standard_density)
        #bean size
        bean_size_label = QLabel("<b>" + u(QApplication.translate("Label", "Bean Size",None, QApplication.UnicodeUTF8)) + "</b>")
        self.bean_size_edit = QLineEdit(str(aw.qmc.beansize))
        self.bean_size_edit.setValidator(QDoubleValidator(0., 10., 1,self.bean_density_weight_edit))
        self.bean_size_edit.setMinimumWidth(45)
        self.bean_size_edit.setMaximumWidth(45)
        self.bean_size_edit.setAlignment(Qt.AlignRight)
        bean_size_unit_label = QLabel(QApplication.translate("Label", "mm",None, QApplication.UnicodeUTF8))
        #bean color
        whole_color_label = QLabel("<b>" + u(QApplication.translate("Label", "Whole Color",None, QApplication.UnicodeUTF8)) + "</b>")
        self.whole_color_edit = QLineEdit(str(aw.qmc.whole_color))
        self.whole_color_edit.setValidator(QIntValidator(0, 1000, self.bean_density_weight_edit))
        self.whole_color_edit.setMinimumWidth(45)
        self.whole_color_edit.setMaximumWidth(45)
        self.whole_color_edit.setAlignment(Qt.AlignRight)
        ground_color_label = QLabel("<b>" + u(QApplication.translate("Label", "Ground Color",None, QApplication.UnicodeUTF8)) + "</b>")
        self.ground_color_edit = QLineEdit(str(aw.qmc.ground_color))
        self.ground_color_edit.setValidator(QIntValidator(0, 1000, self.bean_density_weight_edit))
        self.ground_color_edit.setMinimumWidth(45)
        self.ground_color_edit.setMaximumWidth(45)
        self.ground_color_edit.setAlignment(Qt.AlignRight)
        self.bean_size_edit.setAlignment(Qt.AlignRight)
        self.colorSystemComboBox = QComboBox()
        self.colorSystemComboBox.addItems(aw.qmc.color_systems)
        self.colorSystemComboBox.setCurrentIndex(aw.qmc.color_system_idx)
        #bag humidity
        bag_humidity_label = QLabel("<b>" + u(QApplication.translate("Label", "Storage Conditions",None, QApplication.UnicodeUTF8)) + "</b>")
        bag_humidity_unitslabel = QLabel(aw.qmc.mode)
        bag_humidity_unit_label = QLabel(QApplication.translate("Label", "%",None, QApplication.UnicodeUTF8))
        self.humidity_edit = QLineEdit()
        self.humidity_edit.setText(str(aw.qmc.bag_humidity[0]))
        self.humidity_edit.setMaximumWidth(50)
        self.humidity_edit.setValidator(QDoubleValidator(0., 100., 1, self.humidity_edit))
        self.humidity_edit.setAlignment(Qt.AlignRight)
        bag_humidity_at_label = QLabel(QApplication.translate("Label", "at",None, QApplication.UnicodeUTF8))
        self.bag_temp_edit = QLineEdit()
        self.bag_temp_edit.setText(str(aw.qmc.bag_humidity[1]))
        self.bag_temp_edit.setMaximumWidth(50)
        self.bag_temp_edit.setValidator(QDoubleValidator(0., 200., 1, self.bag_temp_edit))
        self.bag_temp_edit.setAlignment(Qt.AlignRight)
        self.bag_humiditity_tempUnitsComboBox = QComboBox()
        self.bag_humiditity_tempUnitsComboBox.setMaximumWidth(60)
        self.bag_humiditity_tempUnitsComboBox.setMinimumWidth(60)
        #Ambient temperature (uses display mode as unit (F or C)
        ambientlabel = QLabel("<b>" + u(QApplication.translate("Label", "Ambient Conditions",None, QApplication.UnicodeUTF8)) + "</b>")
        ambientunitslabel = QLabel(aw.qmc.mode)
        ambient_humidity_unit_label = QLabel(QApplication.translate("Label", "%",None, QApplication.UnicodeUTF8))
        self.ambient_humidity_edit = QLineEdit()
        self.ambient_humidity_edit.setText(str(aw.qmc.ambient_humidity))
        self.ambient_humidity_edit.setMaximumWidth(50)
        self.ambient_humidity_edit.setValidator(QDoubleValidator(0., 100., 1, self.ambient_humidity_edit))  
        self.ambient_humidity_edit.setAlignment(Qt.AlignRight) 
        ambient_humidity_at_label = QLabel(QApplication.translate("Label", "at",None, QApplication.UnicodeUTF8))
        self.ambientedit = QLineEdit()
        self.ambientedit.setText(str(aw.qmc.ambientTemp))
        self.ambientedit.setMaximumWidth(50)
        self.ambientedit.setValidator(QDoubleValidator(0., 200., 1, self.ambientedit))  
        self.ambientedit.setAlignment(Qt.AlignRight)       
        self.ambientedit_tempUnitsComboBox = QComboBox()
        self.ambientedit_tempUnitsComboBox.setMaximumWidth(60)
        self.ambientedit_tempUnitsComboBox.setMinimumWidth(60)
        # NOTES
        roastertypelabel = QLabel()
        roastertypelabel.setText("<b>" + u(QApplication.translate("Label", "Roaster",None, QApplication.UnicodeUTF8)) + "</b>")
        operatorlabel = QLabel()
        operatorlabel.setText("<b>" + u(QApplication.translate("Label", "Operator",None, QApplication.UnicodeUTF8)) + "</b>")
        roastinglabel = QLabel("<b>" + u(QApplication.translate("Label", "Roasting Notes",None, QApplication.UnicodeUTF8)) + "</b>")
        self.roastingeditor = QTextEdit()
        if aw.qmc.roastingnotes is not None:
            self.roastingeditor.setPlainText(QString(aw.qmc.roastingnotes))
        cuppinglabel = QLabel("<b>" + u(QApplication.translate("Label", "Cupping Notes",None, QApplication.UnicodeUTF8)) + "</b>")
        self.cuppingeditor =  QTextEdit()
        if aw.qmc.cuppingnotes is not None:
            self.cuppingeditor.setPlainText(QString(aw.qmc.cuppingnotes))
        # Flags
        self.heavyFC = QCheckBox(QApplication.translate("CheckBox","Heavy FC", None, QApplication.UnicodeUTF8))
        self.heavyFC.setChecked(aw.qmc.heavyFC_flag)
        self.connect(self.heavyFC,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("heavyFC",x))
        self.lowFC = QCheckBox(QApplication.translate("CheckBox","Low FC", None, QApplication.UnicodeUTF8))
        self.lowFC.setChecked(aw.qmc.lowFC_flag)
        self.connect(self.lowFC,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("lowFC",x))
        self.lightCut = QCheckBox(QApplication.translate("CheckBox","Light Cut", None, QApplication.UnicodeUTF8))
        self.lightCut.setChecked(aw.qmc.lightCut_flag)
        self.connect(self.lightCut,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("lightCut",x))
        self.darkCut = QCheckBox(QApplication.translate("CheckBox","Dark Cut", None, QApplication.UnicodeUTF8))
        self.darkCut.setChecked(aw.qmc.darkCut_flag)
        self.connect(self.darkCut,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("darkCut",x))        
        self.drops = QCheckBox(QApplication.translate("CheckBox","Drops", None, QApplication.UnicodeUTF8))
        self.drops.setChecked(aw.qmc.drops_flag)
        self.connect(self.drops,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("drops",x))
        self.oily = QCheckBox(QApplication.translate("CheckBox","Oily", None, QApplication.UnicodeUTF8))
        self.oily.setChecked(aw.qmc.oily_flag)
        self.connect(self.oily,SIGNAL("stateChanged(int)"),lambda x=0: self.roastflagChanged("oily",x))
        self.uneven = QCheckBox(QApplication.translate("CheckBox","Uneven", None, QApplication.UnicodeUTF8))
        self.uneven.setChecked(aw.qmc.uneven_flag)
        self.tipping = QCheckBox(QApplication.translate("CheckBox","Tipping", None, QApplication.UnicodeUTF8))
        self.tipping.setChecked(aw.qmc.tipping_flag)
        self.scorching = QCheckBox(QApplication.translate("CheckBox","Scorching", None, QApplication.UnicodeUTF8))
        self.scorching.setChecked(aw.qmc.scorching_flag)
        self.divots = QCheckBox(QApplication.translate("CheckBox","Divots", None, QApplication.UnicodeUTF8))
        self.divots.setChecked(aw.qmc.divots_flag)
        # Save button
        saveButton = QPushButton(QApplication.translate("Button", "OK",None, QApplication.UnicodeUTF8))
        self.connect(saveButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        saveButton.setMaximumSize(saveButton.sizeHint())
        saveButton.setMinimumSize(saveButton.minimumSizeHint()) 
        #Cancel Button
        cancelButton = QPushButton(QApplication.translate("Button", "Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        #cancelButton.setMaximumSize(70, 30)
        cancelButton.setMaximumSize(cancelButton.sizeHint())
        cancelButton.setMinimumSize(cancelButton.minimumSize())
        # in button
        inButton = QPushButton(QApplication.translate("Button", "in",None, QApplication.UnicodeUTF8))
        self.connect(inButton, SIGNAL("clicked()"),self.inWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        inButton.setMaximumSize(60,35)
        inButton.setMinimumSize(60,35) 
        inButton.setFocusPolicy(Qt.NoFocus)
        # out button
        outButton = QPushButton(QApplication.translate("Button", "out",None, QApplication.UnicodeUTF8))
        self.connect(outButton, SIGNAL("clicked()"),self.outWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        outButton.setMaximumSize(60,35)
        outButton.setMinimumSize(60,35) 
        outButton.setFocusPolicy(Qt.NoFocus)
        # Ambient Temperature Source Selector
        self.ambientComboBox = QComboBox()
        self.ambientComboBox.addItems(self.buildAmbientTemperatureSourceList())
        self.ambientComboBox.setCurrentIndex(aw.qmc.ambientTempSource)
        self.connect(self.ambientComboBox, SIGNAL("currentIndexChanged(int)"),self.ambientComboBoxIndexChanged)
        ambientSourceLabel = QLabel(QApplication.translate("Label", "Ambient Source",None, QApplication.UnicodeUTF8))
        updateAmbientTemp = QPushButton(QApplication.translate("Button", "Update",None, QApplication.UnicodeUTF8))
        updateAmbientTemp.setFocusPolicy(Qt.NoFocus)
        self.connect(updateAmbientTemp, SIGNAL("clicked()"),self.updateAmbientTemp)
        ##### LAYOUTS
        timeLayout = QGridLayout()
        timeLayout.addWidget(chargelabel,0,0)
        timeLayout.addWidget(drylabel,0,1)
        timeLayout.addWidget(Cstartlabel,0,2)
        timeLayout.addWidget(Cendlabel,0,3)
        timeLayout.addWidget(CCstartlabel,0,4)
        timeLayout.addWidget(CCendlabel,0,5)
        timeLayout.addWidget(droplabel,0,6)
        timeLayout.addWidget(coollabel,0,7)
        timeLayout.addWidget(self.chargeedit,1,0,Qt.AlignHCenter)
        timeLayout.addWidget(self.dryedit,1,1,Qt.AlignHCenter)
        timeLayout.addWidget(self.Cstartedit,1,2,Qt.AlignHCenter)
        timeLayout.addWidget(self.Cendedit,1,3,Qt.AlignHCenter)
        timeLayout.addWidget(self.CCstartedit,1,4,Qt.AlignHCenter)
        timeLayout.addWidget(self.CCendedit,1,5,Qt.AlignHCenter)
        timeLayout.addWidget(self.dropedit,1,6,Qt.AlignHCenter)
        timeLayout.addWidget(self.cooledit,1,7,Qt.AlignHCenter)
        if charge_str != "" or drop_str != "":
            timeLayout.addWidget(self.chargeestimate,2,0)
            timeLayout.addWidget(self.dropestimate,2,6)
        textLayout = QGridLayout()
        textLayout.addWidget(datelabel1,0,0)
        textLayout.addWidget(dateedit,0,1)
        textLayout.addWidget(titlelabel,1,0)
        textLayout.addWidget(self.titleedit,1,1)
        textLayout.addWidget(beanslabel,2,0)
        textLayout.addWidget(self.beansedit,2,1)
        textLayout.addWidget(roastertypelabel,3,0)
        textLayout.addWidget(self.roaster,3,1)
        textLayout.addWidget(operatorlabel,4,0)
        textLayout.addWidget(self.operator,4,1)
        weightLayout = QHBoxLayout()
        weightLayout.setSpacing(0)
        weightLayout.addWidget(weightlabel)
        weightLayout.addSpacing(18)
        weightLayout.addWidget(self.unitsComboBox)
        weightLayout.addSpacing(15)
        weightLayout.addWidget(self.weightinedit)
        weightLayout.addSpacing(1)
        weightLayout.addWidget(weightinlabel)
        weightLayout.addSpacing(15)
        weightLayout.addWidget(self.weightoutedit)
        weightLayout.addSpacing(1)
        weightLayout.addWidget(weightoutlabel)
        weightLayout.addSpacing(15)
        weightLayout.addWidget(self.weightpercentlabel)
        weightLayout.addSpacing(10)
        weightLayout.addWidget(self.roastdegreelabel)
        if aw.scale.device_id != 0:
            weightLayout.addWidget(inButton) 
            weightLayout.addSpacing(10)
            weightLayout.addWidget(outButton) 
        weightLayout.addStretch()  
        volumeLayout = QHBoxLayout()
        volumeLayout.setSpacing(0)
        volumeLayout.addWidget(volumelabel)
        volumeLayout.addSpacing(14)
        volumeLayout.addWidget(self.volumeUnitsComboBox)
        volumeLayout.addSpacing(15)
        volumeLayout.addWidget(self.volumeinedit)
        volumeLayout.addSpacing(1)
        volumeLayout.addWidget(volumeinlabel)
        volumeLayout.addSpacing(15)
        volumeLayout.addWidget(self.volumeoutedit)
        volumeLayout.addSpacing(1)
        volumeLayout.addWidget(volumeoutlabel)
        volumeLayout.addSpacing(15)
        volumeLayout.addWidget(self.volumepercentlabel)
        volumeLayout.addStretch()
        densityLayout = QHBoxLayout()
        densityLayout.setSpacing(0)
        densityLayout.addWidget(bean_density_label)
        densityLayout.addSpacing(13)
        densityLayout.addWidget(self.bean_density_weightUnitsComboBox)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(self.bean_density_weight_edit)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(bean_density_per_label)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(self.bean_density_volumeUnitsComboBox)
        densityLayout.addSpacing(15)
        densityLayout.addWidget(self.bean_density_volume_edit)
        densityLayout.addSpacing(20)
        densityLayout.addWidget(self.standarddensitylabel)
        densityLayout.addStretch()
        beansizeLayout = QHBoxLayout()
        beansizeLayout.setSpacing(0)
        beansizeLayout.addWidget(bean_size_label)
        beansizeLayout.addSpacing(15)
        beansizeLayout.addWidget(self.bean_size_edit)
        beansizeLayout.addSpacing(5)
        beansizeLayout.addWidget(bean_size_unit_label)
        beansizeLayout.addStretch()
        colorLayout = QHBoxLayout()
        colorLayout.setSpacing(0)
        colorLayout.addWidget(whole_color_label)
        colorLayout.addSpacing(15)
        colorLayout.addWidget(self.whole_color_edit)
        colorLayout.addSpacing(25)
        colorLayout.addWidget(ground_color_label)
        colorLayout.addSpacing(15)
        colorLayout.addWidget(self.ground_color_edit)
        colorLayout.addStretch()
        colorLayout.addWidget(self.colorSystemComboBox)
        humidityLayout = QHBoxLayout()
        humidityLayout.addWidget(bag_humidity_label)
        humidityLayout.addSpacing(5)
        humidityLayout.addWidget(self.humidity_edit)
        humidityLayout.addWidget(bag_humidity_unit_label)
        humidityLayout.addSpacing(15)
        humidityLayout.addWidget(bag_humidity_at_label)
        humidityLayout.addSpacing(15)
        humidityLayout.addWidget(self.bag_temp_edit)
        humidityLayout.addWidget(bag_humidity_unitslabel)
        humidityLayout.addStretch()
        humidityLayout.addWidget(ambientSourceLabel)
        ambientLayout = QHBoxLayout()
        ambientLayout.addWidget(ambientlabel)
        ambientLayout.addWidget(self.ambient_humidity_edit)
        ambientLayout.addWidget(ambient_humidity_unit_label)
        ambientLayout.addSpacing(15)
        ambientLayout.addWidget(ambient_humidity_at_label)
        ambientLayout.addSpacing(15)
        ambientLayout.addWidget(self.ambientedit)
        ambientLayout.addWidget(ambientunitslabel)
        ambientLayout.addStretch()
        ambientLayout.addWidget(self.ambientComboBox)
        roastFlagsLayout = QHBoxLayout()
        roastFlagsGrid = QGridLayout()
        roastFlagsGrid.addWidget(self.lowFC,0,0)
        roastFlagsGrid.addWidget(self.heavyFC,1,0)
        roastFlagsGrid.addWidget(self.lightCut,0,1)
        roastFlagsGrid.addWidget(self.darkCut,1,1)
        roastFlagsGrid.addWidget(self.drops,0,2)
        roastFlagsGrid.addWidget(self.oily,1,2)
        roastFlagsGrid.addWidget(self.uneven,0,3)
        roastFlagsGrid.addWidget(self.tipping,1,3)
        roastFlagsGrid.addWidget(self.scorching,0,4)
        roastFlagsGrid.addWidget(self.divots,1,4)
        roastFlagsLayout.addLayout(roastFlagsGrid)
        roastFlagsLayout.addStretch()
        anotationLayout = QVBoxLayout()
        anotationLayout.addWidget(roastinglabel)
        anotationLayout.addWidget(self.roastingeditor)
        anotationLayout.addLayout(roastFlagsLayout)
        anotationLayout.addWidget(cuppinglabel)
        anotationLayout.addWidget(self.cuppingeditor)
        okLayout = QHBoxLayout()
        okLayout.addStretch()
        okLayout.addWidget(cancelButton,0)
        okLayout.addWidget(saveButton,1)
        okLayout.setContentsMargins(0, 0, 0, 0) # left, top, right, bottom
        timeLayoutBox = QHBoxLayout()
        timeLayoutBox.addLayout(timeLayout)
        timeLayoutBox.addStretch()
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(timeLayoutBox)
        timeGroupLayout = QGroupBox(QApplication.translate("GroupBox", "Times",None, QApplication.UnicodeUTF8))
        timeGroupLayout.setLayout(mainLayout)
        eventbuttonLayout = QHBoxLayout()
        eventbuttonLayout.addStretch()
        eventbuttonLayout.addWidget(self.ordereventTableButton)
        eventbuttonLayout.addWidget(self.deleventTableButton)
        eventbuttonLayout.addWidget(self.neweventTableButton)
        #tab 1
        self.tab1aLayout = QVBoxLayout()
        self.tab1aLayout.addWidget(timeGroupLayout)
        self.tab1aLayout.addLayout(textLayout)
        self.tab1aLayout.addLayout(weightLayout)
        self.tab1aLayout.addLayout(volumeLayout)
        self.tab1aLayout.addLayout(densityLayout)
        self.tab1aLayout.addLayout(beansizeLayout)
        self.tab1aLayout.addLayout(colorLayout)
        tab1bLayout = QVBoxLayout()
        tab1bLayout.addLayout(humidityLayout)
        tab1bLayout.addLayout(ambientLayout)
        tab1bLayout.addStretch()
        roastpropertiesLayout = QHBoxLayout()
        roastpropertiesLayout.addWidget(self.roastproperties)
        roastpropertiesLayout.addStretch()
        roastpropertiesLayout.addWidget(updateAmbientTemp)
        tab1Layout = QVBoxLayout()
        tab1Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab1Layout.setMargin(0)
        tab1Layout.addLayout(self.tab1aLayout)
        tab1Layout.addLayout(tab1bLayout)
        tab1Layout.addLayout(roastpropertiesLayout)
        self.calculated_density()
        #tab 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addLayout(anotationLayout)
        tab2Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab2Layout.setMargin(0)
        #tab3 events
        tab3Layout = QVBoxLayout()
        tab3Layout.addWidget(self.eventtable)
        tab3Layout.addLayout(eventbuttonLayout)
        tab3Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        tab3Layout.setMargin(0)
        #tab 4 data
        tab4Layout = QVBoxLayout()
        tab4Layout.addWidget(self.datatable) 
        tab4Layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom 
        tab4Layout.setMargin(0)
        #tabwidget
        self.TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab", "General",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab", "Notes",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab", "Events",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        self.TabWidget.addTab(C4Widget,QApplication.translate("Tab", "Data",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        totallayout = QVBoxLayout()
        totallayout.addWidget(self.TabWidget)
        totallayout.addLayout(okLayout)
        totallayout.setMargin(10)
        #totallayout.addStretch()
        #totallayout.addLayout(buttonsLayout)
        self.setLayout(totallayout)
        
    def roastflagChanged(self,flagname,x):
        if x == Qt.Checked:
            if flagname == "heavyFC":
                self.lowFC.setChecked(False)
            elif flagname == "lowFC":
                self.heavyFC.setChecked(False)
            elif flagname == "lightCut":
                self.darkCut.setChecked(False)
            elif flagname == "darkCut":
                self.lightCut.setChecked(False)
            elif flagname == "drops":
                self.oily.setChecked(False)
            elif flagname == "oily":
                self.drops.setChecked(False)

    def ambientComboBoxIndexChanged(self,i):
        aw.qmc.ambientTempSource = i

    def buildAmbientTemperatureSourceList(self):
        extra_names = []
        for i in range(len(aw.qmc.extradevices)):
            extra_names.append(u(i) + "xT1: " + aw.qmc.extraname1[i])
            extra_names.append(u(i) + "xT2: " + aw.qmc.extraname2[i])
        return ["",
                QApplication.translate("ComboBox","ET",None, QApplication.UnicodeUTF8),
                QApplication.translate("ComboBox","BT",None, QApplication.UnicodeUTF8)] + extra_names

    def updateAmbientTemp(self):
        aw.qmc.updateAmbientTemp()
        self.ambientedit.setText(str(aw.qmc.ambientTemp))

    def outWeight(self):
        aw.retrieveWeightOut()
        self.weightinedit.setText(str(aw.qmc.weight[0]))
        self.weightoutedit.setText(str(aw.qmc.weight[1]))

    def inWeight(self):
        aw.retrieveWeightIn()
        self.weightinedit.setText(str(aw.qmc.weight[0]))
        self.weightoutedit.setText(str(aw.qmc.weight[1]))

    def roastpropertiesChanged(self):
        if self.roastproperties.isChecked():
            aw.qmc.roastpropertiesflag = 1
        else:
            aw.qmc.roastpropertiesflag = 0

    def createDataTable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.timex)
        self.datatable.setRowCount(ndata)
        self.datatable.setColumnCount(6)
        self.datatable.setHorizontalHeaderLabels([QApplication.translate("Table", "Abs Time",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "Rel Time",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "ET",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "BT",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "DeltaET (d/m)",None, QApplication.UnicodeUTF8),
                                                  QApplication.translate("Table", "DeltaBT (d/m)",None, QApplication.UnicodeUTF8)])
        self.datatable.setAlternatingRowColors(True)
        self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
        self.datatable.setSelectionMode(QTableWidget.SingleSelection)
        self.datatable.setShowGrid(True)
        for i in range(ndata):
            Atime = QTableWidgetItem("%.03f"%aw.qmc.timex[i])
            Rtime = QTableWidgetItem(aw.qmc.stringfromseconds(int(round(aw.qmc.timex[i]-aw.qmc.timex[aw.qmc.timeindex[0]]))))
            ET = QTableWidgetItem("%.02f"%aw.qmc.temp1[i])
            BT = QTableWidgetItem("%.02f"%aw.qmc.temp2[i])
            if i > 0 and (aw.qmc.timex[i]-aw.qmc.timex[i-1]):
                deltaET = QTableWidgetItem("%.02f"%(60*(aw.qmc.temp1[i]-aw.qmc.temp1[i-1])/(aw.qmc.timex[i]-aw.qmc.timex[i-1])))
                deltaBT = QTableWidgetItem("%.02f"%(60*(aw.qmc.temp2[i]-aw.qmc.temp2[i-1])/(aw.qmc.timex[i]-aw.qmc.timex[i-1])))
            else:
                deltaET = QTableWidgetItem("--")
                deltaBT = QTableWidgetItem("--")
            if i:                
                    #identify by color and add notation
                if i == aw.qmc.timeindex[0]:
                    Rtime.setBackgroundColor(QColor('#f07800'))
                    text = QApplication.translate("Table", "%1 START",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[1]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "%1 DRY END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[2]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "%1 FC START",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[3]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "%1 FC END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[4]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "%1 SC START",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[5]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "%1 SC END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[6]:
                    Rtime.setBackgroundColor(QColor('#f07800'))
                    text = QApplication.translate("Table", "%1 END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                elif i == aw.qmc.timeindex[7]:
                    Rtime.setBackgroundColor(QColor('orange'))
                    text = QApplication.translate("Table", "%1 COOL",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                    Rtime.setText(text)
                    
            if i in aw.qmc.specialevents:
                Rtime.setBackgroundColor(QColor('yellow'))
                index = aw.qmc.specialevents.index(i)
                text = QApplication.translate("Table", "%1 EVENT #%2 %3%4",None, QApplication.UnicodeUTF8).arg(Rtime.text()).arg(str(index+1)).arg(aw.qmc.etypesf(aw.qmc.specialeventstype[index])[0]).arg(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[index]))
                Rtime.setText(text)
            self.datatable.setItem(i,0,Atime) 
            self.datatable.setItem(i,1,Rtime)
            self.datatable.setItem(i,2,ET)
            self.datatable.setItem(i,3,BT)
            self.datatable.setItem(i,4,deltaET)
            self.datatable.setItem(i,5,deltaBT)
        self.datatable.resizeColumnsToContents()

    def createEventTable(self):
        self.eventtable.clear()
        nevents = len(aw.qmc.specialevents)
        self.eventtable.setRowCount(nevents)
        self.eventtable.setColumnCount(4)
        self.eventtable.setHorizontalHeaderLabels([QApplication.translate("Table", "Time", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "Description", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "Type", None, QApplication.UnicodeUTF8),
                                                   QApplication.translate("Table", "Value", None, QApplication.UnicodeUTF8)])
        self.eventtable.setAlternatingRowColors(True)
        self.eventtable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.eventtable.setSelectionBehavior(QTableWidget.SelectRows)
        self.eventtable.setSelectionMode(QTableWidget.SingleSelection)
        self.eventtable.setShowGrid(True)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        regexvalue = QRegExp(r"^100|\d?\d?$")
        self.eventtable.setShowGrid(True) 
        etypes = aw.qmc.getetypes()
        #populate table
        for i in range(nevents):
            #create widgets
            typeComboBox = QComboBox()
            typeComboBox.addItems(etypes)
            typeComboBox.setCurrentIndex(aw.qmc.specialeventstype[i])
            valueEdit = QLineEdit()
            valueEdit.setAlignment(Qt.AlignRight)
            valueEdit.setValidator(QRegExpValidator(regexvalue,self))
            valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[i]))
            timeline = QLineEdit()
            timeline.setAlignment(Qt.AlignRight)
            timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[i]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
            self.eventtablecopy.append(str(timez)) 
            timeline.setText(timez)
            timeline.setValidator(QRegExpValidator(regextime,self))
            stringline = QLineEdit(aw.qmc.specialeventsStrings[i])
            #add widgets to the table
            self.eventtable.setCellWidget(i,0,timeline)
            self.eventtable.setCellWidget(i,1,stringline)
            self.eventtable.setCellWidget(i,2,typeComboBox)
            self.eventtable.setCellWidget(i,3,valueEdit)
        self.eventtable.resizeColumnsToContents()
        # improve width of Time column
        self.eventtable.setColumnWidth(0,65)
        self.eventtable.setColumnWidth(1,315)
        self.eventtable.setColumnWidth(3,65)

    def saveEventTable(self):
        nevents = self.eventtable.rowCount() 
        for i in range(nevents):
            timez = self.eventtable.cellWidget(i,0)
            if self.eventtablecopy[i] !=  str(timez.text()):
                aw.qmc.specialevents[i] = aw.qmc.time2index(aw.qmc.timex[aw.qmc.timeindex[0]]+ aw.qmc.stringtoseconds(str(timez.text())))
            description = self.eventtable.cellWidget(i,1)
            aw.qmc.specialeventsStrings[i] = str(description.text())
            etype = self.eventtable.cellWidget(i,2)
            aw.qmc.specialeventstype[i] = etype.currentIndex()
            evalue = self.eventtable.cellWidget(i,3).text()
            aw.qmc.specialeventsvalue[i] = aw.qmc.str2eventsvalue(str(evalue))

    def orderEventTable(self):
        nevents = len(aw.qmc.specialevents)
        if nevents:
            for i in range(nevents-1):
                if aw.qmc.specialevents[i] > aw.qmc.specialevents[i+1]:
                    itime = aw.qmc.specialevents[i]
                    itype = aw.qmc.specialeventstype[i]
                    istring = aw.qmc.specialeventsStrings[i]
                    ivalue = aw.qmc.specialeventsvalue[i]
                    aw.qmc.specialevents[i] = aw.qmc.specialevents[i+1]
                    aw.qmc.specialeventstype[i] = aw.qmc.specialeventstype[i+1]
                    aw.qmc.specialeventsStrings[i] = aw.qmc.specialeventsStrings[i+1]
                    aw.qmc.specialeventsvalue[i] = aw.qmc.specialeventsvalue[i+1]
                    aw.qmc.specialevents[i+1] = itime
                    aw.qmc.specialeventstype[i+1] = itype
                    aw.qmc.specialeventsStrings[i+1] = istring
                    aw.qmc.specialeventsvalue[i+1] = ivalue
                    self.orderEventTable()
                    return
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)

    def addEventTable(self):
        if len(aw.qmc.timex):
            self.saveEventTable()
            aw.qmc.specialevents.append(len(aw.qmc.timex)-1)   #qmc.specialevents holds indexes in qmx.timex. Initialize event index
            aw.qmc.specialeventstype.append(0)
            aw.qmc.specialeventsStrings.append(str(len(aw.qmc.specialevents)))
            aw.qmc.specialeventsvalue.append(0)
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            message = QApplication.translate("Message","Event #%1 added", None, QApplication.UnicodeUTF8).arg(str(len(aw.qmc.specialevents))) 
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No profile found", None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)

    def deleteEventTable(self):
        if len(aw.qmc.specialevents):
            self.saveEventTable()
            # check for selection
            selected = self.eventtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                aw.qmc.specialevents = aw.qmc.specialevents[0:selected_row] + aw.qmc.specialevents[selected_row + 1:]
                aw.qmc.specialeventstype = aw.qmc.specialeventstype[0:selected_row] + aw.qmc.specialeventstype[selected_row + 1:]
                aw.qmc.specialeventsStrings = aw.qmc.specialeventsStrings[0:selected_row] + aw.qmc.specialeventsStrings[selected_row + 1:]
                aw.qmc.specialeventsvalue = aw.qmc.specialeventsvalue[0:selected_row] + aw.qmc.specialeventsvalue[selected_row + 1:]
                message = QApplication.translate("Message"," Event #%1 deleted", None, QApplication.UnicodeUTF8).arg(str(selected_row+1))
            else:
                aw.qmc.specialevents.pop()
                aw.qmc.specialeventstype.pop()
                aw.qmc.specialeventsStrings.pop()
                aw.qmc.specialeventsvalue.pop()
                message = QApplication.translate("Message"," Event #%1 deleted", None, QApplication.UnicodeUTF8).arg(str(len(aw.qmc.specialevents)+1))
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No events found", None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)

    def percent(self):
        if float(str(self.weightoutedit.text())) != 0.0:
            percent = aw.weight_loss(float(str(self.weightinedit.text())),float(str(self.weightoutedit.text())))
        else:
            percent = 0.
        percentstring =  "%.1f" %(percent) + "%"
        self.weightpercentlabel.setText(QString(percentstring))    #weight percent loss
# do not disclose this roast degree resulting from an oversimplified calculation
#        roastdegreestring = ""
#        if percent > 0.:
#            roastdegreestring = aw.roast_degree(percent)
#        self.roastdegreelabel.setText(QString(roastdegreestring))

    def volume_percent(self):
        if float(str(self.volumeoutedit.text())) != 0.0:
            percent = aw.weight_loss(float(str(self.volumeoutedit.text())),float(str(self.volumeinedit.text())))
        else:
            percent = 0.
        percentstring =  "%.1f" %(percent) + "%"
        self.volumepercentlabel.setText(QString(percentstring))    #volume percent gain
        
    def calc_density(self):
        din = dout = 0.0
        volumein = float(str(self.volumeinedit.text()))
        volumeout = float(str(self.volumeoutedit.text()))
        weightin = float(str(self.weightinedit.text()))
        weightout = float(str(self.weightoutedit.text()))
        if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
            if self.volumeUnitsComboBox.currentText() == QApplication.translate("ComboBox","ml", None, QApplication.UnicodeUTF8) :
                volumein = volumein / 1000.0
                volumeout = volumeout / 1000.0      
            if self.unitsComboBox.currentText() != QApplication.translate("ComboBox","g", None, QApplication.UnicodeUTF8) :
                weightin = weightin * 1000.0
                weightout = weightout * 1000.0
            din = (weightin / volumein) 
            dout = (weightout / volumeout)
        return din,dout

    def calculated_density(self):
        din, dout = self.calc_density()
        if din > 1 and dout > 1:
            self.calculateddensitylabel.setText(QApplication.translate("Label","                 Density in: %1  g/l   =>   Density out: %2 g/l", None, QApplication.UnicodeUTF8).arg(din).arg(dout))
            self.tab1aLayout.addWidget(self.calculateddensitylabel)
        else:
            self.calculateddensitylabel.setText("")
            self.tab1aLayout.removeWidget(self.calculateddensitylabel)

    def standard_density(self):
        volume = float(str(self.bean_density_volume_edit.text()))
        weight = float(str(self.bean_density_weight_edit.text()))
        if volume != 0.0 and weight != 0.0:
            if self.bean_density_volumeUnitsComboBox.currentText() == QApplication.translate("ComboBox","ml", None, QApplication.UnicodeUTF8) :
                volume = volume / 1000.0
            if self.bean_density_weightUnitsComboBox.currentText() != QApplication.translate("ComboBox","g", None, QApplication.UnicodeUTF8) :
                weight = weight * 1000.0
            self.standarddensitylabel.setText(QApplication.translate("Label","(%1 g/l)", None, QApplication.UnicodeUTF8).arg((weight / volume)))
        else:
            self.standarddensitylabel.setText("")

    def accept(self):
        #check for graph
        if len(aw.qmc.timex):
            
            #prevents accidentally deleting a modified profile.
            aw.qmc.safesaveflag = True
            if self.chargeeditcopy != str(self.chargeedit.text()):
                #if there is a CHARGE recorded and the time entered is positive. Use relative time
                if aw.qmc.stringtoseconds(str(self.chargeedit.text())) > 0 and aw.qmc.timeindex[0] != -1:
                    startindex = aw.qmc.time2index(aw.qmc.timex[aw.qmc.timeindex[0]] + aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm()
                #if there is a CHARGE recorded and the time entered is negative. Use relative time
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) < 0 and aw.qmc.timeindex[0] != -1:
                    relativetime = aw.qmc.timex[aw.qmc.timeindex[0]]-abs(aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    startindex = aw.qmc.time2index(relativetime)
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm()
                #if there is _no_ CHARGE recorded and the time entered is positive. Use absolute time 
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) > 0 and aw.qmc.timeindex[0] == -1:
                    startindex = aw.qmc.time2index(aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm()
                #if there is _no_ CHARGE recorded and the time entered is negative. ERROR
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) < 0 and aw.qmc.timeindex[0] == -1:
                    aw.qmc.adderror(QApplication.translate("Error Message", "Unable to move CHARGE to a value that does not exist",None, QApplication.UnicodeUTF8))
                    return
            # check CHARGE (with index aw.qmc.timeindex[0])
            if aw.qmc.timeindex[0] == -1:
#                aw.qmc.timeindex[0] = 0
                start = 0                   #relative start time
            else:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            if self.dryeditcopy != str(self.dryedit.text()):
                s = aw.qmc.stringtoseconds(str(self.dryedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[1] = 0
                else:
                    dryindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[1] = dryindex
            if self.Cstarteditcopy != str(self.Cstartedit.text()):
                s = aw.qmc.stringtoseconds(str(self.Cstartedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[2] = 0
                else:
                    fcsindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[2] = fcsindex
            if self.Cendeditcopy != str(self.Cendedit.text()):
                s = aw.qmc.stringtoseconds(str(self.Cendedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[3] = 0
                else:
                    fceindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[3] = fceindex
            if self.CCstarteditcopy != str(self.CCstartedit.text()):
                s = aw.qmc.stringtoseconds(str(self.CCstartedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[4] = 0
                else:
                    scsindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[4] = scsindex
            if self.CCendeditcopy != str(self.CCendedit.text()):
                s = aw.qmc.stringtoseconds(str(self.CCendedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[5] = 0
                elif aw.qmc.stringtoseconds(str(self.CCendedit.text())) > 0:
                    sceindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[5] = sceindex
            if self.dropeditcopy != str(self.dropedit.text()):
                s = aw.qmc.stringtoseconds(str(self.dropedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[6] = 0
                else:
                    dropindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[6] = dropindex
            if self.cooleditcopy != str(self.cooledit.text()):
                s = aw.qmc.stringtoseconds(str(self.cooledit.text()))
                if s <= 0:
                    aw.qmc.timeindex[7] = 0
                else:
                    coolindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[7] = coolindex
            if aw.qmc.phasesbuttonflag:   
                # adjust phases by DryEnd and FCs events
                if aw.qmc.timeindex[1]:
                    aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                if aw.qmc.timeindex[2]:
                    aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            self.saveEventTable()
        # Update Title
        aw.qmc.ax.set_title(u(self.titleedit.text()),size=20,color=aw.qmc.palette["title"])
        aw.qmc.title = u(self.titleedit.text())
        # Update beans
        aw.qmc.beans = u(self.beansedit.toPlainText())
        #update ambient temperature source
        aw.qmc.ambientTempSource = self.ambientComboBox.currentIndex()
        #update weight
        try:
            aw.qmc.weight[0] = float(str(self.weightinedit.text()))
        except:
            aw.qmc.weight[0] = 0
        try:
            aw.qmc.weight[1] = float(str(self.weightoutedit.text()))
        except:
            aw.qmc.weight[1] = 0
        aw.qmc.weight[2] =u(self.unitsComboBox.currentText())
        #update volume
        try:
            aw.qmc.volume[0] = float(str(self.volumeinedit.text()))
        except:
            aw.qmc.volume[0] = 0
        try:
            aw.qmc.volume[1] = float(str(self.volumeoutedit.text()))
        except:
            aw.qmc.volume[1] = 0
        aw.qmc.volume[2] = u(self.volumeUnitsComboBox.currentText())
        #update density
        try:
            aw.qmc.density[0] = float(str(self.bean_density_weight_edit.text()))
        except:
            aw.qmc.density[0] = 0
        aw.qmc.density[1] = str(self.bean_density_weightUnitsComboBox.currentText())
        try:
            aw.qmc.density[2] = float(str(self.bean_density_volume_edit.text()))
        except:
            aw.qmc.density[2] = 0
        aw.qmc.density[3] = str(self.bean_density_volumeUnitsComboBox.currentText())
        #update bean size
        try:
            aw.qmc.beansize = float(str(self.bean_size_edit.text()))
        except:
            aw.qmc.beansize = 0.0
        #update roastflags
        aw.qmc.heavyFC_flag = self.heavyFC.isChecked()
        aw.qmc.lowFC_flag = self.lowFC.isChecked()
        aw.qmc.lightCut_flag = self.lightCut.isChecked()
        aw.qmc.darkCut_flag = self.darkCut.isChecked()
        aw.qmc.drops_flag = self.drops.isChecked()
        aw.qmc.oily_flag = self.oily.isChecked()        
        aw.qmc.uneven_flag = self.uneven.isChecked()
        aw.qmc.tipping_flag = self.tipping.isChecked()
        aw.qmc.scorching_flag = self.scorching.isChecked()
        aw.qmc.divots_flag = self.divots.isChecked()
        #update color
        aw.qmc.whole_color = int(str(self.whole_color_edit.text()))
        aw.qmc.ground_color = int(str(self.ground_color_edit.text()))
        aw.qmc.color_system_idx = self.colorSystemComboBox.currentIndex()
        #update humidity
        try:
            aw.qmc.bag_humidity[0] = float(str(self.humidity_edit.text()))
        except:
            aw.qmc.bag_humidity[0] = 0
        try:
            aw.qmc.bag_humidity[1] = float(str(self.bag_temp_edit.text()))
        except:
            aw.qmc.bag_humidity[1] = 0
        #update ambient temperature
        try:
            aw.qmc.ambientTemp = float(str(self.ambientedit.text()))
        except:
            aw.qmc.ambientTemp = 0
        #update ambient humidity
        try:
            aw.qmc.ambient_humidity = float(str(self.ambient_humidity_edit.text()))
        except:
            aw.qmc.ambient_humidity = 0
        #update notes
        aw.qmc.roastertype = u(self.roaster.text())
        aw.qmc.operator = u(self.operator.text())
        aw.qmc.roastingnotes = u(self.roastingeditor.toPlainText())
        aw.qmc.cuppingnotes = u(self.cuppingeditor.toPlainText())
        aw.sendmessage(QApplication.translate("Message","Roast properties updated but profile not saved to disk", None, QApplication.UnicodeUTF8))
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.close()

##########################################################################
#####################  VIEW PLATFORM      ################################
##########################################################################

class platformDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(platformDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Artisan Platform", None, QApplication.UnicodeUTF8))
        platformdic = {}
        platformdic["Architecture"] = str(platform.architecture())
        platformdic["Machine"] = str(platform.machine())
        platformdic["Platform name"] =  str(platform.platform())
        platformdic["Processor"] = str(platform.processor())
        platformdic["Python Build"] = str(platform.python_build())
        platformdic["Python Compiler"] = str(platform.python_compiler())
        platformdic["Python Branch"] = str(platform.python_branch())
        platformdic["Python Implementation"] = str(platform.python_implementation())
        platformdic["Python Revision"] = str(platform.python_revision())
        platformdic["Release"] = str(platform.release())
        platformdic["System"] = str(platform.system())
        platformdic["Version"] = str(platform.version())
        platformdic["Python version"] = str(platform.python_version())
        system = str(platform.system())
        if system == "Windows":
            platformdic["Win32"] = str(platform.win32_ver())
        elif system == "Darwin":
            platformdic["Mac"] = str(platform.mac_ver())
        elif system == "Linux":
            platformdic["Linux"] = str(platform.linux_distribution())
            platformdic["Libc"] = str(platform.libc_ver())
        htmlplatform = "<b>version =</b> " + __version__ + " (" + __revision__ + ")<br>"
        for key in sorted(platformdic):
            htmlplatform += "<b>" + key + " = </b> <i>" + platformdic[key] + "</i><br>"
        platformEdit = QTextEdit()
        platformEdit.setHtml(htmlplatform)
        platformEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(platformEdit)
        self.setLayout(layout)

##########################################################################
#####################  VIEW ATISAN SETTINGS ##############################
##########################################################################

class artisansettingsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(artisansettingsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Settings Viewer", None, QApplication.UnicodeUTF8))
        self.htmlsettings = ""
        self.ncategoriesComboBox = QComboBox()
        self.settingsEdit = QTextEdit()
        self.settingsEdit.setReadOnly(True)
        names = self.getstring()
        self.ncategoriesComboBox.addItems(names)
        self.connect(self.ncategoriesComboBox,SIGNAL("currentIndexChanged(int)"),self.searchstringfromcombobox)
        searchButton = QPushButton(QApplication.translate("Button","Search", None, QApplication.UnicodeUTF8))
        searchButton.setMaximumWidth(150)
        self.connect(searchButton,SIGNAL("clicked()"),self.findtext)
        self.searchbox = QLineEdit(aw.searchtextartisansettings)
        updateButton = QPushButton(QApplication.translate("Button","Update", None, QApplication.UnicodeUTF8))
        updateButton.setMaximumWidth(150)
        self.connect(updateButton,SIGNAL("clicked()"),self.getstring)
        searchlayout = QHBoxLayout()
        searchlayout.addWidget(self.ncategoriesComboBox)
        searchlayout.addWidget(self.searchbox)
        searchlayout.addWidget(searchButton)
        layout = QVBoxLayout()
        layout.addLayout(searchlayout)
        layout.addWidget(self.settingsEdit)
        layout.addWidget(updateButton)
        self.setLayout(layout)

    def findtext(self):
        aw.searchtextartisansettings = str(self.searchbox.text())
        if not self.settingsEdit.find(self.searchbox.text()):
            self.settingsEdit.find(self.searchbox.text(),QTextDocument.FindBackward)

    def searchstringfromcombobox(self):
        if not self.settingsEdit.find(self.ncategoriesComboBox.currentText()):
            self.settingsEdit.find(self.ncategoriesComboBox.currentText(),QTextDocument.FindBackward)

    def getstring(self):
        self.htmlsettings = "<body bgcolor=\"black\">"
        self.htmlsettings += "<font color=\"white\">"
        self.htmlsettings += "version = " +__version__ +"<br><br>"
        settingsdictlist,settingsnameslist = aw.readartisansettings()
        pcolors = ["grey","blue"]
        for n in range(len(settingsnameslist)):
            self.htmlsettings += "<p><b><font color=\"orange\">%s </font></b></p>"%settingsnameslist[n].upper()
            self.htmlsettings += "<p style=\"background-color: %s\">"%pcolors[n%2]
            for keys in sorted(settingsdictlist[n]):
                self.htmlsettings += "<b>&nbsp;&nbsp;" + keys + " = </b> <i>" + str(settingsdictlist[n][keys]) + "</i><br><br>"
            self.htmlsettings += "</p>"
        self.htmlsettings += "<\body><\font>"
        self.settingsEdit.setHtml(self.htmlsettings)
        return settingsnameslist

##########################################################################
#####################  VIEW SERIAL LOG DLG  ##############################
##########################################################################

class serialLogDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(serialLogDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Serial Log", None, QApplication.UnicodeUTF8))
        self.serialcheckbox = QCheckBox(QApplication.translate("CheckBox","Serial Log ON/OFF", None, QApplication.UnicodeUTF8))
        self.serialcheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF logs serial communication",None, QApplication.UnicodeUTF8))
        self.serialcheckbox.setChecked(aw.seriallogflag)
        self.connect(self.serialcheckbox,SIGNAL("stateChanged(int)"),self.serialcheckboxChanged)
        self.serialEdit = QTextEdit()
        self.serialEdit.setReadOnly(True)
        self.serialEdit.setHtml(self.getstring())
        updateButton = QPushButton(QApplication.translate("Button","Update", None, QApplication.UnicodeUTF8))
        updateButton.setMaximumWidth(150)
        self.connect(updateButton,SIGNAL("clicked()"),self.update)
        layout = QVBoxLayout()
        layout.addWidget(self.serialcheckbox,0)
        layout.addWidget(self.serialEdit,1)
        layout.addWidget(updateButton,1)
        self.setLayout(layout)

    def getstring(self):
        #convert list of serial comm an html string
        htmlserial = "version = " +__version__ +"<br><br>"
        lenl = len(aw.seriallog)
        for i in range(len(aw.seriallog)):
            htmlserial += "<b>" + str(lenl-i) + "</b> " + aw.seriallog[-i-1] + "<br><br>"
        return htmlserial

    def update(self):
        if not aw.seriallogflag:
            self.serialcheckbox.setChecked(True)
        self.serialEdit.setText(self.getstring())

    def serialcheckboxChanged(self):
        if self.serialcheckbox.isChecked():
            aw.seriallogflag = True
        else:
            aw.seriallogflag = False

##########################################################################
#####################  VIEW ERROR LOG DLG  ###############################
##########################################################################

class errorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(errorDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Error Log", None, QApplication.UnicodeUTF8))
        #convert list of errors to an html string
        htmlerr = "version = " +__version__ +"<br><br>"
        lenl = len(aw.qmc.errorlog)
        for i in range(len(aw.qmc.errorlog)):
            htmlerr += "<b>" + str(lenl-i) + "</b> <i>" + aw.qmc.errorlog[-i-1] + "</i><br><br>"
        enumber = len(aw.qmc.errorlog)
        labelstr =  "<b>"+ QApplication.translate("Label","Number of errors found %1", None, QApplication.UnicodeUTF8).arg(str(enumber)) + "</b>"
        elabel = QLabel(labelstr)
        errorEdit = QTextEdit()
        errorEdit.setHtml(htmlerr)
        errorEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(elabel,0)
        layout.addWidget(errorEdit,1)
        self.setLayout(layout)

##########################################################################
#####################  MESSAGE HISTORY DLG  ##############################
##########################################################################

class messageDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(messageDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Message History", None, QApplication.UnicodeUTF8))
        #convert list of messages to an html string
        htmlmessage = ""
        for i in range(len(aw.messagehist)):
            htmlmessage += "<b>" + str(len(aw.messagehist)-i) + "</b> <i>" + aw.messagehist[-i-1] + "</i><br><br>"
        messageEdit = QTextEdit()
        messageEdit.setHtml(htmlmessage)
        messageEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(messageEdit,0)
        self.setLayout(layout)

##########################################################################
#####################  AUTOSAVE DLG  #####################################
##########################################################################

class autosaveDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(autosaveDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Keyboard Autosave [a]", None, QApplication.UnicodeUTF8))
        self.prefixEdit = QLineEdit(aw.qmc.autosaveprefix)
        self.prefixEdit.setToolTip(QApplication.translate("Tooltip", "Automatic generated name = This text + date + time",None, QApplication.UnicodeUTF8))
        self.autocheckbox = QCheckBox(QApplication.translate("CheckBox","Autosave [a]", None, QApplication.UnicodeUTF8))
        self.autocheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF of automatic saving when pressing keyboard letter [a]",None, QApplication.UnicodeUTF8))
        self.autocheckbox.setChecked(aw.qmc.autosaveflag)
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))  
        cancelButton = QPushButton(QApplication.translate("Button","Cancel", None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        pathButton = QPushButton(QApplication.translate("Button","Path", None, QApplication.UnicodeUTF8))
        pathButton.setFocusPolicy(Qt.NoFocus)
        self.pathEdit = QLineEdit(str(aw.qmc.autosavepath))
        self.pathEdit.setToolTip(QApplication.translate("Tooltip", "Sets the directory to store batch profiles when using the letter [a]",None, QApplication.UnicodeUTF8))
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.autoChanged)
        self.connect(pathButton,SIGNAL("clicked()"),self.getpath)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        autolayout = QGridLayout()
        autolayout.addWidget(self.autocheckbox,0,0)
        autolayout.addWidget(self.prefixEdit,0,1)
        autolayout.addWidget(pathButton,1,0)
        autolayout.addWidget(self.pathEdit,1,1)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(autolayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def getpath(self):
        filename = aw.ArtisanExistingDirectoryDialog(msg=QApplication.translate("Form Caption","AutoSave Path", None, QApplication.UnicodeUTF8))
        self.pathEdit.setText(filename)

    def autoChanged(self):
        if self.autocheckbox.isChecked(): 
            aw.qmc.autosaveflag = 1
            aw.qmc.autosaveprefix = self.prefixEdit.text()
            message = QApplication.translate("Message","Autosave ON. Prefix: %1").arg(self.prefixEdit.text())
            aw.sendmessage(message)
            aw.qmc.autosavepath = str(self.pathEdit.text())
        else:
            aw.qmc.autosaveflag = 0
            message = QApplication.translate("Message","Autosave OFF", None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
        self.close()

##########################################################################
#####################  WINDOW PROPERTIES DLG  ############################
##########################################################################

class WindowsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(WindowsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Axes",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        xlimitLabel = QLabel(QApplication.translate("Label", "Max",None, QApplication.UnicodeUTF8))
        xlimitLabel_min = QLabel(QApplication.translate("Label", "Min",None, QApplication.UnicodeUTF8))
        ylimitLabel = QLabel(QApplication.translate("Label", "Max",None, QApplication.UnicodeUTF8))
        ylimitLabel_min = QLabel(QApplication.translate("Label", "Min",None, QApplication.UnicodeUTF8))
        zlimitLabel = QLabel(QApplication.translate("Label", "Max",None, QApplication.UnicodeUTF8))
        zlimitLabel_min = QLabel(QApplication.translate("Label", "Min",None, QApplication.UnicodeUTF8))
        self.xlimitEdit = QLineEdit()
        self.xlimitEdit.setMaximumWidth(100)
        self.xlimitEdit_min = QLineEdit()
        self.xlimitEdit_min.setMaximumWidth(100)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.xlimitEdit.setValidator(QRegExpValidator(regextime,self))
        self.xlimitEdit_min.setValidator(QRegExpValidator(regextime,self))
        self.ylimitEdit = QLineEdit()
        self.ylimitEdit.setMaximumWidth(60)
        self.ylimitEdit_min = QLineEdit()
        self.ylimitEdit_min.setMaximumWidth(60)
        self.ylimitEdit.setValidator(QIntValidator(0, 850, self.ylimitEdit))
        self.ylimitEdit_min.setValidator(QIntValidator(-150, 500, self.ylimitEdit_min))
        self.ylimitEdit.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.ylimitEdit_min.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zlimitEdit = QLineEdit()
        self.zlimitEdit.setMaximumWidth(60)
        self.zlimitEdit_min = QLineEdit()
        self.zlimitEdit_min.setMaximumWidth(60)
        self.zlimitEdit.setValidator(QIntValidator(0, 500, self.zlimitEdit))
        self.zlimitEdit_min.setValidator(QIntValidator(-200, 250, self.zlimitEdit_min))
        self.zlimitEdit.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zlimitEdit_min.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.xlimitEdit.setText(aw.qmc.stringfromseconds(aw.qmc.endofx))
        if aw.qmc.timeindex[0] != -1:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx - aw.qmc.timex[aw.qmc.timeindex[0]]))
        else:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx))
        self.ylimitEdit.setText(str(aw.qmc.ylimit))
        self.ylimitEdit_min.setText(str(aw.qmc.ylimit_min))
        self.zlimitEdit.setText(str(aw.qmc.zlimit))
        self.zlimitEdit_min.setText(str(aw.qmc.zlimit_min))
        xrotationlabel = QLabel(QApplication.translate("Label", "Rotation",None, QApplication.UnicodeUTF8))
        self.xrotationSpinBox = QSpinBox()
        self.xrotationSpinBox.setRange(0,90)
        self.xrotationSpinBox.setSingleStep(5)
        self.xrotationSpinBox.setValue(aw.qmc.xrotation)
        self.connect(self.xrotationSpinBox, SIGNAL("valueChanged(int)"),self.changexrotation)
        self.xrotationSpinBox.setMaximumWidth(40)
        self.legendComboBox = QComboBox()
        self.legendComboBox.setMaximumWidth(160)
        legendlocs = ["",#QApplication.translate("ComboBox", "none",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "upper right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "upper left",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "lower left",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "lower right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "center left",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "center right",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "lower center",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "upper center",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "center",None, QApplication.UnicodeUTF8)]
        self.legendComboBox.addItems(legendlocs)
        self.legendComboBox.setCurrentIndex(aw.qmc.legendloc)
        self.connect(self.legendComboBox,SIGNAL("currentIndexChanged(int)"),self.changelegendloc)
        resettimelabel = QLabel(QApplication.translate("Label", "Initial Max",None, QApplication.UnicodeUTF8))
        self.resetEdit = QLineEdit()
        self.resetEdit.setMaximumWidth(100)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.resetEdit.setValidator(QRegExpValidator(regextime,self))
        self.resetEdit.setText(aw.qmc.stringfromseconds(aw.qmc.resetmaxtime))
        # fixmaxtime flag
        self.fixmaxtimeFlag = QCheckBox(QApplication.translate("CheckBox", "Lock Max",None, QApplication.UnicodeUTF8))
        self.fixmaxtimeFlag.setChecked(aw.qmc.fixmaxtime)
        # time axis steps
        timegridlabel = QLabel(QApplication.translate("Label", "Step",None, QApplication.UnicodeUTF8))
        self.xaxislencombobox = QComboBox()
        timelocs =   [QApplication.translate("ComboBox", "30 seconds",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "1 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "2 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "3 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "4 minute",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "5 minute",None, QApplication.UnicodeUTF8)]
        self.xaxislencombobox.addItems(timelocs)
        self.timeconversion = [30,60,120,180,240,300]
        self.xaxislencombobox.setCurrentIndex(self.timeconversion.index(aw.qmc.xgrid))
        self.connect(self.xaxislencombobox,SIGNAL("currentIndexChanged(int)"),self.xaxislenloc)
        ygridlabel = QLabel(QApplication.translate("Label", "Step",None, QApplication.UnicodeUTF8))
        self.ygridSpinBox = QSpinBox()
        self.ygridSpinBox.setRange(10,100)
        self.ygridSpinBox.setSingleStep(5)
        self.ygridSpinBox.setValue(aw.qmc.ygrid)
        self.ygridSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.connect(self.ygridSpinBox, SIGNAL("valueChanged(int)"),self.changeygrid)
        self.ygridSpinBox.setMaximumWidth(60)
        zgridlabel = QLabel(QApplication.translate("Label", "Step",None, QApplication.UnicodeUTF8))
        self.zgridSpinBox = QSpinBox()
        self.zgridSpinBox.setRange(10,100)
        self.zgridSpinBox.setSingleStep(5)
        self.zgridSpinBox.setValue(aw.qmc.zgrid)
        self.zgridSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.connect(self.zgridSpinBox, SIGNAL("valueChanged(int)"),self.changezgrid)
        self.zgridSpinBox.setMaximumWidth(60)
        linestylegridlabel = QLabel(QApplication.translate("Label", "Style",None, QApplication.UnicodeUTF8))
        self.gridstylecombobox = QComboBox()
        gridstyles = [QApplication.translate("ComboBox", "solid",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "dashed",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "dashed-dot",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "dotted",None, QApplication.UnicodeUTF8),
                      QApplication.translate("ComboBox", "None",None, QApplication.UnicodeUTF8)]
        self.gridstylecombobox.addItems(gridstyles) 
        self.gridstylecombobox.setCurrentIndex(aw.qmc.gridlinestyle)
        self.connect(self.gridstylecombobox,SIGNAL("currentIndexChanged(int)"),self.changegridstyle)
        gridthicknesslabel = QLabel(QApplication.translate("Label", "Width",None, QApplication.UnicodeUTF8))
        self.gridwidthSpinBox = QSpinBox()
        self.gridwidthSpinBox.setRange(1,5)
        self.gridwidthSpinBox.setValue(aw.qmc.gridthickness)
        self.connect(self.gridwidthSpinBox, SIGNAL("valueChanged(int)"),self.changegridwidth)
        self.gridwidthSpinBox.setMaximumWidth(40)
        gridalphalabel = QLabel(QApplication.translate("Label", "Opaqueness",None, QApplication.UnicodeUTF8))
        self.gridalphaSpinBox = QSpinBox()
        self.gridalphaSpinBox.setRange(1,10)
        self.gridalphaSpinBox.setValue(int(aw.qmc.gridalpha*10))
        self.connect(self.gridalphaSpinBox, SIGNAL("valueChanged(int)"),self.changegridalpha)
        self.gridalphaSpinBox.setMaximumWidth(40)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        resetButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        resetButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.close)
        self.connect(okButton,SIGNAL("clicked()"),self.updatewindow)
        self.connect(resetButton,SIGNAL("clicked()"),self.reset)
        xlayout = QGridLayout()
        xlayout.addWidget(xlimitLabel_min,0,0)
        xlayout.addWidget(self.xlimitEdit_min,0,1)
        xlayout.addWidget(xlimitLabel,0,2)
        xlayout.addWidget(self.xlimitEdit,0,3)
        xlayout.addWidget(timegridlabel,1,0)
        xlayout.addWidget(self.xaxislencombobox,1,1)
        xlayout.addWidget(resettimelabel,1,2)
        xlayout.addWidget(self.resetEdit,1,3)
        xlayout.addWidget(xrotationlabel,2,0)
        xlayout.addWidget(self.fixmaxtimeFlag,2,2)
        xlayout.addWidget(self.xrotationSpinBox,2,1)
        ylayout = QGridLayout()
        ylayout.addWidget(ylimitLabel_min,0,0)
        ylayout.addWidget(self.ylimitEdit_min,0,1)
        ylayout.addWidget(ylimitLabel,0,2)
        ylayout.addWidget(self.ylimitEdit,0,3)
        ylayout.addWidget(ygridlabel,1,0)
        ylayout.addWidget(self.ygridSpinBox,1,1)
        zlayout = QGridLayout()
        zlayout.addWidget(zlimitLabel_min,0,0)
        zlayout.addWidget(self.zlimitEdit_min,0,1)
        zlayout.addWidget(zlimitLabel,0,2)
        zlayout.addWidget(self.zlimitEdit,0,3)
        zlayout.addWidget(zgridlabel,1,0)
        zlayout.addWidget(self.zgridSpinBox,1,1)
        legentlayout = QHBoxLayout()
        legentlayout.addWidget(self.legendComboBox,0,Qt.AlignLeft)
        graphgridlayout = QGridLayout()
        graphgridlayout.addWidget(linestylegridlabel,1,0)
        graphgridlayout.addWidget(self.gridstylecombobox,1,1,Qt.AlignLeft)
        graphgridlayout.addWidget(gridthicknesslabel,1,2)
        graphgridlayout.addWidget(self.gridwidthSpinBox,1,3,Qt.AlignLeft)
        graphgridlayout.addWidget(gridalphalabel,2,0)
        graphgridlayout.addWidget(self.gridalphaSpinBox,2,1,Qt.AlignLeft)
        xGroupLayout = QGroupBox(QApplication.translate("GroupBox","Time Axis",None, QApplication.UnicodeUTF8))
        xGroupLayout.setLayout(xlayout)
        yGroupLayout = QGroupBox(QApplication.translate("GroupBox","Temperature Axis",None, QApplication.UnicodeUTF8))
        yGroupLayout.setLayout(ylayout)
        zGroupLayout = QGroupBox(QApplication.translate("GroupBox","DeltaBT/DeltaET Axis",None, QApplication.UnicodeUTF8))
        zGroupLayout.setLayout(zlayout)
        legendLayout = QGroupBox(QApplication.translate("GroupBox","Legend Location",None, QApplication.UnicodeUTF8))
        legendLayout.setLayout(legentlayout)
        GridGroupLayout = QGroupBox(QApplication.translate("GroupBox","Grid",None, QApplication.UnicodeUTF8))
        GridGroupLayout.setLayout(graphgridlayout)
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(resetButton)
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(xGroupLayout)
        mainLayout.addWidget(yGroupLayout)
        mainLayout.addWidget(zGroupLayout)
        mainLayout.addWidget(legendLayout)
        mainLayout.addWidget(GridGroupLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def changexrotation(self):
        aw.qmc.xrotation = self.xrotationSpinBox.value()
        aw.qmc.xaxistosm()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changegridalpha(self):
        aw.qmc.gridalpha = self.gridalphaSpinBox.value()/10.
        aw.qmc.redraw(recomputeAllDeltas=False)
        
    def changegridwidth(self):
        aw.qmc.gridthickness = self.gridwidthSpinBox.value()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changegridstyle(self):
        aw.qmc.gridlinestyle = self.gridstylecombobox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changelegendloc(self):
        aw.qmc.legendloc = self.legendComboBox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def xaxislenloc(self):
        aw.qmc.xgrid = self.timeconversion[self.xaxislencombobox.currentIndex()]
        aw.qmc.xaxistosm()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changeygrid(self):
        aw.qmc.ygrid = self.ygridSpinBox.value()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def changezgrid(self):
        aw.qmc.zgrid = self.zgridSpinBox.value()
        aw.qmc.redraw(recomputeAllDeltas=False)

    # exit dialog with OK
    def updatewindow(self):
        yl = int(str(self.ylimitEdit.text()))
        yl_min = int(str(self.ylimitEdit_min.text()))
        if yl > yl_min + 10:
            aw.qmc.ylimit = yl
            aw.qmc.ylimit_min = yl_min
        zl = int(str(self.zlimitEdit.text()))
        zl_min = int(str(self.zlimitEdit_min.text()))
        if zl > zl_min + 5:
            aw.qmc.zlimit = zl
            aw.qmc.zlimit_min = zl_min
        aw.qmc.endofx = aw.qmc.stringtoseconds(str(self.xlimitEdit.text()))
        starteditime = aw.qmc.stringtoseconds(str(self.xlimitEdit_min.text()))
        resettime = aw.qmc.stringtoseconds(str(self.resetEdit.text()))
        if starteditime > 0 and aw.qmc.timeindex[0] != -1:
            aw.qmc.startofx = aw.qmc.timex[aw.qmc.timeindex[0]] + starteditime
        elif starteditime > 0 and aw.qmc.timeindex[0] == -1:
            aw.qmc.startofx = starteditime
        elif starteditime < 0 and aw.qmc.timeindex[0] != -1:
            aw.qmc.startofx = aw.qmc.timex[aw.qmc.timeindex[0]]-abs(starteditime)
        else:
            aw.qmc.startofx = starteditime
        if resettime > 0:
            aw.qmc.resetmaxtime = resettime
        aw.qmc.fixmaxtime = self.fixmaxtimeFlag.isChecked()
        aw.qmc.redraw(recomputeAllDeltas=False)
        string = QApplication.translate("Message","xlimit = (%3,%4) ylimit = (%1,%2) zlimit = (%5,%6)",None, QApplication.UnicodeUTF8).arg(str(self.ylimitEdit_min.text())).arg(str(self.ylimitEdit.text())).arg(str(self.xlimitEdit_min.text())).arg(str(self.xlimitEdit.text())).arg(str(self.zlimitEdit_min.text())).arg(str(self.zlimitEdit.text()))                                   
        aw.sendmessage(string)
        self.close()

    def reset(self):
        if len(aw.qmc.timex) > 1:
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(int(aw.qmc.timex[-1])))
        else:
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(60))
        self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(0))
        if aw.qmc.mode == "F":
            self.ylimitEdit.setText("750")
            self.ylimitEdit_min.setText("0")
            self.zlimitEdit.setText("100")
            self.zlimitEdit_min.setText("0")
        else:
            self.ylimitEdit.setText("400")
            self.ylimitEdit_min.setText("0")
            self.zlimitEdit.setText("40")
            self.zlimitEdit_min.setText("0")

##########################################################################
#####################  ROAST CALCULATOR DLG   ############################
##########################################################################

class calculatorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(calculatorDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Calculator",None, QApplication.UnicodeUTF8))
        #RATE OF CHANGE
        self.result1 = QLabel(QApplication.translate("Label", "Enter two times along profile",None, QApplication.UnicodeUTF8))
        self.result2 = QLabel()
        self.result2.setStyleSheet("background-color:'lightgrey';")
        startlabel = QLabel(QApplication.translate("Label", "Start (00:00)",None, QApplication.UnicodeUTF8))
        endlabel = QLabel(QApplication.translate("Label", "End (00:00)",None, QApplication.UnicodeUTF8))
        self.startEdit = QLineEdit()
        self.endEdit = QLineEdit()
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.startEdit.setValidator(QRegExpValidator(regextime,self))
        self.endEdit.setValidator(QRegExpValidator(regextime,self))
        self.connect(self.startEdit,SIGNAL("editingFinished()"),self.calculateRC)
        self.connect(self.endEdit,SIGNAL("editingFinished()"),self.calculateRC)
        nevents = len(aw.qmc.specialevents)
        events_found = [QApplication.translate("ComboBox","Event #0",None, QApplication.UnicodeUTF8)]
        for i in range(nevents):
            events_found.append(QApplication.translate("ComboBox","Event #%1",None, QApplication.UnicodeUTF8).arg(str(i+1)))
        self.eventAComboBox = QComboBox()
        self.eventAComboBox.addItems(events_found)
        self.connect(self.eventAComboBox,SIGNAL("currentIndexChanged(int)"),self.calcEventRC)
        self.eventBComboBox = QComboBox()
        self.eventBComboBox.addItems(events_found)
        self.connect(self.eventBComboBox,SIGNAL("currentIndexChanged(int)"),self.calcEventRC)
        #TEMPERATURE CONVERSION
        flabel = QLabel(QApplication.translate("Label", "Fahrenheit",None, QApplication.UnicodeUTF8))
        clabel = QLabel(QApplication.translate("Label", "Celsius",None, QApplication.UnicodeUTF8))
        self.faEdit = QLineEdit()
        self.ceEdit = QLineEdit()
        self.faEdit.setValidator(QDoubleValidator(-999., 9999., 2, self.faEdit))
        self.ceEdit.setValidator(QDoubleValidator(-999., 9999., 2, self.ceEdit))
        self.connect(self.faEdit,SIGNAL("editingFinished()"),lambda x="FtoC":self.convertTemp(x))
        self.connect(self.ceEdit,SIGNAL("editingFinished()"),lambda x="CtoF":self.convertTemp(x))
        #WEIGHT CONVERSION
        self.WinComboBox = QComboBox()
        weightunits = [QApplication.translate("ComboBox","g",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","Kg",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","lb",None, QApplication.UnicodeUTF8)]
        self.WinComboBox.addItems(weightunits)
        self.WinComboBox.setMaximumWidth(80)
        self.WinComboBox.setMinimumWidth(80)
        self.WoutComboBox = QComboBox()
        self.WoutComboBox.setMaximumWidth(80)
        self.WoutComboBox.setMinimumWidth(80)
        self.WoutComboBox.addItems(weightunits)
        self.WoutComboBox.setCurrentIndex(2)
        self.WinEdit = QLineEdit()
        self.WoutEdit = QLineEdit()
        self.WinEdit.setMaximumWidth(70)
        self.WoutEdit.setMaximumWidth(70)
        #self.WinEdit.setMinimumWidth(60)
        #self.WoutEdit.setMinimumWidth(60)
        self.WinEdit.setValidator(QDoubleValidator(0., 99999., 2, self.WinEdit))
        self.WoutEdit.setValidator(QDoubleValidator(0., 99999., 2, self.WoutEdit))
        self.connect(self.WinEdit,SIGNAL("editingFinished()"),lambda x="ItoO":self.convertWeight(x))
        self.connect(self.WoutEdit,SIGNAL("editingFinished()"),lambda x="OtoI":self.convertWeight(x))
        #VOLUME CONVERSION
        self.VinComboBox = QComboBox()
        volumeunits = [QApplication.translate("ComboBox","liter",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","gallon",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","quart",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","pint",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","cup",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox","cm^3",None, QApplication.UnicodeUTF8)]
        self.VinComboBox.addItems(volumeunits)
        self.VinComboBox.setMaximumWidth(80)
        self.VinComboBox.setMinimumWidth(80)
        self.VoutComboBox = QComboBox()
        self.VoutComboBox.setMaximumWidth(80)
        self.VoutComboBox.setMinimumWidth(80)
        self.VoutComboBox.addItems(volumeunits)
        self.VoutComboBox.setCurrentIndex(4)
        self.VinEdit = QLineEdit()
        self.VoutEdit = QLineEdit()
        self.VinEdit.setMaximumWidth(70)
        self.VoutEdit.setMaximumWidth(70)
        #self.VinEdit.setMinimumWidth(60)
        #self.VoutEdit.setMinimumWidth(60)
        self.VinEdit.setValidator(QDoubleValidator(0., 99999., 2, self.VinEdit))
        self.VoutEdit.setValidator(QDoubleValidator(0., 99999., 2, self.VoutEdit))
        self.connect(self.VinEdit,SIGNAL("editingFinished()"),lambda x="ItoO":self.convertVolume(x))
        self.connect(self.VoutEdit,SIGNAL("editingFinished()"),lambda x="OtoI":self.convertVolume(x))
        #LAYOUTS
        #Rate of chage
        calrcLayout = QGridLayout()
        calrcLayout.addWidget(startlabel,0,0)
        calrcLayout.addWidget(endlabel,0,1)
        calrcLayout.addWidget(self.startEdit,1,0)
        calrcLayout.addWidget(self.endEdit,1,1)
        calrcLayout.addWidget(self.eventAComboBox ,2,0)
        calrcLayout.addWidget(self.eventBComboBox ,2,1)
        rclayout = QVBoxLayout()
        rclayout.addWidget(self.result1,0)
        rclayout.addWidget(self.result2,1)
        rclayout.addLayout(calrcLayout,2)
        #temperature conversion
        tempLayout = QGridLayout()
        tempLayout.addWidget(flabel,0,0)
        tempLayout.addWidget(clabel,0,1)
        tempLayout.addWidget(self.faEdit,1,0)
        tempLayout.addWidget(self.ceEdit,1,1)
        #weight conversions
        weightLayout = QHBoxLayout()
        weightLayout.addWidget(self.WinComboBox)
        weightLayout.addWidget(self.WinEdit)
        weightLayout.addWidget(self.WoutEdit)
        weightLayout.addWidget(self.WoutComboBox)
        #volume conversions
        volumeLayout = QHBoxLayout()
        volumeLayout.addWidget(self.VinComboBox)
        volumeLayout.addWidget(self.VinEdit)
        volumeLayout.addWidget(self.VoutEdit)
        volumeLayout.addWidget(self.VoutComboBox)
        RoCGroup = QGroupBox(QApplication.translate("GroupBox","Rate of Change",None, QApplication.UnicodeUTF8))
        RoCGroup.setLayout(rclayout)
        tempConvGroup = QGroupBox(QApplication.translate("GroupBox","Temperature Conversion",None, QApplication.UnicodeUTF8))
        tempConvGroup.setLayout(tempLayout)
        weightConvGroup = QGroupBox(QApplication.translate("GroupBox","Weight Conversion",None, QApplication.UnicodeUTF8))
        weightConvGroup.setLayout(weightLayout)
        volumeConvGroup = QGroupBox(QApplication.translate("GroupBox","Volume Conversion",None, QApplication.UnicodeUTF8))
        volumeConvGroup.setLayout(volumeLayout)
        #main
        mainlayout = QVBoxLayout()
        mainlayout.setSpacing(10)
        mainlayout.addWidget(RoCGroup)
        mainlayout.addWidget(tempConvGroup)
        mainlayout.addWidget(weightConvGroup)
        mainlayout.addWidget(volumeConvGroup)
        mainlayout.addStretch()  
        self.setLayout(mainlayout)

    def calcEventRC(self):
        nevents = len(aw.qmc.specialevents)
        Aevent = int(self.eventAComboBox.currentIndex())
        Bevent = int(self.eventBComboBox.currentIndex())
        if Aevent <= nevents and Bevent <= nevents and Aevent and Bevent:
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            self.startEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Aevent-1]] - start))
            self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Bevent-1]] - start))
            self.calculateRC()

    #calculate rate of change
    def calculateRC(self):
        if len(aw.qmc.timex)>2:
            if not len(self.startEdit.text()) or not len(self.endEdit.text()):
                #empty field
                return
            starttime = aw.qmc.stringtoseconds(str(self.startEdit.text()))
            endtime = aw.qmc.stringtoseconds(str(self.endEdit.text()))
            if starttime == -1 or endtime == -1:
                self.result1.setText(QApplication.translate("Label", "Time syntax error. Time not valid",None, QApplication.UnicodeUTF8))
                self.result2.setText("")
                return
            if  endtime > aw.qmc.timex[-1] or endtime < starttime:
                self.result1.setText(QApplication.translate("Label", "Error: End time smaller than Start time",None, QApplication.UnicodeUTF8))
                self.result2.setText("")
                return
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            startindex = aw.qmc.time2index(starttime + start)
            endindex = aw.qmc.time2index(endtime + start)
            #delta
            deltatime = aw.qmc.timex[endindex] -  aw.qmc.timex[startindex]
            deltatemperature = aw.qmc.temp2[endindex] - aw.qmc.temp2[startindex]
            if deltatime == 0:
                deltaseconds = 0
            else:
                deltaseconds = deltatemperature/deltatime
            deltaminutes = deltaseconds*60.
            string1 = QApplication.translate("Label", "Best approximation was made from %1 to %2",None, QApplication.UnicodeUTF8).arg(aw.qmc.stringfromseconds(aw.qmc.timex[startindex]- start)).arg(aw.qmc.stringfromseconds(aw.qmc.timex[endindex]- start))
            string2 = QApplication.translate("Label", "deg/sec = %1    deg/min = <b>%2<\b>",None, QApplication.UnicodeUTF8).arg("%.2f"%(deltaseconds)).arg("%.2f"%(deltaminutes))
            self.result1.setText(string1)
            self.result2.setText(string2)
        else:
            self.result1.setText(QApplication.translate("Label", "No profile found",None, QApplication.UnicodeUTF8))
            self.result2.setText("")

    def convertTemp(self,x):
        if x == "FtoC":
            newC = aw.qmc.fromFtoC(float(str(self.faEdit.text())))
            result = "%.2f"%newC
            self.ceEdit.setText(result)
        elif x == "CtoF":
            newF = aw.qmc.fromCtoF(float(str(self.ceEdit.text())))
            result = "%.2f"%newF
            self.faEdit.setText(result)

    def convertWeight(self,x):
        #                g,            kg,         lb
        convtable = [
                        [1.,           0.001,      0.00220462262     ],    # g
                        [1000,         1.,         2.205             ],    # Kg
                        [453.591999,   0.45359237, 1.                ]     # lb
                    ]
        if x == "ItoO":
            inx = float(str(self.WinEdit.text()))
            outx = inx*convtable[self.WinComboBox.currentIndex()][self.WoutComboBox.currentIndex()]
            self.WoutEdit.setText("%.2f"%outx)
            
        elif x == "OtoI":
            outx = float(str(self.WoutEdit.text()))
            inx = outx*convtable[self.WoutComboBox.currentIndex()][self.WinComboBox.currentIndex()]
            self.WinEdit.setText("%.2f"%inx)

    def convertVolume(self,x):
                        #liter          gal             qt              pt              cup             cm^3
        convtable = [
                        [1.,            0.26417205,     1.05668821,     2.11337643,     4.22675284,     1000.                ],    # liter
                        [3.78541181,    1.,             4.,             8.,             16,             3785.4117884         ],    # gallon
                        [0.94635294,    0.25,           1.,             2.,             4.,             946.352946           ],    # quart
                        [0.47317647,    0.125,          0.5,            1.,             2.,             473.176473           ],    # pint
                        [0.23658823,    0.0625,         0.25,           0.5,            1.,             236.5882365          ],    # cup
                        [0.001,         2.6417205e-4,   1.05668821e-3,  2.11337641e-3,  4.2267528e-3,   1.                   ]     # cm^3
                    ]
        if x == "ItoO":
            inx = float(str(self.VinEdit.text()))
            outx = inx*convtable[self.VinComboBox.currentIndex()][self.VoutComboBox.currentIndex()]
            self.VoutEdit.setText("%.3f"%outx)
            
        elif x == "OtoI":
            outx = float(str(self.VoutEdit.text()))
            inx = outx*convtable[self.VoutComboBox.currentIndex()][self.VinComboBox.currentIndex()]
            self.VinEdit.setText("%.3f"%inx)

##########################################################################
#####################  EVENTS CONFIGURATION DLG     ######################
##########################################################################
#accessed through menu conf

class EventsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(EventsDlg,self).__init__(parent)
        titlefont = QFont()
        titlefont.setBold(True)
        titlefont.setWeight(75)
        self.setWindowTitle(QApplication.translate("Form Caption","Events",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        self.storeState()
        ## TAB 1
        self.eventsbuttonflag = QCheckBox(QApplication.translate("CheckBox","Button",None, QApplication.UnicodeUTF8))
        self.eventsbuttonflag.setChecked(bool(aw.eventsbuttonflag))
        self.connect(self.eventsbuttonflag,SIGNAL("stateChanged(int)"),self.eventsbuttonflagChanged)
        self.eventsshowflagbox = QCheckBox(QApplication.translate("CheckBox","Show",None, QApplication.UnicodeUTF8))
        self.eventsshowflagbox.setChecked(bool(aw.qmc.eventsshowflag))
        self.connect(self.eventsshowflagbox,SIGNAL("stateChanged(int)"),self.eventsshowflagChanged)
        self.minieventsflag = QCheckBox(QApplication.translate("CheckBox","Mini Editor",None, QApplication.UnicodeUTF8))
        self.minieventsflag.setToolTip(QApplication.translate("Tooltip","Allows to enter a description of the last event",None, QApplication.UnicodeUTF8))
        self.minieventsflag.setChecked(bool(aw.minieventsflag))
        self.connect(self.minieventsflag,SIGNAL("stateChanged(int)"),self.minieventsflagChanged)
        barstylelabel = QLabel(QApplication.translate("Label","Bars",None, QApplication.UnicodeUTF8))
        barstyles = ["",
                    QApplication.translate("ComboBox","Type",None, QApplication.UnicodeUTF8),
                    QApplication.translate("ComboBox","Value",None, QApplication.UnicodeUTF8)]
        self.bartypeComboBox =  QComboBox()
        self.bartypeComboBox.setFocusPolicy(Qt.NoFocus)
        self.bartypeComboBox.setMaximumWidth(80)
        self.bartypeComboBox.addItems(barstyles)
        self.bartypeComboBox.setCurrentIndex(aw.qmc.eventsGraphflag)
        self.connect(self.bartypeComboBox,SIGNAL("currentIndexChanged(int)"),self.eventsGraphTypeflagChanged)
        typelabel1 = QLabel("1")
        typelabel2 = QLabel("2")
        typelabel3 = QLabel("3")
        typelabel4 = QLabel("4")
        self.etype0 = QLineEdit(aw.qmc.etypesf(0))        
        self.etype0.setCursorPosition(0)
        self.etype1 = QLineEdit(aw.qmc.etypesf(1))
        self.etype1.setCursorPosition(0)
        self.etype2 = QLineEdit(aw.qmc.etypesf(2))
        self.etype2.setCursorPosition(0)
        self.etype3 = QLineEdit(aw.qmc.etypesf(3))
        self.etype3.setCursorPosition(0)
        self.etype0.setMaximumWidth(80)
        self.etype1.setMaximumWidth(80)
        self.etype2.setMaximumWidth(80)
        self.etype3.setMaximumWidth(80)
        self.E1colorButton = QPushButton(aw.qmc.etypesf(0))
        self.E1colorButton.setFocusPolicy(Qt.NoFocus)
        self.E2colorButton = QPushButton(aw.qmc.etypesf(1))
        self.E2colorButton.setFocusPolicy(Qt.NoFocus)
        self.E3colorButton = QPushButton(aw.qmc.etypesf(2))
        self.E3colorButton.setFocusPolicy(Qt.NoFocus)
        self.E4colorButton = QPushButton(aw.qmc.etypesf(3))
        self.E4colorButton.setFocusPolicy(Qt.NoFocus)
        self.connect(self.E1colorButton,SIGNAL("clicked()"),lambda b=0:self.setcoloreventline(b))
        self.connect(self.E2colorButton,SIGNAL("clicked()"),lambda b=1:self.setcoloreventline(b))
        self.connect(self.E3colorButton,SIGNAL("clicked()"),lambda b=2:self.setcoloreventline(b))
        self.connect(self.E4colorButton,SIGNAL("clicked()"),lambda b=3:self.setcoloreventline(b))
        #marker selection for comboboxes
        self.markers = [QApplication.translate("Marker","Circle",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Square",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Pentagon",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Diamond",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Star",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Hexagon 1",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","Hexagon 2",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","+",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","x",None, QApplication.UnicodeUTF8),
                        QApplication.translate("Marker","None",None, QApplication.UnicodeUTF8)]
        #keys interpreted by matplotlib. Must match order of self.markers 
        self.markervals = ["o","s","p","D","*","h","H","+","x","None"]
        #Marker type
        self.marker1typeComboBox =  QComboBox()
        self.marker1typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker1typeComboBox.addItems(self.markers)
        self.marker1typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[0]))
        self.connect(self.marker1typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=0:self.seteventmarker(x,m))
        self.marker2typeComboBox =  QComboBox()
        self.marker2typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker2typeComboBox.addItems(self.markers)
        self.marker2typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[1]))
        self.connect(self.marker2typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=1:self.seteventmarker(x,m))
        self.marker3typeComboBox =  QComboBox()
        self.marker3typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker3typeComboBox.addItems(self.markers)
        self.marker3typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[2]))
        self.connect(self.marker3typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=2:self.seteventmarker(x,m))
        self.marker4typeComboBox =  QComboBox()
        self.marker4typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker4typeComboBox.addItems(self.markers)
        self.marker4typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[3]))
        self.connect(self.marker4typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda x=1,m=3:self.seteventmarker(x,m))
        valuecolorlabel = QLabel(QApplication.translate("Label","Color",None, QApplication.UnicodeUTF8))
        valuecolorlabel.setFont(titlefont)
        valuesymbollabel = QLabel(QApplication.translate("Label","Marker",None, QApplication.UnicodeUTF8))
        valuesymbollabel.setFont(titlefont)
        valuethicknesslabel = QLabel(QApplication.translate("Label","Thickness",None, QApplication.UnicodeUTF8))
        valuethicknesslabel.setFont(titlefont)
        valuealphalabel = QLabel(QApplication.translate("Label","Opacity",None, QApplication.UnicodeUTF8))
        valuealphalabel.setFont(titlefont)
        valuesizelabel = QLabel(QApplication.translate("Label","Size",None, QApplication.UnicodeUTF8))
        valuesizelabel.setFont(titlefont)
        valuecolorlabel.setMaximumSize(80,20)
        valuesymbollabel.setMaximumSize(70,20)
        valuethicknesslabel.setMaximumSize(80,20)
        valuealphalabel.setMaximumSize(80,20)
        valuesizelabel.setMaximumSize(80,20)
        self.E1thicknessSpinBox = QSpinBox()
        self.E1thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E1thicknessSpinBox.setSingleStep(1)
        self.E1thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1thicknessSpinBox.setRange(1,10)
        self.E1thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[0])
        self.connect(self.E1thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w=1, x=0:self.setElinethickness(w,x))
        self.E2thicknessSpinBox = QSpinBox()
        self.E2thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E2thicknessSpinBox.setSingleStep(1)
        self.E2thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2thicknessSpinBox.setRange(1,10)
        self.E2thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[1])
        self.connect(self.E2thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w =1,x=1:self.setElinethickness(w,x))
        self.E3thicknessSpinBox = QSpinBox()
        self.E3thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E3thicknessSpinBox.setSingleStep(1)
        self.E3thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3thicknessSpinBox.setRange(1,10)
        self.E3thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[2])
        self.connect(self.E3thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=2:self.setElinethickness(w,x))
        self.E4thicknessSpinBox = QSpinBox()
        self.E4thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E4thicknessSpinBox.setSingleStep(1)
        self.E4thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4thicknessSpinBox.setRange(1,10)
        self.E4thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[3])
        self.connect(self.E4thicknessSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=0:self.setElinethickness(w,x))
        self.E1alphaSpinBox = QDoubleSpinBox()
        self.E1alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E1alphaSpinBox.setSingleStep(1)
        self.E1alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1alphaSpinBox.setRange(.1,1.)
        self.E1alphaSpinBox.setSingleStep(.1)
        self.E1alphaSpinBox.setValue(aw.qmc.Evaluealpha[0])
        self.connect(self.E1alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1,x=0:self.setElinealpha(w,x))
        self.E2alphaSpinBox = QDoubleSpinBox()
        self.E2alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E2alphaSpinBox.setSingleStep(1)
        self.E2alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2alphaSpinBox.setRange(.1,1.)
        self.E2alphaSpinBox.setSingleStep(.1)
        self.E2alphaSpinBox.setValue(aw.qmc.Evaluealpha[1])
        self.connect(self.E1alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1,x=1:self.setElinealpha(w,x))
        self.E3alphaSpinBox = QDoubleSpinBox()
        self.E3alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E3alphaSpinBox.setSingleStep(1)
        self.E3alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3alphaSpinBox.setRange(.1,1.)
        self.E3alphaSpinBox.setSingleStep(.1)
        self.E3alphaSpinBox.setValue(aw.qmc.Evaluealpha[2])
        self.connect(self.E3alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1,x=2:self.setElinealpha(w,x))
        self.E4alphaSpinBox = QDoubleSpinBox()
        self.E4alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E4alphaSpinBox.setSingleStep(1)
        self.E4alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4alphaSpinBox.setRange(.1,1.)
        self.E4alphaSpinBox.setSingleStep(.1)
        self.E4alphaSpinBox.setValue(aw.qmc.Evaluealpha[3])
        self.connect(self.E4alphaSpinBox, SIGNAL("valueChanged(double)"),lambda w=1, x=3:self.setElinealpha(w,x))
        #Marker size
        self.E1sizeSpinBox = QSpinBox()
        self.E1sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E1sizeSpinBox.setSingleStep(1)
        self.E1sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1sizeSpinBox.setRange(1,14)
        self.E1sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[0])
        self.connect(self.E1sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=0:self.setEmarkersize(w,x))
        self.E2sizeSpinBox = QSpinBox()
        self.E2sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E2sizeSpinBox.setSingleStep(1)
        self.E2sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2sizeSpinBox.setRange(1,14)
        self.E2sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[1])
        self.connect(self.E2sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=1:self.setEmarkersize(w,x))
        self.E3sizeSpinBox = QSpinBox()
        self.E3sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E3sizeSpinBox.setSingleStep(1)
        self.E3sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3sizeSpinBox.setRange(1,14)
        self.E3sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[2])
        self.connect(self.E3sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=2:self.setEmarkersize(w,x))
        self.E4sizeSpinBox = QSpinBox()
        self.E4sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E4sizeSpinBox.setSingleStep(1)
        self.E4sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4sizeSpinBox.setRange(1,14)
        self.E4sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[3])
        self.connect(self.E4sizeSpinBox, SIGNAL("valueChanged(int)"),lambda w=1,x=3:self.setEmarkersize(w,x))
        self.autoChargeDrop = QCheckBox(QApplication.translate("CheckBox","Automatic CHARGE/DROP",None, QApplication.UnicodeUTF8))
        self.autoChargeDrop.setChecked(aw.qmc.autoChargeDropFlag)
        self.autoChargeDrop.setFocusPolicy(Qt.NoFocus)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        closeButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        defaultButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        closeButton.setFocusPolicy(Qt.NoFocus)
        defaultButton.setFocusPolicy(Qt.NoFocus)
        self.connect(closeButton,SIGNAL("clicked()"),self.restoreState)
        self.connect(okButton,SIGNAL("clicked()"),self.updatetypes)
        self.connect(defaultButton,SIGNAL("clicked()"),self.settypedefault)
        ###  TAB 2
        #table for showing events
        self.eventbuttontable = QTableWidget()
        self.eventbuttontable.setTabKeyNavigation(True)
        self.createEventbuttonTable()
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        addButton.setToolTip(QApplication.translate("Tooltip","Add new extra Event button",None, QApplication.UnicodeUTF8))
        #addButton.setMaximumWidth(100)
        addButton.setFocusPolicy(Qt.NoFocus)
        self.connect(addButton, SIGNAL("clicked()"),self.insertextraeventbutton)
        delButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
        delButton.setToolTip(QApplication.translate("Tooltip","Delete the last extra Event button",None, QApplication.UnicodeUTF8))
        #delButton.setMaximumWidth(100)
        delButton.setFocusPolicy(Qt.NoFocus)
        self.connect(delButton, SIGNAL("clicked()"),self.delextraeventbutton)
        helpButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None, QApplication.UnicodeUTF8))
        helpButton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpButton, SIGNAL("clicked()"),self.showEventbuttonhelp)
        #number of buttons per row
        self.nbuttonslabel = QLabel(QApplication.translate("Label","Max buttons per row", None, QApplication.UnicodeUTF8))
        self.nbuttonsSpinBox = QSpinBox()
        self.nbuttonsSpinBox.setMaximumWidth(100)
        self.nbuttonsSpinBox.setAlignment(Qt.AlignCenter)
        self.nbuttonsSpinBox.setRange(9,30)
        self.nbuttonsSpinBox.setValue(aw.buttonlistmaxlen)
        self.connect(self.nbuttonsSpinBox, SIGNAL("valueChanged(int)"),self.realignbuttons)
        #color patterns
        #flag that prevents changing colors too fast
        self.changingcolorflag = False
        colorpatternlabel = QLabel(QApplication.translate("Label","Color Pattern", None, QApplication.UnicodeUTF8))
        self.colorSpinBox = QSpinBox()
        self.colorSpinBox.setWrapping(True)
        self.colorSpinBox.setMaximumWidth(100)
        self.colorSpinBox.setAlignment(Qt.AlignCenter)
        self.colorSpinBox.setRange(0,359)
        self.connect(self.colorSpinBox, SIGNAL("valueChanged(int)"),self.colorizebuttons)
        ## tab4
        transferpalettebutton = QPushButton(QApplication.translate("Button","Transfer To", None, QApplication.UnicodeUTF8))
        transferpalettebutton.setFocusPolicy(Qt.NoFocus)
        setpalettebutton = QPushButton(QApplication.translate("Button","Restore From", None, QApplication.UnicodeUTF8))
        setpalettebutton.setFocusPolicy(Qt.NoFocus)
        palette = QApplication.translate("Label","palette #", None, QApplication.UnicodeUTF8)
        palettelist = []
        for i in range(10):
            palettelist.append(palette + str(i))
        self.transferpalettecombobox = QComboBox()
        self.transferpalettecombobox.setFocusPolicy(Qt.NoFocus)
        self.transferpalettecombobox.setMaximumWidth(120)
        self.transferpalettecombobox.addItems(palettelist)
        self.connect(transferpalettebutton, SIGNAL("clicked()"),self.transferbuttonsto)
        self.connect(setpalettebutton, SIGNAL("clicked()"),self.setbuttonsfrom)
        backupbutton = QPushButton(QApplication.translate("Button","Save", None, QApplication.UnicodeUTF8))
        backupbutton.setFocusPolicy(Qt.NoFocus)
        restorebutton = QPushButton(QApplication.translate("Button","Load", None, QApplication.UnicodeUTF8))
        restorebutton.setFocusPolicy(Qt.NoFocus)
        backupbutton.setToolTip(QApplication.translate("Tooltip","Backup all palettes to a text file",None, QApplication.UnicodeUTF8))
        restorebutton.setToolTip(QApplication.translate("Tooltip","Restore all palettes from a text",None, QApplication.UnicodeUTF8))
        backupbutton.setMaximumWidth(140)
        restorebutton.setMaximumWidth(140)
        self.connect(backupbutton, SIGNAL("clicked()"),aw.backuppaletteeventbuttons)
        self.connect(restorebutton, SIGNAL("clicked()"),aw.restorepaletteeventbuttons)
        ## tab3
        eventtitlelabel = QLabel(QApplication.translate("Label","Event", None, QApplication.UnicodeUTF8))
        eventtitlelabel.setFont(titlefont)
        actiontitlelabel = QLabel(QApplication.translate("Label","Action", None, QApplication.UnicodeUTF8))
        actiontitlelabel.setFont(titlefont)
        commandtitlelabel = QLabel(QApplication.translate("Label","Command", None, QApplication.UnicodeUTF8))
        commandtitlelabel.setFont(titlefont)
        offsettitlelabel = QLabel(QApplication.translate("Label","Offset", None, QApplication.UnicodeUTF8))
        offsettitlelabel.setFont(titlefont)
        factortitlelabel = QLabel(QApplication.translate("Label","Factor", None, QApplication.UnicodeUTF8))
        factortitlelabel.setFont(titlefont)
        self.E1visibility = QCheckBox(aw.qmc.etypesf(0))
        self.E1visibility.setFocusPolicy(Qt.NoFocus)
        self.E1visibility.setChecked(bool(aw.eventslidervisibilities[0]))
        self.E2visibility = QCheckBox(aw.qmc.etypesf(1))
        self.E2visibility.setFocusPolicy(Qt.NoFocus)
        self.E2visibility.setChecked(bool(aw.eventslidervisibilities[1]))
        self.E3visibility = QCheckBox(aw.qmc.etypesf(2))
        self.E3visibility.setFocusPolicy(Qt.NoFocus)
        self.E3visibility.setChecked(bool(aw.eventslidervisibilities[2]))
        self.E4visibility = QCheckBox(aw.qmc.etypesf(3))
        self.E4visibility.setFocusPolicy(Qt.NoFocus)
        self.E4visibility.setChecked(bool(aw.eventslidervisibilities[3]))
        self.sliderActionTypes = ["",#QApplication.translate("ComboBox", "None",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Serial Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Modbus Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "DTA Command",None, QApplication.UnicodeUTF8)]
        self.E1action = QComboBox()
        self.E1action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E1action.setFocusPolicy(Qt.NoFocus)
        self.E1action.addItems(self.sliderActionTypes)
        self.E1action.setCurrentIndex(aw.eventslideractions[0])
        self.E2action = QComboBox()
        self.E2action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E2action.setFocusPolicy(Qt.NoFocus)
        self.E2action.addItems(self.sliderActionTypes)
        self.E2action.setCurrentIndex(aw.eventslideractions[1])
        self.E3action = QComboBox()
        self.E3action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E3action.setFocusPolicy(Qt.NoFocus)
        self.E3action.addItems(self.sliderActionTypes)
        self.E3action.setCurrentIndex(aw.eventslideractions[2])
        self.E4action = QComboBox()
        self.E4action.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.E4action.setFocusPolicy(Qt.NoFocus)
        self.E4action.addItems(self.sliderActionTypes)
        self.E4action.setCurrentIndex(aw.eventslideractions[3])
        self.E1command = QLineEdit(aw.eventslidercommands[0])
        self.E2command = QLineEdit(aw.eventslidercommands[1])
        self.E3command = QLineEdit(aw.eventslidercommands[2])
        self.E4command = QLineEdit(aw.eventslidercommands[3])
        self.E1offset = QSpinBox()
        self.E1offset.setAlignment(Qt.AlignRight)
        self.E1offset.setRange(-999,999)
        self.E1offset.setValue(aw.eventslideroffsets[0])
        self.E2offset = QSpinBox()
        self.E2offset.setAlignment(Qt.AlignRight)
        self.E2offset.setRange(-999,999)
        self.E2offset.setValue(aw.eventslideroffsets[1])
        self.E3offset = QSpinBox()
        self.E3offset.setAlignment(Qt.AlignRight)
        self.E3offset.setRange(-999,999)
        self.E3offset.setValue(aw.eventslideroffsets[2])
        self.E4offset = QSpinBox()
        self.E4offset.setAlignment(Qt.AlignRight)
        self.E4offset.setRange(-999,999)
        self.E4offset.setValue(aw.eventslideroffsets[3])
        self.E1factor = QDoubleSpinBox()
        self.E1factor.setAlignment(Qt.AlignRight)
        self.E1factor.setRange(-999,999)
        self.E1factor.setDecimals(2)
        self.E1factor.setValue(aw.eventsliderfactors[0])
        self.E1factor.setMaximumWidth(60)
        self.E2factor = QDoubleSpinBox()
        self.E2factor.setAlignment(Qt.AlignRight)
        self.E2factor.setRange(-999,999)
        self.E2factor.setDecimals(2)
        self.E2factor.setValue(aw.eventsliderfactors[1])
        self.E2factor.setMaximumWidth(60)
        self.E3factor = QDoubleSpinBox()
        self.E3factor.setAlignment(Qt.AlignRight)
        self.E3factor.setRange(-999,999)
        self.E3factor.setDecimals(2)
        self.E3factor.setValue(aw.eventsliderfactors[2])
        self.E3factor.setMaximumWidth(60)
        self.E4factor = QDoubleSpinBox()
        self.E4factor.setAlignment(Qt.AlignRight)
        self.E4factor.setRange(-999,999)
        self.E4factor.setDecimals(2)
        self.E4factor.setValue(aw.eventsliderfactors[3])
        self.E4factor.setMaximumWidth(60)
        helpsliderbutton =  QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpsliderbutton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpsliderbutton, SIGNAL("clicked()"),self.showSliderHelp)
        ### LAYOUTS
        #### tab1 layout
        bartypeLayout = QHBoxLayout()
        bartypeLayout.addWidget(barstylelabel)
        bartypeLayout.addWidget(self.bartypeComboBox,Qt.AlignLeft)
        FlagsLayout = QHBoxLayout()
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.eventsbuttonflag)
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.eventsshowflagbox)
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.minieventsflag)
        FlagsLayout.addStretch()
        FlagsLayout.addSpacing(10)
        FlagsLayout.addLayout(bartypeLayout)
        FlagsLayout.addStretch()
        typeLayout = QGridLayout()
        typeLayout.addWidget(typelabel1,0,0)
        typeLayout.addWidget(self.etype0,0,1)
        typeLayout.addWidget(typelabel2,0,2)
        typeLayout.addWidget(self.etype1,0,3)
        typeLayout.addWidget(typelabel3,0,4)
        typeLayout.addWidget(self.etype2,0,5)
        typeLayout.addWidget(typelabel4,0,6)
        typeLayout.addWidget(self.etype3,0,7)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(closeButton)
        buttonLayout.addWidget(okButton)
        typeHBox = QHBoxLayout()
        typeHBox.addLayout(typeLayout)
        typeHBox.addStretch()
        typeHBox.addWidget(defaultButton)
        TypeGroupLayout = QGroupBox(QApplication.translate("GroupBox","Event Types",None, QApplication.UnicodeUTF8))
        TypeGroupLayout.setLayout(typeHBox)
        self.buttonActionTypes = ["",#QApplication.translate("ComboBox", "None",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Serial Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Call Program",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "Modbus Command",None, QApplication.UnicodeUTF8),
                       QApplication.translate("ComboBox", "DTA Command",None, QApplication.UnicodeUTF8)]
        self.CHARGEbutton = QCheckBox(QApplication.translate("CheckBox", "CHARGE",None, QApplication.UnicodeUTF8))
        self.CHARGEbutton.setChecked(bool(aw.qmc.buttonvisibility[0]))
        self.CHARGEbuttonActionType = QComboBox()
        self.CHARGEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.CHARGEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.CHARGEbuttonActionType.addItems(self.buttonActionTypes)
        self.CHARGEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[0])
        self.CHARGEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[0])
        self.CHARGEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.DRYbutton = QCheckBox(QApplication.translate("CheckBox", "DRY END",None, QApplication.UnicodeUTF8))
        self.DRYbutton.setChecked(bool(aw.qmc.buttonvisibility[1]))
        self.DRYbuttonActionType = QComboBox()
        self.DRYbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.DRYbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.DRYbuttonActionType.addItems(self.buttonActionTypes)
        self.DRYbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[1])
        self.DRYbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[1])
        self.DRYbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.FCSbutton = QCheckBox(QApplication.translate("CheckBox", "FC START",None, QApplication.UnicodeUTF8))
        self.FCSbutton.setChecked(bool(aw.qmc.buttonvisibility[2]))
        self.FCSbuttonActionType = QComboBox()
        self.FCSbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.FCSbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.FCSbuttonActionType.addItems(self.buttonActionTypes)
        self.FCSbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[2])
        self.FCSbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[2])
        self.FCSbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.FCEbutton = QCheckBox(QApplication.translate("CheckBox", "FC END",None, QApplication.UnicodeUTF8))
        self.FCEbutton.setChecked(bool(aw.qmc.buttonvisibility[3]))
        self.FCEbuttonActionType = QComboBox()
        self.FCEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.FCEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.FCEbuttonActionType.addItems(self.buttonActionTypes)
        self.FCEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[3])
        self.FCEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[3])
        self.FCEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.SCSbutton = QCheckBox(QApplication.translate("CheckBox", "SC START",None, QApplication.UnicodeUTF8))
        self.SCSbutton.setChecked(bool(aw.qmc.buttonvisibility[4]))
        self.SCSbuttonActionType = QComboBox()
        self.SCSbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.SCSbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SCSbuttonActionType.addItems(self.buttonActionTypes)
        self.SCSbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[4])
        self.SCSbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[4])
        self.SCSbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.SCEbutton = QCheckBox(QApplication.translate("CheckBox", "SC END",None, QApplication.UnicodeUTF8))
        self.SCEbutton.setChecked(bool(aw.qmc.buttonvisibility[5]))
        self.SCEbuttonActionType = QComboBox()
        self.SCEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.SCEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SCEbuttonActionType.addItems(self.buttonActionTypes)
        self.SCEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[5])
        self.SCEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[5])
        self.SCEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.DROPbutton = QCheckBox(QApplication.translate("CheckBox", "DROP",None, QApplication.UnicodeUTF8))
        self.DROPbutton.setChecked(bool(aw.qmc.buttonvisibility[6]))
        self.DROPbuttonActionType = QComboBox()
        self.DROPbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.DROPbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.DROPbuttonActionType.addItems(self.buttonActionTypes)
        self.DROPbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[6])
        self.DROPbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[6])
        self.DROPbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        self.COOLbutton = QCheckBox(QApplication.translate("CheckBox", "COOL END",None, QApplication.UnicodeUTF8))
        self.COOLbutton.setChecked(bool(aw.qmc.buttonvisibility[7]))
        self.COOLbuttonActionType = QComboBox()
        self.COOLbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None, QApplication.UnicodeUTF8))
        self.COOLbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.COOLbuttonActionType.addItems(self.buttonActionTypes)
        self.COOLbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[7])
        self.COOLbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[7])
        self.COOLbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None, QApplication.UnicodeUTF8))
        defaultButtonsLayout = QGridLayout()
        defaultButtonsLayout.addWidget(self.CHARGEbutton,0,0)
        defaultButtonsLayout.addWidget(self.CHARGEbuttonActionType,0,1)
        defaultButtonsLayout.addWidget(self.CHARGEbuttonActionString,0,2)
        defaultButtonsLayout.addWidget(self.DRYbutton,1,0)
        defaultButtonsLayout.addWidget(self.DRYbuttonActionType,1,1)
        defaultButtonsLayout.addWidget(self.DRYbuttonActionString,1,2)
        defaultButtonsLayout.addWidget(self.FCSbutton,2,0)
        defaultButtonsLayout.addWidget(self.FCSbuttonActionType,2,1)
        defaultButtonsLayout.addWidget(self.FCSbuttonActionString,2,2)
        defaultButtonsLayout.addWidget(self.FCEbutton,3,0)
        defaultButtonsLayout.addWidget(self.FCEbuttonActionType,3,1)
        defaultButtonsLayout.addWidget(self.FCEbuttonActionString,3,2)
        defaultButtonsLayout.addWidget(self.SCSbutton,4,0)
        defaultButtonsLayout.addWidget(self.SCSbuttonActionType,4,1)
        defaultButtonsLayout.addWidget(self.SCSbuttonActionString,4,2)
        defaultButtonsLayout.addWidget(self.SCEbutton,5,0)
        defaultButtonsLayout.addWidget(self.SCEbuttonActionType,5,1)
        defaultButtonsLayout.addWidget(self.SCEbuttonActionString,5,2)
        defaultButtonsLayout.addWidget(self.DROPbutton,6,0)
        defaultButtonsLayout.addWidget(self.DROPbuttonActionType,6,1)
        defaultButtonsLayout.addWidget(self.DROPbuttonActionString,6,2)
        defaultButtonsLayout.addWidget(self.COOLbutton,7,0)
        defaultButtonsLayout.addWidget(self.COOLbuttonActionType,7,1)
        defaultButtonsLayout.addWidget(self.COOLbuttonActionString,7,2)
        defaultButtonsLayout.setContentsMargins(5,5,5,5)
        defaultButtonsLayout.setHorizontalSpacing(10)
        defaultButtonsLayout.setVerticalSpacing(7)
        ButtonGroupLayout = QGroupBox(QApplication.translate("GroupBox","Default Buttons",None, QApplication.UnicodeUTF8))
        ButtonGroupLayout.setLayout(defaultButtonsLayout)
        tab1layout = QVBoxLayout()
        tab1layout.addLayout(FlagsLayout)
        tab1layout.addWidget(TypeGroupLayout)
        tab1layout.addWidget(ButtonGroupLayout)
        tab1layout.addWidget(self.autoChargeDrop)
        tab1layout.addStretch()
        tab1layout.setContentsMargins(5,5,5,5)
        nbuttonslayout = QHBoxLayout()
        nbuttonslayout.addWidget(self.nbuttonslabel)
        nbuttonslayout.addWidget(self.nbuttonsSpinBox)
        nbuttonslayout.addWidget(colorpatternlabel)
        nbuttonslayout.addWidget(self.colorSpinBox)
        nbuttonslayout.addStretch()
        tab2buttonlayout = QHBoxLayout()
        tab2buttonlayout.addWidget(addButton)
        tab2buttonlayout.addWidget(delButton)
        tab2buttonlayout.addStretch()
        tab2buttonlayout.addWidget(helpButton)
        ### tab2 layout
        tab2layout = QVBoxLayout()
        tab2layout.addWidget(self.eventbuttontable)
        tab2layout.addLayout(nbuttonslayout)
        tab2layout.addLayout(tab2buttonlayout)
        tab2layout.setSpacing(5)
        tab2layout.setContentsMargins(0,10,0,5)
        ### tab4 layout
        paletteGrid = QGridLayout()
        paletteGrid.addWidget(transferpalettebutton,0,0)
        paletteGrid.addWidget(self.transferpalettecombobox,1,1)
        paletteGrid.addWidget(setpalettebutton,2,0)
        paletteBox = QHBoxLayout()
        paletteBox.addStretch()
        paletteBox.addLayout(paletteGrid)
        paletteBox.addStretch()
        paletteGroupLayout = QGroupBox(QApplication.translate("GroupBox","Management",None, QApplication.UnicodeUTF8))
        paletteGroupLayout.setLayout(paletteBox)
        paletteButtons = QHBoxLayout()
        paletteButtons.addStretch()
        paletteButtons.addWidget(backupbutton)
        paletteButtons.addWidget(restorebutton)
        tab3layout = QVBoxLayout()
        tab3layout.addWidget(paletteGroupLayout)
        tab3layout.addLayout(paletteButtons)
        tab3layout.addStretch()
        ### tab5 layout
        valueLayout = QGridLayout()
        valueLayout.addWidget(valuecolorlabel,0,0)
        valueLayout.addWidget(valuesymbollabel,0,1)
        valueLayout.addWidget(valuethicknesslabel,0,2)
        valueLayout.addWidget(valuealphalabel,0,3)
        valueLayout.addWidget(valuesizelabel,0,4)
        valueLayout.addWidget(self.E1colorButton,1,0)
        valueLayout.addWidget(self.marker1typeComboBox,1,1)
        valueLayout.addWidget(self.E1thicknessSpinBox,1,2)
        valueLayout.addWidget(self.E1alphaSpinBox,1,3)
        valueLayout.addWidget(self.E1sizeSpinBox,1,4)
        valueLayout.addWidget(self.E2colorButton,2,0)
        valueLayout.addWidget(self.marker2typeComboBox,2,1)
        valueLayout.addWidget(self.E2thicknessSpinBox,2,2)
        valueLayout.addWidget(self.E2alphaSpinBox,2,3)
        valueLayout.addWidget(self.E2sizeSpinBox,2,4)
        valueLayout.addWidget(self.E3colorButton,3,0)
        valueLayout.addWidget(self.marker3typeComboBox,3,1)
        valueLayout.addWidget(self.E3thicknessSpinBox,3,2)
        valueLayout.addWidget(self.E3alphaSpinBox,3,3)
        valueLayout.addWidget(self.E3sizeSpinBox,3,4)
        valueLayout.addWidget(self.E4colorButton,4,0)
        valueLayout.addWidget(self.marker4typeComboBox,4,1)
        valueLayout.addWidget(self.E4thicknessSpinBox,4,2)
        valueLayout.addWidget(self.E4alphaSpinBox,4,3)
        valueLayout.addWidget(self.E4sizeSpinBox,4,4)
        valueHLayout = QHBoxLayout()
        valueHLayout.addStretch()
        valueHLayout.addLayout(valueLayout)
        valueHLayout.addStretch()
        ### tab3 layout
        tab5Layout = QGridLayout()
        tab5Layout.addWidget(eventtitlelabel,0,0)
        tab5Layout.addWidget(actiontitlelabel,0,1)
        tab5Layout.addWidget(commandtitlelabel,0,2)
        tab5Layout.addWidget(offsettitlelabel,0,3)
        tab5Layout.addWidget(factortitlelabel,0,4)
        tab5Layout.addWidget(self.E1visibility,1,0)
        tab5Layout.addWidget(self.E2visibility,2,0)
        tab5Layout.addWidget(self.E3visibility,3,0)
        tab5Layout.addWidget(self.E4visibility,4,0)
        tab5Layout.addWidget(self.E1action,1,1)
        tab5Layout.addWidget(self.E2action,2,1)
        tab5Layout.addWidget(self.E3action,3,1)
        tab5Layout.addWidget(self.E4action,4,1)
        tab5Layout.addWidget(self.E1command,1,2)
        tab5Layout.addWidget(self.E2command,2,2)
        tab5Layout.addWidget(self.E3command,3,2)
        tab5Layout.addWidget(self.E4command,4,2)
        tab5Layout.addWidget(self.E1offset,1,3)
        tab5Layout.addWidget(self.E2offset,2,3)
        tab5Layout.addWidget(self.E3offset,3,3)
        tab5Layout.addWidget(self.E4offset,4,3)
        tab5Layout.addWidget(self.E1factor,1,4)
        tab5Layout.addWidget(self.E2factor,2,4)
        tab5Layout.addWidget(self.E3factor,3,4)
        tab5Layout.addWidget(self.E4factor,4,4)
        SliderHelpHBox = QHBoxLayout()
        SliderHelpHBox.addStretch()
        SliderHelpHBox.addWidget(helpsliderbutton)
        C5VBox = QVBoxLayout()
        C5VBox.addLayout(tab5Layout)
        C5VBox.addStretch()
        C5VBox.addLayout(SliderHelpHBox)
###########################################
        #tab layout
        self.TabWidget = QTabWidget()
        self.connect(self.TabWidget,SIGNAL("currentChanged(int)"),lambda i=i:self.tabSwitched(i))
        C1Widget = QWidget()
        C1Widget.setLayout(tab1layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab","Config",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2layout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab","Buttons",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(C5VBox)
        self.TabWidget.addTab(C5Widget,QApplication.translate("Tab","Sliders",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab","Palettes",None, QApplication.UnicodeUTF8))
        valueVLayout = QVBoxLayout()
        valueVLayout.addLayout(valueHLayout)
        valueVLayout.addStretch()
        C4Widget = QWidget()
        C4Widget.setLayout(valueVLayout)
        self.TabWidget.addTab(C4Widget,QApplication.translate("Tab","Style",None, QApplication.UnicodeUTF8))
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(self.TabWidget)
        mainLayout.setSpacing(5)
        mainLayout.setContentsMargins(5, 15, 5, 5)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def showSliderHelp(self):
        string = u(QApplication.translate("Message", "<b>Event</b> hide or show the corresponding slider",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Action</b> Perform an action on slider release",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Command</b> depends on the action type ('{}' is replaced by <i>value</i>*<i>factor</i> + <i>offset</i>)",None, QApplication.UnicodeUTF8)) + "<br><br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Serial Command: ASCII serial command or binary a2b_uu(serial command)",None, QApplication.UnicodeUTF8)) + "<br><br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Modbus Command: write([slaveId,register,value],..,[slaveId,register,value]) writes values to the registers in slaves specified by the given ids",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "DTA Command: Insert Data address : value, ex. 4701:1000 and sv is 100. always multiply with 10 if value Unit: 0.1 / ex. 4719:0 stops heating",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Offset</b> added as offset to the slider value",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Factor</b> multiplicator of the slider value",None, QApplication.UnicodeUTF8))
        QMessageBox.information(self,QApplication.translate("Message", "Event custom buttons",None, QApplication.UnicodeUTF8),string)

    def tabSwitched(self,i):
        if i == 1: # switched to Button tab
            self.createEventbuttonTable()
            self.saveSliderSettings()
        elif i == 2: # switched to Slider tab
            self.updateSliderTab()
        elif i==3: # switched to Palette tab
            # store slider settings from Slider tab to global variables
            # store sliders
            self.saveSliderSettings()
            # store buttons
            self.savetableextraeventbutton()
        elif i == 4: # switched to Style tab
            self.updateStyleTab()
            self.saveSliderSettings()

    def updateStyleTab(self):
        # update color button texts
        self.E1colorButton.setText(self.etype0.text())
        self.E2colorButton.setText(self.etype1.text())
        self.E3colorButton.setText(self.etype2.text())
        self.E4colorButton.setText(self.etype3.text())
        # update markers
        self.marker1typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[0]))
        self.marker2typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[1]))
        self.marker3typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[2]))
        self.marker4typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[3]))
        # line thickness
        self.E1thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[0])
        self.E2thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[1])
        self.E3thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[2])
        self.E4thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[3])
        # opacity
        self.E1alphaSpinBox.setValue(aw.qmc.Evaluealpha[0])
        self.E2alphaSpinBox.setValue(aw.qmc.Evaluealpha[1])
        self.E3alphaSpinBox.setValue(aw.qmc.Evaluealpha[2])
        self.E4alphaSpinBox.setValue(aw.qmc.Evaluealpha[3])
        # marker sizes
        self.E1sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[0])
        self.E2sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[1])
        self.E3sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[2])
        self.E4sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[3])

    def updateSliderTab(self):
        # set event names
        self.E1visibility.setText(self.etype0.text())
        self.E2visibility.setText(self.etype1.text())
        self.E3visibility.setText(self.etype2.text())
        self.E4visibility.setText(self.etype3.text())
        # set slider visibility
        self.E1visibility.setChecked(bool(aw.eventslidervisibilities[0]))
        self.E2visibility.setChecked(bool(aw.eventslidervisibilities[1]))
        self.E3visibility.setChecked(bool(aw.eventslidervisibilities[2]))
        self.E4visibility.setChecked(bool(aw.eventslidervisibilities[3]))
        # set slider action
        self.E1action.setCurrentIndex(aw.eventslideractions[0])
        self.E2action.setCurrentIndex(aw.eventslideractions[1])
        self.E3action.setCurrentIndex(aw.eventslideractions[2])
        self.E4action.setCurrentIndex(aw.eventslideractions[3])
        # set slider command
        self.E1command.setText(aw.eventslidercommands[0])
        self.E2command.setText(aw.eventslidercommands[1])
        self.E3command.setText(aw.eventslidercommands[2])
        self.E4command.setText(aw.eventslidercommands[3])
        # set slider offset
        self.E1offset.setValue(aw.eventslideroffsets[0])
        self.E2offset.setValue(aw.eventslideroffsets[1])
        self.E3offset.setValue(aw.eventslideroffsets[2])
        self.E4offset.setValue(aw.eventslideroffsets[3])
        # set slider factors
        self.E1factor.setValue(aw.eventsliderfactors[0])
        self.E2factor.setValue(aw.eventsliderfactors[1])
        self.E3factor.setValue(aw.eventsliderfactors[2])
        self.E4factor.setValue(aw.eventsliderfactors[3])

    def setElinethickness(self,_,val):
        self.E1thicknessSpinBox.setDisabled(True)
        self.E2thicknessSpinBox.setDisabled(True)
        self.E3thicknessSpinBox.setDisabled(True)
        self.E4thicknessSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.Evaluelinethickness[0] = self.E1thicknessSpinBox.value()
        if val == 1:
            aw.qmc.Evaluelinethickness[1] = self.E2thicknessSpinBox.value()
        if val == 2:
            aw.qmc.Evaluelinethickness[2] = self.E3thicknessSpinBox.value()
        if val == 3:
            aw.qmc.Evaluelinethickness[3] = self.E4thicknessSpinBox.value()
        self.E1thicknessSpinBox.setDisabled(False)
        self.E2thicknessSpinBox.setDisabled(False)
        self.E3thicknessSpinBox.setDisabled(False)
        self.E4thicknessSpinBox.setDisabled(False)
        aw.qmc.redraw()

    def setEmarkersize(self,_,val):
        self.E1sizeSpinBox.setDisabled(True)
        self.E2sizeSpinBox.setDisabled(True)
        self.E3sizeSpinBox.setDisabled(True)
        self.E4sizeSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.EvalueMarkerSize[0] = self.E1sizeSpinBox.value()
        if val == 1:
            aw.qmc.EvalueMarkerSize[1] = self.E2sizeSpinBox.value()
        if val == 2:
            aw.qmc.EvalueMarkerSize[2] = self.E3sizeSpinBox.value()
        if val == 3:
            aw.qmc.EvalueMarkerSize[3] = self.E4sizeSpinBox.value()
        self.E1sizeSpinBox.setDisabled(False)
        self.E2sizeSpinBox.setDisabled(False)
        self.E3sizeSpinBox.setDisabled(False)
        self.E4sizeSpinBox.setDisabled(False)
        aw.qmc.redraw()

    def setElinealpha(self,_,val):
        self.E1alphaSpinBox.setDisabled(True)
        self.E2alphaSpinBox.setDisabled(True)
        self.E3alphaSpinBox.setDisabled(True)
        self.E4alphaSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.Evaluealpha[0] = self.E1alphaSpinBox.value()
        if val == 1:
            aw.qmc.Evaluealpha[1] = self.E2alphaSpinBox.value()
        if val == 2:
            aw.qmc.Evaluealpha[2] = self.E3alphaSpinBox.value()
        if val == 3:
            aw.qmc.Evaluealpha[3] = self.E4alphaSpinBox.value()
        self.E1alphaSpinBox.setDisabled(False)
        self.E2alphaSpinBox.setDisabled(False)
        self.E3alphaSpinBox.setDisabled(False)
        self.E4alphaSpinBox.setDisabled(False)
        aw.qmc.redraw()

    def transferbuttonsto(self):
        pindex = self.transferpalettecombobox.currentIndex()
        aw.transferbuttonsto(pindex)

    def setbuttonsfrom(self):
        pindex = self.transferpalettecombobox.currentIndex()
        answer = aw.setbuttonsfrom(pindex)
        if answer:
            self.createEventbuttonTable()

    #applys a pattern of colors 
    def colorizebuttons(self,pattern=None):
        if self.changingcolorflag:
            n = self.colorSpinBox.value()
            self.colorSpinBox.setValue(n-1)
            return
        self.changingcolorflag = True
        if not pattern:
            pattern = self.colorSpinBox.value()
        ncolumns = aw.buttonlistmaxlen
        nbuttons = len(aw.buttonlist)
        initbuttons = ncolumns - 9
        nrows,extra = divmod((nbuttons-initbuttons),ncolumns)
        #button background colors (aw.extraeventbuttoncolor)
        bcolor = ["lightgrey"]*initbuttons
        step = pattern
        if extra:
            nrows += 1
        gap = int(-1*(230-50)/ncolumns)
        for i in range(nrows):
            for f in range(230,50,gap):
                color = QColor()    
                color.setHsv(step,255,f,255)
                bcolor.append(str(color.name()))
            step += pattern*2
        #text color (aw.extraeventbuttontextcolor)
        tcolor = ["yellow"]*nbuttons
        aw.extraeventbuttoncolor = bcolor[:nbuttons]
        aw.extraeventbuttontextcolor = tcolor[:]
        for i in range(nbuttons):
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[i],aw.extraeventbuttoncolor[i])
            aw.buttonlist[i].setStyleSheet(style)
        self.createEventbuttonTable()
        #check visibility
        if not aw.extraeventsbuttonsflag:
            self.extrabuttonsshowCheck.setChecked(True)
        self.changingcolorflag = False

    def seteventmarker(self,_,m):
        if m == 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker1typeComboBox.currentIndex()])
        if m == 1:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker2typeComboBox.currentIndex()])
        if m == 2:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker3typeComboBox.currentIndex()])
        if m == 3:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker4typeComboBox.currentIndex()])
        aw.qmc.redraw()

    def setcoloreventline(self,b):
        colorf = QColorDialog.getColor(QColor(aw.qmc.EvalueColor[b]),self)
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.EvalueColor[b] = colorname
            aw.qmc.redraw()

    def realignbuttons(self):
        aw.buttonlistmaxlen = self.nbuttonsSpinBox.value()
        aw.realignbuttons()

    def createEventbuttonTable(self):
        self.eventbuttontable.clear()
        nbuttons = len(aw.extraeventstypes) 
        if nbuttons:
            self.eventbuttontable.setRowCount(nbuttons)
            self.eventbuttontable.setColumnCount(9)
            self.eventbuttontable.setHorizontalHeaderLabels([QApplication.translate("Table","Label",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Description",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Type",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Value",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Action",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Documentation",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Visibility",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Color",None, QApplication.UnicodeUTF8),
                                                             QApplication.translate("Table","Text Color",None, QApplication.UnicodeUTF8)])
            self.eventbuttontable.setAlternatingRowColors(True)
            self.eventbuttontable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.eventbuttontable.setSelectionBehavior(QTableWidget.SelectRows)
            self.eventbuttontable.setSelectionMode(QTableWidget.SingleSelection)
            self.eventbuttontable.setShowGrid(True)
            visibility = [QApplication.translate("ComboBox","OFF",None, QApplication.UnicodeUTF8),
                          QApplication.translate("ComboBox","ON",None, QApplication.UnicodeUTF8)]
            for i in range(nbuttons):
                #label
                labeledit = QLineEdit(str(aw.extraeventslabels[i]))
                self.connect(labeledit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setlabeleventbutton(z,i))
                #description
                descriptionedit = QLineEdit(str(aw.extraeventsdescriptions[i]))
                self.connect(descriptionedit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setdescriptioneventbutton(z,i))
                #type
                typeComboBox = QComboBox()
                typeComboBox.addItems([self.etype0.text(),self.etype1.text(),self.etype2.text(),self.etype3.text(),"--"])
                typeComboBox.setCurrentIndex(aw.extraeventstypes[i])
                self.connect(typeComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,i=i:self.settypeeventbutton(z,i))
                #value
                valueEdit = QLineEdit()
                valueEdit.setValidator(QRegExpValidator(QRegExp(r"^100|\d?\d?$"),self))
                valueEdit.setText(aw.qmc.eventsvalues(aw.extraeventsvalues[i]))
                self.connect(valueEdit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setvalueeventbutton(z,i))
                #action
                actionComboBox = QComboBox()
                actionComboBox.addItems([QApplication.translate("ComboBox","None",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("ComboBox","Serial Command",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","Call Program",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","Multiple Event",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("ComboBox","Modbus Command",None, QApplication.UnicodeUTF8),
                                        QApplication.translate("ComboBox","DTA Command",None, QApplication.UnicodeUTF8)])
                actionComboBox.setCurrentIndex(aw.extraeventsactions[i])
                self.connect(actionComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,i=i:self.setactioneventbutton(z,i))
                #action description
                actiondescriptionedit = QLineEdit(str(aw.extraeventsactionstrings[i]))
                self.connect(actiondescriptionedit,SIGNAL("editingFinished()"),lambda z=1,i=i:self.setactiondescriptioneventbutton(z,i))
                #visibility
                visibilityComboBox =  QComboBox()
                visibilityComboBox.addItems(visibility)
                visibilityComboBox.setCurrentIndex(aw.extraeventsvisibility[i])
                self.connect(visibilityComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,i=i:self.setvisibilitytyeventbutton(z,i))
                #Color
                colorButton = QPushButton("Select")
                colorButton.setFocusPolicy(Qt.NoFocus)
                self.connect(colorButton, SIGNAL("clicked()"),lambda i=i: self.setbuttoncolor(i))
                #Text Color
                colorTextButton = QPushButton("Select")
                colorTextButton.setFocusPolicy(Qt.NoFocus)
                self.connect(colorTextButton, SIGNAL("clicked()"),lambda i=i: self.setbuttontextcolor(i))
                #add widgets to the table
                self.eventbuttontable.setCellWidget(i,0,labeledit)
                self.eventbuttontable.setCellWidget(i,1,descriptionedit)
                self.eventbuttontable.setCellWidget(i,2,typeComboBox)
                self.eventbuttontable.setCellWidget(i,3,valueEdit)
                self.eventbuttontable.setCellWidget(i,4,actionComboBox)
                self.eventbuttontable.setCellWidget(i,5,actiondescriptionedit)
                self.eventbuttontable.setCellWidget(i,6,visibilityComboBox)
                self.eventbuttontable.setCellWidget(i,7,colorButton)
                self.eventbuttontable.setCellWidget(i,8,colorTextButton)
            self.eventbuttontable.resizeColumnsToContents()

    def setbuttoncolor(self,x):
        colorf = QColorDialog.getColor(QColor(aw.extraeventbuttoncolor[x]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.extraeventbuttoncolor[x] = colorname
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[x],aw.extraeventbuttoncolor[x])
            aw.buttonlist[x].setStyleSheet(style)

    def setbuttontextcolor(self,x):
        colorf = QColorDialog.getColor(QColor(aw.extraeventbuttontextcolor[x]),self)
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.extraeventbuttontextcolor[x] = colorname
            style = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[x],aw.extraeventbuttoncolor[x])
            aw.buttonlist[x].setStyleSheet(style)

    def savetableextraeventbutton(self):
        for i in range(len(aw.extraeventstypes)):
            labeledit = self.eventbuttontable.cellWidget(i,0)
            label = u(labeledit.text())
            if "\\n" in label:              #make multiple line text if "\n" found in label string
                parts = label.split("\\n")
                label = chr(10).join(parts)
            aw.extraeventslabels[i] = label
            aw.buttonlist[i].setText(aw.extraeventslabels[i])
            descriptionedit = self.eventbuttontable.cellWidget(i,1)
            aw.extraeventsdescriptions[i] = str(descriptionedit.text())
            typecombobox = self.eventbuttontable.cellWidget(i,2)
            aw.extraeventstypes[i] = typecombobox.currentIndex()
            valueedit = self.eventbuttontable.cellWidget(i,3)
            aw.extraeventsvalues[i] = aw.qmc.str2eventsvalue(str(valueedit.text()))
            actioncombobox = self.eventbuttontable.cellWidget(i,4)
            aw.extraeventsactions[i] = actioncombobox.currentIndex()
            actiondescriptionedit = self.eventbuttontable.cellWidget(i,5)
            ades = str(actiondescriptionedit.text())
            aw.extraeventsactionstrings[i] = ades
            aw.update_extraeventbuttons_visibility()

    def setvisibilitytyeventbutton(self,_,i):
        actioncombobox = self.eventbuttontable.cellWidget(i,6)
        aw.extraeventsvisibility[i] = actioncombobox.currentIndex()
        aw.update_extraeventbuttons_visibility()

    def setlabeleventbutton(self,_,i):
        labeledit = self.eventbuttontable.cellWidget(i,0)
        aw.extraeventslabels[i] = labeledit.text()
        aw.settooltip()

    def setdescriptioneventbutton(self,_,i):
        descriptionedit = self.eventbuttontable.cellWidget(i,1)
        aw.extraeventsdescriptions[i] = descriptionedit.text()
        aw.settooltip()

    def setactiondescriptioneventbutton(self,_,i):
        actiondescriptionedit = self.eventbuttontable.cellWidget(i,5)
        aw.extraeventsactionstrings[i] = actiondescriptionedit.text()
        aw.settooltip()

    def setactioneventbutton(self,_,i):
        actioncombobox = self.eventbuttontable.cellWidget(i,4)
        aw.extraeventsactions[i] = actioncombobox.currentIndex()
        aw.settooltip()

    def setvalueeventbutton(self,_,i):
        valueedit = self.eventbuttontable.cellWidget(i,3)
        aw.extraeventsvalues[i] = aw.qmc.str2eventsvalue(str(valueedit.text()))
        part2 = ""
        if aw.extraeventsvalues[i] >= 0:
            part2 = str(aw.qmc.eventsvalues(aw.extraeventsvalues[i]))
        aw.buttonlist[i].setText(u(aw.qmc.etypesf(aw.extraeventstypes[i])[0])+part2)
        aw.settooltip()

    def settypeeventbutton(self,_,i):
        typecombobox = self.eventbuttontable.cellWidget(i,2)
        aw.extraeventstypes[i] = typecombobox.currentIndex()
        etype_char = ""
        if aw.extraeventstypes[i] < 4:
            etype_char = str(aw.qmc.etypesf(aw.extraeventstypes[i])[0])
        aw.buttonlist[i].setText(etype_char+str(aw.qmc.eventsvalues(aw.extraeventsvalues[i])))
        aw.settooltip()

    def delextraeventbutton(self):
        bindex = len(aw.extraeventstypes)-1
        selected = self.eventbuttontable.selectedRanges()
        if len(selected) > 0:
            bindex = selected[0].topRow()
        if bindex >= 0:
            aw.extraeventslabels.pop(bindex)
            aw.extraeventsdescriptions.pop(bindex)
            aw.extraeventstypes.pop(bindex)
            aw.extraeventsvalues.pop(bindex)
            aw.extraeventsactions.pop(bindex)
            aw.extraeventsactionstrings.pop(bindex)
            aw.extraeventsvisibility.pop(bindex)
            aw.extraeventbuttoncolor.pop(bindex)
            aw.extraeventbuttontextcolor.pop(bindex)
            self.createEventbuttonTable()  #update table
            if len(aw.e4buttondialog.buttons()):
                aw.e4buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e4buttondialog.buttons()):
                    aw.e4buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.e3buttondialog.buttons()):
                aw.e3buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e3buttondialog.buttons()):
                    aw.e3buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.e2buttondialog.buttons()):
                aw.e2buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e2buttondialog.buttons()):
                    aw.e2buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.e1buttondialog.buttons()):
                aw.e1buttondialog.removeButton(aw.buttonlist[bindex])
                if not len(aw.e1buttondialog.buttons()):
                    aw.e1buttondialog.setContentsMargins(0,0,0,0)
            elif len(aw.lowerbuttondialog.buttons()):
                aw.lowerbuttondialog.removeButton(aw.buttonlist[bindex])
            aw.buttonlist.pop(bindex)
        aw.update_extraeventbuttons_visibility()

    def insertextraeventbutton(self):
        #save previous changes
        self.savetableextraeventbutton()
        if len(aw.e4buttondialog.buttons()) >= aw.buttonlistmaxlen:
            return
        aw.extraeventsdescriptions.append("")
        aw.extraeventstypes.append(0)
        aw.extraeventsvalues.append(0)
        aw.extraeventsactions.append(0)
        aw.extraeventsactionstrings.append("")
        aw.extraeventsvisibility.append(1)
        aw.extraeventbuttoncolor.append("yellow")
        aw.extraeventbuttontextcolor.append("black")
        initialtext = u(aw.qmc.etypesf(aw.extraeventstypes[-1])[0])+str(aw.qmc.eventsvalues(aw.extraeventsvalues[-1]))
        aw.extraeventslabels.append(initialtext)
        self.createEventbuttonTable() 
        aw.buttonlist.append(QPushButton())
        bindex = len(aw.buttonlist)-1
        aw.buttonlist[bindex].setFocusPolicy(Qt.NoFocus)
        aw.buttonlist[bindex].setStyleSheet("font-size: 10pt; font-weight: bold; color: black; background-color: yellow ")
        aw.buttonlist[bindex].setMaximumSize(90, 50)
        aw.buttonlist[bindex].setMinimumHeight(50)
        aw.buttonlist[bindex].setText(initialtext)
        aw.connect(aw.buttonlist[bindex], SIGNAL("clicked()"), lambda ee=bindex:aw.recordextraevent(ee))
        #add button to row
#        lowerbuttonvisiblebuttons = len(aw.lowerbuttondialog.buttons())
#        for i in range(len(aw.qmc.buttonvisibility)):
#            # remove the invisible ones
#            if not aw.qmc.buttonvisibility[i]:
#                lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
#        if not self.eventsbuttonflag: # remove another count if EVENT button is invisible
#            lowerbuttonvisiblebuttons = lowerbuttonvisiblebuttons - 1
        if False: # lowerbuttonvisiblebuttons < aw.buttonlistmaxlen:
            aw.lowerbuttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
        elif len(aw.e1buttondialog.buttons()) < aw.buttonlistmaxlen:
            aw.e1buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
#            aw.e1buttondialog.setContentsMargins(0,10,0,0)
        elif len(aw.e2buttondialog.buttons()) < aw.buttonlistmaxlen:
            aw.e2buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
#            aw.e2buttondialog.setContentsMargins(0,10,0,0)
        elif len(aw.e3buttondialog.buttons()) < aw.buttonlistmaxlen:
            aw.e3buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
#            aw.e3buttondialog.setContentsMargins(0,10,0,0)
        else:
            aw.e4buttondialog.addButton(aw.buttonlist[bindex],QDialogButtonBox.ActionRole)
#            aw.e4buttondialog.setContentsMargins(0,10,0,0)
        aw.update_extraeventbuttons_visibility()
        aw.settooltip()

    def eventsbuttonflagChanged(self):
        if self.eventsbuttonflag.isChecked():
            aw.button_11.setVisible(True)
            aw.eventsbuttonflag = 1
        else:
            aw.button_11.setVisible(False)
            aw.eventsbuttonflag = 0

    def eventsshowflagChanged(self):
        if self.eventsshowflagbox.isChecked():
            aw.qmc.eventsshowflag = 1
        else:
            aw.qmc.eventsshowflag = 0
        aw.qmc.redraw(recomputeAllDeltas=False)

    def minieventsflagChanged(self):
        if self.minieventsflag.isChecked():
            aw.minieventsflag = 1
        else:
            aw.minieventsflag = 0
        if aw.qmc.flagon:
            aw.update_minieventline_visibility()

    def eventsGraphTypeflagChanged(self):
        aw.qmc.eventsGraphflag = self.bartypeComboBox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def saveSliderSettings(self):
        aw.eventslidervisibilities[0] = int(self.E1visibility.isChecked())
        aw.eventslidervisibilities[1] = int(self.E2visibility.isChecked())
        aw.eventslidervisibilities[2] = int(self.E3visibility.isChecked())
        aw.eventslidervisibilities[3] = int(self.E4visibility.isChecked())
        aw.eventslideractions[0] = int(self.E1action.currentIndex())
        aw.eventslideractions[1] = int(self.E2action.currentIndex())
        aw.eventslideractions[2] = int(self.E3action.currentIndex())
        aw.eventslideractions[3] = int(self.E4action.currentIndex())
        aw.eventslidercommands[0] = str(self.E1command.text())
        aw.eventslidercommands[1] = str(self.E2command.text())
        aw.eventslidercommands[2] = str(self.E3command.text())
        aw.eventslidercommands[3] = str(self.E4command.text())
        aw.eventslideroffsets[0] = int(self.E1offset.value())
        aw.eventslideroffsets[1] = int(self.E2offset.value())
        aw.eventslideroffsets[2] = int(self.E3offset.value())
        aw.eventslideroffsets[3] = int(self.E4offset.value())
        aw.eventsliderfactors[0] = float(self.E1factor.value())
        aw.eventsliderfactors[1] = float(self.E2factor.value())
        aw.eventsliderfactors[2] = float(self.E3factor.value())
        aw.eventsliderfactors[3] = float(self.E4factor.value())

    #the inverse to restoreState
    def storeState(self):
        # event configurations
        self.eventsbuttonflagstored = aw.eventsbuttonflag
        self.eventsshowflagstored = aw.qmc.eventsshowflag
        self.minieventsflagstored = aw.minieventsflag
        self.eventsGraphflagstored = aw.qmc.eventsGraphflag
        self.etypesstored = aw.qmc.etypes
        self.etypeComboBoxstored = aw.etypeComboBox
        self.autoChargeDropFlagstored = aw.qmc.autoChargeDropFlag
        # buttons
        self.extraeventslabels = aw.extraeventslabels
        self.extraeventsdescriptions = aw.extraeventsdescriptions
        self.extraeventstypes = aw.extraeventstypes
        self.extraeventsvalues = aw.extraeventsvalues
        self.extraeventsactions = aw.extraeventsactions
        self.extraeventsactionstrings = aw.extraeventsactionstrings
        self.extraeventsvisibility = aw.extraeventsvisibility
        self.extraeventbuttoncolor = aw.extraeventbuttoncolor
        self.extraeventbuttontextcolor = aw.extraeventbuttontextcolor
        self.buttonlistmaxlen = aw.buttonlistmaxlen
        # sliders
        self.eventslidervisibilities = aw.eventslidervisibilities
        self.eventslideractions = aw.eventslideractions
        self.eventslidercommands = aw.eventslidercommands
        self.eventslideroffsets = aw.eventslideroffsets
        self.eventsliderfactors = aw.eventsliderfactors
        # palettes
        self.buttonpalette = aw.buttonpalette
        # styles
        self.EvalueColor = aw.qmc.EvalueColor
        self.EvalueMarker = aw.qmc.EvalueMarker
        self.Evaluelinethickness = aw.qmc.Evaluelinethickness
        self.Evaluealpha = aw.qmc.Evaluealpha
        self.EvalueMarkerSize = aw.qmc.EvalueMarkerSize

    #called from Cancel button
    def restoreState(self):
        # event configurations
        aw.eventsbuttonflag = self.eventsbuttonflagstored
        aw.qmc.eventsshowflag = self.eventsshowflagstored
        aw.minieventsflag = self.minieventsflagstored
        aw.qmc.eventsGraphflag = self.eventsGraphflagstored
        aw.qmc.etypes = self.etypesstored
        aw.etypeComboBox = self.etypeComboBoxstored
        aw.qmc.autoChargeDropFlag = self.autoChargeDropFlagstored
        # buttons
        aw.extraeventslabels = self.extraeventslabels
        aw.extraeventsdescriptions = self.extraeventsdescriptions
        aw.extraeventstypes = self.extraeventstypes
        aw.extraeventsvalues = self.extraeventsvalues
        aw.extraeventsactions = self.extraeventsactions
        aw.extraeventsactionstrings = self.extraeventsactionstrings
        aw.extraeventsvisibility = self.extraeventsvisibility
        aw.extraeventbuttoncolor = self.extraeventbuttoncolor
        aw.extraeventbuttontextcolor = self.extraeventbuttontextcolor
        aw.buttonlistmaxlen = self.buttonlistmaxlen
        # sliders
        aw.eventslidervisibilities = self.eventslidervisibilities
        aw.eventslideractions = self.eventslideractions
        aw.eventslidercommands = self.eventslidercommands
        aw.eventslideroffsets = self.eventslideroffsets
        aw.eventsliderfactors = self.eventsliderfactors
        # palettes
        aw.buttonpalette = self.buttonpalette
        # styles
        aw.qmc.EvalueColor = self.EvalueColor
        aw.qmc.EvalueMarker = self.EvalueMarker
        aw.qmc.Evaluelinethickness = self.Evaluelinethickness
        aw.qmc.Evaluealpha = self.Evaluealpha
        aw.qmc.EvalueMarkerSize = self.EvalueMarkerSize
        self.accept()

    #called from OK button
    def updatetypes(self):
        try:
            self.savetableextraeventbutton()
            #save default buttons
            aw.qmc.buttonvisibility[0] = self.CHARGEbutton.isChecked()
            aw.button_8.setVisible(bool(aw.qmc.buttonvisibility[0]))
            aw.qmc.buttonvisibility[1] = self.DRYbutton.isChecked()
            aw.button_19.setVisible(bool(aw.qmc.buttonvisibility[1]))
            aw.qmc.buttonvisibility[2] = self.FCSbutton.isChecked()
            aw.button_3.setVisible(bool(aw.qmc.buttonvisibility[2]))
            aw.qmc.buttonvisibility[3] = self.FCEbutton.isChecked()
            aw.button_4.setVisible(bool(aw.qmc.buttonvisibility[3]))
            aw.qmc.buttonvisibility[4] = self.SCSbutton.isChecked()
            aw.button_5.setVisible(bool(aw.qmc.buttonvisibility[4]))
            aw.qmc.buttonvisibility[5] = self.SCEbutton.isChecked()
            aw.button_6.setVisible(bool(aw.qmc.buttonvisibility[5]))
            aw.qmc.buttonvisibility[6] = self.DROPbutton.isChecked()
            aw.button_9.setVisible(bool(aw.qmc.buttonvisibility[6]))
            aw.qmc.buttonvisibility[7] = self.COOLbutton.isChecked()
            aw.button_20.setVisible(bool(aw.qmc.buttonvisibility[7]))
            #save sliders   
            self.saveSliderSettings()
            aw.updateSlidersProperties() # set visibility and event names on slider widgets
            aw.qmc.buttonactions[0] = self.CHARGEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[1] = self.DRYbuttonActionType.currentIndex()
            aw.qmc.buttonactions[2] = self.FCSbuttonActionType.currentIndex()
            aw.qmc.buttonactions[3] = self.FCEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[4] = self.SCSbuttonActionType.currentIndex()
            aw.qmc.buttonactions[5] = self.SCEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[6] = self.DROPbuttonActionType.currentIndex()
            aw.qmc.buttonactions[7] = self.COOLbuttonActionType.currentIndex()
            aw.qmc.buttonactionstrings[0] = self.CHARGEbuttonActionString.text()
            aw.qmc.buttonactionstrings[1] = self.DRYbuttonActionString.text()
            aw.qmc.buttonactionstrings[2] = self.FCSbuttonActionString.text()
            aw.qmc.buttonactionstrings[3] = self.FCEbuttonActionString.text()
            aw.qmc.buttonactionstrings[4] = self.SCSbuttonActionString.text()
            aw.qmc.buttonactionstrings[5] = self.SCEbuttonActionString.text()
            aw.qmc.buttonactionstrings[6] = self.DROPbuttonActionString.text()
            aw.qmc.buttonactionstrings[7] = self.COOLbuttonActionString.text()
            #save etypes
            if len(u(self.etype0.text())) and len(u(self.etype1.text())) and len(u(self.etype2.text())) and len(u(self.etype3.text())):
                aw.qmc.etypes[0] = u(self.etype0.text())
                aw.qmc.etypes[1] = u(self.etype1.text())
                aw.qmc.etypes[2] = u(self.etype2.text())
                aw.qmc.etypes[3] = u(self.etype3.text())
                #update mini editor
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(aw.qmc.etypes)
                #update autoChargeDrop flag
                aw.qmc.autoChargeDropFlag = self.autoChargeDrop.isChecked()
                self.savetableextraeventbutton()
                aw.realignbuttons()
                aw.qmc.redraw(recomputeAllDeltas=False)
                aw.sendmessage(QApplication.translate("Message","Event configuration saved", None, QApplication.UnicodeUTF8))
                self.close()
            else:
                aw.sendmessage(QApplication.translate("Message","Found empty event type box", None, QApplication.UnicodeUTF8))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " updatetypes(): %1").arg(str(e)),exc_tb.tb_lineno)

    def settypedefault(self):
        aw.qmc.etypes = aw.qmc.etypesdefault
        self.etype0.setText(aw.qmc.etypesdefault[0])
        self.etype0.setCursorPosition(0)
        self.etype1.setText(aw.qmc.etypesdefault[1])
        self.etype1.setCursorPosition(0)
        self.etype2.setText(aw.qmc.etypesdefault[2])
        self.etype2.setCursorPosition(0)
        self.etype3.setText(aw.qmc.etypesdefault[3])
        self.etype3.setCursorPosition(0)
        aw.settooltip()

    def showEventbuttonhelp(self):
        string = u(QApplication.translate("Message", "<b>Button Label</b> Enter \\n to create labels with multiple lines.",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Event Description</b> Description of the Event to be recorded.",None, QApplication.UnicodeUTF8)) + "<br>"  
        string += u(QApplication.translate("Message", "<b>Event type</b> Type of event to be recorded.",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Event value</b> Value of event (1-10) to be recorded",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Action</b> Perform an action at the time of the event",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Documentation</b> depends on the action type ('{}' is replaced by the event value):",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Serial Command: ASCII serial command or binary a2b_uu(serial command)",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Call Program: A program/script path (absolute or relative)",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Multiple Event: Adds events of other button numbers separated by a comma: 1,2,3, etc.",None, QApplication.UnicodeUTF8)) + "<br>&nbsp;&nbsp;"
        string += u(QApplication.translate("Message", "Modbus Command: write([slaveId,register,value],..,[slaveId,register,value]) writes values to the registers in slaves specified by the given ids",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "DTA Command: Insert Data address : value, ex. 4701:1000 and sv is 100. always multiply with 10 if value Unit: 0.1 / ex. 4719:0 stops heating",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Button Visibility</b> Hides/shows individual button",None, QApplication.UnicodeUTF8)) + "<br>"
        string += u(QApplication.translate("Message", "<b>Keyboard Shorcut: </b> [b] Hides/shows Extra Button Rows",None, QApplication.UnicodeUTF8)) + "<br>"        
        QMessageBox.information(self,QApplication.translate("Message", "Event custom buttons",None, QApplication.UnicodeUTF8),string)

##########################################################################
#####################  PHASES GRAPH EDIT DLG  ############################
##########################################################################

class phasesGraphDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(phasesGraphDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Phases",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        self.phases = list(aw.qmc.phases)
        dryLabel = QLabel(QApplication.translate("Label", "Drying",None, QApplication.UnicodeUTF8))
        midLabel = QLabel(QApplication.translate("Label", "Maillard",None, QApplication.UnicodeUTF8))
        finishLabel = QLabel(QApplication.translate("Label", "Development",None, QApplication.UnicodeUTF8))
        minf = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxf = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))
        self.startdry = QSpinBox()
        self.startdry.setAlignment(Qt.AlignRight)
        self.startdry.setMinimumWidth(80)
        self.enddry = QSpinBox()
        self.enddry.setAlignment(Qt.AlignRight)
        self.enddry.setMinimumWidth(80)
        self.startmid = QSpinBox()
        self.startmid.setAlignment(Qt.AlignRight)
        self.startmid.setMinimumWidth(80)
        self.endmid = QSpinBox()
        self.endmid.setAlignment(Qt.AlignRight)
        self.endmid.setMinimumWidth(80)
        self.startfinish = QSpinBox()
        self.startfinish.setAlignment(Qt.AlignRight)
        self.startfinish.setMinimumWidth(80)
        self.endfinish = QSpinBox()
        self.endfinish.setAlignment(Qt.AlignRight)
        self.endfinish.setMinimumWidth(80)
        self.events2phases()
        if aw.qmc.mode == "F":
            self.startdry.setSuffix(" F")
            self.enddry.setSuffix(" F")
            self.startmid.setSuffix(" F")
            self.endmid.setSuffix(" F")
            self.startfinish.setSuffix(" F")
            self.endfinish.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.startdry.setSuffix(" C")
            self.enddry.setSuffix(" C")
            self.startmid.setSuffix(" C")
            self.endmid.setSuffix(" C")
            self.startfinish.setSuffix(" C")
            self.endfinish.setSuffix(" C")
        self.startdry.setRange(0,1000)    #(min,max)
        self.enddry.setRange(0,1000)
        self.startmid.setRange(0,1000)
        self.endmid.setRange(0,1000)
        self.startfinish.setRange(0,1000)
        self.endfinish.setRange(0,1000)
        self.connect(self.enddry,SIGNAL("valueChanged(int)"),self.startmid.setValue)
        self.connect(self.startmid,SIGNAL("valueChanged(int)"),self.enddry.setValue)
        self.connect(self.endmid,SIGNAL("valueChanged(int)"),self.startfinish.setValue)
        self.connect(self.startfinish,SIGNAL("valueChanged(int)"),self.endmid.setValue)
        self.getphases()
        self.pushbuttonflag = QCheckBox(QApplication.translate("CheckBox","Auto Adjusted",None, QApplication.UnicodeUTF8))
        self.pushbuttonflag.setChecked(bool(aw.qmc.phasesbuttonflag))
        self.connect(self.pushbuttonflag,SIGNAL("stateChanged(int)"),self.pushbuttonflagChanged)
        self.watermarksflag = QCheckBox(QApplication.translate("CheckBox","Watermarks",None, QApplication.UnicodeUTF8))
        self.watermarksflag.setChecked(bool(aw.qmc.watermarksflag))
        self.connect(self.watermarksflag,SIGNAL("stateChanged(int)"),self.watermarksflagChanged)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        setDefaultButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        setDefaultButton.setFocusPolicy(Qt.NoFocus)
        self.connect(cancelButton,SIGNAL("clicked()"),self.cancel)
        self.connect(okButton,SIGNAL("clicked()"),self.updatephases)
        self.connect(setDefaultButton,SIGNAL("clicked()"),self.setdefault)
        phaseLayout = QGridLayout()
        phaseLayout.addWidget(minf,0,1,Qt.AlignCenter)
        phaseLayout.addWidget(maxf,0,2,Qt.AlignCenter)
        phaseLayout.addWidget(dryLabel,1,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startdry,1,1)
        phaseLayout.addWidget(self.enddry,1,2)
        phaseLayout.addWidget(midLabel,2,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startmid,2,1)
        phaseLayout.addWidget(self.endmid,2,2)
        phaseLayout.addWidget(finishLabel,3,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startfinish,3,1)
        phaseLayout.addWidget(self.endfinish,3,2)
        boxedPhaseLayout = QHBoxLayout()
        boxedPhaseLayout.addStretch()
        boxedPhaseLayout.addLayout(phaseLayout)
        boxedPhaseLayout.addStretch()
        boxedPhaseFlagLayout = QHBoxLayout()
        boxedPhaseFlagLayout.addStretch()
        boxedPhaseFlagLayout.addWidget(self.pushbuttonflag)
        boxedPhaseFlagLayout.addWidget(self.watermarksflag)
        boxedPhaseFlagLayout.addStretch()
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(setDefaultButton)
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(cancelButton)
        buttonsLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(boxedPhaseLayout)
        mainLayout.addLayout(boxedPhaseFlagLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonsLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)
        aw.qmc.redraw(recomputeAllDeltas=False)

    def savePhasesSettings(self):
        if not aw.qmc.phasesbuttonflag:
            settings = QSettings()
            #save phases
            settings.setValue("Phases",aw.qmc.phases)

    def events2phases(self):
        if aw.qmc.phasesbuttonflag:
            # adjust phases by DryEnd and FCs events
            if aw.qmc.timeindex[1]:
                aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                self.enddry.setDisabled(True)
                self.startmid.setDisabled(True)
            if aw.qmc.timeindex[2]:
                aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
                self.endmid.setDisabled(True)
                self.startfinish.setDisabled(True)


    def watermarksflagChanged(self,_):
        aw.qmc.watermarksflag = not aw.qmc.watermarksflag
        aw.qmc.redraw(recomputeAllDeltas=False)

    def pushbuttonflagChanged(self,i):
        if i:
            aw.qmc.phasesbuttonflag = True
            self.events2phases()
            self.getphases()
            aw.qmc.redraw(recomputeAllDeltas=False)
        else:
            aw.qmc.phasesbuttonflag = False
            self.enddry.setEnabled(True)
            self.startmid.setEnabled(True)
            self.endmid.setEnabled(True)
            self.startfinish.setEnabled(True)

    def updatephases(self):
        aw.qmc.phases[0] = self.startdry.value()
        aw.qmc.phases[1] = self.enddry.value()
        aw.qmc.phases[2] = self.endmid.value()
        aw.qmc.phases[3] = self.endfinish.value()
        if self.pushbuttonflag.isChecked():
            aw.qmc.phasesbuttonflag = True
        else:
            aw.qmc.phasesbuttonflag = False
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.savePhasesSettings()
        self.close()

    def cancel(self):
        aw.qmc.phases = list(self.phases)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.savePhasesSettings()
        self.close()
        
    def getphases(self):
        self.startdry.setValue(aw.qmc.phases[0])
        self.enddry.setValue(aw.qmc.phases[1])
        self.endmid.setValue(aw.qmc.phases[2])
        self.endfinish.setValue(aw.qmc.phases[3])

    def setdefault(self):
        if aw.qmc.mode == "F":
            aw.qmc.phases = list(aw.qmc.phases_fahrenheit_defaults)
        elif aw.qmc.mode == "C":
            aw.qmc.phases = list(aw.qmc.phases_celsius_defaults)
        self.events2phases()
        self.getphases()
        aw.sendmessage(QApplication.translate("Message","Phases changed to %1 default: %2",None, QApplication.UnicodeUTF8).arg(aw.qmc.mode).arg(str(aw.qmc.phases)))
        aw.qmc.redraw(recomputeAllDeltas=False)

############################################################################
#####################   FLAVOR STAR PROPERTIES DIALOG   ####################
############################################################################

class flavorDlg(ArtisanDialog):   
    def __init__(self, parent = None):
        super(flavorDlg,self).__init__(parent)
        #avoid questionm mark context help
        flags = self.windowFlags()
        helpFlag = Qt.WindowContextHelpButtonHint
        flags = flags & (~helpFlag)
        self.setWindowFlags(flags)
        self.setWindowTitle(QApplication.translate("Form Caption","Cup Profile",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        defaultlabel = QLabel(QApplication.translate("Label","Default",None, QApplication.UnicodeUTF8))
        self.defaultcombobox = QComboBox()
        self.defaultcombobox.addItems(["","Artisan","SCCA","CQI","SweetMarias","C","E","CoffeeGeek","Intelligentsia","IIAC","*CUSTOM*"])
        self.defaultcombobox.setCurrentIndex(0)
        self.lastcomboboxIndex = 0
        self.connect(self.defaultcombobox, SIGNAL("currentIndexChanged(int)"),self.setdefault)
        self.flavortable = QTableWidget()
        self.flavortable.setTabKeyNavigation(True)
        self.createFlavorTable()
        leftButton = QPushButton("<")
        leftButton.setFocusPolicy(Qt.NoFocus)
        self.connect(leftButton, SIGNAL("clicked()"),lambda x=0:self.move(x))
        rightButton = QPushButton(">")
        rightButton.setFocusPolicy(Qt.NoFocus)
        self.connect(rightButton, SIGNAL("clicked()"),lambda x=1:self.move(x))
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        addButton.setFocusPolicy(Qt.NoFocus)
        self.connect(addButton, SIGNAL("clicked()"),self.addlabel)
        delButton = QPushButton(QApplication.translate("Button","Del",None, QApplication.UnicodeUTF8))
        delButton.setFocusPolicy(Qt.NoFocus)
        self.connect(delButton, SIGNAL("clicked()"),self.poplabel)
        saveImgButton = QPushButton(QApplication.translate("Button","Save Image",None, QApplication.UnicodeUTF8))
        saveImgButton.setFocusPolicy(Qt.NoFocus)
        self.connect(saveImgButton, SIGNAL("clicked()"),lambda x=0,i=1:aw.resize(x,i))
        backButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        self.connect(backButton,SIGNAL("clicked()"),self.close)
        self.backgroundCheck = QCheckBox(QApplication.translate("CheckBox","Background", None, QApplication.UnicodeUTF8))
        if aw.qmc.flavorbackgroundflag:
            self.backgroundCheck.setChecked(True)
        self.connect(self.backgroundCheck, SIGNAL("clicked()"),self.showbackground)
        aspectlabel = QLabel(QApplication.translate("Label","Aspect Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox = QDoubleSpinBox()
        self.aspectSpinBox.setToolTip(QApplication.translate("Tooltip","Aspect Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox.setRange(0.,2.)
        self.aspectSpinBox.setSingleStep(.1)
        self.aspectSpinBox.setValue(aw.qmc.flavoraspect)
        self.connect(self.aspectSpinBox, SIGNAL("valueChanged(double)"),self.setaspect)
        flavorLayout = QHBoxLayout()
        flavorLayout.addWidget(self.flavortable)
        comboLayout = QHBoxLayout()
        comboLayout.addWidget(defaultlabel)
        comboLayout.addWidget(self.defaultcombobox)
        comboLayout.addStretch()
        aspectLayout = QHBoxLayout()
        aspectLayout.addWidget(self.backgroundCheck)
        aspectLayout.addWidget(aspectlabel)
        aspectLayout.addWidget(self.aspectSpinBox)
        aspectLayout.addStretch()
        blayout1 = QHBoxLayout()
        blayout1.addStretch()
        blayout1.addWidget(addButton)
        blayout1.addWidget(delButton)  
        blayout1.addStretch()
        extralayout = QVBoxLayout()
        extralayout.addLayout(comboLayout)
        extralayout.addLayout(aspectLayout)
        extraGroupLayout = QGroupBox()
        extraGroupLayout.setLayout(extralayout)
        blayout = QHBoxLayout()
        blayout.addStretch()
        blayout.addWidget(leftButton)
        blayout.addWidget(rightButton)
        blayout.addStretch()
        mainButtonsLayout = QHBoxLayout()
        mainButtonsLayout.addWidget(saveImgButton)
        mainButtonsLayout.addStretch()
        mainButtonsLayout.addWidget(backButton)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(flavorLayout)
        mainLayout.addLayout(blayout1)
        mainLayout.addWidget(extraGroupLayout)
        mainLayout.addLayout(blayout)
        mainLayout.addStretch()
        mainLayout.addLayout(mainButtonsLayout)
        self.setLayout(mainLayout)
        aw.qmc.flavorchart()

    def setaspect(self):
        aw.qmc.flavoraspect = self.aspectSpinBox.value()
        aw.qmc.flavorchart()

    def createFlavorTable(self):
        self.flavortable.clear()
        nflavors = len(aw.qmc.flavorlabels)
        if nflavors:
            self.flavortable.setRowCount(nflavors)
            self.flavortable.setColumnCount(2)
            self.flavortable.setHorizontalHeaderLabels([QApplication.translate("Table", "Label",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Value",None, QApplication.UnicodeUTF8)])
            self.flavortable.setAlternatingRowColors(True)
            self.flavortable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.flavortable.setSelectionBehavior(QTableWidget.SelectRows)
            self.flavortable.setSelectionMode(QTableWidget.SingleSelection)
            self.flavortable.setShowGrid(True)
            #populate table
            for i in range(nflavors):
                labeledit = QLineEdit(u(aw.qmc.flavorlabels[i]))
                self.connect(labeledit, SIGNAL("textChanged(QString)"),lambda z=1,x=i: self.setlabel(x))
                valueSpinBox = QDoubleSpinBox()
                valueSpinBox.setRange(0.,10.)
                valueSpinBox.setAlignment(Qt.AlignRight)
                val = aw.qmc.flavors[i]
                if aw.qmc.flavors[0] < 1. and aw.qmc.flavors[-1] < 1.: # < 0.5.0 version style compatibility
                    val *= 10.
                valueSpinBox.setValue(val)
                self.connect(valueSpinBox, SIGNAL("valueChanged(double)"),lambda z=1,x=i: self.setvalue(z,x))
                #add widgets to the table
                self.flavortable.setCellWidget(i,0,labeledit)
                self.flavortable.setCellWidget(i,1,valueSpinBox)
            self.flavortable.resizeColumnsToContents()

    def showbackground(self):
        if self.backgroundCheck.isChecked():
            if not aw.qmc.background:
                message = QApplication.translate("Message","Background profile not found", None, QApplication.UnicodeUTF8)
                aw.sendmessage(message)
                self.backgroundCheck.setChecked(False)
            else:
                if len(aw.qmc.backgroundFlavors) != len(aw.qmc.flavors):
                    message = QApplication.translate("Message","Background does not match number of labels", None, QApplication.UnicodeUTF8)
                    aw.sendmessage(message)
                    self.backgroundCheck.setChecked(False)
                else:
                    aw.qmc.flavorbackgroundflag = True
                    aw.qmc.flavorchart()
        else:
            aw.qmc.flavorbackgroundflag = False
            aw.qmc.flavorchart()

    def move(self,x):
        if x == 0:
            aw.qmc.flavorstartangle += 5
        else:
            aw.qmc.flavorstartangle -= 5
        aw.qmc.flavorchart()

    def savetable(self):
        for i in range(len(aw.qmc.flavorlabels)):
            labeledit = self.flavortable.cellWidget(i,0)
            valueSpinBox = self.flavortable.cellWidget(i,1)
            label = u(labeledit.text())
            if "\\n" in label:              #make multiple line text if "\n" found in label string
                parts = label.split("\\n")
                label = chr(10).join(parts)
            aw.qmc.flavorlabels[i] = label
            aw.qmc.flavors[i] = valueSpinBox.value()
        if self.lastcomboboxIndex == 10:
            # store the current labels as *CUSTOM*
            aw.qmc.customflavorlabels = aw.qmc.flavorlabels

    def setlabel(self,x):
        labeledit = self.flavortable.cellWidget(x,0)
        aw.qmc.flavorlabels[x] = labeledit.text()
        aw.qmc.flavorchart()

    def setvalue(self,z,x):
        valueSpinBox = self.flavortable.cellWidget(x,1)
        aw.qmc.flavors[x] = valueSpinBox.value()
        aw.qmc.flavorchart()

    def setdefault(self):
        if self.lastcomboboxIndex == 10:
            # store the current labels as *CUSTOM*
            aw.qmc.customflavorlabels = aw.qmc.flavorlabels
        dindex =  self.defaultcombobox.currentIndex()
        #["","Artisan","SCCA","CQI","SweetMarias","C","E",coffeegeek,Intelligentsia]
        if dindex > 0 or dindex < 11:
            aw.qmc.flavorstartangle = 90
        if dindex == 1:
            aw.qmc.flavorlabels = list(aw.qmc.artisanflavordefaultlabels)
        elif dindex == 2:
            aw.qmc.flavorlabels = list(aw.qmc.SCCAflavordefaultlabels)
        elif dindex == 3:
            aw.qmc.flavorlabels = list(aw.qmc.CQIflavordefaultlabels)
        elif dindex == 4:
            aw.qmc.flavorlabels = list(aw.qmc.SweetMariasflavordefaultlabels)
        elif dindex == 5:
            aw.qmc.flavorlabels = list(aw.qmc.Cflavordefaultlabels)
        elif dindex == 6:
            aw.qmc.flavorlabels = list(aw.qmc.Eflavordefaultlabels)
        elif dindex == 7:
            aw.qmc.flavorlabels = list(aw.qmc.coffeegeekflavordefaultlabels)
        elif dindex == 8:
            aw.qmc.flavorlabels = list(aw.qmc.Intelligentsiaflavordefaultlabels)
        elif dindex == 9:
            aw.qmc.flavorlabels = list(aw.qmc.IstitutoInternazionaleAssaggiatoriCaffe)
        elif dindex == 10:
            aw.qmc.flavorlabels = list(aw.qmc.customflavorlabels)
        else:
            return
        aw.qmc.flavors = [5.]*len(aw.qmc.flavorlabels)
        self.createFlavorTable()
        aw.qmc.flavorchart()
        self.lastcomboboxIndex = dindex

    def addlabel(self):
        aw.qmc.flavorlabels.append("???")
        aw.qmc.flavors.append(5.)
        self.createFlavorTable()
        aw.qmc.flavorchart()

    def poplabel(self):
        fn = len(aw.qmc.flavors)
        aw.qmc.flavors = aw.qmc.flavors[:(fn-1)]
        aw.qmc.flavorlabels = aw.qmc.flavorlabels[:(fn -1)]
        self.createFlavorTable()
        aw.qmc.flavorchart()

    def closeEvent(self,_):
        self.savetable()
        aw.qmc.safesaveflag = True
        self.accept()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def close(self):
        self.closeEvent(None)

#################################################################
#################### BACKGROUND DIALOG  #########################
#################################################################

class backgroundDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(backgroundDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Profile Background", None, QApplication.UnicodeUTF8))
        self.setModal(True)
        #TAB 1
        self.pathedit = QLineEdit(aw.qmc.backgroundpath)
        self.pathedit.setStyleSheet("background-color:'lightgrey';")
        self.pathedit.setReadOnly(True)
        self.filename = ""
        self.backgroundCheck = QCheckBox(QApplication.translate("CheckBox","Show", None, QApplication.UnicodeUTF8))
        self.backgroundDetails = QCheckBox(QApplication.translate("CheckBox","Text", None, QApplication.UnicodeUTF8))
        self.backgroundeventsflag = QCheckBox(QApplication.translate("CheckBox","Events", None, QApplication.UnicodeUTF8))
        self.backgroundDeltaETflag = QCheckBox(QApplication.translate("CheckBox","DeltaET", None, QApplication.UnicodeUTF8))
        self.backgroundDeltaBTflag = QCheckBox(QApplication.translate("CheckBox","DeltaBT", None, QApplication.UnicodeUTF8))
        self.backgroundCheck.setChecked(aw.qmc.background)
        self.backgroundDetails.setChecked(aw.qmc.backgroundDetails)
        self.backgroundeventsflag.setChecked(aw.qmc.backgroundeventsflag)
        self.backgroundDeltaETflag.setChecked(aw.qmc.DeltaETBflag)
        self.backgroundDeltaBTflag.setChecked(aw.qmc.DeltaBTBflag)
        loadButton = QPushButton(QApplication.translate("Button","Load", None, QApplication.UnicodeUTF8))
        loadButton.setFocusPolicy(Qt.NoFocus)
        delButton = QPushButton(QApplication.translate("Button","Delete", None, QApplication.UnicodeUTF8))
        delButton.setFocusPolicy(Qt.NoFocus)
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))
        alignButton = QPushButton(QApplication.translate("Button","Align", None, QApplication.UnicodeUTF8))
        alignButton.setFocusPolicy(Qt.NoFocus)
        self.connect(loadButton, SIGNAL("clicked()"),self.load)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(alignButton, SIGNAL("clicked()"), aw.qmc.timealign)
        self.speedSpinBox = QSpinBox()
        self.speedSpinBox.setRange(1,90)
        self.speedSpinBox.setSingleStep(5)
        self.speedSpinBox.setValue(30)
        intensitylabel =QLabel(QApplication.translate("Label", "Opaqueness",None, QApplication.UnicodeUTF8))
        intensitylabel.setAlignment(Qt.AlignRight)
        self.intensitySpinBox = QSpinBox()
        self.intensitySpinBox.setAlignment(Qt.AlignRight)
        self.intensitySpinBox.setRange(1,9)
        self.intensitySpinBox.setSingleStep(1)
        self.intensitySpinBox.setValue(3)
        colors = [""]
        for key in cnames:
            colors.append(str(key))
        colors.sort()
        colors.insert(0,"ET")
        colors.insert(1,"BT")
        colors.insert(2,"DeltaET")
        colors.insert(3,"DeltaBT")
        metcolorlabel = QLabel(QApplication.translate("Label", "ET Color",None, QApplication.UnicodeUTF8))
        metcolorlabel.setAlignment(Qt.AlignRight)
        self.metcolorComboBox = QComboBox()
        self.metcolorComboBox.addItems(colors)
        self.metcolorComboBox.setCurrentIndex(0)
        btcolorlabel = QLabel(QApplication.translate("Label", "BT Color",None, QApplication.UnicodeUTF8))
        btcolorlabel.setAlignment(Qt.AlignRight)
        self.btcolorComboBox = QComboBox()
        self.btcolorComboBox.addItems(colors)
        self.btcolorComboBox.setCurrentIndex(1)
        deltaetcolorlabel = QLabel(QApplication.translate("Label", "DeltaET Color",None, QApplication.UnicodeUTF8))
        deltaetcolorlabel.setAlignment(Qt.AlignRight)
        self.deltaetcolorComboBox = QComboBox()
        self.deltaetcolorComboBox.addItems(colors)
        self.deltaetcolorComboBox.setCurrentIndex(2)
        deltabtcolorlabel = QLabel(QApplication.translate("Label", "DeltaBT Color",None, QApplication.UnicodeUTF8))
        deltabtcolorlabel.setAlignment(Qt.AlignRight)
        self.deltabtcolorComboBox = QComboBox()
        self.deltabtcolorComboBox.addItems(colors)
        self.deltabtcolorComboBox.setCurrentIndex(3)
        self.upButton = QPushButton(QApplication.translate("Button","Up",None, QApplication.UnicodeUTF8))
        self.upButton.setFocusPolicy(Qt.NoFocus)
        self.downButton = QPushButton(QApplication.translate("Button","Down",None, QApplication.UnicodeUTF8))
        self.downButton.setFocusPolicy(Qt.NoFocus)
        self.leftButton = QPushButton(QApplication.translate("Button","Left",None, QApplication.UnicodeUTF8))
        self.leftButton.setFocusPolicy(Qt.NoFocus)
        self.rightButton = QPushButton(QApplication.translate("Button","Right",None, QApplication.UnicodeUTF8))
        self.rightButton.setFocusPolicy(Qt.NoFocus)
        self.connect(self.backgroundCheck, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundDetails, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundeventsflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundDeltaETflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(self.backgroundDeltaBTflag, SIGNAL("clicked()"),self.readChecks)
        self.connect(delButton, SIGNAL("clicked()"),self.delete)
        self.connect(self.upButton, SIGNAL("clicked()"), lambda m= "up": self.move(m))
        self.connect(self.downButton, SIGNAL("clicked()"), lambda m="down": self.move(m))
        self.connect(self.leftButton, SIGNAL("clicked()"), lambda m="left": self.move(m))
        self.connect(self.rightButton, SIGNAL("clicked()"),lambda m="right": self.move(m))
        self.connect(self.intensitySpinBox, SIGNAL("valueChanged(int)"),self.adjustintensity)
        self.connect(self.btcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color="", curve = "bt": self.adjustcolor(color,curve))
        self.connect(self.metcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color= "", curve = "et": self.adjustcolor(color,curve))
        self.connect(self.deltabtcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color="", curve = "deltabt": self.adjustcolor(color,curve))
        self.connect(self.deltaetcolorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda color= "", curve = "deltaet": self.adjustcolor(color,curve))
        #TAB 2 EVENTS
        #table for showing events
        self.eventtable = QTableWidget()
        self.eventtable.setTabKeyNavigation(True)
        self.createEventTable()
        #TAB 3 DATA
        #table for showing data
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        self.createDataTable()
        #TAB 4
        self.backgroundReproduce = QCheckBox(QApplication.translate("CheckBox","Playback Aid",None, QApplication.UnicodeUTF8))
        self.backgroundReproduce.setChecked(aw.qmc.backgroundReproduce)
        self.backgroundReproduce.setFocusPolicy(Qt.NoFocus)
        self.connect(self.backgroundReproduce, SIGNAL("stateChanged(int)"),self.setreproduce)
        etimelabel =QLabel(QApplication.translate("Label", "Text Warning",None, QApplication.UnicodeUTF8))
        etimeunit =QLabel(QApplication.translate("Label", "sec",None, QApplication.UnicodeUTF8))
        self.etimeSpinBox = QSpinBox()
        self.etimeSpinBox.setRange(1,60)
        self.etimeSpinBox.setValue(aw.qmc.detectBackgroundEventTime)
        self.connect(self.etimeSpinBox, SIGNAL("valueChanged(int)"),self.setreproduce)
        #LAYOUT MANAGERS
        movelayout = QGridLayout()
        movelayout.addWidget(self.upButton,0,1)
        movelayout.addWidget(self.leftButton,1,0)
        movelayout.addWidget(self.speedSpinBox,1,1)
        movelayout.addWidget(self.rightButton,1,2)
        movelayout.addWidget(self.downButton,2,1)
        checkslayout = QHBoxLayout()
        checkslayout.addWidget(self.backgroundCheck)
        checkslayout.addWidget(self.backgroundDetails)
        checkslayout.addWidget(self.backgroundeventsflag)
        checkslayout.addWidget(self.backgroundDeltaETflag)
        checkslayout.addWidget(self.backgroundDeltaBTflag)
        layout = QGridLayout()
        layout.addWidget(intensitylabel,0,0)
        layout.addWidget(self.intensitySpinBox,0,1)
        layout.addWidget(metcolorlabel,1,0)
        layout.addWidget(self.metcolorComboBox,1,1)
        layout.addWidget(btcolorlabel,2,0)
        layout.addWidget(self.btcolorComboBox,2,1)
        layout.addWidget(deltaetcolorlabel,3,0)
        layout.addWidget(self.deltaetcolorComboBox,3,1)
        layout.addWidget(deltabtcolorlabel,4,0)
        layout.addWidget(self.deltabtcolorComboBox,4,1)
        hlayout = QHBoxLayout()
        hlayout.addStretch()
        hlayout.addLayout(layout)
        upperlayout = QVBoxLayout()
        upperlayout.addLayout(movelayout)
        upperlayout.addLayout(checkslayout)
        upperlayout.addLayout(hlayout) 
        layoutBoxed = QHBoxLayout()
        layoutBoxed.addStretch()
        layoutBoxed.addLayout(upperlayout)
        layoutBoxed.addStretch()
        alignButtonBoxed = QHBoxLayout()
        alignButtonBoxed.addWidget(loadButton)
        alignButtonBoxed.addWidget(delButton)        
        alignButtonBoxed.addStretch()
        alignButtonBoxed.addWidget(alignButton)
        tab4content = QHBoxLayout()
        tab4content.addWidget(self.backgroundReproduce)
        tab4content.addStretch()
        tab4content.addWidget(etimelabel)
        tab4content.addWidget(self.etimeSpinBox)
        tab4content.addWidget(etimeunit)
        tab1layout = QVBoxLayout()
        tab1layout.addLayout(layoutBoxed)
        tab1layout.addStretch()
        tab1layout.addLayout(alignButtonBoxed)
        tab1layout.addWidget(self.pathedit)
        tab1layout.addLayout(tab4content)
        tab1layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom 
        tab1layout.setMargin(0)
        tab2layout = QVBoxLayout()
        tab2layout.addWidget(self.eventtable)
        tab2layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom 
        tab2layout.setMargin(0)
        tab3layout = QVBoxLayout()
        tab3layout.addWidget(self.datatable)
        tab3layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom 
        tab3layout.setMargin(0)
        #tab layout
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","Config",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Events",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Data",None, QApplication.UnicodeUTF8))
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(TabWidget) 
        mainLayout.addLayout(buttonLayout)
        mainLayout.setContentsMargins(5, 15, 5, 10) # left, top, right, bottom 
        self.setLayout(mainLayout)

    def setreproduce(self):
        if aw.qmc.background:
            aw.qmc.detectBackgroundEventTime = self.etimeSpinBox.value()
            if self.backgroundReproduce.isChecked():
                aw.qmc.backgroundReproduce = True
                msg = QApplication.translate("Message","Playback Aid set ON at %1 secs",None, QApplication.UnicodeUTF8).arg(str(aw.qmc.detectBackgroundEventTime))
            else:
                aw.qmc.backgroundReproduce = False
                msg = QApplication.translate("StatusBar","Playback Aid set OFF",None, QApplication.UnicodeUTF8)
                aw.messagelabel.setStyleSheet("background-color:'transparent';")
            aw.sendmessage(msg)
        else:
            self.backgroundReproduce.setChecked(False)
            aw.sendmessage(QApplication.translate("Message","No profile background found",None, QApplication.UnicodeUTF8))

    def adjustcolor(self,color,curve):
        color = str(color)
        self.btcolorComboBox.setDisabled(True)
        self.metcolorComboBox.setDisabled(True)
        self.deltabtcolorComboBox.setDisabled(True)
        self.deltaetcolorComboBox.setDisabled(True)
        if color == "ET":
            c = aw.qmc.palette["et"]
        elif color == "BT":
            c = aw.qmc.palette["bt"]
        elif color == "BT":
            c = aw.qmc.palette["deltaet"]
        elif color == "BT":
            c = aw.qmc.palette["deltabt"]
        else:
            c = color
        if curve == "et":
            aw.qmc.backgroundmetcolor = c
        elif curve == "bt":
            aw.qmc.backgroundbtcolor = c
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.btcolorComboBox.setDisabled(False)
        self.metcolorComboBox.setDisabled(False)
        self.deltabtcolorComboBox.setDisabled(False)
        self.deltaetcolorComboBox.setDisabled(False)

    def adjustintensity(self):
        #block button
        self.intensitySpinBox.setDisabled(True)
        aw.qmc.backgroundalpha = self.intensitySpinBox.value()/10.
        aw.qmc.redraw(recomputeAllDeltas=False)
        #reactivate button
        self.intensitySpinBox.setDisabled(False)

    def delete(self):
        self.pathedit.setText("")
# we should not overwrite the users app settings here, right:
#        self.backgroundCheck.setChecked(False)
#        self.backgroundDetails.setChecked(False)
#        self.backgroundeventsflag.setChecked(False)
#        aw.qmc.background = False
#        aw.qmc.backgroundDetails = False
#        aw.qmc.backgroundeventsflag = False
        aw.qmc.temp1B, aw.qmc.temp2B, aw.qmc.timeB = [],[],[]
        aw.qmc.backgroundEvents, aw.qmc.backgroundEtypes = [],[]
        aw.qmc.backgroundEvalues, aw.qmc.backgroundEStrings,aw.qmc.backgroundFlavors = [],[],[]
        aw.qmc.timeindexB = [-1,0,0,0,0,0,0]
        self.eventtable.clear()
        self.datatable.clear()
        aw.qmc.backmoveflag = 1
        aw.qmc.resetlinecountcaches()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def move(self,m):
        #block button
        if m == "up":
            self.upButton.setDisabled(True)
        elif m == "down":
            self.downButton.setDisabled(True)
        elif m == "left":
            self.leftButton.setDisabled(True)
        elif m == "right":
            self.rightButton.setDisabled(True)
        step = self.speedSpinBox.value()
        aw.qmc.movebackground(m,step)
        self.createEventTable()
        self.createDataTable()
        aw.qmc.redraw(recomputeAllDeltas=False)
        #activate button
        if m == "up":
            self.upButton.setDisabled(False)
        elif m == "down":
            self.downButton.setDisabled(False)
        elif m == "left":
            self.leftButton.setDisabled(False)
        elif m == "right":
            self.rightButton.setDisabled(False)

    def readChecks(self):
        aw.qmc.background = bool(self.backgroundCheck.isChecked())
        aw.qmc.backgroundDetails = bool(self.backgroundDetails.isChecked())
        aw.qmc.backgroundeventsflag = bool(self.backgroundeventsflag.isChecked())
        aw.qmc.DeltaETBflag = bool(self.backgroundDeltaETflag.isChecked())
        aw.qmc.DeltaBTBflag = bool(self.backgroundDeltaBTflag.isChecked())
        aw.qmc.redraw(recomputeAllDeltas=False)

    def load(self):
        self.filename = aw.ArtisanOpenFileDialog()
        if len(u(self.filename)) == 0:
            return
        aw.sendmessage(QApplication.translate("Message","Reading background profile...",None, QApplication.UnicodeUTF8))
        aw.qmc.backgroundpath = u(self.filename)
        aw.qmc.resetlinecountcaches()
        aw.loadbackground(u(self.filename))
        self.pathedit.setText(u(self.filename))
        self.backgroundCheck.setChecked(True)
        self.readChecks()
        self.createEventTable()
        self.createDataTable()
        aw.qmc.timealign()

    def createEventTable(self):
        self.eventtable.clear()
        ndata = len(aw.qmc.backgroundEvents)
        if ndata:
            self.eventtable.setRowCount(ndata)
            self.eventtable.setColumnCount(4)
            self.eventtable.setHorizontalHeaderLabels([QApplication.translate("Table","Time",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Description",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Type",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Value",None, QApplication.UnicodeUTF8)])
            self.eventtable.setAlternatingRowColors(True)
            self.eventtable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.eventtable.setSelectionBehavior(QTableWidget.SelectRows)
            self.eventtable.setSelectionMode(QTableWidget.SingleSelection)
            self.eventtable.setShowGrid(True)
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            for i in range(ndata):
                timez = QTableWidgetItem(aw.qmc.stringfromseconds(int(aw.qmc.timeB[aw.qmc.backgroundEvents[i]]-start)))
                timez.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                description = QTableWidgetItem(aw.qmc.backgroundEStrings[i])
                etype = QTableWidgetItem(aw.qmc.Betypesf(aw.qmc.backgroundEtypes[i]))
                evalue = QTableWidgetItem(aw.qmc.eventsvalues(aw.qmc.backgroundEvalues[i]))                
                evalue.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                #add widgets to the table
                self.eventtable.setItem(i,0,timez)
                self.eventtable.setItem(i,1,description)
                self.eventtable.setItem(i,2,etype)
                self.eventtable.setItem(i,3,evalue)
            self.eventtable.resizeColumnsToContents()
            # improve width of Time column
            self.eventtable.setColumnWidth(1,175)

    def createDataTable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.timeB)
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        if ndata:
            self.datatable.setRowCount(ndata)
            self.datatable.setColumnCount(6)
            self.datatable.setHorizontalHeaderLabels([QApplication.translate("Table","Abs Time",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Rel Time",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","ET",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","BT",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","DeltaBT (d/m)",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","DeltaET (d/m)",None, QApplication.UnicodeUTF8)])
            self.datatable.setAlternatingRowColors(True)
            self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
            self.datatable.setSelectionMode(QTableWidget.SingleSelection)
            self.datatable.setShowGrid(True)
            for i in range(ndata):
                Atime = QTableWidgetItem("%.03f"%aw.qmc.timeB[i])                
                Atime.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                Rtime = QTableWidgetItem(aw.qmc.stringfromseconds(int(round(aw.qmc.timeB[i]-start))))
                ET = QTableWidgetItem("%.02f"%aw.qmc.temp1B[i])
                ET.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                BT = QTableWidgetItem("%.02f"%aw.qmc.temp2B[i])
                BT.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                if i:
                    d = (aw.qmc.timeB[i]-aw.qmc.timeB[i-1])
                    if d == 0:
                        dET = 0.
                        dBT = 0.
                    else:
                        dET = (60*(aw.qmc.temp1B[i]-aw.qmc.temp1B[i-1])/d)
                        dBT = (60*(aw.qmc.temp2B[i]-aw.qmc.temp2B[i-1])/d)
                    deltaET = QTableWidgetItem("%.02f"%dET)
                    deltaBT = QTableWidgetItem("%.02f"%dBT)
                else:
                    deltaET = QTableWidgetItem("--")
                    deltaBT = QTableWidgetItem("--")                
                deltaET.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                deltaBT.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
                if i:
                    #identify by color and add notation
                    if i == aw.qmc.timeindexB[0] != -1:
                        Rtime.setBackgroundColor(QColor('#f07800'))
                        text = QApplication.translate("Table", "%1 START",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i == aw.qmc.timeindexB[1]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "%1 DRY END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i == aw.qmc.timeindexB[2]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = Rtime.text()
                        text = QApplication.translate("Table", "%1 FC START",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i == aw.qmc.timeindexB[3]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "%1 FC END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i == aw.qmc.timeindexB[4]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "%1 SC START",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i == aw.qmc.timeindexB[5]:
                        Rtime.setBackgroundColor(QColor('orange'))
                        text = QApplication.translate("Table", "%1 SC END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i == aw.qmc.timeindexB[6]:
                        Rtime.setBackgroundColor(QColor('#f07800'))
                        text = QApplication.translate("Table", "%1 END",None, QApplication.UnicodeUTF8).arg(Rtime.text())
                        Rtime.setText(text)
                    elif i in aw.qmc.backgroundEvents:
                        Rtime.setBackgroundColor(QColor('yellow'))
                        index = aw.qmc.backgroundEvents.index(i)
                        text = QApplication.translate("Table", "%1 EVENT #%2 %3%4",None, QApplication.UnicodeUTF8).arg(Rtime.text()).arg(str(index+1)).arg(aw.qmc.Betypesf(aw.qmc.backgroundEtypes[index])[0]).arg(str(aw.qmc.backgroundEvalues[index]-1))
                        Rtime.setText(text)
                self.datatable.setItem(i,0,Atime)
                self.datatable.setItem(i,1,Rtime)
                self.datatable.setItem(i,2,ET)
                self.datatable.setItem(i,3,BT)
                self.datatable.setItem(i,4,deltaBT)
                self.datatable.setItem(i,5,deltaET)
            self.datatable.resizeColumnsToContents()

#############################################################################
################  Statistics DIALOG ########################
#############################################################################

class StatisticsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(StatisticsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Statistics",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.timez = QCheckBox(QApplication.translate("CheckBox","Time",None, QApplication.UnicodeUTF8))
        self.bar = QCheckBox(QApplication.translate("CheckBox","Bar",None, QApplication.UnicodeUTF8))
        self.ror = QCheckBox(QApplication.translate("CheckBox","d/m",None, QApplication.UnicodeUTF8))
        self.ts = QCheckBox(QApplication.translate("CheckBox","ETBTa",None, QApplication.UnicodeUTF8))
        self.flavor = QCheckBox(QApplication.translate("CheckBox","Evaluation",None, QApplication.UnicodeUTF8))
        self.area = QCheckBox(QApplication.translate("CheckBox","Characteristics",None, QApplication.UnicodeUTF8))
        self.mindryedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[0]))
        self.mindryedit.setAlignment(Qt.AlignRight)
        self.mindryedit.setMinimumWidth(60)
        self.mindryedit.setMaximumWidth(60)
        self.maxdryedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[1]))
        self.maxdryedit.setAlignment(Qt.AlignRight)
        self.maxdryedit.setMinimumWidth(60)
        self.maxdryedit.setMaximumWidth(60)
        self.minmidedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[2]))
        self.minmidedit.setAlignment(Qt.AlignRight)
        self.minmidedit.setMinimumWidth(60)
        self.minmidedit.setMaximumWidth(60)
        self.maxmidedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[3]))
        self.maxmidedit.setAlignment(Qt.AlignRight)
        self.maxmidedit.setMinimumWidth(60)
        self.maxmidedit.setMaximumWidth(60)
        self.minfinishedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[4]))
        self.minfinishedit.setAlignment(Qt.AlignRight)
        self.minfinishedit.setMinimumWidth(60)
        self.minfinishedit.setMaximumWidth(60)
        self.maxfinishedit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[5]))
        self.maxfinishedit.setAlignment(Qt.AlignRight)
        self.maxfinishedit.setMinimumWidth(60)
        self.maxfinishedit.setMaximumWidth(60)
        self.mincooledit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[6]))
        self.mincooledit.setAlignment(Qt.AlignRight)
        self.mincooledit.setMinimumWidth(60)
        self.mincooledit.setMaximumWidth(60)
        self.maxcooledit = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.statisticsconditions[7]))
        self.maxcooledit.setAlignment(Qt.AlignRight)
        self.maxcooledit.setMinimumWidth(60)
        self.maxcooledit.setMaximumWidth(60)
        self.mindryedit.setValidator(QRegExpValidator(regextime,self))
        self.maxdryedit.setValidator(QRegExpValidator(regextime,self))
        self.minmidedit.setValidator(QRegExpValidator(regextime,self))
        self.maxmidedit.setValidator(QRegExpValidator(regextime,self))
        self.minfinishedit.setValidator(QRegExpValidator(regextime,self))
        self.maxfinishedit.setValidator(QRegExpValidator(regextime,self))
        self.mincooledit.setValidator(QRegExpValidator(regextime,self))
        self.maxcooledit.setValidator(QRegExpValidator(regextime,self))
        drylabel =QLabel(QApplication.translate("Label", "Drying",None, QApplication.UnicodeUTF8))
        midlabel =QLabel(QApplication.translate("Label", "Maillard",None, QApplication.UnicodeUTF8))
        finishlabel =QLabel(QApplication.translate("Label", "Development",None, QApplication.UnicodeUTF8))
        coollabel =QLabel(QApplication.translate("Label", "Cooling",None, QApplication.UnicodeUTF8))
        minf = QLabel(QApplication.translate("Label", "min",None, QApplication.UnicodeUTF8))
        maxf = QLabel(QApplication.translate("Label", "max",None, QApplication.UnicodeUTF8))
        #temp fix for possible bug aw.qmc.statisticsflags=[] > empty list out of range
        if aw.qmc.statisticsflags:
            if aw.qmc.statisticsflags[0]:
                self.timez.setChecked(True)
            if aw.qmc.statisticsflags[1]:
                self.bar.setChecked(True)
            if aw.qmc.statisticsflags[2]:
                self.flavor.setChecked(True)
            if aw.qmc.statisticsflags[3]:
                self.area.setChecked(True)
            if aw.qmc.statisticsflags[4]:
                self.ror.setChecked(True)
            if aw.qmc.statisticsflags[5]:
                if aw.qmc.statisticsflags[4]:
                    self.ts.setChecked(False)
                else:
                    self.ts.setChecked(True)
        else:
            aw.qmc.statisticsflags = [1,1,0,1,1,0]
            self.timez.setChecked(True)
            self.bar.setChecked(True)
            self.flavor.setChecked(False)
            self.area.setChecked(True)
            self.ror.setChecked(True)
            self.ts.setChecked(False)
        self.connect(self.timez,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,0))
        self.connect(self.bar,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,1))
        self.connect(self.flavor,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,2))
        self.connect(self.area,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,3))
        self.connect(self.ror,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,4))
        self.connect(self.ts,SIGNAL("stateChanged(int)"),lambda x=0: self.changeStatisticsflag(x,5))
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        resetButton = QPushButton(QApplication.translate("Button","Defaults",None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(resetButton, SIGNAL("clicked()"),self.initialsettings)
        flagsLayout = QGridLayout()
        flagsLayout.addWidget(self.timez,0,0)
        flagsLayout.addWidget(self.bar,0,1)
        flagsLayout.addWidget(self.ror,0,2)
        flagsLayout.addWidget(self.ts,0,3)
        flagsLayout.addWidget(self.flavor,0,4)
        flagsLayout.addWidget(self.area,0,5)
        layout = QGridLayout()
        layout.addWidget(minf,0,1,Qt.AlignCenter)
        layout.addWidget(maxf,0,2,Qt.AlignCenter)
        layout.addWidget(drylabel,1,0,Qt.AlignRight)
        layout.addWidget(self.mindryedit,1,1)
        layout.addWidget(self.maxdryedit,1,2)
        layout.addWidget(midlabel,2,0,Qt.AlignRight)
        layout.addWidget(self.minmidedit,2,1)
        layout.addWidget(self.maxmidedit,2,2)
        layout.addWidget(finishlabel,3,0,Qt.AlignRight)
        layout.addWidget(self.minfinishedit,3,1)
        layout.addWidget(self.maxfinishedit,3,2)
        layout.addWidget(coollabel,4,0,Qt.AlignRight)
        layout.addWidget(self.mincooledit,4,1)
        layout.addWidget(self.maxcooledit,4,2)
        resetButton.setFocusPolicy(Qt.NoFocus)
        layoutHorizontal = QHBoxLayout()
        layoutHorizontal.addLayout(layout)        
        layoutHorizontal.addStretch()
        eventsGroupLayout = QGroupBox(QApplication.translate("GroupBox","Evaluation",None, QApplication.UnicodeUTF8))
        eventsGroupLayout.setLayout(layoutHorizontal)
        displayGroupLayout = QGroupBox(QApplication.translate("GroupBox","Display",None, QApplication.UnicodeUTF8))
        displayGroupLayout.setLayout(flagsLayout)
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(resetButton)
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(okButton)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(displayGroupLayout)
        mainLayout.addWidget(eventsGroupLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonsLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)

    def changeStatisticsflag(self,value,i):
        aw.qmc.statisticsflags[i] = value
        dep_changed = False
        if value:
            if i == 4 and aw.qmc.statisticsflags[5]:
                self.ts.setChecked(False)
                dep_changed = True
            elif i == 5 and aw.qmc.statisticsflags[4]:
                self.ror.setChecked(False)
                dep_changed = True
        if not dep_changed:
            aw.qmc.redraw(recomputeAllDeltas=False)

    def initialsettings(self):
        aw.qmc.statisticsconditions = [180,360,180,600,180,360]
        self.close()
        aw.showstatistics()

    def accept(self):
        mindry = aw.qmc.stringtoseconds(str(self.mindryedit.text()))
        maxdry = aw.qmc.stringtoseconds(str(self.maxdryedit.text()))
        minmid = aw.qmc.stringtoseconds(str(self.minmidedit.text()))
        maxmid = aw.qmc.stringtoseconds(str(self.maxmidedit.text()))
        minfinish = aw.qmc.stringtoseconds(str(self.minfinishedit.text()))
        maxfinish = aw.qmc.stringtoseconds(str(self.maxfinishedit.text()))
        mincool = aw.qmc.stringtoseconds(str(self.mincooledit.text()))
        maxcool = aw.qmc.stringtoseconds(str(self.maxcooledit.text()))
        if mindry != -1 and maxdry != -1 and minmid != -1 and maxmid != -1 and minfinish != -1 and maxfinish != -1 and mincool != -1 and maxcool != -1:
            aw.qmc.statisticsconditions[0] = mindry
            aw.qmc.statisticsconditions[1] = maxdry
            aw.qmc.statisticsconditions[2] = minmid
            aw.qmc.statisticsconditions[3] = maxmid
            aw.qmc.statisticsconditions[4] = minfinish
            aw.qmc.statisticsconditions[5] = maxfinish
            aw.qmc.statisticsconditions[6] = mincool
            aw.qmc.statisticsconditions[7] = maxcool
            if self.timez.isChecked(): 
                aw.qmc.statisticsflags[0] = 1
            else:
                aw.qmc.statisticsflags[0] = 0
                
            if self.bar.isChecked(): 
                aw.qmc.statisticsflags[1] = 1
            else:
                aw.qmc.statisticsflags[1] = 0
                
            if self.flavor.isChecked(): 
                aw.qmc.statisticsflags[2] = 1
            else:
                aw.qmc.statisticsflags[2] = 0
                
            if self.area.isChecked(): 
                aw.qmc.statisticsflags[3] = 1
            else:
                aw.qmc.statisticsflags[3] = 0
                
            if self.ror.isChecked(): 
                aw.qmc.statisticsflags[4] = 1
            else:
                aw.qmc.statisticsflags[4] = 0
                
            if self.ts.isChecked(): 
                aw.qmc.statisticsflags[5] = 1
            else:
                aw.qmc.statisticsflags[5] = 0
            aw.qmc.redraw(recomputeAllDeltas=False)
            self.close()

###########################################################################################
##################### MODBUS PORT #########################################################
###########################################################################################

# modbus_tk variant
#class modbusport(object):
#    """ this class handles the communications with all the modbus devices"""
#    
#    def __init__(self):
#        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
#        self.comport = "COM5"      #NOTE: this string should not be translated. 
#        self.baudrate = 115200
#        self.bytesize = 8
#        self.parity= 'N'
#        self.stopbits = 1
#        self.timeout=1.0
#        self.xonoff=0
#        self.master = None
#        
#    def isConnected(self):
#        return (self.master == None)
#        
#    def connect(self):
#        if self.master == None:
#            try:
#                ser = serial.Serial()
#                ser.setPort(self.comport)
#                ser.setBaudrate(self.baudrate)
#                ser.setByteSize(self.bytesize)
#                ser.setParity(self.parity)
#                ser.setStopbits(self.stopbits)
#                ser.setTimeout(self.timeout)
#                self.master = modbus_rtu.RtuMaster(ser)
#                self.master.set_timeout(1.0)
#                self.master.set_verbose(False)
#            except Exception as e:
#                aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(e))) 
#           
#    def writeSingleRegister(self,slave,register,value):
#        try:
#            self.connect()
#            resp = self.master.execute(int(slave),cst.WRITE_SINGLE_REGISTER,int(register),output_value=int(value))
#        except modbus_tk.modbus_rtu.ModbusInvalidResponseError as e:
#            self.master.close()
#        except Exception as e:
#            pass

class modbusport(object):
    """ this class handles the communications with all the modbus devices"""
    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "COM5"      #NOTE: this string should not be translated.
        self.baudrate = 115200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 1
        self.input1slave = 0
        self.input1register = 0
        self.input1float = False
        self.input1code = 3
        self.input2slave = 0
        self.input2register = 0
        self.input2float = False
        self.input2code = 3
        self.input3slave = 0
        self.input3register = 0
        self.input3float = False
        self.input3code = 3
        self.input4slave = 0
        self.input4register = 0
        self.input4float = False        
        self.input4code = 3
        self.littleEndianFloats = False
        self.xonoff=0
        self.master = None

    def isConnected(self):
        return (self.master == None)

    def connect(self):
        if self.master == None:
            try:
                # as in the following the port is None, no port is opened on creation of the (py)serial object
                self.master = minimalmodbus.Instrument(None, 1) # port, slaveaddress
                # configure serial port:
                self.master.serial.setPort(self.comport)
                self.master.serial.setBaudrate(self.baudrate)
                self.master.serial.setByteSize(self.bytesize)
                self.master.serial.setParity(self.parity)
                self.master.serial.setStopbits(self.stopbits)
                # timeout seems to delay sequential requests in minimalmodbus so keep the default for now
                #self.master.serial.setTimeout(self.timeout) 
                # configure Instrument:
                self.master.debug = False
                # open port
                if not self.master.close_port_after_each_call:
                    self.master.serial.open()
                    libtime.sleep(.5) # avoid possible hickups on startup
            except Exception as ex:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(ex)),exc_tb.tb_lineno)

    def writeSingleRegister(self,slave,register,value):
        try:
            self.connect()
            self.master.address = int(slave)
            self.master.write_register(int(register),int(value),0,6)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " writeSingleRegister() %1").arg(str(ex)),exc_tb.tb_lineno)

    def readFloat(self,slave,register,code=3):
        try:
            self.connect()
            self.master.address = int(slave)
            r = self.master.read_float(int(register),int(code),2)
            return r
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " readFloat() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("MODBUS readFloat :" + settings + " || Slave = " + str(slave) + " || Register = " + str(register) + " || Code = " + str(code) + " || Rx = " + str(r))

    def readSingleRegister(self,slave,register,code=3):
        try:
            self.connect()
            self.master.address = int(slave)
            r = self.master.read_register(int(register),0,int(code))
            return r
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Modbus Error:",None, QApplication.UnicodeUTF8) + " readSingleRegister() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("MODBUS readSingleRegister :" + settings + " || Slave = " + str(slave) + " || Register = " + str(register) + " || Code = " + str(code) + " || Rx = " + str(r))

class scaleport(object):
    """ this class handles the communications with the scale"""
    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 19200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 1
        self.devicefunctionlist = {
            "None" : None,
            "KERN NDE" : self.readKERN_NDE
        }
        self.device = None
        self.device_id = 0
        self.SP = None

    def isConnected(self):
        return (self.SP == None)

    def confport(self):
        self.SP.setPort(self.comport)
        self.SP.setBaudrate(self.baudrate)
        self.SP.setByteSize(self.bytesize)
        self.SP.setParity(self.parity)
        self.SP.setStopbits(self.stopbits)
        self.SP.setTimeout(self.timeout)

    def openport(self):
        try:
            #self.closeport()
            self.confport()
            #open port
            if not self.SP.isOpen():
                self.SP.open()
        except serial.SerialException:
            self.SP.close()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8)
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error + " Unable to open serial port",exc_tb.tb_lineno)

    def closeport(self):
        self.SP.close()

    def connect(self):
        if self.SP == None:
            try:
                self.SP = serial.Serial()
                self.openport()
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " connect() %1").arg(str(e)),exc_tb.tb_lineno)

    # returns weight as float in g or -1 if something went wrong
    def readWeight(self):
        if self.device != "None":
            return self.devicefunctionlist[self.device]()
        else:
            return -1

    def readKERN_NDE(self):
        try:
            self.connect()
            #self.SP.write(str2cmd('s')) # only stable
            self.SP.write(str2cmd('w')) # any weight
            v = self.SP.readline()
            sa = v.decode('ascii').split('g')
            if len(sa) == 2:
                return int(sa[0])
            else:
                return -1 
        except Exception:
            pass

###########################################################################################
##################### SERIAL PORT #########################################################
###########################################################################################

class serialport(object):
    """ this class handles the communications with all the devices"""

    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "COM4"      #NOTE: this string should not be translated. It is an argument for lib Pyserial
        self.baudrate = 9600
        self.bytesize = 8
        self.parity= 'O'
        self.stopbits = 1
        self.timeout=1
        #serial port for ET/BT
        self.SP = serial.Serial()
        #list of comm ports available after Scan
        self.commavailable = []
        ##### SPECIAL METER FLAGS ########
        #stores the id of the meter HH506RA as a string
        self.HH506RAid = "X"
        #select PID type that controls the roaster.
        # Reads/Controls ET
        self.controlETpid = [0,1]        # index0: type of pid: 0 = FujiPXG, 1 = FujiPXR3, 2 = DTA 
#                                        # index1: RS485 unitID: Can be changed in device menu.
        # Reads BT
        self.readBTpid = [1,2]           # index 0: type: FujiPXG, 1 = FujiPXR3, 2 = None, 3 = DTA 
#                                        # index 1: RS485 unitID. Can be changed in device menu. 
        #Initialization for ARDUINO and TC4 meter
        self.arduinoETChannel = "1"
        self.arduinoBTChannel = "2"
        self.arduinoATChannel = "None" # the channel the Ambient Temperature of the Arduino TC4 is reported as (this value will overwrite the corresponding real channel)
        self.ArduinoIsInitialized = 0
        self.HH806Winitflag = 0
        #list of functions calls to read temperature for devices.
        # device 0 (with index 0 bellow) is Fuji Pid
        # device 1 (with index 1 bellow) is Omega HH806
        # device 2 (with index 2 bellow) is omega HH506
        # etc
        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
        # - add to self.devicefunctionlist
        self.devicefunctionlist = [self.fujitemperature,    #0
                                   self.HH806AU,            #1
                                   self.HH506RA,            #2
                                   self.CENTER309,          #3
                                   self.CENTER306,          #4
                                   self.CENTER305,          #5
                                   self.CENTER304,          #6
                                   self.CENTER303,          #7
                                   self.CENTER302,          #8
                                   self.CENTER301,          #9
                                   self.CENTER300,          #10
                                   self.VOLTCRAFTK204,      #11
                                   self.VOLTCRAFTK202,      #12
                                   self.VOLTCRAFT300K,      #13
                                   self.VOLTCRAFT302KJ,     #14
                                   self.EXTECH421509,       #15
                                   self.HH802U,             #16
                                   self.HH309,              #17
                                   self.NONE,               #18
                                   self.ARDUINOTC4,         #19
                                   self.TEVA18B,            #20
                                   self.CENTER309_34,       #21
                                   self.fujidutycycle,      #22
                                   self.HHM28,              #23
                                   self.K204_34,            #24
                                   self.virtual,            #25
                                   self.DTAtemperature,     #26
                                   self.callprogram,        #27
                                   self.ARDUINOTC4_34,      #28
                                   self.MODBUS,             #29
                                   self.VOLTCRAFTK201,      #30
                                   self.AmprobeTMD56,       #31
                                   self.ARDUINOTC4_56,      #32
                                   self.MODBUS_34,          #33
                                   self.HH806W              #34
                                   ]
        #used only in devices that also control the roaster like PIDs or arduino (possible to recieve asynchrous comands from GUI commands and thread sample()). 
        self.COMsemaphore = QSemaphore(1)
        #string with the name of the program for device #27
        self.externalprogram = "test.py"

#####################  FUNCTIONS  ############################
    ######### functions used by Fuji PIDs
    def sendFUJIcommand(self,binstring,nbytes):
        try:
            ###  lock resources ##
            self.COMsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(binstring)
                r = self.SP.read(nbytes)
                ###  release resources  ###
                self.COMsemaphore.release(1)
                #serTX.close()
                libtime.sleep(0.035)                     #this garantees a minimum of 35 miliseconds between readings (for all Fujis)
                lenstring = len(r)
                if lenstring:
                    # CHECK FOR RECEIVED ERROR CODES
                    if ord(r[1]) == 128:
                        if ord(r[2]) == 1:
                            errorcode = QApplication.translate("Error Message","F80h Error",None, QApplication.UnicodeUTF8) + " 1: A nonexistent function code was specified. Please check the function code."
                            errorcode += QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " SendFUJIcommand() 1: Illegal Function in unit %1".arg(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                        if ord(r[2]) == 2:
                            errorcode = QApplication.translate("Error Message","F80h Error",None, QApplication.UnicodeUTF8) + " 2: Faulty address for coil or resistor: The specified relative address for the coil number or resistor\n number cannot be used by the specified function code."
                            errorcode += QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " SendFUJIcommand() 2 Illegal Address for unit %1".arg(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                        if ord(r[2]) == 3:
                            errorcode = QApplication.translate("Error Message","F80h Error",None, QApplication.UnicodeUTF8) + " 3: Faulty coil or resistor number: The specified number is too large and specifies a range that does not contain\n coil numbers or resistor numbers."
                            errorcode += QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " SendFUJIcommand() 3 Illegal Data Value for unit %1".arg(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                    else:
                        #Check crc16
                        crcRx =  hex2int(r[-1],r[-2])
                        crcCal1 = aw.fujipid.fujiCrc16(r[:-2]) 
                        if crcCal1 == crcRx:
                            return r           #OK. Return r after it has been checked for errors
                        else:
                            aw.qmc.adderror(QApplication.translate("Error Message","CRC16 data corruption ERROR. TX does not match RX. Check wiring",None, QApplication.UnicodeUTF8))
                            return "0"
                else:
                    if self.COMsemaphore.available() < 1:
                        self.COMsemaphore.release(1)
                    aw.qmc.adderror(QApplication.translate("Error Message","No RX data received",None, QApplication.UnicodeUTF8))
                    return "0"
            else:
                return "0"
        except serial.SerialException:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendFUJIcommand()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return "0"
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("Fuji :" + settings + " || Tx = " + cmd2str(binascii.hexlify(binstring)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    #finds time, ET and BT when using Fuji PID. Updates sv (set value) LCD. Finds power duty cycle
    def fujitemperature(self):
        #update ET SV LCD 6
        aw.qmc.currentpidsv = aw.fujipid.readcurrentsv()
        # get the temperature for ET. aw.fujipid.gettemperature(unitID)
        t1 = aw.fujipid.gettemperature(self.controlETpid[1])/10.  #Need to divide by 10 beacuse using 1 decimal point in Fuji (ie. received 843 = 84.3)
        #get time of temperature reading in seconds from start; .elapsed() returns miliseconds
        tx = aw.qmc.timeclock.elapsed()/1000.
        #if Fuji for BT is not None (0= PXG, 1 = PXR, 2 = None 3 = DTA)
        if self.readBTpid[0] < 2:                    
            t2 = aw.fujipid.gettemperature(self.readBTpid[1])/10.
        elif self.readBTpid[0] == 3:
            ### arguments to create command to READ TEMPERATURE
            unitID = self.readBTpid[1]
            function = 3
            address = aw.dtapid.dtamem["pv"][1]  #index 1; ascii string
            ndata = 1
            ### create command
            command = aw.dtapid.message2send(unitID,function,address,ndata)
            t2 = self.sendDTAcommand(command)
        else:
            t2 = 0.
        #get current duty cycle and update LCD 7
        aw.qmc.dutycycle = aw.fujipid.readdutycycle()
        aw.qmc.dutycycleTX = aw.qmc.timeclock.elapsed()/1000.
        if t2:
            aw.qmc.fujiETBT = t1-t2
        else:
            aw.qmc.fujiETBT = 0.
        return tx,t1,t2

    #especial function that collects extra duty cycle % and ET minus BT while keeping compatibility
    def fujidutycycle(self):
        #return saved readings from device 0
        return aw.qmc.dutycycleTX, aw.qmc.dutycycle, aw.qmc.fujiETBT

    def DTAtemperature(self):
        ###########################################################
        ### create command
        command = aw.dtapid.message2send(self.controlETpid[1],3,aw.dtapid.dtamem["sv"][1],1)
        #read sv
        aw.qmc.currentpidsv = self.sendDTAcommand(command)
        #update SV value 
        aw.dtapid.dtamem["sv"][0] = aw.qmc.currentpidsv    #index 0
        #sv LCD is updated in qmc.updadegraphics()
        #give some time to rest
        libtime.sleep(.1)
        ##############################################################
        ### create command
        command = aw.dtapid.message2send(self.controlETpid[1],3,aw.dtapid.dtamem["pv"][1],1)
        #read
        t1 = self.sendDTAcommand(command)
        tx = aw.qmc.timeclock.elapsed()/1000.
        #if Fuji for BT is not None (0= PXG, 1 = PXR, 2 = None 3 = DTA)
        if self.readBTpid[0] < 2:                    
            t2 = aw.fujipid.gettemperature(self.readBTpid[1])/10.
        elif self.readBTpid[0] == 3:
            ### create command
            command = aw.dtapid.message2send(self.readBTpid[1],3,aw.dtapid.dtamem["pv"][1],1)
            t2 = self.sendDTAcommand(command)
        else:
            t2 = aw.qmc.currentpidsv  #return 
        ################################################################
        return tx,t1,t2

    def sendDTAcommand(self,command):
        try:
            ###  lock resources ##
            self.COMsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                nrxbytes = 15
                #clear
                self.SP.flushInput()
                self.SP.flushOutput()
                #SEND (tx)
                self.SP.write(str2cmd(command))
                #READ n bytes(rx)
                r = self.SP.read(nrxbytes).decode('utf-8')
                ###  release resources  ###
                self.COMsemaphore.release(1) 
##                command = ":010347000001B4"
##                r =       ":01030401900067"
                if len(r) == nrxbytes:
                    #READ and WRITE commands are different
                    #READ command
                    if command[4] == "3":
                        #CRCreceived = int(r[13:15],16)  #bytes 14&15
                        #CRCcalculated = aw.dtapid.DTACalcChecksum(r[1:11]) #bytes 1-10
                        #if CRCreceived == CRCcalculated:
                        t1 = float(int(r[7:11], 16))*0.1    #convert ascii string from bytes 8-11 (4 bytes) to a float
                        return t1
##                        else:
##                            aw.qmc.adderror(QApplication.translate("Error Message","DTAtemperature(): Data corruption. Check wiring",None, QApplication.UnicodeUTF8))            
##                            if len(aw.qmc.timex) > 2:
##                                return aw.qmc.temp1[-1]
##                            else:
##                                return 0.
                    #WRITE COMMAND. Under Test
##                    if command[4] == "4":
##                        #received  data is equal to sent command
##                        if r == command:
##                            aw.sendmessage("Write operation OK")
##                            return 1
##                        else:
##                            aw.sendmessage("Write operation BAD")
##                            return 0
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","DTAcommand(): %1 bytes received but 15 needed",None, QApplication.UnicodeUTF8).arg(nbytes))            
                    if len(aw.qmc.timex) > 2:
                        return aw.qmc.temp1[-1]
                    else:
                        return -1.
        except serial.SerialException:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendDTAcommand()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds            
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("DElta DTA:" + settings + " || Tx = " + cmd2str(command) + " || Rx = " + str(r))

    def callprogram(self):
        try:
            output = os.popen(self.externalprogram,"r").readline()
            tx = aw.qmc.timeclock.elapsed()/1000.
            if "," in output:
                parts = output.split(",")
                return tx,float(parts[0]),float(parts[1])
            else:
                return tx,0.,float(output)
        except Exception as e:
            tx = aw.qmc.timeclock.elapsed()/1000.
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " callprogram(): %1 ").arg(str(e)),exc_tb.tb_lineno)
            return tx,0.,0.

    def virtual(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        return tx,1.,1.

    def HH506RA(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH506RAtemperature()
        return tx,t2,t1

    def HH806AU(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1

    def AmprobeTMD56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1 

    def HH806W(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806Wtemperature()
        return tx,t2,t1

    def MODBUS(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.MODBUSread()
        return tx,t2,t1

    def MODBUS_34(self):
        return aw.qmc.extraMODBUStx,aw.qmc.extraMODBUSt4,aw.qmc.extraMODBUSt3

    def HH802U(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1

    def HH309(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    def CENTER309(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    #especial function that collects extra T3 and T4 from center 309 while keeping compatibility
    def CENTER309_34(self):
        #return saved readings collected at self.CENTER309temperature()
        return aw.qmc.extra309TX,aw.qmc.extra309T4,aw.qmc.extra309T3

    def CENTER306(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def CENTER305(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def CENTER304(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    def CENTER303(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def CENTER302(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def CENTER301(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def CENTER300(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFTK204(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    #especial function that collects extra T3 and T4 from Vol K204 while keeping compatibility
    def K204_34(self):
        #return saved readings collected at self.CENTER309temperature()
        return aw.qmc.extra309TX,aw.qmc.extra309T4,aw.qmc.extra309T3

    def VOLTCRAFTK201(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFTK202(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def VOLTCRAFT300K(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFT302KJ(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def EXTECH421509(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH506RAtemperature()
        return tx,t2,t1

    def NONE(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.NONEtmp()
        return tx,t2,t1

    def ARDUINOTC4(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.ARDUINOTC4temperature()
        return tx,t2,t1

    def ARDUINOTC4_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT1
        t2 = aw.qmc.extraArduinoT2
        return tx,t2,t1

    def ARDUINOTC4_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT3
        t2 = aw.qmc.extraArduinoT4
        return tx,t2,t1

    def TEVA18B(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.TEVA18Btemperature()
        return tx,t2,t1

    #multimeter
    def HHM28(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        val,symbols= self.HHM28multimeter()  #NOTE: val and symbols are type strings
        #temporary fix to display the output
        aw.sendmessage(val + symbols)
        if "L" in val:  #L = Out of Range
            return tx, 0., 0.
##        else:
##            #read quantifier symbols
##            if "n" in symbols:
##                val /= 1000000000.
##            elif "u" in symbols:
##                val /= 1000000.
##            elif "m" in symbols:
##                val /= 1000.
##            elif "k" in symbols:
##                val *= 1000.
##            elif "M" in symbols:
##                val *= 1000000.
            ### not finished
        else:
            return tx, 0., float(val)   #send a 0. as second reading because the meter only returns one reading

############################################################################
    def openport(self):
        try:
            self.confport()
            self.ArduinoIsInitialized = 0  # Assume the Arduino has to be reinitialized
            #open port
            if not self.SP.isOpen():
                self.SP.open()
                libtime.sleep(.5) # avoid possible hickups on startup
        except serial.SerialException:
            self.SP.close()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + QApplication.translate("Error Message","Unable to open serial port",None, QApplication.UnicodeUTF8)
            aw.qmc.adderror(error)

    #loads configuration to ports
    def confport(self):
        self.SP.setPort(self.comport)
        self.SP.setBaudrate(self.baudrate)
        self.SP.setByteSize(self.bytesize)
        self.SP.setParity(self.parity)
        self.SP.setStopbits(self.stopbits)
        self.SP.setTimeout(self.timeout)

    def closeport(self):
        self.SP.close()

    def closeEvent(self,_):
        try:
            self.closeport() 
        except serial.SerialException:
            pass

    def binary(self, n, digits=8):
        return "{0:0>{1}}".format(bin(n)[2:], digits)

    #t2 and t1 from Omega HH806 or HH802 meter 
    def HH806AUtemperature(self):
        #init command = "#0A0000RA6\r\n"
        try:
            command = str2cmd("#0A0000NA2\r\n")  #"#0A0101NA4\r\n"
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                r = self.SP.read(16)
                if len(r) == 16:
                    #convert to binary to hex string
                    s1 = hex2int(r[5],r[6])/10.
                    s2 = hex2int(r[10],r[11])/10.
                    #we convert the strings to integers. Divide by 10.0 (decimal position)
                    return s1,s2
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH806AUtemperature(): %1 bytes received but 14 needed",None, QApplication.UnicodeUTF8).arg(nbytes))
                    return -1,-1                                    #return something out of scope to avoid function error (expects two values)
            else:
                return -1,-1
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806AUtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806AUtemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def HH806Winit(self):
        try:
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(str2cmd("#0A0000RA6\r\n"))
                libtime.sleep(.3)
                self.SP.write(str2cmd("#0A0000RA6\r\n"))
                libtime.sleep(.3)
                self.SP.write(str2cmd("\x21\x05\x00\x58\x7E"))
                libtime.sleep(2.)
                self.HH806Winitflag = 1
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Winit()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Winit() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                command = "#0A0000RA6\r\n #0A0000RA6\r\n \x21\x05\x00\x58\x7E"
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806Winit :" + settings + " || Tx = " + command + " || Rx = ")

    #UNDER WORK 806 wireless meter
    def HH806Wtemperature(self):
        if self.HH806Winitflag == 0:
            self.HH806Winit()
            if self.HH806Winitflag == 0:
                aw.qmc.adderror(QApplication.translate("Error Message","HH806Wtemperature(): Unable to initiate device",None, QApplication.UnicodeUTF8))
                return -1,-1
        try:
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                for _ in range(27):
                    rcode = self.SP.read(1)
                    #locate first byte
                    if rcode == "\x3d":
                        r = self.SP.read(25)
                        if len(r) == 25:
                            r1 = hex2int(r[11],r[12])/10.
                            r2 = hex2int(r[19],r[20])/10.
                            #GOOD
                            return r1,r2
                #BAD
                return -1.,-1.
        except serial.SerialException:
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Wtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH806Wtemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806Wtemperature: " + settings + " || Rx = " + binascii.hexlify(r))

    #returns v1,v2 from a connected MODBUS device
    def MODBUSread(self):
        # slave, register
        if aw.modbus.input1slave:
            if aw.modbus.input1float:
                res1 = aw.modbus.readFloat(aw.modbus.input1slave,aw.modbus.input1register,aw.modbus.input1code)
            else:
                res1 = aw.modbus.readSingleRegister(aw.modbus.input1slave,aw.modbus.input1register,aw.modbus.input1code)
            if res1 is None:
                res1 = -1
        else:
            res1 = -1
        if aw.modbus.input2slave:
            if aw.modbus.input2float:
                res2 = aw.modbus.readFloat(aw.modbus.input2slave,aw.modbus.input2register,aw.modbus.input2code)
            else:
                res2 = aw.modbus.readSingleRegister(aw.modbus.input2slave,aw.modbus.input2register,aw.modbus.input2code)
            if res2 is None:
                res2 = -1
        else:
            res2 = -1
        if aw.modbus.input3slave:
            if aw.modbus.input3float:
                res3 = aw.modbus.readFloat(aw.modbus.input3slave,aw.modbus.input3register,aw.modbus.input3code)
            else:
                res3 = aw.modbus.readSingleRegister(aw.modbus.input3slave,aw.modbus.input3register,aw.modbus.input3code)
            if res3 is None:
                res3 = -1
        else:
            res3 = -1
        if aw.modbus.input4slave:
            if aw.modbus.input4float:
                res4 = aw.modbus.readFloat(aw.modbus.input4slave,aw.modbus.input4register,aw.modbus.input4code)
            else:
                res4 = aw.modbus.readSingleRegister(aw.modbus.input4slave,aw.modbus.input4register,aw.modbus.input4code)
            if res4 is None:
                res4 = -1
        else:
            res4 = -1
        aw.qmc.extraMODBUSt3 = res3
        aw.qmc.extraMODBUSt4 = res4
        aw.qmc.extraMODBUStx = aw.qmc.timeclock.elapsed()/1000.
        return res2, res1

    def NONEtmp(self):
        dialogx = nonedevDlg()
        if dialogx.exec_():
            ET = int(str(dialogx.etEdit.text()))
            BT = int(str(dialogx.btEdit.text()))
            aw.lcd2.display(ET)
            aw.lcd3.display(BT)
            return ET, BT
        else:
            return -1, -1

    #reads once the id of the HH506RA meter and stores it in the serial variable self.HH506RAid. Marko Luther.
    def HH506RAGetID(self):
        try:
            ID = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                sync = None
                while sync != b"Err\r\n":
                    self.SP.write(b"\r\n")
                    sync = self.SP.read(5)
                    libtime.sleep(1)
                self.SP.write(b"%000R")
                ID = self.SP.read(5)
                if len(ID) == 5:
                    self.HH506RAid = ID[0:3]               # Assign new id to self.HH506RAid
                else:
                    nbytes = len(ID)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH506RAGetID: %1 bytes received but 5 needed",None, QApplication.UnicodeUTF8).arg(nbytes))
        except serial.SerialException:
            self.closeport()
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAGetID()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAGetID() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H506 :" + settings + " || Rx = " + str(ID))

    #HH506RA Device
    #returns t1,t2 from Omega HH506 meter. By Marko Luther
    def HH506RAtemperature(self):
        #if initial id "X" has not changed then get a new one;
        if self.HH506RAid == "X":
            self.HH506RAGetID()                       # obtain new id one time; self.HH506RAid should not be "X" any more
            if self.HH506RAid == "X":                 # if self.HH506RAGetID() went wrong and self.HH506RAid is still "X"
                aw.qmc.adderror(QApplication.translate("Error Message","HH506RAtemperature(): Unable to get id from HH506RA device ",None, QApplication.UnicodeUTF8))
                return -1,-1
        try:
            command = b"#" + self.HH506RAid + b"N\r\n"
            r = ""
            
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                r = self.SP.read(14)
                if len(r) == 14:
                    #we convert the hex strings to integers. Divide by 10.0 (decimal position)
                    r = r.replace(' ','0')
                    return int(r[1:5],16)/10., int(r[7:11],16)/10.
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH506RAtemperature(): %1 bytes received but 14 needed",None, QApplication.UnicodeUTF8).arg(nbytes))               
                    return -1,-1
            else:
                return -1,-1
        except serial.SerialException:
            self.closeport()
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAtemperature()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HH506RAtemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H506 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def CENTER302temperature(self):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                r = self.SP.read(7)                                   #NOTE: different
                if len(r) == 7:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(o(r[2]))              #bit"[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    return T1,0
                else:
                    nbytes = len(r)
                    error = QApplication.translate("Error Message","CENTER302temperature(): %1 bytes received but 7 needed",None, QApplication.UnicodeUTF8).arg(nbytes)
                    timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                    return -1,-1 
            else:
                return -1,-1 
        except serial.SerialException:
            self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER302temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER302temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER302 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER303temperature(self):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                r = self.SP.read(8) #NOTE: different to CENTER306
                if len(r) == 8:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #if bit 5 of byte 3 = 1 then T2 = ####
                    #if bit 5 of byte 3 = 0 then T2 = ###.#
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(o(r[2]))              #bit"[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    bit5 = b3bin[2]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #extract T2
                    B56 = cmd2str(binascii.hexlify(r[5:7])) # select byte 5 and 6; NOTE: different to CENTER303
                    if B56[0].isdigit():
                        T2 = float(B56)
                    else:
                        T2 = float(B56[1:])                    
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    if bit5 == "0":
                        T2 /= 10.
                    return T1,T2
                else:
                    nbytes = len(r)
                    error = QApplication.translate("Error Message","CENTER303temperature(): %1 bytes received but 8 needed",None, QApplication.UnicodeUTF8).arg(nbytes)
                    timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                    return -1,-1 
            else:
                return -1,-1 
        except serial.SerialException:
            self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER303temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER303temperature() %1").arg(str(ex)),exc_tb.tb_lineno)            
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER303 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER306temperature(self):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                r = self.SP.read(10) #NOTE: different to CENTER303
                if len(r) == 10:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #if bit 5 of byte 3 = 1 then T2 = ####
                    #if bit 5 of byte 3 = 0 then T2 = ###.#
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(o(r[2]))          #bits string order "[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    bit5 = b3bin[2]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #extract T2
                    B78 = cmd2str(binascii.hexlify(r[7:9])) # select byte 7 and 9; NOTE: different to CENTER303
                    if B78[0].isdigit():
                        T2 = float(B78)
                    else:
                        T2 = float(B78[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    if bit5 == "0":
                        T2 /= 10.
                    return T1,T2
                else:
                    nbytes = len(r)
                    error = QApplication.translate("Error Message","CENTER306temperature(): %1 bytes received but 10 needed",None, QApplication.UnicodeUTF8).arg(nbytes)
                    timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                    return -1,-1
            else:
                return -1,-1
        except serial.SerialException:
            self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER306temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER306temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER306 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER309temperature(self):
        ##    command = "\x4B" returns 4 bytes . Model number.
        ##    command = "\x48" simulates HOLD button
        ##    command = "\x4D" simulates MAX/MIN button
        ##    command = "\x4E" simulates EXIT MAX/MIN button
        ##    command = "\x52" simulates TIME button
        ##    command = "\x43" simulates C/F button
        ##    command = "\x55" dump all memmory
        ##    command = "\x50" Load recorded data
        ##    command = "\x41" returns 45 bytes (8x5 + 5 = 45) as follows:
        ##    
        ##    "\x02\x80\xUU\xUU\xUU\xUU\xUU\xAA"  \x80 means "Celsi" (if \x00 then "Faren") UUs unknown
        ##    "\xAA\xBB\xBB\xCC\xCC\xDD\xDD\x00"  Temprerature T1 = AAAA, T2=BBBB, T3= CCCC, T4 = DDDD
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown (possible data containers but found empty)
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown
        ##    "\x00\x00\x00\x0E\x03"              The byte r[43] \x0E changes depending on what thermocouple(s) are connected.
        ##                                        If T1 thermocouple connected alone, then r[43]  = \x0E = 14
        ##                                        If T2 thermocouple connected alone, then r[43]  = \x0D = 13
        ##                                        If T1 + T2 thermocouples connected, then r[43]  = \x0C = 12
        ##                                        If T3 thermocouple connected alone, then r[43]  = \x0B = 11
        ##                                        If T4 thermocouple connected alone, then r[43]  = \x07 = 7
        ##                                        Note: Print r[43] if you want to find other connect-combinations
        ##                                        THIS ONLY WORKS WHEN TEMPERATURE < 200. If T >= 200 r[43] changes
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
                self.SP.write(command)
                r = self.SP.read(45)
                if len(r) == 45:
                    T1 = T2 = T3 = T3 = -1
                    try:
                        T1 = hex2int(r[7],r[8])/10.
                    except Exception:
                        pass
                    try:
                        T2 = hex2int(r[9],r[10])/10.
                    except Exception:
                        pass
                    try:
                        T3 = hex2int(r[11],r[12])/10.
                    except Exception:
                        pass
                    try:
                        T4 = hex2int(r[13],r[14])/10.
                    except Exception:
                        pass
                    #save these variables if using T3 and T4
                    aw.qmc.extra309T3 = T3
                    aw.qmc.extra309T4 = T4
                    aw.qmc.extra309TX = aw.qmc.timeclock.elapsed()/1000.
                    return T1,T2
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","CENTER309temperature(): %1 bytes received but 45 needed",None, QApplication.UnicodeUTF8).arg(nbytes))            
                    return -1,-1 
            else:
                return -1,-1
        except serial.SerialException:
            self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " CENTER309temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " CENTER309temperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER309 :" + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def ARDUINOTC4temperature(self):
        try:
            command = ""
            res = ""
            result = ""
            t1,t2 = 0.,0.
            if not self.SP.isOpen():
                self.openport()
                libtime.sleep(3)
                #Reinitialize Arduino in case communication was interupted
                self.ArduinoIsInitialized = 0
            if self.SP.isOpen():
                #INITIALIZE (ONLY ONCE)
                if not self.ArduinoIsInitialized:
                    self.SP.flushInput()
                    self.SP.flushOutput()
                    #build initialization command 
                    et_channel = self.arduinoETChannel
                    if et_channel == "None":
                        et_channel = "0"
                    bt_channel = self.arduinoBTChannel
                    if bt_channel == "None":
                        bt_channel = "0"
                    #If extra device +ArduinoTC4_XX present. read all 4 Ts
                    if 28 in aw.qmc.extradevices: # +ArduinoTC4_34
                        vals = ["1","2","3","4"]
                        vals.pop(vals.index(self.arduinoETChannel))
                        vals.pop(vals.index(self.arduinoBTChannel))
                        command = "CHAN;" + et_channel + bt_channel + vals[0] + vals[1]
                    else:
                    #no extra device +ArduinoTC4_XX present. reads ambient T, ET, BT
                        command = "CHAN;" + et_channel + bt_channel + "0000"
                    if aw.qmc.arduino56active: # +ArduinoTC4_56
                        if 32 in aw.qmc.extradevices:
                            command += "11"
                        else:
                            command += "00"
                    self.SP.write(str2cmd(command + "\n"))       #send command
                    result = self.SP.readline().decode('utf-8')[:-2]  #read
                    if (not len(result) == 0 and not result.startswith("#")):
                        raise Exception(QApplication.translate("Error Message","Arduino could not set channels",None, QApplication.UnicodeUTF8))
                    elif result.startswith("#"):
                        #OK. NOW SET UNITS
                        self.SP.flushInput()
                        self.SP.flushOutput()
                        command = "UNIT;" + aw.qmc.mode + "\n"   #Set units
                        self.SP.write(str2cmd(command))
                        result = self.SP.readline().decode('utf-8')[:-2]
                        if (not len(result) == 0 and not result.startswith("#")):
                            raise Exception(QApplication.translate("Error Message","Arduino could not set temperature unit",None, QApplication.UnicodeUTF8))
                        else:
                            ### EVERYTHING OK  ###
                            self.ArduinoIsInitialized = 1
                #READ TEMPERATURE
                self.SP.flushInput()
                self.SP.flushOutput()
                command = "READ\n"  #Read command.
                self.SP.write(str2cmd(command))
                rl = self.SP.readline().decode('utf-8')[:-2]
                res = rl.rsplit(',')  #response: list ["t0","t1","t2"] with t0 = internal temp; t1 = ET; t2 = BT
                if self.arduinoETChannel == "None":
                    t1 = -1
                else:
                    t1 = float(res[1])
                if self.arduinoBTChannel == "None":
                    t2 = -1
                else:
                    t2 = float(res[2])
                #if extra device +ArduinoTC4_XX
                if 28 in aw.qmc.extradevices:
                    #set the other values to extra temp variables
                    aw.qmc.extraArduinoT1 = float(res[3])
                    aw.qmc.extraArduinoT2 = float(res[4])
                if 32 in aw.qmc.extradevices: # +ArduinoTC4_56
                    if aw.qmc.arduino56active:
                        try:
                            aw.qmc.extraArduinoT3 = float(res[5])
                            aw.qmc.extraArduinoT4 = float(res[6])
                        except:
                            pass
                    else:
                        aw.qmc.extraArduinoT3 = aw.qmc.extraArduinoT4 = -1
                # overwrite temps by AT internal Ambient Temperature
                if aw.ser.arduinoATChannel != "None":
                    if aw.ser.arduinoATChannel == "T1":
                        t1 = float(res[0])
                    elif aw.ser.arduinoATChannel == "T2":
                        t2 = float(res[0])
                    elif 28 in aw.qmc.extradevices and aw.ser.arduinoATChannel == "T3":
                        aw.qmc.extraArduinoT1 = float(res[0])
                    elif 28 in aw.qmc.extradevices and aw.ser.arduinoATChannel == "T4":
                        aw.qmc.extraArduinoT2 = float(res[0])
                    elif 32 in aw.qmc.extradevices and aw.ser.arduinoATChannel == "T5":
                        aw.qmc.extraArduinoT3 = float(res[0])
                    elif 32 in aw.qmc.extradevices and aw.ser.arduinoATChannel == "T6":
                        aw.qmc.extraArduinoT4 = float(res[0])
                return t1, t2
        except serial.SerialException as e:
            self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.ARDUINOTC4temperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1.,-1.
        except Exception as e:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " ser.ARDUINOTC4temperature(): %1").arg(str(e)),exc_tb.tb_lineno)
            return -1.,-1.
        finally:
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("ArduinoTC4 :" + settings + " || Tx = " + str(command) + " || Rx = " + str(res) + "|| Ts= %.1f, %.1f, %.1f, %.1f"%(t1,t2,aw.qmc.extraArduinoT1,aw.qmc.extraArduinoT2))

    def TEVA18Bconvert(self, seg):
        if seg == 0x7D:
            return 0
        elif seg == 0x05:
            return 1
        elif seg == 0x5B:
            return 2
        elif seg == 0x1F:
            return 3
        elif seg == 0x27:
            return 4
        elif seg == 0x3E:
            return 5
        elif seg == 0x7E:
            return 6
        elif seg == 0x15:
            return 7
        elif seg == 0x7F:
            return 8
        elif seg == 0x3F:
            return 9
        else:
            return -1

    def TEVA18Btemperature(self):
        try:
            r = ""
            run = 1
            counter = 0
            while(run):
                
                #MaWa
                #really interesting:
                #need this sleep. without artisan hungs after 20 to 40 seconds.
                #seems like iam running the loop forever, forever .... with sleep it is ok
                #seen this sometimes in communication between threads in C or C++. --> volatile problem?
                if counter > 0:
                    libtime.sleep(1)
                counter = counter + 1
                if not self.SP.isOpen():
                    self.openport()    
                    libtime.sleep(2)
                if self.SP.isOpen():
                    self.SP.flushInput()
                    r = self.SP.read(14)
                    if len(r) != 14:
                        continue
#                    s200 = binascii.hexlify(r[0])
                    s201 = binascii.hexlify(r[1])
                    s202 = binascii.hexlify(r[2])
                    s203 = binascii.hexlify(r[3])
                    s204 = binascii.hexlify(r[4])
                    s205 = binascii.hexlify(r[5])
                    s206 = binascii.hexlify(r[6])
                    s207 = binascii.hexlify(r[7])
                    s208 = binascii.hexlify(r[8])
    #                s209 = binascii.hexlify(r[9])
    #                s210 = binascii.hexlify(r[10])
    #                s211 = binascii.hexlify(r[11])
    #                s212 = binascii.hexlify(r[12])
                    s213 = binascii.hexlify(r[13])
#                   t200 = int(s200,16)
                    t201 = int(s201,16)
                    t202 = int(s202,16)
                    t203 = int(s203,16)
                    t204 = int(s204,16)
                    t205 = int(s205,16)
                    t206 = int(s206,16)
                    t207 = int(s207,16)
                    t208 = int(s208,16)
    #                t209 = int(s209,16)
    #                t210 = int(s210,16)
    #                t211 = int(s211,16)
    #                t212 = int(s212,16)
                    t213 = int(s213,16)
                    # is meter in temp mode?
                    # first check byte order
                    if(((t213 & 0xf0) >> 4) != 14):
                        #ERROR try again .....
                        continue
                    elif(((t213 & 0x0f) & 0x02) != 2):
                        #ERROR
                        # device seems not to be in temp mode, break here
                        raise ValueError
                    # convert
                    bNegative = 0
                    iDivisor = 0
                    # first lets check the byte order
                    # seg1 bytes
                    if (((t201 & 0xf0) >> 4) == 2) and (((t202 & 0xf0) >> 4) == 3):
                        seg1 = ((t201 & 0x0f) << 4) + (t202 & 0x0f)
                    else:
                        continue
                    # seg2 bytes
                    if (((t203 & 0xf0) >> 4) == 4) and (((t204 & 0xf0) >> 4) == 5):
                        seg2 = ((t203 & 0x0f) << 4) + (t204 & 0x0f)
                    else:
                        continue
                    # seg3 bytes
                    if (((t205 & 0xf0) >> 4) == 6) and (((t206 & 0xf0) >> 4) == 7):
                        seg3 = ((t205 & 0x0f) << 4) + (t206 & 0x0f)
                    else:
                        continue
                    # seg4 bytes
                    if (((t207 & 0xf0) >> 4) == 8) and (((t208 & 0xf0) >> 4) == 9):
                        seg4 = ((t207 & 0x0f) << 4) + (t208 & 0x0f)
                    else:
                        continue
                    # is negative?
                    if (seg1 & 0x80):
                        bNegative = 1
                        seg1 = seg1 & ~0x80
                    # check divisor
                    if (seg2 & 0x80):
                        iDivisor = 1000.
                        seg2 = seg2 & ~0x80
                    elif (seg3 & 0x80):
                        iDivisor = 100.
                        seg3 = seg3 & ~0x80
                    elif (seg4 & 0x80):
                        iDivisor = 10.
                        seg4 = seg4 & ~0x80
                    iValue = 0
                    fReturn = 0
                    i = self.TEVA18Bconvert(seg1)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = i * 1000
                    i = self.TEVA18Bconvert(seg2)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + (i * 100)
                    i = self.TEVA18Bconvert(seg3)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + (i * 10)
                    i = self.TEVA18Bconvert(seg4)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + i
                    # what about the divisor?
                    if (iDivisor > 0):
                        fReturn = iValue / iDivisor
                    # is value negative?
                    if (fReturn):
                        if (bNegative):
                            fReturn = fReturn * (-1)
                    #ok seems we got valid value
                    # break loop here
                    run = 0
            #Since the meter reads only one temperature, send 0 as ET and fReturn as BT
            if fReturn:
                return 0.,fReturn    #  **** RETURN T HERE  ******
            else:
                raise ValueError
        except ValueError:
            self.closeport()
            error = QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " ser.TEVA18Btemperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1 
        except serial.SerialException:
            self.closeport()
            error = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.TEVA18Btemperature()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1 
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.TEVA18Btemperature() %1").arg(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("TEVA18B :" + settings + " || Tx = " + "No command" + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def HHM28multimeter(self):
        # This meter sends a continuos frame byte by byte. It only transmits data. It does not receive commands.
        # A frame is composed of 14 ordered bytes. A byte is represented bellow enclosed in "XX"
        # FRAME  = ["1A","2B","3C","4D","5E","6F","7G","8H","9I","10J","11K","12L","13M","14N"]
        # The first 4 bits of each byte are dedicated to identify the byte in the frame by using a number.
        # The last 4 bits of each byte are dedicated to carry Data. Depending on the byte number, the meaning of data changes.
        # Bytes 2,3,4,5,6,7,8,9 carry data bits that represent actual segments of the four LCD numbers of the meter display.
        # Bytes 1,10,11,12,13 carry data bits that represent other symbols like F (for Farad), u (for micro), M (for Mega), etc, of the meter display
        try:
            r, r2 = "",""
            frame = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.flushInput()
                self.SP.flushOutput()
            #keep reading till the first byte of next frame (till we read an actual 1 in 1A )
            for i in range(28):  #any number > 14 will be OK
                r = self.SP.read(1)
                if r:
                    fb = (ord(r[0]) & 0xf0) >> 4
                    if fb == 1:
                        r2 = self.SP.read(13)   #read the remaining 13 bytes to get 14 bytes
                        break
                else:
                    raise ValueError(str("No Data received"))
##                if (ord(r[0]) & 0xf0) >> 4 == 1:
##                    r2 = self.SP.read(13)   #read the remaining 13 bytes to get 14 bytes
##                    break
            frame = r + r2
            #check bytes
            for i in range(14):
                number = fb = (ord(frame[i]) & 0xf0) >> 4
                if number != i+1:
                    #find device index
                    raise ValueError(str("Data corruption"))
            if len(frame) == 14:
                #extract data from frame in to a list containing the hex string values of the data
                data = []
                for i in range(14):
                    data.append(hex((ord(frame[i]) & 0x0f))[2:])
                #The four LCD digits are BC + DE + FG + HI   
                digits = [data[1]+data[2],data[3]+data[4],data[5]+data[6],data[7]+data[8]]
                #find sign 
                sign = ""   # +
                if (int(digits[0],16) & 0x80) >> 7:
                    sign = "-"
                #find location of decimal point
                for i in range(4):
                    if (int(digits[i],16) & 0x80) >> 7:
                        dec = i
                        digits[i] = hex(int(digits[i],16) & 0x7f)[2:]  #remove decimal point
                        if len(digits[i]) < 2:
                            digits[i] = "0" + digits[i]
                #find value from table
                table = {"00":" ","68":"L","7d":"0","05":"1","5b":"2","1f":"3",
                         "27":"4","3e":"5","7e":"6","15":"7","7f":"8","3f":"9"} 
                val = ""
                #some erros found in values: "38","5d",0A,etc
                for i in range(4):
                    if digits[i] in table:
                        val += table[digits[i]]
                    else:
                        raise ValueError(str("Data corruption"))
                number = ".".join((val[:dec],val[dec:]))  #add the decimal point
                #find symbols
                tablesymbols = [
                                ["AC","","",""],    #["AC","","Auto","RS232"]
                                ["u","n","k","diode"],
                                ["m","%","M","Beep"],
                                ["F","Ohm","Relative","Hold"],
                                ["A","V","Hz","Low Batt"]
                                ]
                masks = [0x08,0x04,0x02,0x01]
                nbytes = [0,9,10,11,12]
                symbols = ""
                for p in range(5):
                    for i in range(4):
                        if (int(data[nbytes[p]],16) & masks[i]):
                            symbols += " " + tablesymbols[p][i]
                return (sign + number), symbols
            else:
                raise ValueError(str("Needed 14 bytes but only received %i"%(len(frame))))
        except ValueError:
            self.closeport()
            error  = QApplication.translate("Error Message","Value Error:",None, QApplication.UnicodeUTF8) + " ser.HHM28multimeter()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            #find device index
            if aw.qmc.device == 23:
                if len(aw.qmc.temp1):
                    return str(aw.qmc.temp1[-1]),str(aw.qmc.temp2[-1])
                else:
                    return "0","0"
            else:
                index = aw.qmc.extradevices.index(23)
                if len(aw.qmc.extratemp1[i]):
                    return str(aw.qmc.extratemp1[index][-1]),str(aw.qmc.temp2[index][-1])
                else:
                    return "0","0"
        except serial.SerialException:
            self.closeport()
            error  = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.HHM28multimeter()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return "0",""
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.HHM28multimeter() %1").arg(str(ex)),exc_tb.tb_lineno)
            return "0"""
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("HHM28multimeter :" + settings + " || Tx = " + "No command" + " || Rx = " + str(frame))

    #sends a command to the ET/BT device. (used by eventaction to send serial command to e.g. Arduino)
    def sendTXcommand(self,command):
        try:
            if not self.SP.isOpen():
                self.openport()
                libtime.sleep(3)
                #Reinitialize Arduino in case communication was interrupted
                if aw.qmc.device == 19:
                    self.ArduinoIsInitialized = 0
            if self.SP.isOpen():
                if (aw.qmc.device == 19 and not command.endswith("\n")):
                    command += "\n"
                self.SP.write(str2cmd(command))
        except serial.SerialException:
            self.closeport()
            error  = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXcommand()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXcommand() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("Arduinocommand :" + settings + " || Tx = " + command + " || Rx = " + "No answer needed")

    #Example function
    #NOT USED YET, maybe FUTURE Arduino?
    #sends a command to the ET/BT device and receives data of length nbytes 
    def sendTXRXcommand(self,command,nbytes):
        try:
            self.SP.write(str2cmd(command))
            r = self.SP.read(nbytes)
            if len(r) == nbytes:
                return r
            else:
                return "ERR"
        except serial.SerialException:
            self.closeport()
            error  = QApplication.translate("Error Message","Serial Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXRXcommand()"
            timez = str(QDateTime.currentDateTime().toString(QString("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " ser.sendTXRXcommand() %1").arg(str(ex)),exc_tb.tb_lineno)
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("FutureArduinocommand :" + settings + " || Tx = " + command + " || Rx = " + "No answer needed")

#########################################################################
#############  DESIGNER CONFIG DIALOG ###################################
#########################################################################

class designerconfigDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(designerconfigDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Designer Config",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        #landmarks
        charge = QLabel(QApplication.translate("Label", "CHARGE",None, QApplication.UnicodeUTF8))
        charge.setAlignment(Qt.AlignRight)
        charge.setStyleSheet("background-color: #f07800")
        self.dryend = QCheckBox(QApplication.translate("CheckBox","DRY END",None, QApplication.UnicodeUTF8))
        self.dryend.setStyleSheet("background-color: orange")
        self.fcs = QCheckBox(QApplication.translate("CheckBox","FC START",None, QApplication.UnicodeUTF8))
        self.fcs.setStyleSheet("background-color: orange")
        self.fce = QCheckBox(QApplication.translate("CheckBox","FC END",None, QApplication.UnicodeUTF8))
        self.fce.setStyleSheet("background-color: orange")
        self.scs = QCheckBox(QApplication.translate("CheckBox","SC START",None, QApplication.UnicodeUTF8))
        self.scs.setStyleSheet("background-color: orange")
        self.sce = QCheckBox(QApplication.translate("CheckBox","SC END",None, QApplication.UnicodeUTF8))
        self.sce.setStyleSheet("background-color: orange")
        drop = QLabel(QApplication.translate("Label", "DROP",None, QApplication.UnicodeUTF8))
        drop.setAlignment(Qt.AlignRight)
        drop.setStyleSheet("background-color: #f07800")
        self.loadconfigflags()
        self.connect(self.dryend, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,1))
        self.connect(self.fcs, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,2))
        self.connect(self.fce, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,3))
        self.connect(self.scs, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,4))
        self.connect(self.sce, SIGNAL("clicked()"),lambda x=0: self.changeflags(x,5))
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        markersettinglabel = QLabel(QApplication.translate("Label", "Marker",None, QApplication.UnicodeUTF8))
        markersettinglabel.setAlignment(Qt.AlignCenter)
        timesettinglabel = QLabel(QApplication.translate("Label", "Time",None, QApplication.UnicodeUTF8))
        timesettinglabel.setAlignment(Qt.AlignCenter)
        btsettinglabel = QLabel(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8))
        btsettinglabel.setAlignment(Qt.AlignCenter)
        etsettinglabel = QLabel(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8))
        etsettinglabel.setAlignment(Qt.AlignCenter)
        self.Edit0 = QLineEdit(aw.qmc.stringfromseconds(0))
        self.Edit0.setEnabled(False)
        self.Edit0bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[0]])
        self.Edit0et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[0]])
        self.Edit0.setAlignment(Qt.AlignRight)
        self.Edit0bt.setAlignment(Qt.AlignRight)
        self.Edit0et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[1]:
            self.Edit1 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[1]] - start))
            self.Edit1bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[1]])
            self.Edit1et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[1]])
        else:
            self.Edit1 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit1bt = QLineEdit("0.0")
            self.Edit1et = QLineEdit("0.0")
        self.Edit1.setAlignment(Qt.AlignRight)
        self.Edit1bt.setAlignment(Qt.AlignRight)
        self.Edit1et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[2]:
            self.Edit2 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[2]] - start))
            self.Edit2bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[2]])
            self.Edit2et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[2]])
        else:
            self.Edit2 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit2bt = QLineEdit("0.0")
            self.Edit2et = QLineEdit("0.0")
        self.Edit2.setAlignment(Qt.AlignRight)
        self.Edit2bt.setAlignment(Qt.AlignRight)
        self.Edit2et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[3]:
            self.Edit3 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[3]] - start))
            self.Edit3bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[3]])
            self.Edit3et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[3]])
        else:
            self.Edit3 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit3bt = QLineEdit("0.0")
            self.Edit3et = QLineEdit("0.0")
        self.Edit3.setAlignment(Qt.AlignRight)
        self.Edit3bt.setAlignment(Qt.AlignRight)
        self.Edit3et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[4]:
            self.Edit4 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[4]] - start))
            self.Edit4bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[4]])
            self.Edit4et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[4]])
        else:
            self.Edit4 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit4bt = QLineEdit("0.0")
            self.Edit4et = QLineEdit("0.0")
        self.Edit4.setAlignment(Qt.AlignRight)
        self.Edit4bt.setAlignment(Qt.AlignRight)
        self.Edit4et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[5]:
            self.Edit5 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[5]] - start))
            self.Edit5bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[5]])
            self.Edit5et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[5]])
        else:
            self.Edit5 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit5bt = QLineEdit("0.0")
            self.Edit5et = QLineEdit("0.0")
        self.Edit5.setAlignment(Qt.AlignRight)
        self.Edit5bt.setAlignment(Qt.AlignRight)
        self.Edit5et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[6]:
            self.Edit6 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[6]] - start))
            self.Edit6bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[6]])
            self.Edit6et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[6]])
        else:
            self.Edit6 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit6bt = QLineEdit("0.0")
            self.Edit6et = QLineEdit("0.0")
        self.Edit6.setAlignment(Qt.AlignRight)
        self.Edit6bt.setAlignment(Qt.AlignRight)
        self.Edit6et.setAlignment(Qt.AlignRight)
        self.Edit0.setMaximumWidth(50)
        self.Edit1.setMaximumWidth(50)
        self.Edit2.setMaximumWidth(50)
        self.Edit3.setMaximumWidth(50)
        self.Edit4.setMaximumWidth(50)
        self.Edit5.setMaximumWidth(50)
        self.Edit6.setMaximumWidth(50)
        self.Edit0bt.setMaximumWidth(50)
        self.Edit1bt.setMaximumWidth(50)
        self.Edit2bt.setMaximumWidth(50)
        self.Edit3bt.setMaximumWidth(50)
        self.Edit4bt.setMaximumWidth(50)
        self.Edit5bt.setMaximumWidth(50)
        self.Edit6bt.setMaximumWidth(50)
        self.Edit0et.setMaximumWidth(50)
        self.Edit1et.setMaximumWidth(50)
        self.Edit2et.setMaximumWidth(50)
        self.Edit3et.setMaximumWidth(50)
        self.Edit4et.setMaximumWidth(50)
        self.Edit5et.setMaximumWidth(50)
        self.Edit6et.setMaximumWidth(50)
        self.Edit1copy = self.Edit1.text()
        self.Edit2copy = self.Edit2.text()
        self.Edit3copy = self.Edit3.text()
        self.Edit4copy = self.Edit4.text()
        self.Edit5copy = self.Edit5.text()
        self.Edit6copy = self.Edit6.text()
        self.Edit0btcopy = self.Edit0bt.text()
        self.Edit1btcopy = self.Edit1bt.text()
        self.Edit2btcopy = self.Edit2bt.text()
        self.Edit3btcopy = self.Edit3bt.text()
        self.Edit4btcopy = self.Edit4bt.text()
        self.Edit5btcopy = self.Edit5bt.text()
        self.Edit6btcopy = self.Edit6bt.text()
        self.Edit0etcopy = self.Edit0et.text()
        self.Edit1etcopy = self.Edit1et.text()
        self.Edit2etcopy = self.Edit2et.text()
        self.Edit3etcopy = self.Edit3et.text()
        self.Edit4etcopy = self.Edit4et.text()
        self.Edit5etcopy = self.Edit5et.text()
        self.Edit6etcopy = self.Edit6et.text()
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.Edit0.setValidator(QRegExpValidator(regextime,self))
        self.Edit1.setValidator(QRegExpValidator(regextime,self))
        self.Edit2.setValidator(QRegExpValidator(regextime,self))
        self.Edit3.setValidator(QRegExpValidator(regextime,self))
        self.Edit4.setValidator(QRegExpValidator(regextime,self))
        self.Edit5.setValidator(QRegExpValidator(regextime,self))
        self.Edit6.setValidator(QRegExpValidator(regextime,self))
        self.Edit0bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit0bt))
        self.Edit1bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit1bt))
        self.Edit2bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit2bt))
        self.Edit3bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit3bt))
        self.Edit4bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit4bt))
        self.Edit5bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit5bt))
        self.Edit6bt.setValidator(QDoubleValidator(0., 999., 1, self.Edit6bt))
        self.Edit0et.setValidator(QDoubleValidator(0., 999., 1, self.Edit0et))
        self.Edit1et.setValidator(QDoubleValidator(0., 999., 1, self.Edit1et))
        self.Edit2et.setValidator(QDoubleValidator(0., 999., 1, self.Edit2et))
        self.Edit3et.setValidator(QDoubleValidator(0., 999., 1, self.Edit3et))
        self.Edit4et.setValidator(QDoubleValidator(0., 999., 1, self.Edit4et))
        self.Edit5et.setValidator(QDoubleValidator(0., 999., 1, self.Edit5et))
        self.Edit6et.setValidator(QDoubleValidator(0., 999., 1, self.Edit6et))
        curvinesslabel = QLabel(QApplication.translate("Label", "Curviness",None, QApplication.UnicodeUTF8))
        etcurviness = QLabel(QApplication.translate("Label", "ET",None, QApplication.UnicodeUTF8))
        btcurviness = QLabel(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8))
        etcurviness.setAlignment(Qt.AlignRight)
        btcurviness.setAlignment(Qt.AlignRight)
        self.ETsplineComboBox = QComboBox()
        self.ETsplineComboBox.addItems(["1","2","3","4","5"])
        self.ETsplineComboBox.setCurrentIndex(aw.qmc.ETsplinedegree - 1)
        self.connect(self.ETsplineComboBox,SIGNAL("currentIndexChanged(int)"), self.redrawcurviness)
        self.BTsplineComboBox = QComboBox()
        self.BTsplineComboBox.addItems(["1","2","3","4","5"])
        self.BTsplineComboBox.setCurrentIndex(aw.qmc.BTsplinedegree - 1)
        self.connect(self.BTsplineComboBox,SIGNAL("currentIndexChanged(int)"), self.redrawcurviness)
        reproducelabel = QLabel(QApplication.translate("Label", "Events Playback",None, QApplication.UnicodeUTF8))
        self.reproduceComboBox = QComboBox()
        self.reproduceComboBox.addItems(["",
                                         QApplication.translate("ComboBox","DeltaBT",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","DeltaET",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","SV Commands",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("ComboBox","Ramp Commands",None, QApplication.UnicodeUTF8)])
        self.reproduceComboBox.setCurrentIndex(aw.qmc.reproducedesigner)
        self.connect(self.reproduceComboBox,SIGNAL("currentIndexChanged(int)"), self.changereproducemode)
        updateButton = QPushButton(QApplication.translate("Button","Update",None, QApplication.UnicodeUTF8))
        updateButton.setFocusPolicy(Qt.NoFocus)
        self.connect(updateButton, SIGNAL("clicked()"), self.settimes)
        updateButton.setMinimumWidth(100)
        defaultButton = QPushButton(QApplication.translate("Button","Reset",None, QApplication.UnicodeUTF8))
        defaultButton.setFocusPolicy(Qt.NoFocus)
        defaultButton.setMinimumWidth(100)
        self.connect(defaultButton, SIGNAL("clicked()"), self.reset)
        closeButton = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        closeButton.setFocusPolicy(Qt.NoFocus)
        self.connect(closeButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        convertButton = QPushButton(QApplication.translate("Button","Create",None, QApplication.UnicodeUTF8))
        self.connect(convertButton, SIGNAL("clicked()"),self.create)
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(closeButton)
        buttonLayout.addWidget(convertButton)
        marksLayout = QGridLayout()
        marksLayout.addWidget(markersettinglabel,0,0)
        marksLayout.addWidget(timesettinglabel,0,1)
        marksLayout.addWidget(btsettinglabel,0,2)
        marksLayout.addWidget(etsettinglabel,0,3)
        marksLayout.addWidget(charge,1,0)
        marksLayout.addWidget(self.Edit0,1,1)
        marksLayout.addWidget(self.Edit0bt,1,2)
        marksLayout.addWidget(self.Edit0et,1,3)
        marksLayout.addWidget(self.dryend,2,0)
        marksLayout.addWidget(self.Edit1,2,1)
        marksLayout.addWidget(self.Edit1bt,2,2)
        marksLayout.addWidget(self.Edit1et,2,3)
        marksLayout.addWidget(self.fcs,3,0)
        marksLayout.addWidget(self.Edit2,3,1)
        marksLayout.addWidget(self.Edit2bt,3,2)
        marksLayout.addWidget(self.Edit2et,3,3)
        marksLayout.addWidget(self.fce,4,0)
        marksLayout.addWidget(self.Edit3,4,1)
        marksLayout.addWidget(self.Edit3bt,4,2)
        marksLayout.addWidget(self.Edit3et,4,3)
        marksLayout.addWidget(self.scs,5,0)
        marksLayout.addWidget(self.Edit4,5,1)
        marksLayout.addWidget(self.Edit4bt,5,2)
        marksLayout.addWidget(self.Edit4et,5,3)
        marksLayout.addWidget(self.sce,6,0)
        marksLayout.addWidget(self.Edit5,6,1)
        marksLayout.addWidget(self.Edit5bt,6,2)
        marksLayout.addWidget(self.Edit5et,6,3)
        marksLayout.addWidget(drop,7,0)
        marksLayout.addWidget(self.Edit6,7,1)
        marksLayout.addWidget(self.Edit6bt,7,2)
        marksLayout.addWidget(self.Edit6et,7,3)
        updateLayout = QHBoxLayout()
        updateLayout.addWidget(defaultButton)
        updateLayout.addWidget(updateButton)
        settingsLayout = QVBoxLayout()
        settingsLayout.addLayout(marksLayout)
        settingsLayout.addLayout(updateLayout)
        curvinessLayout = QHBoxLayout()
        curvinessLayout.addWidget(curvinesslabel)
        curvinessLayout.addWidget(etcurviness)
        curvinessLayout.addWidget(self.ETsplineComboBox)
        curvinessLayout.addWidget(btcurviness)
        curvinessLayout.addWidget(self.BTsplineComboBox)
        reproduceLayout = QHBoxLayout()
        reproduceLayout.addWidget(reproducelabel)
        reproduceLayout.addWidget(self.reproduceComboBox)
        modLayout = QVBoxLayout()
        modLayout.addLayout(curvinessLayout)
        modLayout.addLayout(reproduceLayout)
        marksGroupLayout = QGroupBox(QApplication.translate("GroupBox","Initial Settings",None, QApplication.UnicodeUTF8))
        marksGroupLayout.setLayout(settingsLayout)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(marksGroupLayout)
        mainLayout.addLayout(modLayout)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def changereproducemode(self):
        aw.qmc.reproducedesigner = self.reproduceComboBox.currentIndex()

    def redrawcurviness(self):
        ETcurviness = int(str(self.ETsplineComboBox.currentText()))
        BTcurviness = int(str(self.BTsplineComboBox.currentText()))
        timepoints = len(aw.qmc.timex)
        if (timepoints - ETcurviness) >= 1:
            aw.qmc.ETsplinedegree = ETcurviness
        else:
            aw.qmc.ETsplinedegree = len(aw.qmc.timex)-1
            self.ETsplineComboBox.setCurrentIndex(aw.qmc.ETsplinedegree-1)
            ms = QApplication.translate("Message","Not enough time points for an ET curviness of %1. Set curviness to %2",None, QApplication.UnicodeUTF8).arg(ETcurviness).arg(aw.qmc.ETsplinedegree)
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),ms)
        if (timepoints - BTcurviness) >= 1:
            aw.qmc.BTsplinedegree = BTcurviness
        else:
            aw.qmc.BTsplinedegree = len(aw.qmc.timex)-1
            self.BTsplineComboBox.setCurrentIndex(aw.qmc.BTsplinedegree-1)
            ms = QApplication.translate("Message","Not enough time points for an BT curviness of %1. Set curviness to %2",None, QApplication.UnicodeUTF8).arg(BTcurviness).arg(aw.qmc.BTsplinedegree)
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),ms)
        aw.qmc.redrawdesigner()

    def settimes(self):
        #check input
        strings = [QApplication.translate("Message","CHARGE",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","DRY END",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","FC START",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","FC END",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","SC START",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","SC END",None, QApplication.UnicodeUTF8),
                   QApplication.translate("Message","DROP",None, QApplication.UnicodeUTF8)]
        timecheck = self.validatetime()
        if timecheck != 1000:
            st = QApplication.translate("Message","Incorrect time format. Please recheck %1 time",None, QApplication.UnicodeUTF8).arg(strings[timecheck])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),st)            
            return 1
        checkvalue = self.validatetimeorder()
        if checkvalue != 1000:
            st = QApplication.translate("Message","Times need to be in ascending order. Please recheck %1 time",None, QApplication.UnicodeUTF8).arg(strings[checkvalue+1])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),st)            
            return 1
        if self.Edit0bt.text() != self.Edit0btcopy:
            aw.qmc.temp2[aw.qmc.timeindex[0]] = float(str(self.Edit0bt.text()))
        if self.Edit0et.text() != self.Edit0etcopy:
            aw.qmc.temp1[aw.qmc.timeindex[0]] = float(str(self.Edit0et.text()))
        if self.dryend.isChecked():
            if self.Edit1.text() != self.Edit1copy:
                if aw.qmc.stringtoseconds(str(self.Edit1.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit1.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[1]] = timez
            if self.Edit1bt.text() != self.Edit1btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[1]] = float(str(self.Edit1bt.text()))
            if self.Edit1et.text() != self.Edit1etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[1]] = float(str(self.Edit1et.text()))
        if self.fcs.isChecked():
            if self.Edit2.text() != self.Edit2copy:
                if aw.qmc.stringtoseconds(str(self.Edit2.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit2.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[2]] = timez
            if self.Edit2bt.text() != self.Edit2btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[2]] = float(str(self.Edit2bt.text()))
            if self.Edit2et.text() != self.Edit2etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[2]] = float(str(self.Edit2et.text()))
        if self.fce.isChecked():
            if self.Edit3.text() != self.Edit3copy:
                if aw.qmc.stringtoseconds(str(self.Edit3.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit3.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[3]] = timez
            if self.Edit3bt.text() != self.Edit3btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[3]] = float(str(self.Edit3bt.text()))
            if self.Edit3et.text() != self.Edit3etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[3]] = float(str(self.Edit3et.text()))
        if self.scs.isChecked():
            if self.Edit4.text() != self.Edit4copy:
                if aw.qmc.stringtoseconds(str(self.Edit4.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit4.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[4]] = timez
            if self.Edit4bt.text() != self.Edit4btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[4]] = float(str(self.Edit4bt.text()))
            if self.Edit4et.text() != self.Edit4etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[4]] = float(str(self.Edit4et.text()))
        if self.sce.isChecked():
            if self.Edit5.text() != self.Edit5copy:
                if aw.qmc.stringtoseconds(str(self.Edit5.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit5.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[5]] = timez
            if self.Edit5bt.text() != self.Edit5btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[5]] = float(str(self.Edit5bt.text()))
            if self.Edit5et.text() != self.Edit5etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[5]] = float(str(self.Edit5et.text()))
        if self.Edit6.text() != self.Edit6copy:
            if aw.qmc.stringtoseconds(str(self.Edit6.text())):
                timez = aw.qmc.stringtoseconds(str(self.Edit6.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                aw.qmc.timex[aw.qmc.timeindex[6]] = timez
        if self.Edit6bt.text() != self.Edit6btcopy:
            aw.qmc.temp2[aw.qmc.timeindex[6]] = float(str(self.Edit6bt.text()))
        if self.Edit6et.text() != self.Edit6etcopy:
            aw.qmc.temp1[aw.qmc.timeindex[6]] = float(str(self.Edit6et.text()))
        for i in range(1,6): #1-5
            aw.qmc.designertimeinit[i] = aw.qmc.timex[aw.qmc.timeindex[i]]
        aw.qmc.xaxistosm()
        aw.qmc.redrawdesigner()
        return 0

    #supporting function for settimes()
    def validatetimeorder(self):
        time = []
        checks = self.readchecks()
        time.append(aw.qmc.stringtoseconds(str(self.Edit0.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit1.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit2.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit3.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit4.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit5.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit6.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        for i in range(len(time)-1):
            if time[i+1] <= time[i] and checks[i+1] != 0:
                return i
        return 1000

    def validatetime(self):
        strings = []
        strings.append(self.Edit0.text())
        strings.append(self.Edit1.text())
        strings.append(self.Edit2.text())
        strings.append(self.Edit3.text())
        strings.append(self.Edit4.text())
        strings.append(self.Edit5.text())
        strings.append(self.Edit6.text())
        for i in range(len(strings)):
            if len(str(strings[i])) < 5:
                return i
        else:
            return 1000

    #supporting function for settimes()
    def readchecks(self):
        checks = [0,0,0,0,0,0,0]
        if self.dryend.isChecked(): 
            checks[1] = 1
        if self.fcs.isChecked():
            checks[2] = 1
        if self.fce.isChecked():
            checks[3] = 1
        if self.scs.isChecked():
            checks[4] = 1
        if self.sce.isChecked():
            checks[5] = 1
        return checks

    def create(self):
        self.close()
        aw.qmc.convert_designer()

    #reset
    def reset(self):
        self.dryend.setChecked(True)
        self.fcs.setChecked(True)
        self.fce.setChecked(True)
        self.scs.setChecked(True)
        self.sce.setChecked(True)
        #reset designer
        aw.qmc.reset_designer()
        #update editboxes
        self.Edit0.setText(aw.qmc.stringfromseconds(0))
        self.Edit1.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[1]))
        self.Edit2.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[2]))
        self.Edit3.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[3]))
        self.Edit4.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[4]))
        self.Edit5.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[5]))
        self.Edit6.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[6]))
        self.Edit0bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[0]])
        self.Edit1bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[1]])
        self.Edit2bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[2]])
        self.Edit3bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[3]])
        self.Edit4bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[4]])
        self.Edit5bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[5]])
        self.Edit6bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[6]])
        self.Edit0et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[0]])
        self.Edit1et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[1]])
        self.Edit2et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[2]])
        self.Edit3et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[3]])
        self.Edit4et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[4]])
        self.Edit5et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[5]])
        self.Edit6et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[6]])
        aw.sendmessage(QApplication.translate("Message","Designer has been reset",None, QApplication.UnicodeUTF8))

    def loadconfigflags(self):
        self.dryend.setChecked(aw.qmc.timeindex[1])
        self.fcs.setChecked(aw.qmc.timeindex[2])
        self.fce.setChecked(aw.qmc.timeindex[3])
        self.scs.setChecked(aw.qmc.timeindex[4])
        self.sce.setChecked(aw.qmc.timeindex[5])

    #adds deletes landmarks
    def changeflags(self,_,idi):
        if self.validatetimeorder() != 1000:
            if idi == 1:
                if self.dryend.isChecked():
                    self.dryend.setChecked(False)
            elif idi == 2:
                if self.fcs.isChecked():
                    self.fcs.setChecked(False)
            elif idi == 3:
                if self.fce.isChecked():
                    self.fes.setChecked(False)
            elif idi == 4:
                if self.scs.isChecked():
                    self.scs.setChecked(False)
            elif idi == 5:
                if self.sce.isChecked():
                    self.sce.setChecked(False)
            #ERROR time from edit boxes is not in ascending order
            strings = [QApplication.translate("Message","CHARGE",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","DRY END",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","FC START",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","FC END",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","SC START",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","SC END",None, QApplication.UnicodeUTF8),
                       QApplication.translate("Message","DROP",None, QApplication.UnicodeUTF8)]
            st = QApplication.translate("Message","Times need to be in ascending order. Please recheck %1 time",None, QApplication.UnicodeUTF8).arg(strings[idi])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None, QApplication.UnicodeUTF8),st)
            return
        #idi = id index
        if aw.qmc.timeindex[idi]:
            #ERASE mark point
            aw.qmc.currentx = aw.qmc.timex[aw.qmc.timeindex[idi]]
            aw.qmc.currenty = aw.qmc.temp2[aw.qmc.timeindex[idi]]
            aw.qmc.removepoint()
        else:
            #ADD mark point
            if idi == 1:
                timez = aw.qmc.stringtoseconds(str(self.Edit1.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit1bt.text()))
                et = float(str(self.Edit1et.text()))
            if idi == 2:
                timez = aw.qmc.stringtoseconds(str(self.Edit2.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit2bt.text()))
                et = float(str(self.Edit2et.text()))
            if idi == 3:
                timez = aw.qmc.stringtoseconds(str(self.Edit3.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit3bt.text()))
                et = float(str(self.Edit3et.text()))
            if idi == 4:
                timez = aw.qmc.stringtoseconds(str(self.Edit4.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit4bt.text()))
                et = float(str(self.Edit4et.text()))
            if idi == 5:
                timez = aw.qmc.stringtoseconds(str(self.Edit5.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit5bt.text()))
                et = float(str(self.Edit5et.text()))
            aw.qmc.currentx = timez 
            aw.qmc.currenty = bt
            newindex = aw.qmc.addpoint()
            aw.qmc.timeindex[idi] = newindex
            aw.qmc.temp2[aw.qmc.timeindex[idi]] = bt
            aw.qmc.temp1[aw.qmc.timeindex[idi]] = et
            aw.qmc.xaxistosm()
            aw.qmc.redrawdesigner()

#########################################################################
#############  NONE DEVICE DIALOG #######################################
#########################################################################

#inputs temperature
class nonedevDlg(QDialog):
    def __init__(self, parent = None):
        super(nonedevDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Manual Temperature Logger",None, QApplication.UnicodeUTF8))
        if len(aw.qmc.timex):
            if aw.qmc.manuallogETflag:
                etval = str(int(aw.qmc.temp1[-1]))
            else:
                etval = "0"
            btval = str(int(aw.qmc.temp2[-1])) 
        else:
            etval = "0"
            btval = "0"
        self.etEdit = QLineEdit(etval)
        btlabel = QLabel(QApplication.translate("Label", "BT",None, QApplication.UnicodeUTF8))
        self.btEdit = QLineEdit(btval)
        self.etEdit.setValidator(QIntValidator(0, 1000, self.etEdit))
        self.btEdit.setValidator(QIntValidator(0, 1000, self.btEdit))
        self.ETbox = QCheckBox(QApplication.translate("CheckBox","ET",None, QApplication.UnicodeUTF8))
        if aw.qmc.manuallogETflag == True:
            self.ETbox.setChecked(True)
        else:
            self.ETbox.setChecked(False)
            self.etEdit.setVisible(False)
        self.connect(self.ETbox,SIGNAL("stateChanged(int)"),self.changemanuallogETflag)
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        grid = QGridLayout()
        grid.addWidget(self.ETbox,0,0)
        grid.addWidget(self.etEdit,0,1)
        grid.addWidget(btlabel,1,0)
        grid.addWidget(self.btEdit,1,1)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(grid)
        mainLayout.addStretch()  
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    def changemanuallogETflag(self):
        if self.ETbox.isChecked():
            aw.qmc.manuallogETflag = 1
            self.etEdit.setVisible(True)
        else:
            aw.qmc.manuallogETflag = 0
            self.etEdit.setVisible(False)

#########################################################################
#############  SERIAL PORT CONFIGURATION DIALOG #########################
#########################################################################

class comportDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(comportDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Serial Ports Configuration",None, QApplication.UnicodeUTF8))
        self.setModal(True)
        xports = self.portlist()
        ##########################    TAB 1 WIDGETS
        comportlabel =QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.comportEdit = QComboBox()
        self.comportEdit.addItems(xports)
        self.comportEdit.setCurrentIndex(xports.index(aw.ser.comport))
        self.comportEdit.setEditable(True)
        comportlabel.setBuddy(self.comportEdit)
        baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.baudrateComboBox = QComboBox()
        baudratelabel.setBuddy(self.baudrateComboBox)
        self.bauds = ["2400","9600","19200","38400","57600","115200"]
        self.baudrateComboBox.addItems(self.bauds)
        self.baudrateComboBox.setCurrentIndex(self.bauds.index(str(aw.ser.baudrate)))
        bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.bytesizeComboBox = QComboBox()
        bytesizelabel.setBuddy(self.bytesizeComboBox)
        self.bytesizes = ["7","8"]
        self.bytesizeComboBox.addItems(self.bytesizes)
        self.bytesizeComboBox.setCurrentIndex(self.bytesizes.index(str(aw.ser.bytesize)))
        paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.parityComboBox = QComboBox()
        paritylabel.setBuddy(self.parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.parity = ["O","E","N"]
        self.parityComboBox.addItems(self.parity)
        self.parityComboBox.setCurrentIndex(self.parity.index(aw.ser.parity))
        stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.stopbitsComboBox = QComboBox()
        stopbitslabel.setBuddy(self.stopbitsComboBox)
        self.stopbits = ["0","1","2"]
        self.stopbitsComboBox.addItems(self.stopbits)
        self.stopbitsComboBox.setCurrentIndex(aw.ser.stopbits)
        timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.timeoutEdit = QLineEdit(str(aw.ser.timeout))
        self.timeoutEdit.setValidator(QIntValidator(0,5,self.timeoutEdit))
        etbt_help_label = QLabel(QApplication.translate("Label", "Settings for non-Modbus devices",None, QApplication.UnicodeUTF8) + "<br>")
        ##########################    TAB 2  WIDGETS   EXTRA DEVICES
        self.serialtable = QTableWidget()
        self.serialtable.setTabKeyNavigation(True)
        self.createserialTable()
        ##########################    TAB 3 WIDGETS   MODBUS
        modbus_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.modbus_comportEdit = QComboBox()
        self.modbus_comportEdit.addItems(xports)
        self.modbus_comportEdit.setCurrentIndex(xports.index(aw.modbus.comport))
        self.modbus_comportEdit.setEditable(True)
        modbus_comportlabel.setBuddy(self.modbus_comportEdit)
        modbus_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.modbus_baudrateComboBox = QComboBox()
        modbus_baudratelabel.setBuddy(self.modbus_baudrateComboBox)
        self.modbus_bauds = ["2400","9600","19200","38400","57600","115200"]
        self.modbus_baudrateComboBox.addItems(self.modbus_bauds)
        self.modbus_baudrateComboBox.setCurrentIndex(self.modbus_bauds.index(str(aw.modbus.baudrate)))
        modbus_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.modbus_bytesizeComboBox = QComboBox()
        modbus_bytesizelabel.setBuddy(self.modbus_bytesizeComboBox)
        self.modbus_bytesizes = ["7","8"]
        self.modbus_bytesizeComboBox.addItems(self.modbus_bytesizes)
        self.modbus_bytesizeComboBox.setCurrentIndex(self.modbus_bytesizes.index(str(aw.modbus.bytesize)))
        modbus_paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.modbus_parityComboBox = QComboBox()
        modbus_paritylabel.setBuddy(self.modbus_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.modbus_parity = ["O","E","N"]
        self.modbus_parityComboBox.addItems(self.modbus_parity)
        self.modbus_parityComboBox.setCurrentIndex(self.modbus_parity.index(aw.modbus.parity))
        modbus_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.modbus_stopbitsComboBox = QComboBox()
        modbus_stopbitslabel.setBuddy(self.modbus_stopbitsComboBox)
        self.modbus_stopbits = ["0","1","2"]
        self.modbus_stopbitsComboBox.addItems(self.stopbits)
        self.modbus_stopbitsComboBox.setCurrentIndex(aw.modbus.stopbits)
        modbus_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.modbus_timeoutEdit = QLineEdit(str(aw.modbus.timeout))
        self.modbus_timeoutEdit.setValidator(QIntValidator(1,5,self.modbus_timeoutEdit))
        modbus_input1slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input1slaveEdit = QLineEdit(str(aw.modbus.input1slave))
        self.modbus_input1slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input1slaveEdit))
        self.modbus_input1slaveEdit.setFixedWidth(50)
        self.modbus_input1slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input1registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input1registerEdit = QLineEdit(str(aw.modbus.input1register))
        self.modbus_input1registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input1registerEdit))
        self.modbus_input1registerEdit.setFixedWidth(50)
        self.modbus_input1registerEdit.setAlignment(Qt.AlignRight)
        modbus_function_codes = ["3","4"]
        modbus_input1floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input1codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input1float = QCheckBox()
        self.modbus_input1float.setChecked(aw.modbus.input1float)
        self.modbus_input1float.setFocusPolicy(Qt.NoFocus) 
        self.connect(self.modbus_input1float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())       
        self.modbus_input1code = QComboBox()
        self.modbus_input1code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input1code.addItems(modbus_function_codes)
        self.modbus_input1code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input1code)))
        self.modbus_input1code.setFixedWidth(50)
        modbus_input2slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input2slaveEdit = QLineEdit(str(aw.modbus.input2slave))
        self.modbus_input2slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input2slaveEdit))
        self.modbus_input2slaveEdit.setFixedWidth(50)
        self.modbus_input2slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input2registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input2registerEdit = QLineEdit(str(aw.modbus.input2register))
        self.modbus_input2registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input2registerEdit))
        self.modbus_input2registerEdit.setFixedWidth(50)
        self.modbus_input2registerEdit.setAlignment(Qt.AlignRight)
        modbus_input2floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input2codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input2float = QCheckBox()
        self.modbus_input2float.setChecked(aw.modbus.input2float)
        self.modbus_input2float.setFocusPolicy(Qt.NoFocus)  
        self.connect(self.modbus_input2float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())      
        self.modbus_input2code = QComboBox()
        self.modbus_input2code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input2code.addItems(modbus_function_codes)
        self.modbus_input2code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input2code)))
        self.modbus_input2code.setFixedWidth(50)
        modbus_input3slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input3slaveEdit = QLineEdit(str(aw.modbus.input3slave))
        self.modbus_input3slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input3slaveEdit))
        self.modbus_input3slaveEdit.setFixedWidth(50)
        self.modbus_input3slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input3registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input3registerEdit = QLineEdit(str(aw.modbus.input3register))
        self.modbus_input3registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input3registerEdit))
        self.modbus_input3registerEdit.setFixedWidth(50)
        self.modbus_input3registerEdit.setAlignment(Qt.AlignRight)
        modbus_input3floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input3codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input3float = QCheckBox()
        self.modbus_input3float.setChecked(aw.modbus.input3float)
        self.modbus_input3float.setFocusPolicy(Qt.NoFocus) 
        self.connect(self.modbus_input3float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())       
        self.modbus_input3code = QComboBox()
        self.modbus_input3code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input3code.addItems(modbus_function_codes)
        self.modbus_input3code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input3code)))
        self.modbus_input3code.setFixedWidth(50)
        modbus_input4slavelabel = QLabel(QApplication.translate("Label", "Slave",None, QApplication.UnicodeUTF8))
        self.modbus_input4slaveEdit = QLineEdit(str(aw.modbus.input4slave))
        self.modbus_input4slaveEdit.setValidator(QIntValidator(0,247,self.modbus_input4slaveEdit))
        self.modbus_input4slaveEdit.setFixedWidth(50)
        self.modbus_input4slaveEdit.setAlignment(Qt.AlignRight)
        modbus_input4registerlabel = QLabel(QApplication.translate("Label", "Register",None, QApplication.UnicodeUTF8))
        self.modbus_input4registerEdit = QLineEdit(str(aw.modbus.input4register))
        self.modbus_input4registerEdit.setValidator(QIntValidator(0,65025,self.modbus_input4registerEdit))
        self.modbus_input4registerEdit.setFixedWidth(50)
        self.modbus_input4registerEdit.setAlignment(Qt.AlignRight)
        modbus_input4floatlabel = QLabel(QApplication.translate("Label", "Float",None, QApplication.UnicodeUTF8))
        modbus_input4codelabel = QLabel(QApplication.translate("Label", "Function",None, QApplication.UnicodeUTF8))
        self.modbus_input4float = QCheckBox()
        self.modbus_input4float.setChecked(aw.modbus.input4float)
        self.modbus_input4float.setFocusPolicy(Qt.NoFocus)
        self.connect(self.modbus_input4float, SIGNAL("stateChanged(int)"),lambda i=0:self.changeEndianVisibility())
        self.modbus_input4code = QComboBox()
        self.modbus_input4code.setFocusPolicy(Qt.NoFocus)
        self.modbus_input4code.addItems(modbus_function_codes)
        self.modbus_input4code.setCurrentIndex(modbus_function_codes.index(str(aw.modbus.input4code)))
        self.modbus_input4code.setFixedWidth(50)
        self.modbus_littleEndianFloats = QCheckBox(QApplication.translate("ComboBox","little-endian",None, QApplication.UnicodeUTF8))
        self.modbus_littleEndianFloats.setChecked(aw.modbus.littleEndianFloats)
        self.modbus_littleEndianFloats.setFocusPolicy(Qt.NoFocus)
        if self.modbus_input1float.isChecked() or self.modbus_input2float.isChecked() or self.modbus_input3float.isChecked() or self.modbus_input4float.isChecked():
            self.modbus_littleEndianFloats.setEnabled(True)
        else:
            self.modbus_littleEndianFloats.setEnabled(False)
        modbus_help_text = QApplication.translate("Message", "These serial settings are used for all Modbus communication.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "The MODBUS device corresponds to input channels 1 and 2.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "The +MODBUS_34 extra device adds input channels 3 and 4.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Inputs with slave id set to 0 are turned off.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Modbus function 3 'read holding register' is the standard.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Modbus function 4 triggers the use of 'read input register'.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Input registers (fct 4) usually are from the range 30000-39999.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Most devices hold data in 2 byte integer registers.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "A temperature of 145.2C is often send as 1452.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "In that case you have to use the symbolic assignment 'x/10'.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Few devices hold data as 4 byte floats in two registers.",None, QApplication.UnicodeUTF8) + "<br>"
        modbus_help_text += QApplication.translate("Message", "Tick the Float flag in this case.",None, QApplication.UnicodeUTF8)
        modbus_help_label = QLabel(modbus_help_text)
        ##########################    TAB 4 WIDGETS   SCALE
        scale_devicelabel = QLabel(QApplication.translate("Label", "Device", None, QApplication.UnicodeUTF8))
        self.scale_deviceEdit = QComboBox()
        self.scale_deviceEdit.addItems(list(aw.scale.devicefunctionlist.keys()))
        try:
            self.scale_deviceEdit.setCurrentIndex(aw.scale.device_id)
        except:
            self.scale_deviceEdit.setCurrentIndex(0)
        self.scale_deviceEdit.setEditable(False)
        scale_devicelabel.setBuddy(self.scale_deviceEdit)
        scale_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None, QApplication.UnicodeUTF8))
        self.scale_comportEdit = QComboBox()
        self.scale_comportEdit.addItems([aw.scale.comport])
        self.scale_comportEdit.setEditable(True)
        scale_comportlabel.setBuddy(self.scale_comportEdit)
        scale_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None, QApplication.UnicodeUTF8))
        self.scale_baudrateComboBox = QComboBox()
        scale_baudratelabel.setBuddy(self.scale_baudrateComboBox)
        self.scale_bauds = ["1200","2400","4800","9600","19200","38400","57600","115200"]
        self.scale_baudrateComboBox.addItems(self.scale_bauds)
        self.scale_baudrateComboBox.setCurrentIndex(self.scale_bauds.index(str(aw.scale.baudrate)))
        scale_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None, QApplication.UnicodeUTF8))
        self.scale_bytesizeComboBox = QComboBox()
        scale_bytesizelabel.setBuddy(self.scale_bytesizeComboBox)
        self.scale_bytesizes = ["7","8"]
        self.scale_bytesizeComboBox.addItems(self.scale_bytesizes)
        self.scale_bytesizeComboBox.setCurrentIndex(self.scale_bytesizes.index(str(aw.scale.bytesize)))
        scale_paritylabel = QLabel(QApplication.translate("Label", "Parity",None, QApplication.UnicodeUTF8))
        self.scale_parityComboBox = QComboBox()
        scale_paritylabel.setBuddy(self.scale_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.scale_parity = ["O","E","N"]
        self.scale_parityComboBox.addItems(self.scale_parity)
        self.scale_parityComboBox.setCurrentIndex(self.scale_parity.index(aw.scale.parity))
        scale_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None, QApplication.UnicodeUTF8))
        self.scale_stopbitsComboBox = QComboBox()
        scale_stopbitslabel.setBuddy(self.scale_stopbitsComboBox)
        self.scale_stopbits = ["0","1","2"]
        self.scale_stopbitsComboBox.addItems(self.stopbits)
        self.scale_stopbitsComboBox.setCurrentIndex(aw.scale.stopbits)
        scale_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None, QApplication.UnicodeUTF8))
        self.scale_timeoutEdit = QLineEdit(str(aw.scale.timeout))
        self.scale_timeoutEdit.setValidator(QIntValidator(1,5,self.scale_timeoutEdit))
        #### dialog buttons
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        scanButton = QPushButton(QApplication.translate("Button","Scan for Ports",None, QApplication.UnicodeUTF8))
        scanButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(scanButton, SIGNAL("clicked()"), self.scanforport)
        #button layout
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(scanButton)
        buttonLayout.addStretch()  
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        #LAYOUT TAB 1
        grid = QGridLayout()
        grid.addWidget(comportlabel,0,0,Qt.AlignRight)
        grid.addWidget(self.comportEdit,0,1)
        grid.addWidget(baudratelabel,1,0,Qt.AlignRight)
        grid.addWidget(self.baudrateComboBox,1,1)
        grid.addWidget(bytesizelabel,2,0,Qt.AlignRight)
        grid.addWidget(self.bytesizeComboBox,2,1)
        grid.addWidget(paritylabel,3,0,Qt.AlignRight)
        grid.addWidget(self.parityComboBox,3,1)
        grid.addWidget(stopbitslabel,4,0,Qt.AlignRight)
        grid.addWidget(self.stopbitsComboBox,4,1)
        grid.addWidget(timeoutlabel,5,0,Qt.AlignRight)
        grid.addWidget(self.timeoutEdit,5,1)
        gridBoxLayout = QHBoxLayout()
        gridBoxLayout.addLayout(grid)
        gridBoxLayout.addStretch()
        tab1Layout = QVBoxLayout()
        tab1Layout.addWidget(etbt_help_label)
        devid = aw.qmc.device
        if devid != 29 and devid != 33: # hide serial confs for MODBUS devices
            tab1Layout.addLayout(gridBoxLayout)
        tab1Layout.addStretch()
        #LAYOUT TAB 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.serialtable)
        #LAYOUT TAB 3
        modbus_grid = QGridLayout()
        modbus_grid.addWidget(modbus_comportlabel,0,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_comportEdit,0,1)
        modbus_grid.addWidget(modbus_baudratelabel,1,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_baudrateComboBox,1,1)
        modbus_grid.addWidget(modbus_bytesizelabel,2,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_bytesizeComboBox,2,1)
        modbus_grid.addWidget(modbus_paritylabel,3,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_parityComboBox,3,1)
        modbus_grid.addWidget(modbus_stopbitslabel,4,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_stopbitsComboBox,4,1)
        modbus_grid.addWidget(modbus_timeoutlabel,5,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_timeoutEdit,5,1)
        modbus_gridV = QVBoxLayout()
        modbus_gridV.addStretch()
        modbus_gridV.addLayout(modbus_grid)
        modbus_gridV.addStretch()
        modbus_input1 = QGridLayout()
        modbus_input1.addWidget(modbus_input1slavelabel,0,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1slaveEdit,0,1)
        modbus_input1.addWidget(modbus_input1registerlabel,1,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1registerEdit,1,1)
        modbus_input1.addWidget(modbus_input1codelabel,2,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1code,2,1)
        modbus_input1.addWidget(modbus_input1floatlabel,3,0,Qt.AlignRight)
        modbus_input1.addWidget(self.modbus_input1float,3,1)
        modbus_input1group = QGroupBox(QApplication.translate("GroupBox", "Input 1",None, QApplication.UnicodeUTF8))
        modbus_input1group.setLayout(modbus_input1)
        modbus_input2 = QGridLayout()
        modbus_input2.addWidget(modbus_input2slavelabel,0,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2slaveEdit,0,1)
        modbus_input2.addWidget(modbus_input2registerlabel,1,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2registerEdit,1,1)
        modbus_input2.addWidget(modbus_input2codelabel,2,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2code,2,1)
        modbus_input2.addWidget(modbus_input2floatlabel,3,0,Qt.AlignRight)
        modbus_input2.addWidget(self.modbus_input2float,3,1)        
        modbus_input2group = QGroupBox(QApplication.translate("GroupBox", "Input 2",None, QApplication.UnicodeUTF8))
        modbus_input2group.setLayout(modbus_input2)
        modbus_input3 = QGridLayout()
        modbus_input3.addWidget(modbus_input3slavelabel,0,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3slaveEdit,0,1)
        modbus_input3.addWidget(modbus_input3registerlabel,1,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3registerEdit,1,1)
        modbus_input3.addWidget(modbus_input3codelabel,2,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3code,2,1)
        modbus_input3.addWidget(modbus_input3floatlabel,3,0,Qt.AlignRight)
        modbus_input3.addWidget(self.modbus_input3float,3,1)
        modbus_input3group = QGroupBox(QApplication.translate("GroupBox", "Input 3",None, QApplication.UnicodeUTF8))
        modbus_input3group.setLayout(modbus_input3)
        modbus_input4 = QGridLayout()
        modbus_input4.addWidget(modbus_input4slavelabel,0,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4slaveEdit,0,1)
        modbus_input4.addWidget(modbus_input4registerlabel,1,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4registerEdit,1,1)
        modbus_input4.addWidget(modbus_input4codelabel,2,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4code,2,1)
        modbus_input4.addWidget(modbus_input4floatlabel,3,0,Qt.AlignRight)
        modbus_input4.addWidget(self.modbus_input4float,3,1)
        modbus_input4group = QGroupBox(QApplication.translate("GroupBox", "Input 4",None, QApplication.UnicodeUTF8))
        modbus_input4group.setLayout(modbus_input4)
        modbus_inputV = QHBoxLayout()
        modbus_inputV.addWidget(modbus_input1group)
        modbus_inputV.addStretch()
        modbus_inputV.addWidget(modbus_input2group)
        modbus_inputV.addStretch()
        modbus_inputV.addWidget(modbus_input3group)
        modbus_inputV.addStretch()
        modbus_inputV.addWidget(modbus_input4group)
        modbus_inputV.addStretch()
        modbus_gridVLayout = QHBoxLayout()
        modbus_gridVLayout.addLayout(modbus_gridV)
        modbus_gridVLayout.addWidget(modbus_help_label)
        modbus_gridVLayout.addStretch()
        tab3Layout = QVBoxLayout()
        tab3Layout.addLayout(modbus_gridVLayout)
        tab3Layout.addLayout(modbus_inputV)
        tab3Layout.addWidget(self.modbus_littleEndianFloats)
        tab3Layout.addStretch()
        #LAYOUT TAB 4
        scale_grid = QGridLayout()
        scale_grid.addWidget(scale_devicelabel,0,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_deviceEdit,0,1)
        scale_grid.addWidget(scale_comportlabel,1,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_comportEdit,1,1)
        scale_grid.addWidget(scale_baudratelabel,2,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_baudrateComboBox,2,1)
        scale_grid.addWidget(scale_bytesizelabel,3,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_bytesizeComboBox,3,1)
        scale_grid.addWidget(scale_paritylabel,4,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_parityComboBox,4,1)
        scale_grid.addWidget(scale_stopbitslabel,5,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_stopbitsComboBox,5,1)
        scale_grid.addWidget(scale_timeoutlabel,6,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_timeoutEdit,6,1)
        scaleH = QHBoxLayout()
        scaleH.addLayout(scale_grid)
        scaleH.addStretch()
        tab4Layout = QVBoxLayout()
        tab4Layout.addLayout(scaleH)
        tab4Layout.addStretch()
        #tab widget
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","ET/BT",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Extra",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Modbus",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Scale",None, QApplication.UnicodeUTF8))
        if devid == 29: # switch to MODBUS tab if MODBUS device was selected as main device
            TabWidget.setCurrentIndex(2)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(buttonLayout)
        self.setLayout(Mlayout)

    def changeEndianVisibility(self):
        if self.modbus_input1float.isChecked() or self.modbus_input2float.isChecked() or self.modbus_input3float.isChecked() or self.modbus_input4float.isChecked():
            self.modbus_littleEndianFloats.setEnabled(True)
        else:
            self.modbus_littleEndianFloats.setEnabled(False)
        
    def portlist(self):
        xports = list(aw.extracomport)
        xports.append(aw.ser.comport)
        xports.append(aw.modbus.comport)
        xports.append(aw.scale.comport)
        return sorted(list(set(xports)))

    def createserialTable(self):
        try:
            self.serialtable.clear()
            nssdevices = len(aw.extracomport)
            if nssdevices:
                self.serialtable.setRowCount(nssdevices)
                self.serialtable.setColumnCount(7)
                self.serialtable.setHorizontalHeaderLabels([QApplication.translate("Table","Device",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Comm Port",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Baud Rate",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Byte Size",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Parity",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Stopbits",None, QApplication.UnicodeUTF8),
                                                            QApplication.translate("Table","Timeout",None, QApplication.UnicodeUTF8)])
                self.serialtable.setAlternatingRowColors(True)
                self.serialtable.setEditTriggers(QTableWidget.NoEditTriggers)
                self.serialtable.setSelectionBehavior(QTableWidget.SelectRows)
                self.serialtable.setSelectionMode(QTableWidget.SingleSelection)
                self.serialtable.setShowGrid(True)
                xports = self.portlist()
                for i in range(nssdevices):
                    devid = aw.qmc.extradevices[i]
                    devicename = aw.qmc.devices[devid-1]
                    device = QTableWidgetItem(devicename)    #type identification of the device. Non editable
                    self.serialtable.setItem(i,0,device)
                    if devid != 29 and devid != 33 and devicename[0] != "+": # hide serial confs for MODBUS and "+X" extra devices
                        comportComboBox =  QComboBox()
                        comportComboBox.addItems(xports)
                        comportComboBox.setCurrentIndex(xports.index(aw.extracomport[i]))
                        comportComboBox.setFixedWidth(200)
                        baudComboBox =  QComboBox()
                        baudComboBox.addItems(self.bauds)
                        if str(aw.extrabaudrate[i]) in self.bauds:
                            baudComboBox.setCurrentIndex(self.bauds.index(str(aw.extrabaudrate[i])))
                        byteComboBox =  QComboBox()
                        byteComboBox.addItems(self.bytesizes)
                        if str(aw.extrabytesize[i]) in self.bytesizes:
                            byteComboBox.setCurrentIndex(self.bytesizes.index(str(aw.extrabytesize[i])))
                        parityComboBox =  QComboBox()
                        parityComboBox.addItems(self.parity)
                        if aw.extraparity[i] in self.parity:
                            parityComboBox.setCurrentIndex(self.parity.index(aw.extraparity[i]))
                        #self.connect(baudComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,x=i:self.setextradevice(z,x))
                        stopbitsComboBox = QComboBox()
                        stopbitsComboBox.addItems(self.stopbits)
                        if str(aw.extrastopbits[i]) in self.stopbits:
                            stopbitsComboBox.setCurrentIndex(self.stopbits.index(str(aw.extrastopbits[i])))
                        timeoutEdit = QLineEdit(str(aw.extratimeout[i]))
                        timeoutEdit.setValidator(QIntValidator(1,5,timeoutEdit))
                        timeoutEdit.setFixedWidth(65)
                        timeoutEdit.setAlignment(Qt.AlignRight)
                        #add widgets to the table
                        self.serialtable.setCellWidget(i,1,comportComboBox)
                        self.serialtable.setCellWidget(i,2,baudComboBox)
                        self.serialtable.setCellWidget(i,3,byteComboBox)
                        self.serialtable.setCellWidget(i,4,parityComboBox)
                        self.serialtable.setCellWidget(i,5,stopbitsComboBox)
                        self.serialtable.setCellWidget(i,6,timeoutEdit)
                self.serialtable.resizeColumnsToContents()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " createserialTable(): %1").arg(str(e)),exc_tb.tb_lineno)

    def saveserialtable(self):
        try:
            #aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            ser_ports = len(aw.extracomport)
            self.closeserialports()
            for i in range(ser_ports):
                devid = aw.qmc.extradevices[i]
                devicename = aw.qmc.devices[devid-1]    #type identification of the device. Non editable
                if devid != 29 and devid != 33 and devicename[0] != "+": # hide serial confs for MODBUS and "+XX" extra devices
                    comportComboBox =  self.serialtable.cellWidget(i,1)
                    aw.extracomport[i] = str(comportComboBox.currentText())
                    baudComboBox =  self.serialtable.cellWidget(i,2)
                    aw.extrabaudrate[i] = int(str(baudComboBox.currentText()))
                    byteComboBox =  self.serialtable.cellWidget(i,3)
                    aw.extrabytesize[i] = int(str(byteComboBox.currentText()))
                    parityComboBox =  self.serialtable.cellWidget(i,4)
                    aw.extraparity[i] = str(parityComboBox.currentText())
                    stopbitsComboBox =  self.serialtable.cellWidget(i,5)
                    aw.extrastopbits[i] = int(str(stopbitsComboBox.currentText()))
                    timeoutEdit = self.serialtable.cellWidget(i,6)
                    aw.extratimeout[i] = int(str(timeoutEdit.text()))
            #create serial ports for each extra device
            aw.extraser = [None]*ser_ports
            #load the settings for the extra serial ports found
            for i in range(ser_ports):
                aw.extraser[i] = serialport()
                aw.extraser[i].comport = str(aw.extracomport[i])
                aw.extraser[i].baudrate = aw.extrabaudrate[i]
                aw.extraser[i].bytesize = aw.extrabytesize[i]
                aw.extraser[i].parity = str(aw.extraparity[i])
                aw.extraser[i].stopbits = aw.extrastopbits[i]
                aw.extraser[i].timeout = aw.extratimeout[i]
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " saveserialtable(): %1").arg(str(e)),exc_tb.tb_lineno)

    def accept(self):
        #validate serial parameter against input errors
        class comportError(Exception): pass
#        class baudrateError(Exception): pass
#        class bytesizeError(Exception): pass
#        class parityError(Exception): pass
#        class stopbitsError(Exception): pass
        class timeoutError(Exception): pass
        comport = str(self.comportEdit.currentText())
        baudrate = str(self.baudrateComboBox.currentText())
        bytesize = str(self.bytesizeComboBox.currentText())
        parity = str(self.parityComboBox.currentText())
        stopbits = str(self.stopbitsComboBox.currentText())
        timeout = str(self.timeoutEdit.text())
        #save extra serial ports by reading the serial extra table
        self.saveserialtable()
        try:
            #check here comport errors
            if not comport:
                raise comportError
            if not timeout:
                raise timeoutError
            #add more checks here
            aw.sendmessage(QApplication.translate("Message","Serial Port Settings: %1, %2, %3, %4, %5, %6", None, QApplication.UnicodeUTF8).arg(comport).arg(baudrate).arg(bytesize).arg(parity).arg(stopbits).arg(timeout))
        except comportError:
            aw.qmc.adderror(QApplication.translate("Error Message","Serial Exception: invalid comm port", None, QApplication.UnicodeUTF8))
            self.comportEdit.selectAll()
            self.comportEdit.setFocus()
            return
        except timeoutError:
            aw.qmc.adderror(QApplication.translate("Error Message","Serial Exception: timeout", None, QApplication.UnicodeUTF8))
            self.timeoutEdit.selectAll()
            self.timeoutEdit.setFocus()
            return
        QDialog.accept(self)

    # returns a list of strings indicating available serial ports
    def serialports(self):
        available = []
        if platf in ('Windows', 'Microsoft'):
            #scans serial ports in Windows computer
            for i in range(100):
                try:
                    s = serial.Serial(i)
                    available.append(s.portstr)
                    s.close()
                except serial.SerialException:
                    pass
        elif platf == 'Darwin':
            if float(serial.VERSION) < 2.6:
                #scans serial ports in Mac computer
                for name in glob.glob("/dev/cu.*"):
                    if name.upper().rfind("MODEM") < 0:
                        try:  
                            f = open(name, "r+")
                            f.close()
                            available.append(name)
                        except Exception:
                            pass
            else:
                from serial.tools import list_ports
                available = list([port[0] for port in list_ports.comports() if not(port[0] in ['/dev/tty.Bluetooth-PDA-Sync','/dev/tty.Bluetooth-Modem'])])
        elif platf == 'Linux':
            if float(serial.VERSION) < 2.6:
                maxnum=9
                for prefix in ["/dev/ttyS", "/dev/cua", "/dev/ttyUSB","/dev/usb/ttyUSB", "/dev/usb/tts/"]:
                    for num in range(maxnum+1):
                        name=prefix+repr(num)
                        if not os.path.exists(name):
                            continue
                        try:
                            f = open(name, "r+")
                            f.close()
                            available.append(name)
                        except Exception:
                            pass
            else:
                from serial.tools import list_ports
                available = list([port[0] for port in list_ports.comports()])
        else:
            self.sendmessage(QApplication.translate("Message","Port scan on this platform not yet supported", None, QApplication.UnicodeUTF8))
        return available


    def scanforport(self):
        try:
            available = self.serialports()
            aw.ser.closeport()            #set comboBoxes
            self.comportEdit.clear()
            self.comportEdit.addItems(available)
            self.modbus_comportEdit.clear()
            self.modbus_comportEdit.addItems(available)
            if len(available):
                if aw.ser.comport in available:
                    self.comportEdit.setCurrentIndex(available.index(aw.ser.comport))
                else:
                    self.comportEdit.setCurrentIndex(len(available)-1)
                aw.ser.commavailable = available[:]
                for i in range(len(aw.qmc.extradevices)):
                    comportComboBox =  self.serialtable.cellWidget(i,1)
                    if comportComboBox != None:
                        comportComboBox.clear()
                        comportComboBox.addItems(aw.ser.commavailable)
                        if aw.extracomport[i] in aw.ser.commavailable:
                            comportComboBox.setCurrentIndex(aw.ser.commavailable.index(aw.extracomport[i]))
                        else:
                            comportComboBox.setCurrentIndex(len(aw.ser.commavailable)-1)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " scanforport(): %1").arg(str(e)),exc_tb.tb_lineno)

    def closeserialports(self):
        if aw.ser.SP.isOpen():
            aw.ser.SP.close()
        for i in range(len(aw.extraser)):
            if aw.extraser[i].SP.isOpen():
                aw.extraser[i].SP.close()

#################################################################################
##################   Device assignments DIALOG for reading temperature   ########
#################################################################################

class DeviceAssignmentDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(DeviceAssignmentDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Device Assignment", None, QApplication.UnicodeUTF8))
        self.setModal(True)
        ################ TAB 1   WIDGETS
        #ETcurve
        self.ETcurve = QCheckBox(QApplication.translate("CheckBox", "ET",None, QApplication.UnicodeUTF8))
        self.ETcurve.setChecked(aw.qmc.ETcurve)
        #BTcurve
        self.BTcurve = QCheckBox(QApplication.translate("CheckBox", "BT",None, QApplication.UnicodeUTF8))
        self.BTcurve.setChecked(aw.qmc.BTcurve)
        #ETlcd
        self.ETlcd = QCheckBox(QApplication.translate("CheckBox", "ET",None, QApplication.UnicodeUTF8))
        self.ETlcd.setChecked(aw.qmc.ETlcd)
        #BTlcd
        self.BTlcd = QCheckBox(QApplication.translate("CheckBox", "BT",None, QApplication.UnicodeUTF8))
        self.BTlcd.setChecked(aw.qmc.BTlcd)
        self.curveHBox = QHBoxLayout()
        self.curveHBox.addWidget(self.ETcurve)
        self.curveHBox.addSpacing(10)
        self.curveHBox.addWidget(self.BTcurve)
        self.curveHBox.addStretch()
        self.curves = QGroupBox(QApplication.translate("GroupBox","Curves",None, QApplication.UnicodeUTF8))
        self.curves.setLayout(self.curveHBox)
        self.lcdHBox = QHBoxLayout()
        self.lcdHBox.addWidget(self.ETlcd)
        self.lcdHBox.addSpacing(10)
        self.lcdHBox.addWidget(self.BTlcd)
        self.lcdHBox.addStretch()
        self.lcds = QGroupBox(QApplication.translate("GroupBox","LCDs",None, QApplication.UnicodeUTF8))
        self.lcds.setLayout(self.lcdHBox)
        self.curveBox = QHBoxLayout()
        self.curveBox.addWidget(self.curves)
        self.curveBox.addWidget(self.lcds)
        self.nonpidButton = QRadioButton(QApplication.translate("Radio Button","Meter", None, QApplication.UnicodeUTF8))
        self.pidButton = QRadioButton(QApplication.translate("Radio Button","PID", None, QApplication.UnicodeUTF8))
        self.arduinoButton = QRadioButton(QApplication.translate("Radio Button","Arduino TC4", None, QApplication.UnicodeUTF8))
        self.programButton = QRadioButton(QApplication.translate("Radio Button","Program", None, QApplication.UnicodeUTF8))
        #As a main device, don't show the devices that start with a "+"
        # devices with a first letter "+" are extra devices an depend on another device
        # each device provides 2 curves
        #don't show devices with a "-". Devices with a - at front are either a pid, arduino, or an external program
        dev = aw.qmc.devices[:]             #deep copy
        limit = len(dev)
        for _ in range(limit):
            for i in range(len(dev)):
                if dev[i][0] == "+" or dev[i][0] == "-":
                    dev.pop(i)              #note: pop() makes the list smaller that's why there are 2 FOR statements
                    break 
        sorted_devices = sorted(dev)
        self.devicetypeComboBox = QComboBox()
        self.devicetypeComboBox.addItems(sorted_devices)
        self.programedit = QLineEdit(aw.ser.externalprogram)
        selectprogrambutton =  QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
        selectprogrambutton.setFocusPolicy(Qt.NoFocus)
        self.connect(selectprogrambutton, SIGNAL("clicked()"),self.loadprogramname)
        helpprogrambutton =  QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpprogrambutton.setFocusPolicy(Qt.NoFocus)
        self.connect(helpprogrambutton, SIGNAL("clicked()"),self.showhelpprogram)
        ###################################################
        # PID
        controllabel =QLabel(QApplication.translate("Label", "Control ET",None, QApplication.UnicodeUTF8))
        self.controlpidtypeComboBox = QComboBox()
        self.controlpidtypeComboBox.addItems(["Fuji PXG","Fuji PXR","Delta DTA"])
        self.controlpidtypeComboBox.setCurrentIndex(aw.ser.controlETpid[0])  #pid type is index 0
        btlabel =QLabel(QApplication.translate("Label", "Read BT",None, QApplication.UnicodeUTF8))
        self.btpidtypeComboBox = QComboBox()
        self.btpidtypeComboBox.addItems(["Fuji PXG","Fuji PXR","None","Delta DTA"])
        self.btpidtypeComboBox.setCurrentIndex(aw.ser.readBTpid[0]) #pid type is index 0
        label1 = QLabel(QApplication.translate("Label", "Type",None, QApplication.UnicodeUTF8))
        label2 = QLabel(QApplication.translate("Label", "RS485 Unit ID",None, QApplication.UnicodeUTF8))
        #rs485 possible unit IDs (1-32); unit 0 is master (computer)
        unitids = list(map(str,list(range(1,33))))
        self.controlpidunitidComboBox = QComboBox()
        self.controlpidunitidComboBox.addItems(unitids)
        self.btpidunitidComboBox = QComboBox()
        self.btpidunitidComboBox.addItems(unitids)
        # index 1 = unitID of the rs485 network
        self.controlpidunitidComboBox.setCurrentIndex(unitids.index(str(aw.ser.controlETpid[1])))
        self.btpidunitidComboBox.setCurrentIndex(unitids.index(str(aw.ser.readBTpid[1])))
        ####################################################
        #Arduino TC4 channel config
        arduinoChannels = ["None","1","2","3","4"]
        arduinoETLabel =QLabel(QApplication.translate("Label", "ET Channel",None, QApplication.UnicodeUTF8))
        self.arduinoETComboBox = QComboBox()
        self.arduinoETComboBox.addItems(arduinoChannels)
        arduinoBTLabel =QLabel(QApplication.translate("Label", "BT Channel",None, QApplication.UnicodeUTF8))
        self.arduinoBTComboBox = QComboBox()
        self.arduinoBTComboBox.addItems(arduinoChannels)
        self.arduino56 = QCheckBox(QApplication.translate("CheckBox", "TC4_56",None, QApplication.UnicodeUTF8))
        self.arduino56.setChecked(aw.qmc.arduino56active)
        #check previous settings for radio button
        if aw.qmc.device == 0 or aw.qmc.device == 26:   #if Fuji pid or Delta DTA pid
            self.pidButton.setChecked(True)
        elif aw.qmc.device == 19:                       #if arduino
            self.arduinoButton.setChecked(True)
        elif aw.qmc.device == 27:                       #if program
            self.programButton.setChecked(True)            
        else:
            self.nonpidButton.setChecked(True)          #else 
            selected_device_index = 0
            try:
                selected_device_index = sorted_devices.index(aw.qmc.devices[aw.qmc.device - 1])
            except Exception:
                pass
            self.devicetypeComboBox.setCurrentIndex(selected_device_index)
        self.arduinoETComboBox.setCurrentIndex(arduinoChannels.index(aw.ser.arduinoETChannel))
        self.arduinoBTComboBox.setCurrentIndex(arduinoChannels.index(aw.ser.arduinoBTChannel))
        arduinoATLabel =QLabel(QApplication.translate("Label", "AT Channel",None, QApplication.UnicodeUTF8))
        arduinoTemperatures = ["None","T1","T2","T3","T4","T5","T6"]
        self.arduinoATComboBox = QComboBox()        
        self.arduinoATComboBox.addItems(arduinoTemperatures)
        self.arduinoATComboBox.setCurrentIndex(arduinoTemperatures.index(aw.ser.arduinoATChannel))
        ####################################################
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        self.connect(cancelButton, SIGNAL("clicked()"),self, SLOT("reject()"))
        labelETadvanced = QLabel(QApplication.translate("Label", "ET Y(x)",None, QApplication.UnicodeUTF8))
        labelBTadvanced = QLabel(QApplication.translate("Label", "BT Y(x)",None, QApplication.UnicodeUTF8))
        self.ETfunctionedit = QLineEdit(str(aw.qmc.ETfunction))
        self.BTfunctionedit = QLineEdit(str(aw.qmc.BTfunction))
        symbolicHelpButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        symbolicHelpButton.setMaximumSize(symbolicHelpButton.sizeHint())
        symbolicHelpButton.setMinimumSize(symbolicHelpButton.minimumSizeHint())
        symbolicHelpButton.setFocusPolicy(Qt.NoFocus)
        self.connect(symbolicHelpButton, SIGNAL("clicked()"),aw.showSymbolicHelp)
        ##########################    TAB 2  WIDGETS   "EXTRA DEVICES"
        #table for showing data
        self.devicetable = QTableWidget()
        self.devicetable.setTabKeyNavigation(True)
        self.createDeviceTable()
        self.addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        self.addButton.setFocusPolicy(Qt.NoFocus)
        self.addButton.setMinimumWidth(100)
        self.addButton.setMaximumWidth(100)
        self.connect(self.addButton, SIGNAL("clicked()"),self.adddevice)
        resetButton = QPushButton(QApplication.translate("Button","Reset",None, QApplication.UnicodeUTF8))
        resetButton.setFocusPolicy(Qt.NoFocus)
        resetButton.setMinimumWidth(100)
        self.connect(resetButton, SIGNAL("clicked()"),self.resetextradevices)
        self.delButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
        self.delButton.setFocusPolicy(Qt.NoFocus)
        self.delButton.setMinimumWidth(100)
        self.delButton.setMaximumWidth(100)
        self.connect(self.delButton, SIGNAL("clicked()"),self.deldevice) 
        self.enableDisableAddDeleteButtons()
        ##########     LAYOUTS
        # create pid box
        PIDgrid = QGridLayout()
        PIDgrid.addWidget(label1,0,1)
        PIDgrid.addWidget(label2,0,2)
        PIDgrid.addWidget(controllabel,1,0,Qt.AlignRight)
        PIDgrid.addWidget(self.controlpidtypeComboBox,1,1)
        PIDgrid.addWidget(self.controlpidunitidComboBox,1,2)
        PIDgrid.addWidget(btlabel,2,0,Qt.AlignRight)
        PIDgrid.addWidget(self.btpidtypeComboBox,2,1)
        PIDgrid.addWidget(self.btpidunitidComboBox,2,2)
        PIDBox = QHBoxLayout()
        PIDBox.addLayout(PIDgrid)
        PIDBox.addStretch()
        PIDGroupBox = QGroupBox(QApplication.translate("GroupBox","PID",None, QApplication.UnicodeUTF8))
        PIDGroupBox.setLayout(PIDBox)
        # create arduino box
        arduinogrid = QGridLayout()
        arduinogrid.addWidget(arduinoETLabel,1,0,Qt.AlignRight)
        arduinogrid.addWidget(self.arduinoETComboBox,1,1)
        arduinogrid.addWidget(arduinoBTLabel,2,0,Qt.AlignRight)
        arduinogrid.addWidget(self.arduinoBTComboBox,2,1)
        arduinogrid.addWidget(self.arduino56,1,4)
        arduinogrid.addWidget(self.arduinoATComboBox,2,3)
        arduinogrid.addWidget(arduinoATLabel,2,4)
        arduinoBox = QHBoxLayout()
        arduinoBox.addLayout(arduinogrid)
        arduinoBox.addStretch()
        arduinoGroupBox = QGroupBox(QApplication.translate("GroupBox","Arduino TC4",None, QApplication.UnicodeUTF8))
        arduinoGroupBox.setLayout(arduinoBox)
        #create program Box
        programlayout = QHBoxLayout()
        programlayout.addWidget(helpprogrambutton)
        programlayout.addWidget(selectprogrambutton)
        programlayout.addWidget(self.programedit)
        programGroupBox = QGroupBox(QApplication.translate("GroupBox","External Program",None, QApplication.UnicodeUTF8))
        programGroupBox.setLayout(programlayout)
        #ET BT symbolic adjustments/assignments Box
        adjustmentHelp = QHBoxLayout()
        adjustmentHelp.addStretch()
        adjustmentHelp.addWidget(symbolicHelpButton)
        adjustmentGroupBox = QGroupBox(QApplication.translate("GroupBox","Symbolic Assignments",None, QApplication.UnicodeUTF8))
        adjustmentsLayout = QVBoxLayout()
        adjustmentsLayout.addWidget(labelETadvanced)
        adjustmentsLayout.addWidget(self.ETfunctionedit)
        adjustmentsLayout.addWidget(labelBTadvanced)
        adjustmentsLayout.addWidget(self.BTfunctionedit)
        adjustmentsLayout.addStretch()
        adjustmentsLayout.addLayout(adjustmentHelp)
        adjustmentGroupBox.setLayout(adjustmentsLayout)
        #LAYOUT TAB 1
        deviceSelector = QHBoxLayout()
        deviceSelector.addWidget(self.devicetypeComboBox)
        deviceSelector.addStretch()
        grid = QGridLayout()
        grid.addLayout(self.curveBox,0,1)
        grid.addWidget(self.nonpidButton,1,0)
        grid.addLayout(deviceSelector,1,1)
        grid.addWidget(self.pidButton,2,0)
        grid.addWidget(PIDGroupBox,2,1)
        grid.addWidget(self.arduinoButton,3,0)
        grid.addWidget(arduinoGroupBox,3,1)
        grid.addWidget(self.programButton,4,0)
        grid.addWidget(programGroupBox,4,1)
        gridBoxLayout = QHBoxLayout()
        gridBoxLayout.addLayout(grid)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        tab1Layout = QVBoxLayout()
        tab1Layout.addLayout(gridBoxLayout)
        tab1Layout.setSpacing(5)
        tab1Layout.setContentsMargins(5,10,0,0)
        tab1Layout.addStretch()
        bLayout = QHBoxLayout()
        bLayout.addWidget(self.addButton)
        bLayout.addWidget(self.delButton)
        bLayout.addStretch()
        bLayout.addSpacing(10)
        bLayout.addWidget(resetButton)
        #LAYOUT TAB 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.devicetable)
        tab2Layout.setSpacing(5)
        tab2Layout.setContentsMargins(0,10,0,5)
        tab2Layout.addLayout(bLayout)
        #LAYOUT TAB 3
        tab3Layout = QVBoxLayout()
        tab3Layout.addWidget(adjustmentGroupBox)
        #main tab widget
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","ET/BT",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Extra Devices",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Symb ET/BT",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(buttonLayout)
        self.setLayout(Mlayout)

    def createDeviceTable(self):
        try:
            self.devicetable.clear()
            nddevices = len(aw.qmc.extradevices)
            self.devicetable.setRowCount(nddevices)
            self.devicetable.setColumnCount(11)
            self.devicetable.setHorizontalHeaderLabels([QApplication.translate("Table", "Device",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Color 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Color 2",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Label 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Label 2",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "y1(x)",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "y2(x)",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "LCD 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "LCD 2",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Curve 1",None, QApplication.UnicodeUTF8),
                                                        QApplication.translate("Table", "Curve 2",None, QApplication.UnicodeUTF8)])
            self.devicetable.setAlternatingRowColors(True)
            self.devicetable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.devicetable.setSelectionBehavior(QTableWidget.SelectRows)
            self.devicetable.setSelectionMode(QTableWidget.SingleSelection)
            self.devicetable.setShowGrid(True)
            if nddevices:
                dev = aw.qmc.devices[:]             #deep copy
                limit = len(dev)
                for _ in range(limit):
                    for i in range(len(dev)):
                        if dev[i][0] == "-":
                            dev.pop(i)              #note: pop() makes the list smaller 
                            break 
                devices = sorted(dev)
                #devices.insert(0,"")         #add empty space for PID
                for i in range(nddevices):
                    typeComboBox =  QComboBox()
                    typeComboBox.addItems(sorted(devices))
                    typeComboBox.setCurrentIndex(devices.index(aw.qmc.devices[aw.qmc.extradevices[i]-1]))
                    color1Button = QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
                    color1Button.setFocusPolicy(Qt.NoFocus)
                    self.connect(color1Button, SIGNAL("clicked()"),lambda l = 1, c = i: self.setextracolor(l,c))
                    color2Button = QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
                    color2Button.setFocusPolicy(Qt.NoFocus)
                    self.connect(color2Button, SIGNAL("clicked()"),lambda l = 2, c = i: self.setextracolor(l,c))
                    name1edit = QLineEdit(str(aw.qmc.extraname1[i]))
                    name2edit = QLineEdit(str(aw.qmc.extraname2[i]))
                    mexpr1edit = QLineEdit(str(aw.qmc.extramathexpression1[i]))
                    mexpr2edit = QLineEdit(str(aw.qmc.extramathexpression2[i]))
                    mexpr1edit.setToolTip(QApplication.translate("Tooltip","Example: 100 + 2*x",None, QApplication.UnicodeUTF8))
                    mexpr2edit.setToolTip(QApplication.translate("Tooltip","Example: 100 + x",None, QApplication.UnicodeUTF8))
                    LCD1visibilityComboBox =  QCheckBox()
                    if aw.extraLCDvisibility1[i]:
                        LCD1visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        LCD1visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(LCD1visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,lcd=1, ind=i: self.updateLCDvisibility(x,lcd,ind))
                    LCD2visibilityComboBox =  QCheckBox()
                    if aw.extraLCDvisibility2[i]:
                        LCD2visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        LCD2visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(LCD2visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,lcd=2, ind=i: self.updateLCDvisibility(x,lcd,ind))
                    Curve1visibilityComboBox =  QCheckBox()
                    if aw.extraCurveVisibility1[i]:
                        Curve1visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        Curve1visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(Curve1visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,curve=1, ind=i: self.updateCurveVisibility(bool(x),curve,ind))
                    Curve2visibilityComboBox =  QCheckBox()
                    if aw.extraCurveVisibility2[i]:
                        Curve2visibilityComboBox.setCheckState(Qt.Checked)
                    else:
                        Curve2visibilityComboBox.setCheckState(Qt.Unchecked)
                    self.connect(Curve2visibilityComboBox, SIGNAL("stateChanged(int)"),lambda x=0,curve=2, ind=i: self.updateCurveVisibility(bool(x),curve,ind))
                    #add widgets to the table
                    self.devicetable.setCellWidget(i,0,typeComboBox)
                    self.devicetable.setCellWidget(i,1,color1Button)
                    self.devicetable.setCellWidget(i,2,color2Button)
                    self.devicetable.setCellWidget(i,3,name1edit)
                    self.devicetable.setCellWidget(i,4,name2edit)
                    self.devicetable.setCellWidget(i,5,mexpr1edit)
                    self.devicetable.setCellWidget(i,6,mexpr2edit)
                    self.devicetable.setCellWidget(i,7,LCD1visibilityComboBox)
                    self.devicetable.setCellWidget(i,8,LCD2visibilityComboBox)
                    self.devicetable.setCellWidget(i,9,Curve1visibilityComboBox)
                    self.devicetable.setCellWidget(i,10,Curve2visibilityComboBox)
                self.devicetable.resizeColumnsToContents()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " createDeviceTable(): %1").arg(str(e)),exc_tb.tb_lineno)

    def showhelpprogram(self):
        string = "<b>Allows to link to external programs that print temperature when called</b><br><br>"
        string += "The output of the program must be to Stdout (like when using print statements)<br><br>"
        string += "this allows to connect meters that use any programming language <br><br>"
        string += "Example of output needed from program for single temperature (BT)<br><br> \"100.4\" (note: \"\" not needed) <br><br>"
        string += "Example of output needed from program for double temperature (ET,BT)<br><br> \"200.4,100.4\" (note: temperatures are separated by a comma \"ET,BT\")<br><br>"
        string += "Example of a file written in python language called test.py:<br>"
        string += "#comment: print a string with two numbers separated by a comma<br><br>"
        string += "#!/usr/bin/env python<br>"
        string += "print (\"237.1,100.4\")"
        translatedstring = QApplication.translate("Message",string,None, QApplication.UnicodeUTF8)
        QMessageBox.information(self,QApplication.translate("Message", "External program",None, QApplication.UnicodeUTF8),translatedstring)

    def loadprogramname(self):
        fileName = aw.ArtisanOpenFileDialog()
        if fileName:
            self.programedit.setText(fileName)

    def enableDisableAddDeleteButtons(self):
        if len(aw.qmc.extradevices) >= aw.nLCDS:
            self.addButton.setEnabled(False)
        else:
            self.addButton.setEnabled(True)
        if len(aw.qmc.extradevices) > 0:
            self.delButton.setEnabled(True)
        else:
            self.delButton.setEnabled(False)

    #adds extra device
    def adddevice(self):
        try:
            self.savedevicetable()
            #addDevice() is located in aw so that the same function can be used in init after dynamically loading settings
            aw.addDevice()
            self.createDeviceTable()
            self.enableDisableAddDeleteButtons()
            aw.qmc.resetlinecountcaches()
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " adddevice(): %1").arg(str(e)),exc_tb.tb_lineno)

    def deldevice(self):
        try:
            bindex = len(aw.qmc.extradevices)-1
            selected = self.devicetable.selectedRanges()
            if len(selected) > 0:
                bindex = selected[0].topRow()
            if bindex >= 0:
                self.delextradevice(bindex)
            aw.updateExtraLCDvisibility()
            aw.qmc.resetlinecountcaches()
            self.enableDisableAddDeleteButtons()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " deldevice(): %1").arg(str(e)),exc_tb.tb_lineno)

    def resetextradevices(self):
        try:
            #delete extra devices
            aw.qmc.extradevices = []
            #delete extra curves variables
            aw.qmc.extratimex = []
            aw.qmc.extradevicecolor1 = []
            aw.qmc.extradevicecolor2 = []
            aw.qmc.extratemp1,aw.qmc.extratemp2 = [],[]
            aw.qmc.extrastemp1,aw.qmc.extrastemp2 = [],[]
            aw.qmc.extratemp1lines,aw.qmc.extratemp2lines = [],[]
            aw.qmc.extralinestyles1,aw.qmc.extralinestyles2 = [],[]
            aw.qmc.extradrawstyles1,aw.qmc.extradrawstyles2 = [],[]
            aw.qmc.extralinewidths1,aw.qmc.extralinewidths2 = [],[]
            aw.qmc.extramarkers1,aw.qmc.extramarkers2 = [],[]
            aw.qmc.extramarkersizes1,aw.qmc.extramarkersizes2 = [],[]
            aw.qmc.extraname1,aw.qmc.extraname2 = [],[]
            aw.qmc.extramathexpression1,aw.qmc.extramathexpression2 = [],[]
            for i in range(len(aw.extraLCDlabel1)):
                aw.extraLCDframe1[i].setVisible(False)
                aw.extraLCDframe2[i].setVisible(False)
            #delete EXTRA COMM PORTS VARIABLES
            aw.extraser = []
            aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            #update table
            self.createDeviceTable()
            #enable/disable buttons
            self.enableDisableAddDeleteButtons()
            aw.qmc.resetlinecountcaches()
            #redraw
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " resetextradevices(): %1").arg(str(e)),exc_tb.tb_lineno)

    def delextradevice(self,x):
        try:
            aw.qmc.extradevices.pop(x)
            aw.qmc.extradevicecolor1.pop(x)
            aw.qmc.extradevicecolor2.pop(x)
            aw.qmc.extratimex.pop(x)
            aw.qmc.extratemp1.pop(x)
            aw.qmc.extratemp2.pop(x)
            aw.qmc.extrastemp1.pop(x)
            aw.qmc.extrastemp2.pop(x)
            aw.qmc.extralinestyles1.pop(x)
            aw.qmc.extralinestyles2.pop(x)
            aw.qmc.extradrawstyles1.pop(x)
            aw.qmc.extradrawstyles2.pop(x)
            aw.qmc.extralinewidths1.pop(x)
            aw.qmc.extralinewidths2.pop(x)
            aw.qmc.extramarkers1.pop(x)
            aw.qmc.extramarkers2.pop(x)
            aw.qmc.extramarkersizes1.pop(x)
            aw.qmc.extramarkersizes2.pop(x)
            # visible courves before this one
            before1 = before2 = 0
            for j in range(x):
                if aw.extraCurveVisibility1[j]:
                    before1 = before1 + 1
                if aw.extraCurveVisibility2[j]:
                    before2 = before2 + 1
            if aw.extraCurveVisibility1[x]:
                aw.qmc.extratemp1lines.pop(before1)
            if aw.extraCurveVisibility2[x]:
                aw.qmc.extratemp2lines.pop(before2)
            aw.qmc.extraname1.pop(x)
            aw.qmc.extraname2.pop(x)
            aw.qmc.extramathexpression1.pop(x)
            aw.qmc.extramathexpression2.pop(x)
            aw.updateExtraLCDvisibility()
            #pop serial port settings
            if len(aw.extracomport) > x:
                aw.extracomport.pop(x)
            if len(aw.extrabaudrate) > x:
                aw.extrabaudrate.pop(x)
            if len(aw.extrabytesize) > x:
                aw.extrabytesize.pop(x)
            if len(aw.extraparity) > x:
                aw.extraparity.pop(x)
            if len(aw.extrastopbits) > x:
                aw.extrastopbits.pop(x)
            if len(aw.extratimeout) > x:
                aw.extratimeout.pop(x)
            if len(aw.extraser) > x:
                if aw.extraser[x].SP.isOpen():
                    aw.extraser[x].SP.close()
                aw.extraser.pop(x)
            self.createDeviceTable()
            aw.qmc.resetlinecountcaches()
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "delextradevice(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def savedevicetable(self):
        try:
            for i in range(len(aw.qmc.extradevices)):
                typecombobox = self.devicetable.cellWidget(i,0)
                #cellWidget(i,1) and cellWidget(i,2) are saved automatically when there is a change. No need to save here.
                name1edit = self.devicetable.cellWidget(i,3)
                name2edit = self.devicetable.cellWidget(i,4)
                mexpr1edit = self.devicetable.cellWidget(i,5)
                mexpr2edit = self.devicetable.cellWidget(i,6)
                aw.qmc.extradevices[i] = aw.qmc.devices.index(str(typecombobox.currentText())) + 1
                aw.qmc.extraname1[i] = str(name1edit.text())
                aw.qmc.extraname2[i] = str(name2edit.text())
                aw.extraLCDlabel1[i].setText("<b>" + aw.qmc.extraname1[i] + "<\b>")
                aw.extraLCDlabel2[i].setText("<b>" + aw.qmc.extraname2[i] + "<\b>")
                aw.qmc.extramathexpression1[i] = str(mexpr1edit.text())
                aw.qmc.extramathexpression2[i] = str(mexpr2edit.text())
            #update legend with new curves
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + "savedevicetable(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def updateLCDvisibility(self,x,lcd,ind):
        if lcd == 1:
            aw.extraLCDvisibility1[ind] = bool(x)
            aw.extraLCDframe1[ind].setVisible(bool(x))
        elif lcd == 2:
            aw.extraLCDvisibility2[ind] = bool(x)
            aw.extraLCDframe2[ind].setVisible(bool(x))

    def updateCurveVisibility(self,x,curve,ind):
        aw.qmc.resetlinecountcaches()
        if curve == 1:
            aw.extraCurveVisibility1[ind] = bool(x)
        elif curve == 2:
            aw.extraCurveVisibility2[ind] = bool(x)

    def setextracolor(self,l,i):
        try:
            #line 1
            if l == 1:
                colorf = QColorDialog.getColor(QColor(aw.qmc.extradevicecolor1[i]),self)
                if colorf.isValid():
                    colorname = str(colorf.name())
                    aw.qmc.extradevicecolor1[i] = colorname
                    # set LCD label color
                    aw.setLabelColor(aw.extraLCDlabel1[i],QColor(colorname))
            #line 2
            elif l == 2:
                colorf = QColorDialog.getColor(QColor(aw.qmc.extradevicecolor2[i]),self)
                if colorf.isValid():
                    colorname = str(colorf.name())
                    aw.qmc.extradevicecolor2[i] = colorname
                    # set LCD label color
                    aw.setLabelColor(aw.extraLCDlabel2[i],QColor(colorname))
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setextracolor(): %1").arg(str(e)),exc_tb.tb_lineno)

    def accept(self):
        try:
            #save any extra devices here
            self.savedevicetable()
            message = QApplication.translate("Message","Device not set", None, QApplication.UnicodeUTF8)
            # by default switch PID buttons/LCDs off
            aw.button_10.setVisible(False)
            aw.label6.setVisible(False)
            aw.lcd6.setVisible(False)
            aw.label7.setVisible(False)
            aw.lcd7.setVisible(False)
            aw.qmc.resetlinecountcaches()
            if self.pidButton.isChecked():
                #type index[0]: 0 = PXG, 1 = PXR, 2 = DTA
                if str(self.controlpidtypeComboBox.currentText()) == "Fuji PXG":
                    aw.ser.controlETpid[0] = 0
                    str1 = "Fuji PXG"
                elif str(self.controlpidtypeComboBox.currentText()) == "Fuji PXR":
                    aw.ser.controlETpid[0] = 1
                    str1 = "Fuji PXR"
                elif str(self.controlpidtypeComboBox.currentText()) == "Delta DTA":
                    aw.ser.controlETpid[0] = 2
                    str1 = "Delta DTA"
                aw.ser.controlETpid[1] =  int(str(self.controlpidunitidComboBox.currentText()))
                if str(self.btpidtypeComboBox.currentText()) == "Fuji PXG":
                    aw.ser.readBTpid[0] = 0
                    str2 = "Fuji PXG"
                elif str(self.btpidtypeComboBox.currentText()) == "Fuji PXR":
                    aw.ser.readBTpid[0] = 1
                    str2 = "Fuji PXR"
                elif str(self.btpidtypeComboBox.currentText()) == "None":
                    aw.ser.readBTpid[0] = 2
                    str2 = "None"
                elif str(self.btpidtypeComboBox.currentText()) == "Delta DTA":
                    aw.ser.readBTpid[0] = 3
                    str2 = "Delta DTA"
                aw.ser.readBTpid[1] =  int(str(self.btpidunitidComboBox.currentText()))
                #If fuji pid
                if str1 != "Delta DTA":
                    aw.qmc.device = 0
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'O'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                #else if DTA pid
                else:
                    aw.qmc.device = 26
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                message = QApplication.translate("Message","PID to control ET set to %1 %2" + \
                                                 " ; PID to read BT set to %3 %4", None, QApplication.UnicodeUTF8).arg(str1).arg(str(aw.ser.controlETpid[1])).arg(str2).arg(str(aw.ser.readBTpid[1]))
                aw.button_10.setVisible(True)
                aw.label6.setVisible(True)
                aw.lcd6.setVisible(True)
                aw.label7.setVisible(True)
                aw.lcd7.setVisible(True)
            elif self.arduinoButton.isChecked():
                aw.ser.arduinoETChannel = str(self.arduinoETComboBox.currentText())
                aw.ser.arduinoBTChannel = str(self.arduinoBTComboBox.currentText())
                aw.ser.arduinoATChannel = str(self.arduinoATComboBox.currentText())
                aw.qmc.arduino56active = bool(self.arduino56.isChecked())
                meter = "Arduino (TC4)"
                aw.qmc.device = 19
                aw.ser.baudrate = 19200
                aw.ser.bytesize = 8
                aw.ser.parity= 'N'
                aw.ser.stopbits = 1
                aw.ser.timeout = 1
                aw.ser.ArduinoIsInitialized = 0 # ensure the Arduino gets reinitalized if settings changed
                message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
                aw.button_10.setVisible(True)
            elif self.programButton.isChecked():
                meter = str(self.programedit.text())
                aw.ser.externalprogram = meter
                aw.qmc.device = 27
                message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
            elif self.nonpidButton.isChecked():
                meter = str(self.devicetypeComboBox.currentText())
                message = QApplication.translate("Error Message","Device error",None,QApplication.UnicodeUTF8)
                if meter == "Omega HH806AU":
                    aw.qmc.device = 1
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Omega HH506RA":
                    aw.qmc.device = 2
                    #aw.ser.comport = "/dev/tty.usbserial-A2001Epn"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 7
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    aw.ser.HH506RAid = "X" # ensure the HH506RA gets reinitalized if settings changed
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 309":
                    aw.qmc.device = 3
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 306":
                    aw.qmc.device = 4
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 305":
                    aw.qmc.device = 5
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to CENTER 305, which is equivalent to CENTER 306. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 304":
                    aw.qmc.device = 6
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 309. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 303":
                    aw.qmc.device = 7
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 302":
                    aw.qmc.device = 8
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 301":
                    aw.qmc.device = 9
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "CENTER 300":
                    aw.qmc.device = 10
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT K204":
                    aw.qmc.device = 11
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 309. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT K202":
                    aw.qmc.device = 12
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 306. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT 300K":
                    aw.qmc.device = 13
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT 302KJ":
                    aw.qmc.device = 14
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 303. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "EXTECH 421509":
                    aw.qmc.device = 15
                    #aw.ser.comport = "/dev/tty.usbserial-A2001Epn"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 7
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to Omega HH506RA. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Omega HH802U":
                    aw.qmc.device = 16
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to Omega HH806AU. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Omega HH309":
                    aw.qmc.device = 17
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                #special device manual mode. No serial settings.
                elif meter == "NONE":
                    aw.qmc.device = 18
                    message = QApplication.translate("Message","Device set to %1", None, QApplication.UnicodeUTF8).arg(meter)
                    st = ""
                    if aw.qmc.delay != 1000:
                        aw.qmc.delay = 1000
                        st += ". Sampling rate changed to 1 second"
                    # ensure that events button is shown
                    aw.eventsbuttonflag = 1
                    aw.button_11.setVisible(True)
                    message = QApplication.translate("Message","Device set to %1%2", None, QApplication.UnicodeUTF8).arg(meter).arg(st)
                elif meter == "TE VA18B":
                    aw.qmc.device = 20
                    #aw.ser.comport = "COM7"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 21 is +309_34 but +DEVICE cannot be set as main device
                ##########################                    
                ##########################
                ####  DEVICE 22 is +FUJI DUTY% but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Omega HHM28[6]":
                    aw.qmc.device = 23
                    #aw.ser.comport = "COM1"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, check Serial Port settings", None, QApplication.UnicodeUTF8).arg(meter)
# +DEVICEs cannot be set as main device
                elif meter == "+204_34":
                    aw.qmc.device = 24
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = ""  #empty message especial device                   
                ##########################
                ####  DEVICE 25 is +Virtual but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 26 is DTA pid
                ##########################
                ##########################
                ####  DEVICE 27 is an external program
                ##########################                   
                ##########################
                ####  DEVICE 28 is +ArduinoTC4_34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "MODBUS":
                    aw.qmc.device = 29
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 115200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "VOLTCRAFT K201":
                    aw.qmc.device = 30
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to CENTER 302. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                elif meter == "Amprobe TMD-56":
                    aw.qmc.device = 31
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1, which is equivalent to Omega HH806AU. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
                ##########################
                ####  DEVICE 32 is +ArduinoTC4_56 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 33 is +MODBUS_34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Omega HH806W":
                    aw.qmc.device = 34
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 38400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1
                    message = QApplication.translate("Message","Device set to %1. Now, chose serial port", None, QApplication.UnicodeUTF8).arg(meter)
        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
        # - add an elif entry above to specify the default serial settings                    
                # ensure that by selecting a real device, the initial sampling rate is set to 5s
                if meter != "NONE":
                    if aw.qmc.delay < 3000:
                        aw.qmc.delay = 3000
                #extra devices serial config
                #set of different serial settings modes options
                ssettings = [[9600,8,'O',1,2],[19200,8,'E',1,2],[2400,7,'E',1,2],[9600,8,'N',1,2],
                             [19200,8,'N',1,2],[2400,8,'N',1,2],[9600,8,'E',1,2],[38400,8,'E',1,2],[115200,8,'N',1,2]]
                #map device index to a setting mode (chose the one that matches the device)
        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
        # - add an entry to devsettings below (and potentially to ssettings above)                  
                devssettings = [0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1,3,0,4,5,3,6,5,3,3,6,3,4,8,3,1,4,7,8]  #0-34
                #init serial settings of extra devices
                for i in range(len(aw.qmc.extradevices)):
                    dsettings = ssettings[devssettings[aw.qmc.extradevices[i]]]
                    if i < len(aw.extrabaudrate):
                        aw.extrabaudrate[i] = dsettings[0]
                    else:
                        aw.extrabaudrate.append(dsettings[0])
                    if i < len(aw.extrabytesize):
                        aw.extrabytesize[i] = dsettings[1]
                    else:
                        aw.extrabytesize.append(dsettings[1])
                    if i < len(aw.extraparity): 
                        aw.extraparity[i] = dsettings[2]
                    else:
                        aw.extraparity.append(dsettings[2])
                    if i < len(aw.extrastopbits):
                        aw.extrastopbits[i] = dsettings[3]
                    else:
                        aw.extrastopbits.append(dsettings[3])
                    if i < len(aw.extratimeout):
                        aw.extratimeout[i] = dsettings[4]
                    else:
                        aw.extratimeout.append(dsettings[4])
                aw.button_10.setVisible(False)
                aw.button_12.setVisible(False)
                aw.button_13.setVisible(False)
                aw.button_14.setVisible(False)
                aw.button_15.setVisible(False)
                aw.button_16.setVisible(False)
                aw.button_17.setVisible(False)
                aw.label6.setVisible(False)
                aw.lcd6.setVisible(False)
                aw.label7.setVisible(False)
                aw.lcd7.setVisible(False)
            aw.qmc.ETfunction = str(self.ETfunctionedit.text())
            aw.qmc.BTfunction = str(self.BTfunctionedit.text())
            aw.qmc.ETcurve = self.ETcurve.isChecked()
            aw.qmc.BTcurve = self.BTcurve.isChecked()
            aw.qmc.ETlcd = self.ETlcd.isChecked()
            aw.qmc.BTlcd = self.BTlcd.isChecked()
            if aw.qmc.flagon:
                aw.LCD2frame.setVisible(aw.qmc.ETlcd)
                aw.LCD3frame.setVisible(aw.qmc.BTlcd)
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.sendmessage(message)
            #open serial conf Dialog
            #if device is not None or not external-program (don't need serial settings config)
            if aw.qmc.device != 18 and aw.qmc.device != 27:
                aw.setcommport()
            self.close()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " device accept(): %1").arg(str(e)),exc_tb.tb_lineno)

############################################################
#######################  CUSTOM COLOR DIALOG  ##############
############################################################

class graphColorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(graphColorDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Colors", None, QApplication.UnicodeUTF8))
        frameStyle = QFrame.Sunken | QFrame.Panel
        ## Translation: Right now the default palette colors are not translated (as they are used as-is)
        ##              We will add a translation list.
        #TAB1
        self.backgroundLabel = QLabel(aw.qmc.palette["background"])
        self.backgroundLabel.setPalette(QPalette(QColor(aw.qmc.palette["background"])))
        self.backgroundLabel.setAutoFillBackground(True)
        self.backgroundButton = QPushButton(QApplication.translate("Button","Background", None, QApplication.UnicodeUTF8))
        self.backgroundButton.setFocusPolicy(Qt.NoFocus)
        self.backgroundLabel.setFrameStyle(frameStyle)
        self.connect(self.backgroundButton, SIGNAL("clicked()"), lambda var=self.backgroundLabel,color="background": self.setColor("Background",var,color))
        self.gridLabel =QLabel(aw.qmc.palette["grid"])
        self.gridLabel.setPalette(QPalette(QColor(aw.qmc.palette["grid"])))
        self.gridLabel.setAutoFillBackground(True)
        self.gridButton = QPushButton(QApplication.translate("Button","Grid", None, QApplication.UnicodeUTF8))
        self.gridButton.setFocusPolicy(Qt.NoFocus)
        self.gridLabel.setFrameStyle(frameStyle)
        self.connect(self.gridButton, SIGNAL("clicked()"), lambda var=self.gridLabel, color= "grid": self.setColor("Grid",var,color))
        self.titleLabel =QLabel(aw.qmc.palette["title"])
        self.titleLabel.setPalette(QPalette(QColor(aw.qmc.palette["title"])))
        self.titleLabel.setAutoFillBackground(True)
        self.titleButton = QPushButton(QApplication.translate("Button","Title", None, QApplication.UnicodeUTF8))
        self.titleButton.setFocusPolicy(Qt.NoFocus)
        self.titleLabel.setFrameStyle(frameStyle)
        self.connect(self.titleButton, SIGNAL("clicked()"), lambda var=self.titleLabel,color="title": self.setColor("Title",var,color))
        self.yLabel =QLabel(aw.qmc.palette["ylabel"])
        self.yLabel.setPalette(QPalette(QColor(aw.qmc.palette["ylabel"])))
        self.yLabel.setAutoFillBackground(True)
        self.yButton = QPushButton(QApplication.translate("Button","Y Label", None, QApplication.UnicodeUTF8))
        self.yButton.setFocusPolicy(Qt.NoFocus)
        self.yLabel.setFrameStyle(frameStyle)
        self.connect(self.yButton, SIGNAL("clicked()"), lambda var=self.yLabel,color="ylabel": self.setColor("Y Label",var,color))
        self.xLabel =QLabel(aw.qmc.palette["xlabel"])
        self.xLabel.setPalette(QPalette(QColor(aw.qmc.palette["xlabel"])))
        self.xLabel.setAutoFillBackground(True)
        self.xButton = QPushButton(QApplication.translate("Button","X Label", None, QApplication.UnicodeUTF8))
        self.xButton.setFocusPolicy(Qt.NoFocus)
        self.xLabel.setFrameStyle(frameStyle)
        self.connect(self.xButton, SIGNAL("clicked()"), lambda var=self.xLabel,color="xlabel": self.setColor("X Label",var,color))
        self.rect1Label =QLabel(aw.qmc.palette["rect1"])
        self.rect1Label.setPalette(QPalette(QColor(aw.qmc.palette["rect1"])))
        self.rect1Label.setAutoFillBackground(True)
        self.rect1Button = QPushButton(QApplication.translate("Button","Drying Phase", None, QApplication.UnicodeUTF8))
        self.rect1Button.setFocusPolicy(Qt.NoFocus)
        self.rect1Label.setFrameStyle(frameStyle)
        self.connect(self.rect1Button, SIGNAL("clicked()"), lambda var=self.rect1Label,color="rect1": self.setColor("Drying Phase",var,color))
        self.rect2Label =QLabel(aw.qmc.palette["rect2"])
        self.rect2Label.setPalette(QPalette(QColor(aw.qmc.palette["rect2"])))
        self.rect2Label.setAutoFillBackground(True)
        self.rect2Button = QPushButton(QApplication.translate("Button","Maillard Phase", None, QApplication.UnicodeUTF8))
        self.rect2Button.setFocusPolicy(Qt.NoFocus)
        self.rect2Label.setFrameStyle(frameStyle)
        self.connect(self.rect2Button, SIGNAL("clicked()"), lambda var=self.rect2Label,color="rect2": self.setColor("Maillard Phase",var,color))
        self.rect3Label =QLabel(aw.qmc.palette["rect3"])
        self.rect3Label.setPalette(QPalette(QColor(aw.qmc.palette["rect3"])))
        self.rect3Label.setAutoFillBackground(True)
        self.rect3Button = QPushButton(QApplication.translate("Button","Development Phase", None, QApplication.UnicodeUTF8))
        self.rect3Button.setFocusPolicy(Qt.NoFocus)
        self.rect3Label.setFrameStyle(frameStyle)
        self.connect(self.rect3Button, SIGNAL("clicked()"), lambda var=self.rect3Label,color="rect3": self.setColor("Development Phase",var,color))
        self.rect4Label =QLabel(aw.qmc.palette["rect4"])
        self.rect4Label.setPalette(QPalette(QColor(aw.qmc.palette["rect4"])))
        self.rect4Label.setAutoFillBackground(True)
        self.rect4Button = QPushButton(QApplication.translate("Button","Cooling Phase", None, QApplication.UnicodeUTF8))
        self.rect4Button.setFocusPolicy(Qt.NoFocus)
        self.rect4Label.setFrameStyle(frameStyle)
        self.connect(self.rect4Button, SIGNAL("clicked()"), lambda var=self.rect4Label,color="rect4": self.setColor("Cooling Phase",var,color))
        self.metLabel =QLabel(aw.qmc.palette["et"])
        self.metLabel.setPalette(QPalette(QColor(aw.qmc.palette["et"])))
        self.metLabel.setAutoFillBackground(True)
        self.metButton = QPushButton(QApplication.translate("Button","ET", None, QApplication.UnicodeUTF8))
        self.metButton.setFocusPolicy(Qt.NoFocus)
        self.metLabel.setFrameStyle(frameStyle)
        self.connect(self.metButton, SIGNAL("clicked()"), lambda var=self.metLabel,color="et": self.setColor("ET",var,color))
        self.btLabel =QLabel(aw.qmc.palette["bt"])
        self.btLabel.setPalette(QPalette(QColor(aw.qmc.palette["bt"])))
        self.btLabel.setAutoFillBackground(True)
        self.btButton = QPushButton(QApplication.translate("Button","BT", None, QApplication.UnicodeUTF8))
        self.btButton.setFocusPolicy(Qt.NoFocus)
        self.btLabel.setFrameStyle(frameStyle)
        self.connect(self.btButton, SIGNAL("clicked()"), lambda var=self.btLabel,color="bt": self.setColor("BT",var,color))
        self.deltametLabel =QLabel(aw.qmc.palette["deltaet"])
        self.deltametLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltaet"])))
        self.deltametLabel.setAutoFillBackground(True)
        self.deltametButton = QPushButton(QApplication.translate("Button","DeltaET", None, QApplication.UnicodeUTF8))
        self.deltametButton.setFocusPolicy(Qt.NoFocus)
        self.deltametLabel.setFrameStyle(frameStyle)
        self.connect(self.deltametButton, SIGNAL("clicked()"), lambda var=self.deltametLabel,color="deltaet": self.setColor("DeltaET",var,color))
        self.deltabtLabel =QLabel(aw.qmc.palette["deltabt"])
        self.deltabtLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltabt"])))
        self.deltabtLabel.setAutoFillBackground(True)
        self.deltabtButton = QPushButton(QApplication.translate("Button","DeltaBT", None, QApplication.UnicodeUTF8))
        self.deltabtButton.setFocusPolicy(Qt.NoFocus)
        self.deltabtLabel.setFrameStyle(frameStyle)
        self.connect(self.deltabtButton, SIGNAL("clicked()"), lambda var=self.deltabtLabel,color="deltabt": self.setColor("DeltaBT",var,color))
        self.markersLabel =QLabel(aw.qmc.palette["markers"])
        self.markersLabel.setPalette(QPalette(QColor(aw.qmc.palette["markers"])))
        self.markersLabel.setAutoFillBackground(True)
        self.markersButton = QPushButton(QApplication.translate("Button","Markers", None, QApplication.UnicodeUTF8))
        self.markersButton.setFocusPolicy(Qt.NoFocus)
        self.markersLabel.setFrameStyle(frameStyle)
        self.connect(self.markersButton, SIGNAL("clicked()"), lambda var=self.markersLabel,color="markers": self.setColor("Markers",var,color))
        self.textLabel =QLabel(aw.qmc.palette["text"])
        self.textLabel.setPalette(QPalette(QColor(aw.qmc.palette["text"])))
        self.textLabel.setAutoFillBackground(True)
        self.textButton = QPushButton(QApplication.translate("Button","Text", None, QApplication.UnicodeUTF8))
        self.textButton.setFocusPolicy(Qt.NoFocus)
        self.textLabel.setFrameStyle(frameStyle)
        self.connect(self.textButton, SIGNAL("clicked()"), lambda var=self.textLabel,color="text": self.setColor("Text",var,color))
        self.watermarksLabel =QLabel(aw.qmc.palette["watermarks"])
        self.watermarksLabel.setPalette(QPalette(QColor(aw.qmc.palette["watermarks"])))
        self.watermarksLabel.setAutoFillBackground(True)
        self.watermarksButton = QPushButton(QApplication.translate("Button","Watermarks", None, QApplication.UnicodeUTF8))
        self.watermarksButton.setFocusPolicy(Qt.NoFocus)
        self.watermarksLabel.setFrameStyle(frameStyle)
        self.connect(self.watermarksButton, SIGNAL("clicked()"), lambda var=self.watermarksLabel,color="watermarks": self.setColor("Watermarks",var,color))
        self.ClineLabel =QLabel(aw.qmc.palette["Cline"])
        self.ClineLabel.setPalette(QPalette(QColor(aw.qmc.palette["Cline"])))
        self.ClineLabel.setAutoFillBackground(True)
        self.ClineButton = QPushButton(QApplication.translate("Button","C Lines", None, QApplication.UnicodeUTF8))
        self.ClineButton.setFocusPolicy(Qt.NoFocus)
        self.ClineLabel.setFrameStyle(frameStyle)
        self.connect(self.ClineButton, SIGNAL("clicked()"), lambda var=self.ClineLabel,color="Cline": self.setColor("C Lines",var,color))
        okButton = QPushButton(QApplication.translate("Button","OK", None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self, SLOT("accept()"))
        defaultsButton = QPushButton(QApplication.translate("Button","Defaults", None, QApplication.UnicodeUTF8))
        defaultsButton.setFocusPolicy(Qt.NoFocus)
        self.connect(defaultsButton, SIGNAL("clicked()"),lambda x=1:self.recolor(x))
        greyButton = QPushButton(QApplication.translate("Button","Grey", None, QApplication.UnicodeUTF8))
        greyButton.setFocusPolicy(Qt.NoFocus)
        self.connect(greyButton, SIGNAL("clicked()"),lambda x=2:self.recolor(x))
        #TAB 2
        #use indexes to translate
        self.lcdcolors = ["","grey","darkGrey","slateGrey","lightGray","black","white","transparent"]     #this one is not to be translated as arguments need to be in English
        lcdcolorstranslate = ["",
                              QApplication.translate("ComboBox","grey",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Dark Grey",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Slate Grey",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Light Gray",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Black",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","White",None, QApplication.UnicodeUTF8),
                              QApplication.translate("ComboBox","Transparent",None, QApplication.UnicodeUTF8)]  # translated
        self.lcd1colorComboBox =  QComboBox()
        self.lcd1colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd1colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd1colorComboBox.currentText(),flag = 2,x=1:self.paintlcds(text,flag,x))
        self.lcd2colorComboBox =  QComboBox()
        self.lcd2colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd2colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd2colorComboBox.currentText(),flag = 2,x=2:self.paintlcds(text,flag,x))
        self.lcd3colorComboBox =  QComboBox()
        self.lcd3colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd3colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd3colorComboBox.currentText(),flag = 2,x=3:self.paintlcds(text,flag,x))
        self.lcd4colorComboBox =  QComboBox()
        self.lcd4colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd4colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd4colorComboBox.currentText(),flag = 2,x=4:self.paintlcds(text,flag,x))
        self.lcd5colorComboBox =  QComboBox()
        self.lcd5colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd5colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd5colorComboBox.currentText(),flag = 2,x=5:self.paintlcds(text,flag,x))
        self.lcd6colorComboBox =  QComboBox()
        self.lcd6colorComboBox.addItems(lcdcolorstranslate)
        self.connect(self.lcd6colorComboBox, SIGNAL("currentIndexChanged(QString)"),lambda text = self.lcd6colorComboBox.currentText(),flag = 2,x=6:self.paintlcds(text,flag,x))
        lcd1backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd1backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=1:self.paintlcds(text,flag,x))
        lcd2backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd2backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=2:self.paintlcds(text,flag,x))
        lcd3backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd3backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=3:self.paintlcds(text,flag,x))
        lcd4backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd4backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=4:self.paintlcds(text,flag,x))
        lcd5backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd5backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=5:self.paintlcds(text,flag,x))
        lcd6backButton = QPushButton(QApplication.translate("Button","Background",None, QApplication.UnicodeUTF8))
        self.connect(lcd6backButton, SIGNAL("clicked()"),lambda text =0,flag=0,x=6:self.paintlcds(text,flag,x))
        lcd1LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd1LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=1:self.paintlcds(text,flag,x))
        lcd2LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd2LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=2:self.paintlcds(text,flag,x))
        lcd3LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd3LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=3:self.paintlcds(text,flag,x))
        lcd4LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd4LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=4:self.paintlcds(text,flag,x))
        lcd5LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd5LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=5:self.paintlcds(text,flag,x))
        lcd6LEDButton = QPushButton(QApplication.translate("Button","LED",None, QApplication.UnicodeUTF8))
        self.connect(lcd6LEDButton, SIGNAL("clicked()"),lambda text =0,flag=1,x=6:self.paintlcds(text,flag,x))
        self.lcd1spinbox = QSpinBox()
        self.lcd1spinbox.setSingleStep(10)
        self.lcd1spinbox.setMaximum(359)
        self.lcd1spinbox.setWrapping(True)
        self.connect(self.lcd1spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd1spinbox.value(),lcd=1:self.setLED(val,lcd))
        self.lcd2spinbox = QSpinBox()
        self.lcd2spinbox.setSingleStep(10)
        self.lcd2spinbox.setWrapping(True)
        self.lcd2spinbox.setMaximum(359)
        self.connect(self.lcd2spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd2spinbox.value(),lcd=2:self.setLED(val,lcd))
        self.lcd3spinbox = QSpinBox()
        self.lcd3spinbox.setSingleStep(10)
        self.lcd3spinbox.setWrapping(True)
        self.lcd3spinbox.setMaximum(359)
        self.connect(self.lcd3spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd3spinbox.value(),lcd=3:self.setLED(val,lcd))
        self.lcd4spinbox = QSpinBox()
        self.lcd4spinbox.setSingleStep(10)
        self.lcd4spinbox.setWrapping(True)
        self.lcd4spinbox.setMaximum(359)
        self.connect(self.lcd4spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd4spinbox.value(),lcd=4:self.setLED(val,lcd))
        self.lcd5spinbox = QSpinBox()
        self.lcd5spinbox.setSingleStep(10)
        self.lcd1spinbox.setWrapping(True)
        self.lcd5spinbox.setMaximum(359)
        self.connect(self.lcd5spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd5spinbox.value(),lcd=5:self.setLED(val,lcd))
        self.lcd6spinbox = QSpinBox()
        self.lcd6spinbox.setSingleStep(10)
        self.lcd1spinbox.setWrapping(True)
        self.lcd6spinbox.setMaximum(359)
        self.connect(self.lcd6spinbox, SIGNAL("valueChanged(int)"),lambda val=self.lcd6spinbox.value(),lcd=6:self.setLED(val,lcd))
        LCDdefaultButton = QPushButton(QApplication.translate("Button","B/W",None, QApplication.UnicodeUTF8))
        self.connect(LCDdefaultButton, SIGNAL("clicked()"),self.setLCDdefaults)
        #LAYOUTS
        #tab1 layout
        grid = QGridLayout()
        grid.setColumnStretch(1,10)
        grid.setColumnMinimumWidth(1,200)
        grid.addWidget(self.backgroundButton,0,0)
        grid.addWidget(self.backgroundLabel,0,1)
        grid.addWidget(self.titleButton,1,0)
        grid.addWidget(self.titleLabel,1,1)
        grid.addWidget(self.gridButton,2,0)
        grid.addWidget(self.gridLabel,2,1)
        grid.addWidget(self.metButton,3,0)
        grid.addWidget(self.metLabel,3,1)
        grid.addWidget(self.btButton,4,0)
        grid.addWidget(self.btLabel,4,1)
        grid.addWidget(self.deltametButton,5,0)
        grid.addWidget(self.deltametLabel,5,1)
        grid.addWidget(self.deltabtButton,6,0)
        grid.addWidget(self.deltabtLabel,6,1)
        grid.addWidget(self.yButton,7,0)
        grid.addWidget(self.yLabel,7,1)
        grid.addWidget(self.xButton,8,0)
        grid.addWidget(self.xLabel,8,1)
        grid.addWidget(self.rect1Button,9,0)
        grid.addWidget(self.rect1Label,9,1)
        grid.addWidget(self.rect2Button,10,0)
        grid.addWidget(self.rect2Label,10,1)
        grid.addWidget(self.rect3Button,11,0)
        grid.addWidget(self.rect3Label,11,1)
        grid.addWidget(self.rect4Button,12,0)
        grid.addWidget(self.rect4Label,12,1)
        grid.addWidget(self.markersButton,13,0)
        grid.addWidget(self.markersLabel,13,1)
        grid.addWidget(self.textButton,14,0)
        grid.addWidget(self.textLabel,14,1)
        grid.addWidget(self.watermarksButton,15,0)
        grid.addWidget(self.watermarksLabel,15,1)
        grid.addWidget(self.ClineButton,16,0)
        grid.addWidget(self.ClineLabel,16,1)
        defaultsLayout = QHBoxLayout()
        defaultsLayout.addStretch()
        defaultsLayout.addWidget(greyButton)
        defaultsLayout.addWidget(defaultsButton)
        defaultsLayout.addWidget(okButton)
        grid.addLayout(defaultsLayout,17,1)
        graphLayout = QVBoxLayout()
        graphLayout.addLayout(grid)
        #tab 2
        lcdlayout = QVBoxLayout()
        lcd1layout = QHBoxLayout()
        lcd1layout.addWidget(lcd1backButton,0)
        lcd1layout.addWidget(self.lcd1colorComboBox,1)
        lcd1layout.addWidget(lcd1LEDButton,2)
        lcd1layout.addWidget(self.lcd1spinbox,3)
        lcd2layout = QHBoxLayout()
        lcd2layout.addWidget(lcd2backButton,0)
        lcd2layout.addWidget(self.lcd2colorComboBox,1)
        lcd2layout.addWidget(lcd2LEDButton,2)
        lcd2layout.addWidget(self.lcd2spinbox,3)
        lcd3layout = QHBoxLayout()
        lcd3layout.addWidget(lcd3backButton,0)
        lcd3layout.addWidget(self.lcd3colorComboBox,1)
        lcd3layout.addWidget(lcd3LEDButton,2)
        lcd3layout.addWidget(self.lcd3spinbox,3)
        lcd4layout = QHBoxLayout()
        lcd4layout.addWidget(lcd4backButton,0)
        lcd4layout.addWidget(self.lcd4colorComboBox,1)
        lcd4layout.addWidget(lcd4LEDButton,2)
        lcd4layout.addWidget(self.lcd4spinbox,3)
        lcd5layout = QHBoxLayout()
        lcd5layout.addWidget(lcd5backButton,0)
        lcd5layout.addWidget(self.lcd5colorComboBox,1)
        lcd5layout.addWidget(lcd5LEDButton,2)
        lcd5layout.addWidget(self.lcd5spinbox,3)
        lcd6layout = QHBoxLayout()
        lcd6layout.addWidget(lcd6backButton,0)
        lcd6layout.addWidget(self.lcd6colorComboBox,1)
        lcd6layout.addWidget(lcd6LEDButton,2)
        lcd6layout.addWidget(self.lcd6spinbox,3)
        LCD1GroupLayout = QGroupBox(QApplication.translate("GroupBox","Timer LCD",None, QApplication.UnicodeUTF8))
        LCD1GroupLayout.setLayout(lcd1layout)
        LCD2GroupLayout = QGroupBox(QApplication.translate("GroupBox","ET LCD",None, QApplication.UnicodeUTF8))
        LCD2GroupLayout.setLayout(lcd2layout)
        LCD3GroupLayout = QGroupBox(QApplication.translate("GroupBox","BT LCD",None, QApplication.UnicodeUTF8))
        LCD3GroupLayout.setLayout(lcd3layout)
        LCD4GroupLayout = QGroupBox(QApplication.translate("GroupBox","DeltaET LCD",None, QApplication.UnicodeUTF8))
        LCD4GroupLayout.setLayout(lcd4layout)
        LCD5GroupLayout = QGroupBox(QApplication.translate("GroupBox","DeltaBT LCD",None, QApplication.UnicodeUTF8))
        LCD5GroupLayout.setLayout(lcd5layout)
        LCD6GroupLayout = QGroupBox(QApplication.translate("GroupBox","Extra Devices / PID SV LCD",None, QApplication.UnicodeUTF8))
        LCD6GroupLayout.setLayout(lcd6layout)
        buttonlayout  = QHBoxLayout()
        buttonlayout.addStretch()
        buttonlayout.addWidget(LCDdefaultButton)
        lcdlayout.addWidget(LCD1GroupLayout)
        lcdlayout.addWidget(LCD2GroupLayout)
        lcdlayout.addWidget(LCD3GroupLayout)
        lcdlayout.addWidget(LCD4GroupLayout)
        lcdlayout.addWidget(LCD5GroupLayout)
        lcdlayout.addWidget(LCD6GroupLayout)
        lcdlayout.addLayout(buttonlayout)
        ###################################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(graphLayout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","Graph",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(lcdlayout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","LCDs",None, QApplication.UnicodeUTF8))
        okLayout = QHBoxLayout()
        okLayout.addStretch()
        okLayout.addWidget(okButton)
        okLayout.setMargin(0)
        okLayout.setContentsMargins(0, 0, 0, 0)
        TabWidget.setContentsMargins(0, 0, 0, 0)
        C1Widget.setContentsMargins(0, 0, 0, 0)
        C2Widget.setContentsMargins(0, 0, 0, 0)
        graphLayout.setMargin(0)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(okLayout)
        Mlayout.setMargin(10)
        Mlayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(Mlayout)

    def setLCDdefaults(self):
        aw.lcdpaletteB["timer"] = "black"
        aw.lcdpaletteF["timer"] = "white"
        aw.lcdpaletteB["et"] = "black"
        aw.lcdpaletteF["et"] = "white"
        aw.lcdpaletteB["bt"] = "black"
        aw.lcdpaletteF["bt"] = "white"
        aw.lcdpaletteB["deltaet"] = "black"
        aw.lcdpaletteF["deltaet"] = "white"
        aw.lcdpaletteB["deltabt"] = "black"
        aw.lcdpaletteF["deltabt"] = "white"
        aw.lcdpaletteB["sv"] = "black"
        aw.lcdpaletteF["sv"] = "white"
        aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        aw.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        aw.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        aw.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        aw.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        aw.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        aw.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        aw.updateExtraLCDvisibility()

    def setLED(self,hue,lcd):
        if lcd == 1:
            color = QColor(aw.lcdpaletteF["timer"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["timer"] = str(color.name())
            aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        elif lcd == 2:
            color = QColor(aw.lcdpaletteF["et"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["et"] = str(color.name())
            aw.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        elif lcd == 3:
            color = QColor(aw.lcdpaletteF["bt"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["bt"] = str(color.name())
            aw.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        elif lcd == 4:
            color = QColor(aw.lcdpaletteF["deltaet"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["deltaet"] = str(color.name())
            aw.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        elif lcd == 5:
            color = QColor(aw.lcdpaletteF["deltabt"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["deltabt"] = str(color.name())
            aw.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        elif lcd == 6:
            color = QColor(aw.lcdpaletteF["sv"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["sv"] = str(color.name())
            aw.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))

    def paintlcds(self,text,flag,lcdnumber):
        if lcdnumber ==1:
            if flag == 0:
                aw.lcdpaletteB["timer"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteB["timer"]),self)).name())
            elif flag == 1:
                aw.lcdpaletteF["timer"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteF["timer"]),self)).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["timer"] = self.lcdcolors[self.lcd1colorComboBox.currentIndex()]
            aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        if lcdnumber ==2:
            if flag == 0:
                aw.lcdpaletteB["et"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteB["et"]),self)).name())
            elif flag == 1:
                aw.lcdpaletteF["et"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteF["et"]),self)).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["et"] = self.lcdcolors[self.lcd2colorComboBox.currentIndex()]
            aw.lcd2.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        if lcdnumber ==3:
            if flag == 0:
                aw.lcdpaletteB["bt"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteB["bt"]),self)).name())
            elif flag == 1:
                aw.lcdpaletteF["bt"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteF["bt"]),self)).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["bt"] = self.lcdcolors[self.lcd3colorComboBox.currentIndex()]
            aw.lcd3.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        if lcdnumber ==4:
            if flag == 0:
                aw.lcdpaletteB["deltaet"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteB["deltaet"]),self)).name())
            elif flag == 1:
                aw.lcdpaletteF["deltaet"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteF["deltaet"]),self)).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["deltaet"] = self.lcdcolors[self.lcd4colorComboBox.currentIndex()]
            aw.lcd4.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        if lcdnumber ==5:
            if flag == 0:
                aw.lcdpaletteB["deltabt"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteB["deltabt"]),self)).name())
            elif flag == 1:
                aw.lcdpaletteF["deltabt"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteF["deltabt"]),self)).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["deltabt"] = self.lcdcolors[self.lcd5colorComboBox.currentIndex()]
            aw.lcd5.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        if lcdnumber ==6:
            if flag == 0:
                aw.lcdpaletteB["sv"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteB["sv"]),self)).name())
            elif flag == 1:
                aw.lcdpaletteF["sv"] = str((QColorDialog.getColor(QColor(aw.lcdpaletteF["sv"]),self)).name())
            elif flag == 2 and text:
                aw.lcdpaletteB["sv"] = self.lcdcolors[self.lcd6colorComboBox.currentIndex()]
            aw.lcd6.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.lcd7.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.updateExtraLCDvisibility()

    # adds a new event to the Dlg
    def recolor(self, x):
        aw.qmc.changeGColor(x)
        self.gridLabel.setText(aw.qmc.palette["grid"])
        self.gridLabel.setPalette(QPalette(QColor(aw.qmc.palette["grid"])))
        self.backgroundLabel.setText(aw.qmc.palette["background"])
        self.backgroundLabel.setPalette(QPalette(QColor(aw.qmc.palette["background"])))
        self.titleLabel.setText(aw.qmc.palette["title"])
        self.titleLabel.setPalette(QPalette(QColor(aw.qmc.palette["title"])))
        self.yLabel.setText(aw.qmc.palette["ylabel"])
        self.yLabel.setPalette(QPalette(QColor(aw.qmc.palette["ylabel"])))
        self.xLabel.setText(aw.qmc.palette["xlabel"])
        self.xLabel.setPalette(QPalette(QColor(aw.qmc.palette["xlabel"])))
        self.rect1Label.setText(aw.qmc.palette["rect1"])
        self.rect1Label.setPalette(QPalette(QColor(aw.qmc.palette["rect1"])))
        self.rect2Label.setText(aw.qmc.palette["rect2"])
        self.rect2Label.setPalette(QPalette(QColor(aw.qmc.palette["rect2"])))
        self.rect3Label.setText(aw.qmc.palette["rect3"])
        self.rect3Label.setPalette(QPalette(QColor(aw.qmc.palette["rect3"])))
        self.rect4Label.setText(aw.qmc.palette["rect4"])
        self.rect4Label.setPalette(QPalette(QColor(aw.qmc.palette["rect4"])))
        self.metLabel.setText(aw.qmc.palette["et"])
        self.metLabel.setPalette(QPalette(QColor(aw.qmc.palette["et"])))
        self.btLabel.setText(aw.qmc.palette["bt"])
        self.btLabel.setPalette(QPalette(QColor(aw.qmc.palette["bt"])))
        self.deltametLabel.setText(aw.qmc.palette["deltaet"])
        self.deltametLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltaet"])))
        self.deltabtLabel.setText(aw.qmc.palette["deltabt"])
        self.deltabtLabel.setPalette(QPalette(QColor(aw.qmc.palette["deltabt"])))
        self.markersLabel.setText(aw.qmc.palette["markers"])
        self.markersLabel.setPalette(QPalette(QColor(aw.qmc.palette["markers"])))
        self.textLabel.setText(aw.qmc.palette["text"])
        self.textLabel.setPalette(QPalette(QColor(aw.qmc.palette["text"])))
        self.watermarksLabel.setText(aw.qmc.palette["watermarks"])
        self.watermarksLabel.setPalette(QPalette(QColor(aw.qmc.palette["watermarks"])))
        self.ClineLabel.setText(aw.qmc.palette["Cline"])
        self.ClineLabel.setPalette(QPalette(QColor(aw.qmc.palette["Cline"])))

    def setColor(self,title,var,color):
        labelcolor = QColor(aw.qmc.palette[color])
        colorf = QColorDialog.getColor(labelcolor,self)
        if colorf.isValid():
            aw.qmc.palette[color] = str(colorf.name())
            var.setText(colorf.name())
            var.setPalette(QPalette(colorf))
            var.setAutoFillBackground(True)
            aw.qmc.fig.canvas.redraw(recomputeAllDeltas=False)
            if title == "ET":
                aw.setLabelColor(aw.label2,QColor(aw.qmc.palette[color]))
            elif title == "BT":
                aw.setLabelColor(aw.label3,QColor(aw.qmc.palette[color]))
            elif title == "DeltaET":
                aw.setLabelColor(aw.label4,QColor(aw.qmc.palette[color]))
            elif title == "DeltaBT":
                aw.setLabelColor(aw.label5,QColor(aw.qmc.palette[color]))
            aw.sendmessage(QApplication.translate("Message","Color of %1 set to %2", None, QApplication.UnicodeUTF8).arg(title).arg(str(aw.qmc.palette[color])))


############################################################
#######################  WHEEL GRAPH CONFIG DIALOG  ########
############################################################

class WheelDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(WheelDlg,self).__init__(parent)
        self.setModal(False)
        self.setWindowTitle(QApplication.translate("Form Caption","Wheel Graph Editor",None, QApplication.UnicodeUTF8))
        self.viewmodeflag = False
        #table for alarms
        self.datatable = QTableWidget()
        self.createdatatable()
        #table for labels
        self.labeltable = QTableWidget()
        self.labelCloseButton = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        self.connect(self.labelCloseButton, SIGNAL("clicked()"),self.closelabels)
        self.labelResetButton = QPushButton(QApplication.translate("Button","Reset Parents",None, QApplication.UnicodeUTF8))
        self.labelResetButton.setToolTip(QApplication.translate("Tooltip","Erases wheel parent hierarchy",None, QApplication.UnicodeUTF8))
        self.connect(self.labelResetButton, SIGNAL("clicked()"),self.resetlabelparents)
        self.labelwheelx = 0   #index of wheel being edited on labeltable
        self.hierarchyButton = QPushButton(QApplication.translate("Button","Reverse Hierarchy",None, QApplication.UnicodeUTF8))
        self.hierarchyButton.setToolTip(QApplication.translate("Tooltip","Sets graph hierarchy child->parent instead of parent->child",None, QApplication.UnicodeUTF8))
        self.connect(self.hierarchyButton, SIGNAL("clicked()"),aw.qmc.setWheelHierarchy)
        self.labeltable.setVisible(False)
        self.labelCloseButton.setVisible(False)
        self.labelResetButton.setVisible(False)
        aspectlabel = QLabel(QApplication.translate("Label","Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox = QDoubleSpinBox()
        self.aspectSpinBox.setToolTip(QApplication.translate("Tooltip","Aspect Ratio",None, QApplication.UnicodeUTF8))
        self.aspectSpinBox.setRange(0.,2.)
        self.aspectSpinBox.setSingleStep(.1)
        self.aspectSpinBox.setValue(aw.qmc.wheelaspect)
        self.connect(self.aspectSpinBox, SIGNAL("valueChanged(double)"),self.setaspect)
        txtlabel = QLabel(QApplication.translate("Label","Text",None, QApplication.UnicodeUTF8))
        txtButtonplus = QPushButton(QApplication.translate("Button","+",None, QApplication.UnicodeUTF8))
        txtButtonplus.setToolTip(QApplication.translate("Tooltip","Increase size of text in all the graph",None, QApplication.UnicodeUTF8))
        self.connect(txtButtonplus, SIGNAL("clicked()"),lambda x = 1: self.changetext(x))
        txtButtonminus = QPushButton(QApplication.translate("Button","-",None, QApplication.UnicodeUTF8))
        txtButtonminus.setToolTip(QApplication.translate("Tooltip","Decrease size of text in all the graph",None, QApplication.UnicodeUTF8))
        self.connect(txtButtonminus, SIGNAL("clicked()"),lambda x = 0: self.changetext(x))
        edgelabel = QLabel(QApplication.translate("Label","Edge",None, QApplication.UnicodeUTF8))
        self.edgeSpinBox = QSpinBox()
        self.edgeSpinBox.setToolTip(QApplication.translate("Tooltip","Decorative edge beween wheels",None, QApplication.UnicodeUTF8))
        self.edgeSpinBox.setRange(0,5)
        self.edgeSpinBox.setValue(int(aw.qmc.wheeledge*100))
        self.connect(self.edgeSpinBox, SIGNAL("valueChanged(int)"),self.setedge)
        linewidthlabel = QLabel(QApplication.translate("Label","Line",None, QApplication.UnicodeUTF8))
        self.linewidthSpinBox = QSpinBox()
        self.linewidthSpinBox.setToolTip(QApplication.translate("Tooltip","Line thickness",None, QApplication.UnicodeUTF8))
        self.linewidthSpinBox.setRange(0,20)
        self.linewidthSpinBox.setValue(aw.qmc.wheellinewidth)
        self.connect(self.linewidthSpinBox, SIGNAL("valueChanged(int)"),self.setlinewidth)
        linecolor = QPushButton(QApplication.translate("Button","Line Color",None, QApplication.UnicodeUTF8))
        linecolor.setToolTip(QApplication.translate("Tooltip","Line color",None, QApplication.UnicodeUTF8))
        self.connect(linecolor, SIGNAL("clicked()"),self.setlinecolor)
        colorlabel = QLabel(QApplication.translate("Label","Color pattern",None, QApplication.UnicodeUTF8))
        self.colorSpinBox = QSpinBox()
        self.colorSpinBox.setToolTip(QApplication.translate("Tooltip","Apply color pattern to whole graph",None, QApplication.UnicodeUTF8))
        self.colorSpinBox.setRange(0,255)
        self.colorSpinBox.setValue(aw.qmc.wheelcolorpattern)
        self.colorSpinBox.setWrapping(True)
        self.connect(self.colorSpinBox, SIGNAL("valueChanged(int)"),self.setcolorpattern)
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        addButton.setToolTip(QApplication.translate("Tooltip","Add new wheel",None, QApplication.UnicodeUTF8))
        self.connect(addButton, SIGNAL("clicked()"),self.insertwheel)
        rotateLeftButton = QPushButton(QApplication.translate("Button","<",None, QApplication.UnicodeUTF8))
        rotateLeftButton.setToolTip(QApplication.translate("Tooltip","Rotate graph 1 degree counter clockwise",None, QApplication.UnicodeUTF8))
        self.connect(rotateLeftButton, SIGNAL("clicked()"),lambda x = 1: self.rotatewheels(x))
        rotateRightButton = QPushButton(QApplication.translate("Button",">",None, QApplication.UnicodeUTF8))
        rotateRightButton.setToolTip(QApplication.translate("Tooltip","Rotate graph 1 degree clockwise",None, QApplication.UnicodeUTF8))
        self.connect(rotateRightButton, SIGNAL("clicked()"),lambda x = 0: self.rotatewheels(x))
        saveButton = QPushButton(QApplication.translate("Button","Save File",None, QApplication.UnicodeUTF8))
        self.connect(saveButton, SIGNAL("clicked()"),self.fileSave)
        saveButton.setToolTip(QApplication.translate("Tooltip","Save graph to a text file.wg",None, QApplication.UnicodeUTF8))
        saveImgButton = QPushButton(QApplication.translate("Button","Save Img",None, QApplication.UnicodeUTF8))
        saveImgButton.setToolTip(QApplication.translate("Tooltip","Save image using current graph size to a png format",None, QApplication.UnicodeUTF8))
        self.connect(saveImgButton, SIGNAL("clicked()"),lambda x=0,i=1:aw.resize(x,i))
        viewModeButton = QPushButton(QApplication.translate("Button","View Mode",None, QApplication.UnicodeUTF8))
        viewModeButton.setToolTip(QApplication.translate("Tooltip","Sets Wheel graph to view mode",None, QApplication.UnicodeUTF8))
        self.connect(viewModeButton, SIGNAL("clicked()"),self.viewmode)
        openButton = QPushButton(QApplication.translate("Button","Open",None, QApplication.UnicodeUTF8))
        openButton.setToolTip(QApplication.translate("Tooltip","open graph file.wg",None, QApplication.UnicodeUTF8))
        self.connect(openButton, SIGNAL("clicked()"),self.loadWheel)
        closeButton = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        closeButton.setToolTip(QApplication.translate("Tooltip","Close wheel graph editor",None, QApplication.UnicodeUTF8))
        self.connect(closeButton, SIGNAL("clicked()"),self.close)
        aw.qmc.drawWheel()
        label1layout = QVBoxLayout()
        label2layout = QHBoxLayout()
        label1layout.addWidget(self.labeltable)
        label2layout.addWidget(self.labelCloseButton)
        label2layout.addWidget(self.labelResetButton)
        label1layout.addLayout(label2layout)
        self.labelGroupLayout = QGroupBox(QApplication.translate("GroupBox","Label Properties",None, QApplication.UnicodeUTF8))
        self.labelGroupLayout.setLayout(label1layout)
        self.labelGroupLayout.setVisible(False)
        buttonlayout = QHBoxLayout()
        buttonlayout.addWidget(openButton)
        buttonlayout.addWidget(saveButton)
        buttonlayout.addWidget(saveImgButton)
        buttonlayout.addWidget(viewModeButton)
        buttonlayout.addWidget(closeButton)
        configlayout =  QHBoxLayout()
        configlayout.addWidget(colorlabel)
        configlayout.addWidget(self.colorSpinBox)
        configlayout.addWidget(aspectlabel)
        configlayout.addWidget(self.aspectSpinBox)
        configlayout.addWidget(edgelabel)
        configlayout.addWidget(self.edgeSpinBox)
        configlayout.addWidget(linewidthlabel)
        configlayout.addWidget(self.linewidthSpinBox)
        configlayout.addWidget(linecolor)
        configlayout.addWidget(txtlabel)
        configlayout.addWidget(txtButtonplus)
        configlayout.addWidget(txtButtonminus)
        controlLayout = QHBoxLayout()
        controlLayout.addWidget(addButton)
        controlLayout.addWidget(rotateLeftButton)
        controlLayout.addWidget(rotateRightButton)
        controlLayout.addWidget(self.hierarchyButton)
        mainlayout = QVBoxLayout()
        mainlayout.addWidget(self.datatable)
        mainlayout.addWidget(self.labelGroupLayout)
        mainlayout.addLayout(controlLayout)
        mainlayout.addLayout(configlayout)
        mainlayout.addLayout(buttonlayout)
        self.setLayout(mainlayout)

    #creates config table for wheel with index x
    def createlabeltable(self,x):
        self.labelwheelx = x                    #wheel being edited
        self.labelGroupLayout.setVisible(True)
        self.labeltable.setVisible(True)
        self.labelCloseButton.setVisible(True)
        self.labelResetButton.setVisible(True)
        self.labeltable.clear()
        nlabels = len(aw.qmc.wheelnames[x])
        if nlabels:
            self.labeltable.setRowCount(nlabels)
            self.labeltable.setColumnCount(5)
            self.labeltable.setHorizontalHeaderLabels([QApplication.translate("Table","Label",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Parent",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Width",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Color",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Opaqueness",None, QApplication.UnicodeUTF8)])
            self.labeltable.setAlternatingRowColors(True)
            self.labeltable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.labeltable.setSelectionBehavior(QTableWidget.SelectRows)
            self.labeltable.setSelectionMode(QTableWidget.SingleSelection)
            self.labeltable.setShowGrid(True)
            #populate table
            for i in range(nlabels):
                label = QTableWidgetItem(aw.qmc.wheelnames[x][i])
                parentComboBox =  QComboBox()
                if x > 0:
                    items = aw.qmc.wheelnames[x-1][:]
                    items.insert(0,"")
                    parentComboBox.addItems(items)
                    if aw.qmc.wheellabelparent[x][i]:
                        parentComboBox.setCurrentIndex(aw.qmc.wheellabelparent[x][i])
                else:
                    parentComboBox.addItems([])
                self.connect(parentComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,x=x,i=i:self.setwheelchild(z,x,i))
                labelwidthSpinBox = QDoubleSpinBox()
                labelwidthSpinBox.setRange(1.,100.)
                labelwidthSpinBox.setValue(aw.qmc.segmentlengths[x][i])
                labelwidthSpinBox.setSuffix("%")
                self.connect(labelwidthSpinBox, SIGNAL("valueChanged(double)"),lambda z=1,x=x,u=i: self.setlabelwidth(z,x,u))
                colorButton = QPushButton("Set Color")
                self.connect(colorButton, SIGNAL("clicked()"),lambda x =x,i=i: self.setsegmentcolor(x,i))
                alphaSpinBox = QSpinBox()
                alphaSpinBox.setRange(0,10)
                alphaSpinBox.setValue(int(aw.qmc.segmentsalpha[x][i]*10))
                self.connect(alphaSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=x,u=i: self.setsegmentalpha(z,x,u))
                #add widgets to the table
                self.labeltable.setItem(i,0,label)
                self.labeltable.setCellWidget(i,1,parentComboBox)
                self.labeltable.setCellWidget(i,2,labelwidthSpinBox)
                self.labeltable.setCellWidget(i,3,colorButton)
                self.labeltable.setCellWidget(i,4,alphaSpinBox)

    def setsegmentcolor(self,x,i):
        colorf = QColorDialog.getColor(QColor(aw.qmc.wheelcolor[x][i]),self)
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.wheelcolor[x][i] = colorname      #add new color to label
            self.createdatatable()                           #update main table with label names (label::color)
            aw.qmc.drawWheel()

    #sets a uniform color in wheel
    def setwheelcolor(self,x):
        colorf = QColorDialog.getColor(QColor(aw.qmc.wheelcolor[x][0]),self)
        if colorf.isValid():
            colorname = str(colorf.name())
            for i in range(len(aw.qmc.wheelcolor[x])):
                aw.qmc.wheelcolor[x][i] =  colorname
        self.createdatatable()
        aw.qmc.drawWheel()

    #sets color pattern (many colors) in wheel
    def setwheelcolorpattern(self,z,x):
        wsb =  self.datatable.cellWidget(x,9)
        wpattern = wsb.value()
        wlen = len(aw.qmc.wheelcolor[x])
        for i in range(wlen):
            color = QColor()
            color.setHsv((360/wlen)*i*wpattern,255,255,255)
            aw.qmc.wheelcolor[x][i] = str(color.name())
        aw.qmc.drawWheel()

    #sets color pattern (many colors) for whole graph
    def setcolorpattern(self):
        aw.qmc.wheelcolorpattern = self.colorSpinBox.value()
        if aw.qmc.wheelcolorpattern:
            for x in range(len(aw.qmc.wheelcolor)):
                wlen = len(aw.qmc.wheelcolor[x])
                for i in range(wlen):
                    color = QColor()
                    color.setHsv((360/wlen)*i*aw.qmc.wheelcolorpattern,255,255,255)
                    aw.qmc.wheelcolor[x][i] = str(color.name())
            aw.qmc.drawWheel()

    def setsegmentalpha(self,z,x,u):
        aw.qmc.segmentsalpha[x][u] = float(z/10.)
        aw.qmc.drawWheel()

    #rotate whole graph 
    def rotatewheels(self,x):
        if x == 1: #left,counterclockwise
            for i in range(len(aw.qmc.startangle)):
                aw.qmc.startangle[i] += 1
        elif x == 0: #right,clockwise
            for i in range(len(aw.qmc.startangle)):
                aw.qmc.startangle[i] -= 1
        aw.qmc.drawWheel()

    #z= new width%, x= wheel number index, u = index of segment in the wheel
    def setlabelwidth(self,z,x,u):
        newwidth = z
        oldwidth = aw.qmc.segmentlengths[x][u]
        diff = newwidth - oldwidth
        l = len(aw.qmc.segmentlengths[x])
        for i in range(l):
            if i != u:
                if diff > 0:
                    aw.qmc.segmentlengths[x][i] -= abs(float(diff))/(l-1)
                else:
                    aw.qmc.segmentlengths[x][i] += abs(float(diff))/(l-1)
        aw.qmc.segmentlengths[x][u] = newwidth
        aw.qmc.drawWheel()

    #input: z = index of parent in previus wheel; x = wheel number; i = index of element in wheel
    def setwheelchild(self,z,x,i):
        aw.qmc.setwheelchild(z,x,i)
        aw.qmc.drawWheel()
        self.createdatatable() #update data table

    #deletes parent-child relation in a wheel. It obtains the wheel index by self.labelwheelx
    def resetlabelparents(self):
        x = self.labelwheelx
        nsegments = len(aw.qmc.wheellabelparent[x])
        for i in range(nsegments):
            aw.qmc.wheellabelparent[x][i] = 0
            aw.qmc.segmentlengths[x][i] = 100./nsegments
        aw.qmc.drawWheel()
        self.createlabeltable(x)

    def setaspect(self):
        aw.qmc.wheelaspect = self.aspectSpinBox.value()
        aw.qmc.drawWheel()

    #adjust decorative edge between wheels
    def setedge(self):
        aw.qmc.wheeledge = float(self.edgeSpinBox.value())/100.
        aw.qmc.drawWheel()

    #adjusts line thickness
    def setlinewidth(self):
        aw.qmc.wheellinewidth = self.linewidthSpinBox.value()
        aw.qmc.drawWheel()

    #sets line color
    def setlinecolor(self):
        colorf = QColorDialog.getColor(QColor(aw.qmc.wheellinecolor),self)
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.wheellinecolor = colorname      #add new color to label
            aw.qmc.drawWheel()

    #makes not visible the wheel config table
    def closelabels(self):
        self.labelGroupLayout.setVisible(False)
        self.labeltable.setVisible(False)
        self.labelCloseButton.setVisible(False)
        self.labelResetButton.setVisible(False)

    #creates graph table
    def createdatatable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.wheelnames)
        if ndata:
            self.datatable.setRowCount(ndata)
            self.datatable.setColumnCount(10)
            self.datatable.setHorizontalHeaderLabels([QApplication.translate("Table","Delete Wheel",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Edit Labels",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Update Labels",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Properties",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Radius",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Starting angle",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Projection",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Text Size",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Color",None, QApplication.UnicodeUTF8),
                                                      QApplication.translate("Table","Color Pattern",None, QApplication.UnicodeUTF8)])
            self.datatable.setAlternatingRowColors(True)
            self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
            self.datatable.setSelectionMode(QTableWidget.SingleSelection)
            self.datatable.setShowGrid(True)
            #populate table
            for i in range(ndata):
                delButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
                self.connect(delButton, SIGNAL("clicked()"),lambda x = i: self.popwheel(x))
                labelsedit = QLineEdit(str(",".join(aw.qmc.wheelnames[i])))
                updateButton = QPushButton(QApplication.translate("Button","Update",None, QApplication.UnicodeUTF8))
                self.connect(updateButton, SIGNAL("clicked()"),lambda x = i: self.updatelabels(x))
                setButton = QPushButton(QApplication.translate("Button","Select",None, QApplication.UnicodeUTF8))
                self.connect(setButton, SIGNAL("clicked()"),lambda x = i: self.createlabeltable(x))
                widthSpinBox = QDoubleSpinBox()
                widthSpinBox.setRange(1.,100.)
                widthSpinBox.setValue(aw.qmc.wradii[i])
                widthSpinBox.setSuffix("%")
                self.connect(widthSpinBox, SIGNAL("valueChanged(double)"),lambda z=1,x=i: self.setwidth(z,x))
                angleSpinBox = QSpinBox()
                angleSpinBox.setSuffix(QApplication.translate("Label"," dg",None, QApplication.UnicodeUTF8))
                angleSpinBox.setRange(0,359)
                angleSpinBox.setWrapping(True)
                angleSpinBox.setValue(aw.qmc.startangle[i])
                self.connect(angleSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=i: self.setangle(z,x))
                projectionComboBox =  QComboBox()
                projectionComboBox.addItems([QApplication.translate("ComboBox","Flat",None, QApplication.UnicodeUTF8),
                                             QApplication.translate("ComboBox","Perpendicular",None, QApplication.UnicodeUTF8),
                                             QApplication.translate("ComboBox","Radial",None, QApplication.UnicodeUTF8)])
                projectionComboBox.setCurrentIndex(aw.qmc.projection[i])
                self.connect(projectionComboBox,SIGNAL("currentIndexChanged(int)"),lambda z=1,x=i:self.setprojection(z,x))
                txtSpinBox = QSpinBox()
                txtSpinBox.setRange(1,30)
                txtSpinBox.setValue(aw.qmc.wheeltextsize[i])
                self.connect(txtSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=i: self.setTextsizeX(z,x))
                colorButton = QPushButton(QApplication.translate("Button","Set Color",None, QApplication.UnicodeUTF8))
                self.connect(colorButton, SIGNAL("clicked()"),lambda x =i: self.setwheelcolor(x))
                colorSpinBox = QSpinBox()
                colorSpinBox.setRange(0,255)
                colorSpinBox.setWrapping(True)
                self.connect(colorSpinBox, SIGNAL("valueChanged(int)"),lambda z=1,x=i,: self.setwheelcolorpattern(z,x))
                #add widgets to the table
                self.datatable.setCellWidget(i,0,delButton)
                self.datatable.setCellWidget(i,1,labelsedit)
                self.datatable.setCellWidget(i,2,updateButton)
                self.datatable.setCellWidget(i,3,setButton)
                self.datatable.setCellWidget(i,4,widthSpinBox)
                self.datatable.setCellWidget(i,5,angleSpinBox)
                self.datatable.setCellWidget(i,6,projectionComboBox)
                self.datatable.setCellWidget(i,7,txtSpinBox)
                self.datatable.setCellWidget(i,8,colorButton)
                self.datatable.setCellWidget(i,9,colorSpinBox)

    #reads label edit box for wheel with index x, and updates labels
    def updatelabels(self,x):
        labelsedit =  self.datatable.cellWidget(x,1)
        text  = str(labelsedit.text())
        if "\\n" in text:              #make multiple line text if "\n" found in label string
            parts = text.split("\\n")
            text = chr(10).join(parts)
        newwheellabels = text.strip().split(",")
        newnlabels = len(newwheellabels)
        oldnlabels = len(aw.qmc.wheelnames[x])
        #adjust segments len and alpha for each wheel if number of labels changed
        if oldnlabels != newnlabels:
            aw.qmc.segmentlengths[x] = [100./newnlabels]*newnlabels
            aw.qmc.segmentsalpha[x] = [.3]*newnlabels
            aw.qmc.wheellabelparent[x] = [0]*newnlabels
            aw.qmc.wheelcolor[x] = [aw.qmc.wheelcolor[x][0]]*newnlabels
        aw.qmc.wheelnames[x] = newwheellabels[:]
        aw.qmc.drawWheel()

    #sets radii for a wheel. z is a variable dummy with no meaning but passed by the Qt inner workings
    def setwidth(self,z,x):
        widthSpinBox = self.datatable.cellWidget(x,4)
        newwidth = widthSpinBox.value()
        oldwidth = aw.qmc.wradii[x]
        diff = newwidth - oldwidth
        l = len(aw.qmc.wradii)
        for i in range(l):
            if i != x:
                if diff > 0:
                    aw.qmc.wradii[i] -= abs(float(diff))/(l-1)
                else:
                    aw.qmc.wradii[i] += abs(float(diff))/(l-1)
        aw.qmc.wradii[x] = newwidth
        #Need 100.0% coverage. Correct for numerical floating point rounding errors:
        count = 0.
        for i in range(len(aw.qmc.wradii)):
            count +=  aw.qmc.wradii[i]
        diff = 100. - count
        if diff  != 0.:
            if diff > 0.000:  #if count smaller
                aw.qmc.wradii[x] += abs(diff)
            else:
                aw.qmc.wradii[x] -= abs(diff)
        aw.qmc.drawWheel()

    #sets starting angle (rotation) for a wheel with index x
    def setangle(self,z,x):
        angleSpinBox = self.datatable.cellWidget(x,5)
        aw.qmc.startangle[x] = angleSpinBox.value()
        aw.qmc.drawWheel()

    #sets text projection style for a wheel with index x
    def setprojection(self,z,x):
        projectionComboBox = self.datatable.cellWidget(x,6)
        aw.qmc.projection[x] = projectionComboBox.currentIndex()
        aw.qmc.drawWheel()

    #chages text size in wheel with index x
    def setTextsizeX(self,z,x):
        txtSpinBox = self.datatable.cellWidget(x,7)
        aw.qmc.wheeltextsize[x] = txtSpinBox.value()
        aw.qmc.drawWheel()

    #changes size of text in whole graph
    def changetext(self,x):
        for i in range(len(aw.qmc.wheeltextsize)):
            if x == 1:
                aw.qmc.wheeltextsize[i] += 1
            else:
                aw.qmc.wheeltextsize[i] -= 1
        aw.qmc.drawWheel()

    #adds new top wheel 
    def insertwheel(self):
        ndata = len(aw.qmc.wradii)
        if ndata:
            count = 0.
            for i in range(ndata):
                aw.qmc.wradii[i] = 100./(ndata+1)
                count += aw.qmc.wradii[i]
            aw.qmc.wradii.append(100.-count)
        else:
            aw.qmc.wradii.append(100.)
        #find number of labels of most outer wheel (last)
        if len(aw.qmc.wheelnames):
            nwheels = len(aw.qmc.wheelnames[-1])
        else:                                       #if no wheels
            nwheels = 3
        wn,sl,sa,wlp,co = [],[],[],[],[]
        for i in range(nwheels+1):
            wn.append("W%i %i"%(len(aw.qmc.wheelnames)+1,i+1))
            sl.append(100./(nwheels+1))
            sa.append(.3)
            wlp.append(0)
            color = QColor()
            color.setHsv((360/(nwheels+1))*i,255,255,255)
            co.append(str(color.name()))
        aw.qmc.wheelnames.append(wn)
        aw.qmc.segmentlengths.append(sl)
        aw.qmc.segmentsalpha.append(sa)
        aw.qmc.wheellabelparent.append(wlp)
        aw.qmc.startangle.append(0)
        aw.qmc.projection.append(2)
        aw.qmc.wheeltextsize.append(10)
        aw.qmc.wheelcolor.append(co)
        self.createdatatable()
        aw.qmc.drawWheel()

    #deletes wheel with index x
    def popwheel(self,x):
        #correct raius of other wheels (to use 100% coverage)
        width = aw.qmc.wradii[x]
        l = len(aw.qmc.wradii)
        for i in range(l):
            if i != x:
                aw.qmc.wradii[i] += float(width)/(l-1)
        aw.qmc.wheelnames.pop(x)
        aw.qmc.wradii.pop(x)
        aw.qmc.startangle.pop(x)
        aw.qmc.projection.pop(x)
        aw.qmc.wheeltextsize.pop(x)
        aw.qmc.segmentlengths.pop(x)
        aw.qmc.segmentsalpha.pop(x)
        aw.qmc.wheellabelparent.pop(x)
        aw.qmc.wheelcolor.pop(x)
        self.createdatatable()
        aw.qmc.drawWheel()

    def fileSave(self):
        try:
            filename = aw.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Wheel graph",None, QApplication.UnicodeUTF8),ext="*.wg")
            if filename:
                #write
                aw.serialize(filename,aw.getWheelGraph())
                aw.sendmessage(QApplication.translate("Message","Wheel Graph saved",None, QApplication.UnicodeUTF8))
        except IOError as e:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:",None, QApplication.UnicodeUTF8) + " Wheel graph filesave(): %1").arg(str(e)))
            return

    def loadWheel(self):        
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Open Wheel Graph",None, QApplication.UnicodeUTF8),path = "Wheels",ext="*.wg")
        aw.loadWheel(filename)
        self.createdatatable()
        aw.qmc.drawWheel()

    def closeEvent(self, event):
        #if switching to View-mode don't redraw() (faster)
        if not self.viewmodeflag:
            aw.qmc.disconnectWheel()
            aw.qmc.redraw(recomputeAllDeltas=False)
        else:
            aw.qmc.disconnectWheel(buttomvisibility=False)

    def viewmode(self):
        self.viewmodeflag = True
        self.close()
        aw.qmc.connectWheel()
        aw.qmc.drawWheel()
           
############################################################
#######################  ALARM DIALOG  #####################
############################################################

class AlarmDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(AlarmDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Alarms",None, QApplication.UnicodeUTF8))
        #local alarm variables
        self.alarmflag = aw.qmc.alarmflag
        self.alarmguard = aw.qmc.alarmguard
        self.alarmtime = aw.qmc.alarmtime
        self.alarmoffset = aw.qmc.alarmoffset
        self.alarmcond = aw.qmc.alarmcond
        self.alarmsource = aw.qmc.alarmsource
        self.alarmtemperature = aw.qmc.alarmtemperature
        self.alarmaction = aw.qmc.alarmaction
        self.alarmstrings = aw.qmc.alarmstrings
        #table for alarms
        self.alarmtable = QTableWidget()
        self.createalarmtable()
        allonButton = QPushButton(QApplication.translate("Button","All On",None, QApplication.UnicodeUTF8))
        self.connect(allonButton,  SIGNAL("clicked()"), lambda flag=1: self.alarmson(flag))
        allonButton.setFocusPolicy(Qt.NoFocus)
        alloffButton = QPushButton(QApplication.translate("Button","All Off",None, QApplication.UnicodeUTF8))
        self.connect(alloffButton, SIGNAL("clicked()"), lambda flag=0: self.alarmson(flag))
        alloffButton.setFocusPolicy(Qt.NoFocus)
        addButton = QPushButton(QApplication.translate("Button","Add",None, QApplication.UnicodeUTF8))
        self.connect(addButton, SIGNAL("clicked()"),self.addalarm)
        addButton.setMinimumWidth(80)
        addButton.setFocusPolicy(Qt.NoFocus)
        deleteButton = QPushButton(QApplication.translate("Button","Delete",None, QApplication.UnicodeUTF8))
        self.connect(deleteButton, SIGNAL("clicked()"),self.deletealarm)
        deleteButton.setMinimumWidth(80)
        deleteButton.setFocusPolicy(Qt.NoFocus)
        importButton = QPushButton(QApplication.translate("Button","Load",None, QApplication.UnicodeUTF8))
        self.connect(importButton, SIGNAL("clicked()"),self.importalarms)
        importButton.setMinimumWidth(80)
        importButton.setFocusPolicy(Qt.NoFocus)
        exportButton = QPushButton(QApplication.translate("Button","Save",None, QApplication.UnicodeUTF8))
        self.connect(exportButton, SIGNAL("clicked()"),self.exportalarms)
        exportButton.setMinimumWidth(80)
        exportButton.setFocusPolicy(Qt.NoFocus)        
        okButton = QPushButton(QApplication.translate("Button","OK",None, QApplication.UnicodeUTF8))
        self.connect(okButton, SIGNAL("clicked()"),self.closealarms)
        helpButton = QPushButton(QApplication.translate("Button","Help",None, QApplication.UnicodeUTF8))
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None, QApplication.UnicodeUTF8))
        helpButton.setFocusPolicy(Qt.NoFocus)
        helpButton.setMinimumWidth(80)
        self.connect(helpButton, SIGNAL("clicked()"),self.showAlarmbuttonhelp)
        tablelayout = QVBoxLayout()
        buttonlayout = QHBoxLayout()
        mainlayout = QVBoxLayout()
        tablelayout.addWidget(self.alarmtable)
        buttonlayout.addWidget(addButton)
        buttonlayout.addWidget(deleteButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(10)
        buttonlayout.addWidget(alloffButton)
        buttonlayout.addWidget(allonButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(10)
        buttonlayout.addWidget(importButton)
        buttonlayout.addWidget(exportButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(15)
        buttonlayout.addWidget(helpButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(15)
        buttonlayout.addWidget(okButton)
        mainlayout.addLayout(tablelayout)
        mainlayout.addLayout(buttonlayout)
        self.setLayout(mainlayout)

    def alarmson(self,flag):
        for i in range(len(aw.qmc.alarmflag)):
            if flag == 1:
                aw.qmc.alarmflag[i] = 1
            else:
                aw.qmc.alarmflag[i] = 0
        self.createalarmtable()

    def addalarm(self):
        self.alarmflag.append(1)
        self.alarmguard.append(-1)
        self.alarmtime.append(-1)
        self.alarmoffset.append(0)
        self.alarmcond.append(1)
        self.alarmsource.append(1)
        self.alarmtemperature.append(500)
        self.alarmaction.append(0)
        self.alarmstrings.append(QApplication.translate("Label","Enter description",None, QApplication.UnicodeUTF8))
        nalarms = self.alarmtable.rowCount()
        self.alarmtable.setRowCount(nalarms + 1)
        self.setalarmtablerow(nalarms)
        self.alarmtable.resizeColumnsToContents()
        if nalarms < 1:            
            # improve width of Qlineedit columns
            self.alarmtable.setColumnWidth(1,65)
            self.alarmtable.setColumnWidth(3,50)
            self.alarmtable.setColumnWidth(6,50)


    def deletealarm(self):
        nalarms = self.alarmtable.rowCount()
        if nalarms:
            # check for selection
            selected = self.alarmtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                self.alarmtable.removeRow(selected_row)
                self.alarmflag = self.alarmflag[0:selected_row] + self.alarmflag[selected_row + 1:]
                self.alarmguard = self.alarmguard[0:selected_row] + self.alarmguard[selected_row + 1:]
                self.alarmtime = self.alarmtime[0:selected_row] + self.alarmtime[selected_row + 1:]
                self.alarmoffset = self.alarmoffset[0:selected_row] + self.alarmoffset[selected_row + 1:]
                self.alarmcond = self.alarmcond[0:selected_row] + self.alarmcond[selected_row + 1:]
                self.alarmsource = self.alarmsource[0:selected_row] + self.alarmsource[selected_row + 1:]
                self.alarmtemperature = self.alarmtemperature[0:selected_row] + self.alarmtemperature[selected_row + 1:]
                self.alarmaction = self.alarmaction[0:selected_row] + self.alarmaction[selected_row + 1:]
                self.alarmstrings = self.alarmstrings[0:selected_row] + self.alarmstrings[selected_row + 1:]
            else:
                self.alarmtable.removeRow(self.alarmtable.rowCount() - 1)
                # nothing selected, we pop the last element
                self.alarmflag.pop()
                self.alarmguard.pop()
                self.alarmtime.pop()
                self.alarmoffset.pop()
                self.alarmcond.pop()
                self.alarmsource.pop()
                self.alarmtemperature.pop()
                self.alarmaction.pop()
                self.alarmstrings.pop()
            self.alarmtable.setRowCount(nalarms - 1)

    def importalarms(self):
        aw.fileImport(QApplication.translate("Message", "Load Alarms",None, QApplication.UnicodeUTF8),self.importalarmsJSON)
        
    def importalarmsJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            alarms = json.load(infile)
            infile.close()
            self.alarmflag = alarms["alarmflags"]
            self.alarmguard = alarms["alarmguards"]
            self.alarmtime = alarms["alarmtimes"]
            self.alarmoffset = alarms["alarmoffsets"]
            self.alarmcond = alarms["alarmconds"]
            self.alarmsource = alarms["alarmsources"]
            self.alarmtemperature = alarms["alarmtemperatures"]
            self.alarmaction = alarms["alarmactions"]
            self.alarmstrings = alarms["alarmstrings"]
            self.createalarmtable()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " importalarmsJSON() %1").arg(str(ex)),exc_tb.tb_lineno)
        
    def exportalarms(self):
        aw.fileExport(QApplication.translate("Message", "Save Alarms",None, QApplication.UnicodeUTF8),"*.alrm",self.exportalarmsJSON)
        
    def exportalarmsJSON(self,filename):
        try:
            alarms = {}
            alarms["alarmflags"] = self.alarmflag
            alarms["alarmguards"] = self.alarmguard
            alarms["alarmtimes"] = self.alarmtime
            alarms["alarmoffsets"] = self.alarmoffset
            alarms["alarmconds"] = self.alarmcond
            alarms["alarmsources"] = self.alarmsource
            alarms["alarmtemperatures"] = self.alarmtemperature
            alarms["alarmactions"] = self.alarmaction
            alarms["alarmstrings"] = list(map(lambda s:u(s),self.alarmstrings))
            outfile = open(filename, 'w')
            json.dump(alarms, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " exportalarmsJSON(): %1").arg(str(ex)),exc_tb.tb_lineno)

    def closealarms(self):
        self.savealarms()
        self.accept()

    def showAlarmbuttonhelp(self):
        string  = u(QApplication.translate("Message", "<b>Status:</b> activate or deactive alarm",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>If Alarm:</b> alarm triggered only if the alarm with the given number was triggered before. Use 0 for no guard.",None, QApplication.UnicodeUTF8)) + "<br><br>"  
        string += u(QApplication.translate("Message", "<b>From:</b> alarm only triggered after the given event",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Time:</b> if not 00:00, alarm is triggered mm:ss after the event 'From' happend",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Source:</b> the temperature source that is observed",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Condition:</b> alarm is triggered if source rises above or below the specified temperature",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Temp:</b> the speficied temperature limit",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Action:</b> if all conditions are fulfilled the alarm triggeres the corresponding action",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>Description:</b> the text of the popup, the name of the program, the number of the event button (if 0 the COOL event is triggered ) or the new value of the slider",None, QApplication.UnicodeUTF8)) + "<br><br>"
        string += u(QApplication.translate("Message", "<b>NOTE:</b> each alarm is only triggered once",None, QApplication.UnicodeUTF8))
        QMessageBox.information(self,QApplication.translate("Message", "Event custom buttons",None, QApplication.UnicodeUTF8),string)

    def savealarms(self):
        nalarms = self.alarmtable.rowCount()
        aw.qmc.alarmflag = [1]*nalarms
        aw.qmc.alarmguard = [-1]*nalarms
        aw.qmc.alarmtime = [-1]*nalarms
        aw.qmc.alarmoffset = [0]*nalarms
        aw.qmc.alarmcond = [1]*nalarms
        aw.qmc.alarmsource = [1]*nalarms
        aw.qmc.alarmtemperature = [500]*nalarms
        aw.qmc.alarmaction = [0]*nalarms
        aw.qmc.alarmstrings = [0]*nalarms
        for i in range(nalarms):
            flag = self.alarmtable.cellWidget(i,0)
            aw.qmc.alarmflag[i] = int(flag.isChecked())
            guard = self.alarmtable.cellWidget(i,1)
            guard_value = int(str(guard.text())) - 1
            if guard_value > -1 and guard_value < nalarms:
                aw.qmc.alarmguard[i] = guard_value
            else:
                aw.qmc.alarmguard[i] = -1
            timez =  self.alarmtable.cellWidget(i,2)
            aw.qmc.alarmtime[i] = aw.qmc.menuidx2alarmtime[timez.currentIndex()]
            offset =  self.alarmtable.cellWidget(i,3)
            if offset and offset != "":
                aw.qmc.alarmoffset[i] = max(0,aw.qmc.stringtoseconds(str(offset.text())))
            atype = self.alarmtable.cellWidget(i,4)
            aw.qmc.alarmsource[i] = int(str(atype.currentIndex())) - 3
            cond = self.alarmtable.cellWidget(i,5)
            aw.qmc.alarmcond[i] = int(str(cond.currentIndex())) 
            temp = self.alarmtable.cellWidget(i,6)
            try:
                aw.qmc.alarmtemperature[i] = int(str(temp.text()))
            except:
                aw.qmc.alarmtemperature[i] = 0
            action = self.alarmtable.cellWidget(i,7)
            aw.qmc.alarmaction[i] = int(str(action.currentIndex() - 1))
            description = self.alarmtable.cellWidget(i,8)
            aw.qmc.alarmstrings[i] = str(description.text())
        aw.qmc.alarmstate = [0]*len(aw.qmc.alarmflag)    # 0 = not triggered

    def buildAlarmSourceList(self):
        extra_names = []
        for i in range(len(aw.qmc.extradevices)):
            extra_names.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            extra_names.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
        return ["",
             QApplication.translate("ComboBox","DeltaET",None, QApplication.UnicodeUTF8),
             QApplication.translate("ComboBox","DeltaBT",None, QApplication.UnicodeUTF8),
             QApplication.translate("ComboBox","ET",None, QApplication.UnicodeUTF8),
             QApplication.translate("ComboBox","BT",None, QApplication.UnicodeUTF8)] + extra_names

    # creates Widget in row i of self.alarmtable and sets them to values from local dialog variables at position i
    def setalarmtablerow(self,i):
        #flag
        flagComboBox = QCheckBox()
        flagComboBox.setFocusPolicy(Qt.NoFocus)
        flagComboBox.setText(QApplication.translate("ComboBox","ON",None, QApplication.UnicodeUTF8))
        if self.alarmflag[i]:
            flagComboBox.setCheckState(Qt.Checked)
        else:
            flagComboBox.setCheckState(Qt.Unchecked)
        #guarded by alarm
        guardedit = QLineEdit(str(self.alarmguard[i] + 1))
        guardedit.setValidator(QIntValidator(0, 30,guardedit))
        guardedit.setAlignment(Qt.AlignRight)
        #Effective time from
        timeComboBox = QComboBox()
        timeComboBox.addItems([QApplication.translate("ComboBox","START",None, QApplication.UnicodeUTF8), # qmc.alarmtime -1
                               QApplication.translate("ComboBox","CHARGE",None, QApplication.UnicodeUTF8), # qmc.alarmtime 0
                               QApplication.translate("ComboBox","TP",None, QApplication.UnicodeUTF8), # qmc.alarmtime 8
                               QApplication.translate("ComboBox","DRY END",None, QApplication.UnicodeUTF8), # qmc.alarmtime 1
                               QApplication.translate("ComboBox","FC START",None, QApplication.UnicodeUTF8), # qmc.alarmtime 2
                               QApplication.translate("ComboBox","FC END",None, QApplication.UnicodeUTF8), # qmc.alarmtime 3
                               QApplication.translate("ComboBox","SC START",None, QApplication.UnicodeUTF8), # qmc.alarmtime 4
                               QApplication.translate("ComboBox","SC END",None, QApplication.UnicodeUTF8), # qmc.alarmtime 5
                               QApplication.translate("ComboBox","DROP",None, QApplication.UnicodeUTF8), # qmc.alarmtime 6
                               QApplication.translate("ComboBox","COOL",None, QApplication.UnicodeUTF8)]) # qmc.alarmtime 7
        timeComboBox.setCurrentIndex(aw.qmc.alarmtime2menuidx[self.alarmtime[i]])
        #time after selected event
        timeoffsetedit = QLineEdit(aw.qmc.stringfromseconds(max(0,self.alarmoffset[i])))
        timeoffsetedit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        timeoffsetedit.setValidator(QRegExpValidator(regextime,self))
        #type
        typeComboBox = QComboBox()
        aitems = self.buildAlarmSourceList()
        typeComboBox.addItems(aitems)
        if self.alarmsource[i] + 3 < len(aitems):
            typeComboBox.setCurrentIndex(self.alarmsource[i] + 3)
        else:
            typeComboBox.setCurrentIndex(3)
        #condition
        condComboBox = QComboBox()
        condComboBox.addItems([QApplication.translate("ComboBox","below",None, QApplication.UnicodeUTF8),
                               QApplication.translate("ComboBox","above",None, QApplication.UnicodeUTF8)])
        condComboBox.setCurrentIndex(self.alarmcond[i])
        #temperature
        tempedit = QLineEdit(str(self.alarmtemperature[i]))
        tempedit.setAlignment(Qt.AlignRight)
        tempedit.setMaximumWidth(100)
        tempedit.setValidator(QIntValidator(0, 999,tempedit))
        #action
        actionComboBox = QComboBox()
        actionComboBox.addItems(["",
                                 QApplication.translate("ComboBox","Pop Up",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","Call Program",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","Event Button",None, QApplication.UnicodeUTF8),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(0)),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(1)),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(2)),
                                 QApplication.translate("ComboBox","Slider",None, QApplication.UnicodeUTF8) + " " + u(aw.qmc.etypesf(3))])
        actionComboBox.setCurrentIndex(self.alarmaction[i] + 1)
        #text description
        descriptionedit = QLineEdit(str(self.alarmstrings[i]))
        self.alarmtable.setCellWidget(i,0,flagComboBox)
        self.alarmtable.setCellWidget(i,1,guardedit)
        self.alarmtable.setCellWidget(i,2,timeComboBox)
        self.alarmtable.setCellWidget(i,3,timeoffsetedit)
        self.alarmtable.setCellWidget(i,4,typeComboBox)
        self.alarmtable.setCellWidget(i,5,condComboBox)
        self.alarmtable.setCellWidget(i,6,tempedit)
        self.alarmtable.setCellWidget(i,7,actionComboBox)
        self.alarmtable.setCellWidget(i,8,descriptionedit)

    def createalarmtable(self):
        self.alarmtable.clear()
        self.alarmtable.setTabKeyNavigation(True)
        self.alarmtable.setColumnCount(9)
        self.alarmtable.setHorizontalHeaderLabels([QApplication.translate("Table","Status",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","If Alarm",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","From",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Time",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Source",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Condition",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Temp",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Action",None, QApplication.UnicodeUTF8),
                                                       QApplication.translate("Table","Description",None, QApplication.UnicodeUTF8)])
        self.alarmtable.setAlternatingRowColors(True)
        self.alarmtable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.alarmtable.setSelectionBehavior(QTableWidget.SelectRows)
        self.alarmtable.setSelectionMode(QTableWidget.SingleSelection)
        self.alarmtable.setShowGrid(True)
        nalarms = len(self.alarmtemperature)
        if nalarms:
            self.alarmtable.setRowCount(nalarms)
            #populate table
            for i in range(nalarms):
                self.setalarmtablerow(i)
            self.alarmtable.resizeColumnsToContents()
            # improve width of Qlineedit columns
            self.alarmtable.setColumnWidth(1,80)
            self.alarmtable.setColumnWidth(3,50)
            self.alarmtable.setColumnWidth(6,50)

# UNDER WORK 
#######################################################################################
#################### COFFEE CRACK  DETECTOR PROJECT ###################################
#######################################################################################

#class soundcrack(FigureCanvas):
#    def __init__(self,parent):
#        self.fig = Figure(facecolor='lightgrey')
#        FigureCanvas.__init__(self, self.fig)
#        self.ax = self.fig.add_subplot(111, axisbg="black")
#        self.ax.grid(True,linewidth=2,color="green")
#        self.ax.set_xlim(0,5500)
#        self.ax.set_ylim(-1,1)
#        #make first empty plot of frequency
#        self.Freqline, = self.ax.plot([], [], animated=True, lw=1,color = "#78E800")
#        #make first empty plot of rms amplitude     
#        self.Ampline, = self.ax.plot([], [], animated=True, lw=2,color = "orange")
#        self.N_SAMPLES = 1024
#        self.SAMPLING_RATE = 11025
#        self.amplitudeThreshold = .6
#        self.fig.canvas.draw()
#        self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
#        self.ampsensitivity = 10
#        self.freqs = numpy.fft.fftfreq(self.N_SAMPLES,1./self.SAMPLING_RATE)[:self.N_SAMPLES/2] #X axis
#        self.stream = None
#        self.pa = None
#        self.ON = 0
#
#    def reset(self):
#        self.fig.clf()   #wipe out figure
#        self.ax = self.fig.add_subplot(111, axisbg="black")
#        self.ax.grid(True,linewidth=2,color="green")
#        self.ax.set_xlim(0,5500)
#        self.ax.set_ylim(-1,1)
#        self.fig.canvas.draw()
#        self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
#
#    def crackdetedted(self):
#        pass
#
#    #updates animated display
#    def blitsound(self):   
#        if self.ON:
#            self.fig.canvas.restore_region(self.background)
#            F,amplitude = self.getsound()
#            amplitude *= self.ampsensitivity
#            self.Freqline.set_data(self.freqs,F)
#            self.Ampline.set_data([0,5500],[amplitude,amplitude])
#            self.ax.draw_artist(self.Freqline)
#            self.ax.draw_artist(self.Ampline)
#            self.fig.canvas.blit(self.ax.bbox)
#
#    def opensound(self):
#        try:
#            import pyaudio
#        except ImportError:
#            return False
#        self.reset()
#        self.ON = 1    
#        self.pa = pyaudio.PyAudio()
#        self.stream = self.pa.open(format=pyaudio.paInt16, channels=1, rate=self.SAMPLING_RATE,
#                     input=True, frames_per_buffer=self.N_SAMPLES)
#
#    def closesound(self):
#        self.ON = 0
#        self.stream.close()
#        self.pa.terminate()
#        
#    def getsound(self):
#        #F[m] = m*SAMPLING_RATE/N_SAMPLES   (List with magnitudes of frequencies) Y axis
#        
#        block = self.stream.read(self.N_SAMPLES)
#        
#        count = len(block)/2
#        formatS = "%dh"%(count)    
#        audio_data  = struct.unpack(formatS, block)
#        sum_squares = 0
#        naudio = []
#        for sample in audio_data:
#            n = sample /32768.            #normalize
#            naudio.append(n)
#            sum_squares += n*n
#        from scipy import fft
#        F = fft(naudio)[:self.N_SAMPLES/2]
#        amplitude =  math.sqrt(sum_squares / count)    #rms
#        return F,amplitude
#
#    def keyPressEvent(self,event):
#        key = int(event.key())
#        #uncomment next line to find the integer value of a key
#        #print key
#        if key == 16777216: #ESCAPE
#            self.close()

#########################################################################
######################## FUJI PXR CONTROL DIALOG  #######################
#########################################################################

class PXRpidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(PXRpidDlgControl,self).__init__(parent)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXR PID Control",None, QApplication.UnicodeUTF8))
        #create Ramp Soak control button colums
        self.labelrs1 = QLabel()
        self.labelrs1.setMargin(5)
        self.labelrs1.setStyleSheet("background-color:'#CCCCCC';")
        self.labelrs1.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak HH:MM<br>(1-4)",None, QApplication.UnicodeUTF8) + "<\b></font>")
        self.labelrs1.setMaximumSize(120, 62)
        self.labelrs2 = QLabel()
        self.labelrs2.setMargin(5)
        self.labelrs2.setStyleSheet("background-color:'#CCCCCC';")
        self.labelrs2.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak HH:MM<br>(5-8)",None, QApplication.UnicodeUTF8) + "<\b></font>")
        self.labelrs2.setMaximumSize(120, 62)
        labelpattern = QLabel(QApplication.translate("Label", "Ramp/Soak Pattern",None, QApplication.UnicodeUTF8))
        self.patternComboBox =  QComboBox()
        self.patternComboBox.addItems(["1-4","5-8","1-8"])
        self.patternComboBox.setCurrentIndex(aw.fujipid.PXR["rampsoakpattern"][0])
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Ready",None, QApplication.UnicodeUTF8),5000)
        self.label_rs1 =  QLabel()
        self.label_rs2 =  QLabel()
        self.label_rs3 =  QLabel()
        self.label_rs4 =  QLabel()
        self.label_rs5 =  QLabel()
        self.label_rs6 =  QLabel()
        self.label_rs7 =  QLabel()
        self.label_rs8 =  QLabel()
        self.paintlabels()
        #update button and exit button
        button_getall = QPushButton(QApplication.translate("Button","Read Ra/So values",None, QApplication.UnicodeUTF8))
        button_rson =  QPushButton(QApplication.translate("Button","RampSoak ON",None, QApplication.UnicodeUTF8))
        button_rsoff =  QPushButton(QApplication.translate("Button","RampSoak OFF",None, QApplication.UnicodeUTF8))
        button_standbyON = QPushButton(QApplication.translate("Button","PID OFF",None, QApplication.UnicodeUTF8))
        button_standbyOFF = QPushButton(QApplication.translate("Button","PID ON",None, QApplication.UnicodeUTF8))
        button_exit = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        self.connect(self.patternComboBox,SIGNAL("currentIndexChanged(int)"),self.paintlabels)
        self.connect(button_getall, SIGNAL("clicked()"), self.getallsegments)
        self.connect(button_rson, SIGNAL("clicked()"), lambda flag=1: self.setONOFFrampsoak(flag))
        self.connect(button_rsoff, SIGNAL("clicked()"), lambda flag=0: self.setONOFFrampsoak(flag))
        self.connect(button_standbyON, SIGNAL("clicked()"), lambda flag=1: self.setONOFFstandby(flag))
        self.connect(button_standbyOFF, SIGNAL("clicked()"), lambda flag=0: self.setONOFFstandby(flag))
        self.connect(button_exit, SIGNAL("clicked()"),self, SLOT("reject()"))
        #TAB 2
        tab2svbutton = QPushButton(QApplication.translate("Button","Write SV",None, QApplication.UnicodeUTF8))
        tab2cancelbutton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton = QPushButton(QApplication.translate("Button","SV Buttons ON",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton.setStyleSheet("QPushButton { background-color: #ffaaff}")
        tab2easyOFFsvbutton = QPushButton(QApplication.translate("Button","SV Buttons OFF",None, QApplication.UnicodeUTF8))
        tab2easyOFFsvbutton.setStyleSheet("QPushButton { background-color: lightblue}")
        tab2getsvbutton = QPushButton(QApplication.translate("Button","Read SV",None, QApplication.UnicodeUTF8))
        self.readsvedit = QLineEdit()
        self.connect(tab2svbutton, SIGNAL("clicked()"),self.setsv)
        self.connect(tab2getsvbutton, SIGNAL("clicked()"),self.getsv)
        self.connect(tab2cancelbutton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(tab2easyONsvbutton, SIGNAL("clicked()"), lambda flag=1: aw.fujipid.activateONOFFeasySV(flag))
        self.connect(tab2easyOFFsvbutton, SIGNAL("clicked()"), lambda flag=0: aw.fujipid.activateONOFFeasySV(flag))
        svwarning1 = QLabel("<CENTER><b>" + QApplication.translate("Label", "WARNING",None, QApplication.UnicodeUTF8) + "</b><br>"
                            + QApplication.translate("Label", "Writing eeprom memory",None, QApplication.UnicodeUTF8) + "<br>"
                            + QApplication.translate("Label", "<u>Max life</u> 10,000 writes",None, QApplication.UnicodeUTF8) + "<br>"
                            + QApplication.translate("Label", "Infinite read life.",None, QApplication.UnicodeUTF8) + "</CENTER>")
        svwarning2 = QLabel("<CENTER><b>" + QApplication.translate("Label", "WARNING",None, QApplication.UnicodeUTF8) + "</b><br>"
                            + QApplication.translate("Label", "After <u>writing</u> an adjustment,<br>never power down the pid<br>for the next 5 seconds <br>or the pid may never recover.",None, QApplication.UnicodeUTF8) + "<br>"
                            + QApplication.translate("Label", "Read operations manual",None, QApplication.UnicodeUTF8) + "</CENTER>")
        self.svedit = QLineEdit()
        self.svedit.setValidator(QDoubleValidator(0., 999., 1, self.svedit))
        #TAB 3
        button_p = QPushButton(QApplication.translate("Button","Set p",None, QApplication.UnicodeUTF8))
        button_i = QPushButton(QApplication.translate("Button","Set i",None, QApplication.UnicodeUTF8))
        button_d = QPushButton(QApplication.translate("Button","Set d",None, QApplication.UnicodeUTF8))
        plabel =  QLabel("p")
        ilabel =  QLabel("i")
        dlabel =  QLabel("d")
        self.pedit = QLineEdit(str(aw.fujipid.PXR["p"][0]))
        self.iedit = QLineEdit(str(aw.fujipid.PXR["i"][0]))
        self.dedit = QLineEdit(str(aw.fujipid.PXR["d"][0]))
        self.pedit.setMaximumWidth(60)
        self.iedit.setMaximumWidth(60)
        self.dedit.setMaximumWidth(60)
        self.pedit.setValidator(QDoubleValidator(0., 999., 1, self.pedit))
        self.iedit.setValidator(QIntValidator(0, 3200, self.iedit))
        self.dedit.setValidator(QDoubleValidator(0., 999.0, 1, self.dedit))
        button_autotuneON = QPushButton(QApplication.translate("Button","Autotune ON",None, QApplication.UnicodeUTF8))
        button_autotuneOFF = QPushButton(QApplication.translate("Button","Autotune OFF",None, QApplication.UnicodeUTF8))
        button_readpid = QPushButton(QApplication.translate("Button","Read PID Values",None, QApplication.UnicodeUTF8))
        tab3cancelbutton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        self.connect(button_autotuneON, SIGNAL("clicked()"), lambda flag=1: self.setONOFFautotune(flag))
        self.connect(button_autotuneOFF, SIGNAL("clicked()"), lambda flag=0: self.setONOFFautotune(flag))
        self.connect(button_p, SIGNAL("clicked()"), lambda var="p": self.setpid(var))
        self.connect(button_i, SIGNAL("clicked()"), lambda var="i": self.setpid(var))
        self.connect(button_d, SIGNAL("clicked()"), lambda var="d": self.setpid(var))
        self.connect(tab3cancelbutton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(button_readpid, SIGNAL("clicked()"), self.getpid)
        #TAB4
        #table for setting segments
        self.segmenttable = QTableWidget()
        self.createsegmenttable()
        #****************************   TAB5 WIDGETS
        ETthermolabel = QLabel(QApplication.translate("Label","ET Thermocouple type",None, QApplication.UnicodeUTF8))
        BTthermolabel = QLabel(QApplication.translate("Label","BT Thermocouple type",None, QApplication.UnicodeUTF8))
        BTthermolabelnote = QLabel(QApplication.translate("Label","NOTE: BT Thermocouple type is not stored in the Artisan settings",None, QApplication.UnicodeUTF8))
        self.ETthermocombobox = QComboBox()
        self.BTthermocombobox = QComboBox()
        self.BTthermocombobox.setStyleSheet("background-color:'lightgrey';")
        ## FUJI PXG input types
        ##0 (JPT 100'3f)
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##9 (no function)
        ##10 (no function)
        ##11 (no function)
        ##12 (N)
        ##13 (PL- 2)
        ##14 (no function)
        ##15 (0V to 5V / 0mA to 20mA
        ##16 (1V to 5V/4mA to 20mA)
        ##17 (0mV to 10V)
        ##18 (2V to 10V)
        ##19 (0mV to 100mV)
        self.PXGthermotypes = ["JPT 100",#0
                            "PT 100",    #1
                            "J",         #2
                            "K",         #3
                            "R",         #4
                            "B",         #5
                            "S",         #6
                            "T",         #7
                            "E",         #8
                            "N",         #12
                            "PL-2",      #13
                            "0V-5V/0mA-20mA", #15
                            "1V-5V/4mA-20mA", #16
                            "0mV-10V",   #17
                            "2V to 10V", #18
                            "0mV-100mV"  #19
                            ]
        self.PXGconversiontoindex = [0,1,2,3,4,5,6,7,8,12,13,15,16,17,18,19]  #converts fuji PID PXG types to indexes
        ## FUJI PXR input types
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##12 (N)
        ##13 (PL- 2)
        ##16 (1V to 5V/4mA to 20mA)
        self.PXRthermotypes = [
                            "PT 100",   #1
                            "J",        #2
                            "K",        #3
                            "R",        #4
                            "B",        #5
                            "S",        #6
                            "T",        #7
                            "E",        #8
                            "N",        #12
                            "PL-2",    #13
                            "1V to 5V/4mA to 20mA" #16
                            ]
        self.PXRconversiontoindex = [1,2,3,4,5,6,7,8,12,13,16]  #converts fuji PID PXR types to indexes
        self.ETthermocombobox.addItems(self.PXRthermotypes)
        if aw.ser.readBTpid[0] == 0:        #fuji PXG
            self.BTthermocombobox.addItems(self.PXGthermotypes)
        else:                               #fuji PXR
            self.BTthermocombobox.addItems(self.PXRthermotypes)
        if aw.fujipid.PXR["pvinputtype"][0] in self.PXRconversiontoindex:
            self.ETthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(aw.fujipid.PXR["pvinputtype"][0]))
        setETthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        setBTthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        getETthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        getBTthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        setETthermocouplebutton.setMaximumWidth(80)
        getETthermocouplebutton.setMaximumWidth(80)
        setBTthermocouplebutton.setMaximumWidth(80)
        getBTthermocouplebutton.setMaximumWidth(80)
        self.connect(setETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.setthermocoupletype(PID))
        self.connect(setBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.setthermocoupletype(PID))
        self.connect(getETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.readthermocoupletype(PID))
        self.connect(getBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.readthermocoupletype(PID))
        PointButtonET = QPushButton(QApplication.translate("Button","Set ET PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonBT = QPushButton(QApplication.translate("Button","Set BT PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonET.setMaximumWidth(180)
        PointButtonBT.setMaximumWidth(180)
        pointlabel = QLabel(QApplication.translate("Label","Artisan uses 1 decimal point",None, QApplication.UnicodeUTF8))
        self.connect(PointButtonET, SIGNAL("clicked()"), lambda PID="ET": self.setpoint(PID))
        self.connect(PointButtonBT, SIGNAL("clicked()"), lambda PID="BT": self.setpoint(PID))
        #create layouts
        buttonMasterLayout = QGridLayout()
        buttonRampSoakLayout1 = QVBoxLayout()
        buttonRampSoakLayout2 = QVBoxLayout()
        tab3layout = QGridLayout()
        svlayout = QGridLayout()
        #place rs buttoms in RampSoakLayout1
        buttonRampSoakLayout1.addWidget(self.labelrs1,0)
        buttonRampSoakLayout1.addWidget(self.label_rs1,1)
        buttonRampSoakLayout1.addWidget(self.label_rs2,2)
        buttonRampSoakLayout1.addWidget(self.label_rs3,3)
        buttonRampSoakLayout1.addWidget(self.label_rs4,4)
        buttonRampSoakLayout2.addWidget(self.labelrs2,0)
        buttonRampSoakLayout2.addWidget(self.label_rs5,1)
        buttonRampSoakLayout2.addWidget(self.label_rs6,2)
        buttonRampSoakLayout2.addWidget(self.label_rs7,3)
        buttonRampSoakLayout2.addWidget(self.label_rs8,4)
        buttonMasterLayout.addLayout(buttonRampSoakLayout1,0,0)
        buttonMasterLayout.addLayout(buttonRampSoakLayout2,0,1)
        buttonMasterLayout.addWidget(labelpattern,1,0)
        buttonMasterLayout.addWidget(self.patternComboBox,1,1)
        buttonMasterLayout.addWidget(button_rson,2,0)
        buttonMasterLayout.addWidget(button_rsoff,2,1)
        buttonMasterLayout.addWidget(button_autotuneOFF,3,1)
        buttonMasterLayout.addWidget(button_autotuneON,3,0)
        buttonMasterLayout.addWidget(button_standbyOFF,4,0)
        buttonMasterLayout.addWidget(button_standbyON,4,1)
        buttonMasterLayout.addWidget(button_getall,5,0)
        buttonMasterLayout.addWidget(button_exit,5,1)
        #tab 2
        svlayout.addWidget(svwarning2,0,0)
        svlayout.addWidget(svwarning1,0,1)
        svlayout.addWidget(self.readsvedit,1,0)
        svlayout.addWidget(tab2getsvbutton,1,1)
        svlayout.addWidget(self.svedit,2,0)
        svlayout.addWidget(tab2svbutton,2,1)
        svlayout.addWidget(tab2easyONsvbutton,3,0)
        svlayout.addWidget(tab2easyOFFsvbutton,3,1)
        svlayout.addWidget(tab2cancelbutton,4,1)
        #tab 3
        tab3layout.addWidget(plabel,0,0)
        tab3layout.addWidget(self.pedit,0,1)
        tab3layout.addWidget(button_p,0,2)
        tab3layout.addWidget(ilabel,1,0)
        tab3layout.addWidget(self.iedit,1,1)
        tab3layout.addWidget(button_i,1,2)
        tab3layout.addWidget(dlabel,2,0)
        tab3layout.addWidget(self.dedit,2,1)
        tab3layout.addWidget(button_d,2,2)
        tab3layout.addWidget(button_autotuneON,3,1)
        tab3layout.addWidget(button_autotuneOFF,3,2)
        tab3layout.addWidget(button_readpid,4,1)
        tab3layout.addWidget(tab3cancelbutton,4,2)
        tab4layout = QVBoxLayout()
        tab4layout.addWidget(self.segmenttable)
        #tab5
        thermolayout = QGridLayout()
        thermolayout.addWidget(ETthermolabel,0,0)
        thermolayout.addWidget(self.ETthermocombobox,0,1)
        thermolayout.addWidget(getETthermocouplebutton,0,2)
        thermolayout.addWidget(setETthermocouplebutton,0,3)
        thermolayout.addWidget(BTthermolabel,1,0)
        thermolayout.addWidget(self.BTthermocombobox,1,1)
        thermolayout.addWidget(getBTthermocouplebutton,1,2)
        thermolayout.addWidget(setBTthermocouplebutton,1,3)
        tab5Layout = QVBoxLayout()
        tab5Layout.addStretch()
        tab5Layout.addLayout(thermolayout)
        tab5Layout.addWidget(BTthermolabelnote)
        tab5Layout.addStretch()
        tab5Layout.addWidget(pointlabel)
        tab5Layout.addWidget(PointButtonET)
        tab5Layout.addWidget(PointButtonBT)
        tab5Layout.addStretch()
        ###################################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(buttonMasterLayout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","RS",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(svlayout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","SV",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","PID",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Set RS",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Extra",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(self.status,0)
        Mlayout.addWidget(TabWidget,1)
        self.setLayout(Mlayout)

    def setpoint(self,PID):
        command = ""
        try:
            if PID == "ET":
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["decimalposition"][1],1)
            elif PID == "BT":
                if aw.ser.readBTpid[0] == 0:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["decimalposition"][1],1)
                elif aw.ser.readBTpid[0] == 1:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["decimalposition"][1],1)
            r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Decimal position successfully set to 1",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting decimal position",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setpoint(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setthermocoupletype(self,PID):
        command = ""
        try:
            if PID == "ET":
                index = self.ETthermocombobox.currentIndex()
                value = self.PXRconversiontoindex[index]
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["pvinputtype"][1],value)
            elif PID == "BT":
                index = self.BTthermocombobox.currentIndex()
                if aw.ser.readBTpid[0] == 0:
                    value = self.PXGconversiontoindex[index]
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["pvinputtype"][1],value)
                elif aw.ser.readBTpid[0] == 1:
                    value = self.PXRconversiontoindex[index]
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["pvinputtype"][1],value)
            r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                if PID == "ET":
                    aw.fujipid.PXG4["pvinputtype"][0] = self.PXRconversiontoindex[self.ETthermocombobox.currentIndex()]
                elif PID == "BT":
                    pass #this info is not stored
                message = QApplication.translate("StatusBar","Thermocouple type successfully set to %i"%(value),None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting thermocouple type",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def readthermocoupletype(self,PID):
        message = "empty"
        command = ""
        try:
            if PID == "ET":
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["pvinputtype"][1],1)
            elif PID == "BT":
                if aw.ser.readBTpid[0] == 0:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXG4["pvinputtype"][1],1)
                elif aw.ser.readBTpid[0] == 1:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXR["pvinputtype"][1],1)
            if command:
                Thtype = aw.fujipid.readoneword(command)
                
                if PID == "ET":
                    if Thtype in self.PXRconversiontoindex:
                        self.ETthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(Thtype))
                        aw.fujipid.PXR["pvinputtype"][0] = Thtype
                        message = "ET PXR input type %i: %s"%(Thtype,self.PXRthermotypes[self.PXRconversiontoindex.index(Thtype)])
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:
                        if Thtype in self.PXGconversiontoindex:
                            self.BTthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(Thtype))
                            message = "BT PXG input type %i: %s"%(Thtype,self.PXGthermotypes[self.PXGconversiontoindex.index(Thtype)])
                    elif aw.ser.readBTpid[0] == 1:
                        if Thtype in self.PXRconversiontoindex:
                            self.BTthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(Thtype))
                            aw.fujipid.PXR["pvinputtype"][0] = Thtype
                            message = "BT PXR input type %i: %s"%(Thtype,self.PXRthermotypes[self.PXRconversiontoindex.index(Thtype)])
                self.status.showMessage(message,5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " readthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def paintlabels(self):
        str1 = "T = " + str(aw.fujipid.PXR["segment1sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment1ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment1soak"][0]))
        str2 = "T = " + str(aw.fujipid.PXR["segment2sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment2ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment2soak"][0]))
        str3 = "T = " + str(aw.fujipid.PXR["segment3sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment3ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment3soak"][0]))
        str4 = "T = " + str(aw.fujipid.PXR["segment4sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment4ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment4soak"][0]))
        str5 = "T = " + str(aw.fujipid.PXR["segment5sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment5ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment5soak"][0]))
        str6 = "T = " + str(aw.fujipid.PXR["segment6sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment6ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment6soak"][0]))
        str7 = "T = " + str(aw.fujipid.PXR["segment7sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment7ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment7soak"][0]))
        str8 = "T = " + str(aw.fujipid.PXR["segment8sv"][0]) + "\nRamp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment8ramp"][0])) + "\nSoak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment8soak"][0]))
        self.label_rs1.setText(QString(str1))
        self.label_rs2.setText(QString(str2))
        self.label_rs3.setText(QString(str3))
        self.label_rs4.setText(QString(str4))
        self.label_rs5.setText(QString(str5))
        self.label_rs6.setText(QString(str6))
        self.label_rs7.setText(QString(str7))
        self.label_rs8.setText(QString(str8))
        pattern = [[1,1,1,1,0,0,0,0],
                  [0,0,0,0,1,1,1,1],
                  [1,1,1,1,1,1,1,1]]
        aw.fujipid.PXR["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][0]:   
            self.label_rs1.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs1.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][1]:
            self.label_rs2.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs2.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][2]:   
            self.label_rs3.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs3.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][3]:   
            self.label_rs4.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs4.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][4]:   
            self.label_rs5.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs5.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][5]:   
            self.label_rs6.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs6.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][6]:   
            self.label_rs7.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs7.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][7]:   
            self.label_rs8.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs8.setStyleSheet("background-color:white;")

    def setONOFFautotune(self,flag):
        self.status.showMessage(QApplication.translate("StatusBar","setting autotune...",None, QApplication.UnicodeUTF8),500)
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["autotuning"][1],flag)
        #TX and RX
        r = aw.ser.sendFUJIcommand(command,8)
        if len(r) == 8:
            if flag == 0:
                aw.fujipid.PXR["autotuning"][0] = 0
                self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned OFF",None, QApplication.UnicodeUTF8),5000)
            if flag == 1:
                aw.fujipid.PXR["autotuning"][0] = 1
                self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned ON",None, QApplication.UnicodeUTF8),5000) 
        else:
            mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFautotune()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFautotune()")

    def setONOFFstandby(self,flag):
        #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
        #flag = 0 standby OFF, flag = 1 standby ON (pid off)
        self.status.showMessage(QApplication.translate("StatusBar","wait...",None, QApplication.UnicodeUTF8),500)
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["runstandby"][1],flag)
        #TX and RX
        r = aw.ser.sendFUJIcommand(command,8)
        if r == command:
            if flag == 1:
                message = QApplication.translate("StatusBar","PID OFF",None, QApplication.UnicodeUTF8)     #put pid in standby 1 (pid on)
                aw.fujipid.PXR["runstandby"][0] = 1
            elif flag == 0:
                message = QApplication.translate("StatusBar","PID ON",None, QApplication.UnicodeUTF8)      #put pid in standby 0 (pid off)
                aw.fujipid.PXR["runstandby"][0] = 0
            self.status.showMessage(message,5000)
        else:
            mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFstandby()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def setsv(self):
        if self.svedit.text() != "":
            newSVvalue = int(float(self.svedit.text())*10) #multiply by 10 because of decimal point
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["sv0"][1],newSVvalue)
            r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                message = QApplication.translate("StatusBar","SV successfully set to %1",None, QApplication.UnicodeUTF8).arg(self.svedit.text())
                aw.fujipid.PXR["sv0"][0] = float(str(self.svedit.text()))
                self.status.showMessage(message,5000)
                #record command as an Event 
                strcommand = "SETSV::"+ str("%.1f"%(newSVvalue/10.))
                aw.qmc.DeviceEventRecord(strcommand)
            else:
                mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setsv()"
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
        else:
            self.status.showMessage(QApplication.translate("StatusBar","Empty SV box",None, QApplication.UnicodeUTF8),5000)

    def getsv(self):
        temp = aw.fujipid.readcurrentsv()
        if temp != -1:
            aw.fujipid.PXR["sv0"][0] =  temp
            aw.lcd6.display(aw.fujipid.PXR["sv0"][0])
            self.readsvedit.setText(str(aw.fujipid.PXR["sv0"][0]))
        else:
            self.status.showMessage(QApplication.translate("StatusBar","Unable to read SV",None, QApplication.UnicodeUTF8),5000)

    def checkrampsoakmode(self):
        msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["rampsoakmode"][1],1)
        currentmode = aw.fujipid.readoneword(msg)
        aw.fujipid.PXR["rampsoakstartend"][0] = currentmode
        if currentmode == 0:
            mode = ["0",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 1:
            mode = ["1",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 2:
            mode = ["2",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 3:
            mode = ["3",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 4:
            mode = ["4",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 5:
            mode = ["5",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 6:
            mode = ["6",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 7:
            mode = ["7",
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 8:
            mode = ["8",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 9:
            mode = ["9",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 10:
            mode = ["10",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 11:
            mode = ["11",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 12:
            mode = ["12",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 13:
            mode = ["13",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        elif currentmode == 14:
            mode = ["14",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None, QApplication.UnicodeUTF8)]
        elif currentmode == 15:
            mode = ["15",
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None, QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None, QApplication.UnicodeUTF8)]
        else:
            return -1
        string =  QApplication.translate("Message","The rampsoak-mode tells how to start and end the ramp/soak",None, QApplication.UnicodeUTF8) + "\n\n"
        string += QApplication.translate("Message","Your rampsoak mode in this pid is:",None, QApplication.UnicodeUTF8) + "\n\n"
        string += QApplication.translate("Message","Mode = %1",None, QApplication.UnicodeUTF8).arg(mode[0]) + "\n"
        string += "-----------------------------------------------------------------------\n"
        string += QApplication.translate("Message","Start to run from PV value: %1",None, QApplication.UnicodeUTF8).arg(mode[1]) + "\n"
        string += QApplication.translate("Message","End output status at the end of ramp/soak: %1",None, QApplication.UnicodeUTF8).arg(mode[2]) + "\n"
        string += QApplication.translate("Message","Output status while ramp/soak operation set to OFF: %1",None, QApplication.UnicodeUTF8).arg(mode[3]) + "\n"
        string += QApplication.translate("Message","\nRepeat Operation at the end: %1",None, QApplication.UnicodeUTF8).arg(mode[4]) + "\n"
        string += "-----------------------------------------------------------------------\n"
        string += QApplication.translate("Message","Recomended Mode = 0",None, QApplication.UnicodeUTF8) + "\n\n"
        string += QApplication.translate("Message","If you need to change it, change it now and come back later",None, QApplication.UnicodeUTF8) + "\n"
        string += QApplication.translate("Message","Use the Parameter Loader Software by Fuji if you need to\n\n",None, QApplication.UnicodeUTF8) + "\n\n\n"
        string += QApplication.translate("Message","Continue?",None, QApplication.UnicodeUTF8)
        QMessageBox.information(self,QApplication.translate("Message", "RampSoak Mode",None, QApplication.UnicodeUTF8),string)

    def setONOFFrampsoak(self,flag):
        #flag =0 OFF, flag = 1 ON, flag = 2 hold
        #set rampsoak pattern ON
        if flag == 1:
            check = self.checkrampsoakmode()
            if check == 0:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak operation cancelled",None, QApplication.UnicodeUTF8), 5000)
                return
            elif check == -1:
                self.status.showMessage(QApplication.translate("StatusBar","No RX data",None, QApplication.UnicodeUTF8), 5000)
                
            self.status.showMessage(QApplication.translate("StatusBar","RS ON",None, QApplication.UnicodeUTF8),500)
            #0 = 1-4
            #1 = 5-8
            #2 = 1-8
            selectedmode = self.patternComboBox.currentIndex()
            msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["rampsoakpattern"][1],1)
            currentmode = aw.fujipid.readoneword(msg)
            if currentmode != -1:
                aw.fujipid.PXR["rampsoakpattern"][0] = currentmode
                if currentmode != selectedmode:
                    #set mode in pid to match the mode selected in the combobox
                    self.status.showMessage(QApplication.translate("StatusBar","Need to change pattern mode...",None, QApplication.UnicodeUTF8),1000)
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["rampsoakpattern"][1],selectedmode)
                    r = aw.ser.sendFUJIcommand(command,8)
                    if len(r) == 8:
                        self.status.showMessage(QApplication.translate("StatusBar","Pattern has been changed. Wait 5 secs.",None, QApplication.UnicodeUTF8), 500)
                        aw.fujipid.PXR["rampsoakpattern"][0] = selectedmode
                    else:
                        self.status.showMessage(QApplication.translate("StatusBar","Pattern could not be changed",None, QApplication.UnicodeUTF8), 5000)
                        return
                #combobox mode matches pid mode
                #set ramp soak mode ON
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["rampsoak"][1],flag)
                r = aw.ser.sendFUJIcommand(command,8)
                if r == command:
                    #record command as an Event if flag = 1
                    self.status.showMessage(QApplication.translate("StatusBar","RS ON",None, QApplication.UnicodeUTF8), 5000)
                    #ramp soak pattern. 0=executes 1 to 4; 1=executes 5 to 8; 2=executes 1 to 8
                    pattern =[[1,4],[5,8],[1,8]]
                    start = pattern[aw.fujipid.PXR["rampsoakpattern"][0]][0]
                    end = pattern[aw.fujipid.PXR["rampsoakpattern"][0]][1]+1
                    strcommand = "SETRS"
                    result = ""
                    for i in range(start,end):
                        svkey = "segment"+str(i)+"sv"
                        rampkey = "segment"+str(i)+"ramp"
                        soakkey = "segment"+str(i)+"soak"
                        strcommand += "::" + str(aw.fujipid.PXR[svkey][0]) + "::" + str(aw.fujipid.PXR[rampkey][0]) + "::" + str(aw.fujipid.PXR[soakkey][0])+"::"
                        result += strcommand
                        strcommand = "SETRS"
                    result = result.strip("::")
                    aw.qmc.DeviceEventRecord(result)
                else:
                    self.status.showMessage(QApplication.translate("StatusBar","RampSoak could not be changed",None, QApplication.UnicodeUTF8), 5000)
            else:
                mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setONOFFrampsoak()"
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
        #set ramp soak OFF
        elif flag == 0:
            self.status.showMessage(QApplication.translate("StatusBar","RS OFF",None, QApplication.UnicodeUTF8),500)
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["rampsoak"][1],flag)
            r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                self.status.showMessage(QApplication.translate("StatusBar","RS successfully turned OFF",None, QApplication.UnicodeUTF8), 5000)
                aw.fujipid.PXR["rampsoak"][0] = flag
            else:
                mssg = QApplication.translate("StatusBar","setONOFFrampsoak(): Ramp Soak could not be set OFF",None, QApplication.UnicodeUTF8)
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)

    def getsegment(self, idn):
        svkey = "segment" + str(idn) + "sv"
        svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR[svkey][1],1)
        sv = aw.fujipid.readoneword(svcommand)
        if sv == -1:
            mssg = QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " getsegment()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            return -1
        aw.fujipid.PXR[svkey][0] = sv/10.              #divide by 10 because the decimal point is not sent by the PID
        rampkey = "segment" +str(idn) + "ramp"
        rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR[rampkey][1],1)
        ramp = aw.fujipid.readoneword(rampcommand)
        if ramp == -1:
            mssg = QApplication.translate("StatusBar","getsegment(): problem reading ramp",None, QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            return -1
        aw.fujipid.PXR[rampkey][0] = ramp/10.
        soakkey = "segment" + str(idn) + "soak"
        soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR[soakkey][1],1)
        soak = aw.fujipid.readoneword(soakcommand)
        if soak == -1:
            mssg = QApplication.translate("StatusBar","getsegment(): problem reading soak",None, QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
            return -1
        aw.fujipid.PXR[soakkey][0] = soak/10.

    #get all Ramp Soak values for all 8 segments
    def getallsegments(self):
        for i in range(8):
            msg = "Reading Ramp/Soak #" + str(i+1)
            self.status.showMessage(msg,500)
            k = self.getsegment(i+1)
            if k == -1:
                mssg = QApplication.translate("StatusBar","getallsegments(): problem reading R/S ",None, QApplication.UnicodeUTF8)
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
                return
            self.paintlabels()
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading Ramp/Soak val.",None, QApplication.UnicodeUTF8),5000)

    def getpid(self):
        pcommand= aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["p"][1],1)
        p = aw.fujipid.readoneword(pcommand)/10.
        if p == -1 :
            return -1
        else:
            self.pedit.setText(str(p))
            aw.fujipid.PXR["p"][0] = p
        #i is int range 0-3200
        icommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["i"][1],1)
        i = aw.fujipid.readoneword(icommand)/10
        if i == -1:
            return -1
        else:
            self.iedit.setText(str(int(i)))
            aw.fujipid.PXR["i"][0] = i
        dcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["d"][1],1)
        d = aw.fujipid.readoneword(dcommand)/10.
        if d == -1:
            return -1
        else:
            self.dedit.setText(str(d))
            aw.fujipid.PXR["d"][0] = d
            
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading pid values",None, QApplication.UnicodeUTF8),5000)

    def setpid(self,var):
        r = ""
        if var == "p":
            if str(self.pedit.text()).isdigit():
                p = int(str(self.pedit.text()))*10
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["p"][1],p)
                r = aw.ser.sendFUJIcommand(command,8)
            else:
                return -1
        elif var == "i":
            if str(self.iedit.text()).isdigit():
                i = int(str(self.iedit.text()))*10
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["i"][1],i)
                r = aw.ser.sendFUJIcommand(command,8)
            else:
                return -1
        elif var == "d":
            if str(self.dedit.text()).isdigit():
                d = int(str(self.dedit.text()))*10
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["d"][1],d)
                r = aw.ser.sendFUJIcommand(command,8)
            else:
                return -1
                
        if len(r) == 8:
            message = QApplication.translate("StatusBar","%1 successfully send to pid ",None, QApplication.UnicodeUTF8).arg(var)
            self.status.showMessage(message,5000)
            if var == "p":
                aw.fujipid.PXR["p"][0] = p
            elif var == "i":
                aw.fujipid.PXR["i"][0] = i
            elif var == "d":
                aw.fujipid.PXR["i"][0] = d
        else:
            mssg = QApplication.translate("StatusBar","setpid(): There was a problem setting %1",None, QApplication.UnicodeUTF8).arg(var)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def createsegmenttable(self):
        self.segmenttable.setRowCount(8)
        self.segmenttable.setColumnCount(4)
        self.segmenttable.setHorizontalHeaderLabels([QApplication.translate("Table","SV",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("Table","Ramp HH:MM",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("Table","Soak HH:MM",None, QApplication.UnicodeUTF8),""])
        self.segmenttable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.segmenttable.setSelectionBehavior(QTableWidget.SelectRows)
        self.segmenttable.setSelectionMode(QTableWidget.SingleSelection)
        self.segmenttable.setShowGrid(True)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #populate table
        for i in range(8):
            #create widgets
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            
            svedit = QLineEdit(str(aw.fujipid.PXR[svkey][0]))
            svedit.setValidator(QDoubleValidator(0., 999., 1, svedit))
            rampedit = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXR[rampkey][0])))
            rampedit.setValidator(QRegExpValidator(regextime,self))
            soakedit  = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXR[soakkey][0])))
            soakedit.setValidator(QRegExpValidator(regextime,self))
            setButton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
            self.connect(setButton,SIGNAL("clicked()"),lambda idn =i:self.setsegment(i))
            #add widgets to the table
            self.segmenttable.setCellWidget(i,0,svedit)
            self.segmenttable.setCellWidget(i,1,rampedit)
            self.segmenttable.setCellWidget(i,2,soakedit)
            self.segmenttable.setCellWidget(i,3,setButton)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    def setsegment(self,i):
        idn = i+1
        svedit =  self.segmenttable.cellWidget(i,0)
        rampedit = self.segmenttable.cellWidget(i,1)
        soakedit = self.segmenttable.cellWidget(i,2)
        sv = float(str(svedit.text()))
        ramp = aw.qmc.stringtoseconds(str(rampedit.text()))
        soak = aw.qmc.stringtoseconds(str(soakedit.text()))
        svkey = "segment" + str(idn) + "sv"
        svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[svkey][1],int(sv*10))
        r1 = aw.ser.sendFUJIcommand(svcommand,8)
        libtime.sleep(0.1) #important time between writings
        rampkey = "segment" + str(idn) + "ramp"
        rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[rampkey][1],ramp)
        r2 = aw.ser.sendFUJIcommand(rampcommand,8)
        libtime.sleep(0.1) #important time between writings
        soakkey = "segment" + str(idn) + "soak"
        soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[soakkey][1],soak)
        r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1) == 8 and len(r2) == 8 and len(r3) == 8:
            aw.fujipid.PXR[svkey][0] = sv
            aw.fujipid.PXR[rampkey][0] = ramp
            aw.fujipid.PXR[soakkey][0] = soak
            self.paintlabels()
            self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak successfully written",None, QApplication.UnicodeUTF8),5000) 
        else:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None, QApplication.UnicodeUTF8))

############################################################################
######################## FUJI PXG4 PID CONTROL DIALOG ######################
############################################################################

class PXG4pidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(PXG4pidDlgControl,self).__init__(parent)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXG PID Control",None, QApplication.UnicodeUTF8))
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Ready",None, QApplication.UnicodeUTF8),5000)
        #*************    TAB 1 WIDGETS
        labelrs1 = QLabel()
        labelrs1.setMargin(5)
        labelrs1.setStyleSheet("background-color:'#CCCCCC';")
        labelrs1.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak (MM:SS)<br>(1-7)",None, QApplication.UnicodeUTF8) + "<\b></font>")
        #labelrs1.setMaximumSize(90, 42)
        #labelrs1.setMinimumHeight(50)
        labelrs2 = QLabel()
        labelrs2.setMargin(5)
        labelrs2.setStyleSheet("background-color:'#CCCCCC';")
        labelrs2.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak (MM:SS)<br>(8-16)",None, QApplication.UnicodeUTF8) + "<\b></font>")
        #labelrs2.setMaximumSize(90, 42)
        #labelrs2.setMinimumHeight(50)
        self.label_rs1 =  QLabel()
        self.label_rs2 =  QLabel()
        self.label_rs3 =  QLabel()
        self.label_rs4 =  QLabel()
        self.label_rs5 =  QLabel()
        self.label_rs6 =  QLabel()
        self.label_rs7 =  QLabel()
        self.label_rs8 =  QLabel()
        self.label_rs9 =  QLabel()
        self.label_rs10 =  QLabel()
        self.label_rs11 =  QLabel()
        self.label_rs12 =  QLabel()
        self.label_rs13 =  QLabel()
        self.label_rs14 =  QLabel()
        self.label_rs15 =  QLabel()
        self.label_rs16 =  QLabel()
        self.label_rs1.setMinimumWidth(170)
        self.label_rs2.setMinimumWidth(170)
        self.label_rs3.setMinimumWidth(170)
        self.label_rs4.setMinimumWidth(170)
        self.label_rs5.setMinimumWidth(170)
        self.label_rs6.setMinimumWidth(170)
        self.label_rs7.setMinimumWidth(170)
        self.label_rs8.setMinimumWidth(170)
        self.label_rs9.setMinimumWidth(170)
        self.label_rs10.setMinimumWidth(170)
        self.label_rs11.setMinimumWidth(170)
        self.label_rs12.setMinimumWidth(170)
        self.label_rs13.setMinimumWidth(170)
        self.label_rs14.setMinimumWidth(170)
        self.label_rs15.setMinimumWidth(170)
        self.label_rs16.setMinimumWidth(170)
        self.patternComboBox =  QComboBox()
        self.patternComboBox.addItems(["1-4","5-8","1-8","9-12","13-16","9-16","1-16"])
        self.patternComboBox.setCurrentIndex(aw.fujipid.PXG4["rampsoakpattern"][0])
        self.connect(self.patternComboBox,SIGNAL("currentIndexChanged(int)"),self.paintlabels)
        self.paintlabels()
        patternlabel = QLabel(QApplication.translate("Label","Pattern",None, QApplication.UnicodeUTF8))
        patternlabel.setAlignment(Qt.AlignRight)
        button_getall = QPushButton(QApplication.translate("Button","Read RS values",None, QApplication.UnicodeUTF8))
        button_rson =  QPushButton(QApplication.translate("Button","RampSoak ON",None, QApplication.UnicodeUTF8))        
        button_rsoff =  QPushButton(QApplication.translate("Button","RampSoak OFF",None, QApplication.UnicodeUTF8))
        button_exit = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        button_exit2 = QPushButton(QApplication.translate("Button","Close",None, QApplication.UnicodeUTF8))
        button_standbyON = QPushButton(QApplication.translate("Button","PID OFF",None, QApplication.UnicodeUTF8))
        button_standbyOFF = QPushButton(QApplication.translate("Button","PID ON",None, QApplication.UnicodeUTF8))
        self.connect(button_getall, SIGNAL("clicked()"), self.getallsegments)
        self.connect(button_rson, SIGNAL("clicked()"), lambda flag=1: self.setONOFFrampsoak(flag))
        self.connect(button_rsoff, SIGNAL("clicked()"), lambda flag=0: self.setONOFFrampsoak(flag))
        self.connect(button_standbyON, SIGNAL("clicked()"), lambda flag=1: self.setONOFFstandby(flag))
        self.connect(button_standbyOFF, SIGNAL("clicked()"), lambda flag=0: self.setONOFFstandby(flag))
        self.connect(button_exit, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(button_exit2, SIGNAL("clicked()"),self, SLOT("reject()"))
        #create layouts and place tab1 widgets inside 
        buttonRampSoakLayout1 = QVBoxLayout() #TAB1/COLUNM 1
        buttonRampSoakLayout1.setSpacing(10)
        buttonRampSoakLayout2 = QVBoxLayout() #TAB1/COLUMN 2 
        buttonRampSoakLayout2.setSpacing(10)
        #place rs labels in RampSoakLayout1 #TAB1/COLUNM 1
        buttonRampSoakLayout1.addWidget(labelrs1)
        buttonRampSoakLayout1.addWidget(self.label_rs1)
        buttonRampSoakLayout1.addWidget(self.label_rs2)
        buttonRampSoakLayout1.addWidget(self.label_rs3)
        buttonRampSoakLayout1.addWidget(self.label_rs4)
        buttonRampSoakLayout1.addWidget(self.label_rs5)
        buttonRampSoakLayout1.addWidget(self.label_rs6)
        buttonRampSoakLayout1.addWidget(self.label_rs7)
        buttonRampSoakLayout1.addWidget(self.label_rs8)
        #place rs labels in RampSoakLayout2 #TAB1/COLUMN 2
        buttonRampSoakLayout2.addWidget(labelrs2)
        buttonRampSoakLayout2.addWidget(self.label_rs9)
        buttonRampSoakLayout2.addWidget(self.label_rs10)
        buttonRampSoakLayout2.addWidget(self.label_rs11)
        buttonRampSoakLayout2.addWidget(self.label_rs12)
        buttonRampSoakLayout2.addWidget(self.label_rs13)
        buttonRampSoakLayout2.addWidget(self.label_rs14)
        buttonRampSoakLayout2.addWidget(self.label_rs15)
        buttonRampSoakLayout2.addWidget(self.label_rs16)
        # *************** TAB 2 WIDGETS
        labelsv = QLabel()
        labelsv.setMargin(10)
        labelsv.setStyleSheet("background-color:'#CCCCCC';")
        labelsv.setText("<font color='white'><b>" + QApplication.translate("Label", "SV (7-0)",None, QApplication.UnicodeUTF8) + "<\b></font>")
        labelsv.setMaximumSize(100, 42)
        labelsv.setMinimumHeight(50)
        labelsvedit = QLabel()
        labelsvedit.setMargin(10)
        labelsvedit.setStyleSheet("background-color:'#CCCCCC';")
        labelsvedit.setText("<font color='white'><b>" + QApplication.translate("Label", "Write",None, QApplication.UnicodeUTF8) + "<\b></font>")
        labelsvedit.setMaximumSize(100, 42)
        labelsvedit.setMinimumHeight(50)
        button_sv1 =QPushButton(QApplication.translate("Button","Write SV1",None, QApplication.UnicodeUTF8))
        button_sv2 =QPushButton(QApplication.translate("Button","Write SV2",None, QApplication.UnicodeUTF8))
        button_sv3 =QPushButton(QApplication.translate("Button","Write SV3",None, QApplication.UnicodeUTF8))
        button_sv4 =QPushButton(QApplication.translate("Button","Write SV4",None, QApplication.UnicodeUTF8))
        button_sv5 =QPushButton(QApplication.translate("Button","Write SV5",None, QApplication.UnicodeUTF8))
        button_sv6 =QPushButton(QApplication.translate("Button","Write SV6",None, QApplication.UnicodeUTF8))
        button_sv7 =QPushButton(QApplication.translate("Button","Write SV7",None, QApplication.UnicodeUTF8))
        self.connect(button_sv1, SIGNAL("clicked()"), lambda v=1: self.setsv(v))
        self.connect(button_sv2, SIGNAL("clicked()"), lambda v=2: self.setsv(v))
        self.connect(button_sv3, SIGNAL("clicked()"), lambda v=3: self.setsv(v))
        self.connect(button_sv4, SIGNAL("clicked()"), lambda v=4: self.setsv(v))
        self.connect(button_sv5, SIGNAL("clicked()"), lambda v=5: self.setsv(v))
        self.connect(button_sv6, SIGNAL("clicked()"), lambda v=6: self.setsv(v))
        self.connect(button_sv7, SIGNAL("clicked()"), lambda v=7: self.setsv(v))
        self.sv1edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv1"][0])))
        self.sv2edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv2"][0])))
        self.sv3edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv3"][0])))
        self.sv4edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv4"][0])))
        self.sv5edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv5"][0])))
        self.sv6edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv6"][0])))
        self.sv7edit = QLineEdit(QString(str(aw.fujipid.PXG4["sv7"][0])))
        self.sv1edit.setMaximumWidth(80)
        self.sv2edit.setMaximumWidth(80)
        self.sv3edit.setMaximumWidth(80)
        self.sv4edit.setMaximumWidth(80)
        self.sv5edit.setMaximumWidth(80)
        self.sv6edit.setMaximumWidth(80)
        self.sv7edit.setMaximumWidth(80)
        self.sv1edit.setValidator(QDoubleValidator(0., 999., 1, self.sv1edit))
        self.sv2edit.setValidator(QDoubleValidator(0., 999., 1, self.sv2edit))
        self.sv3edit.setValidator(QDoubleValidator(0., 999., 1, self.sv3edit))
        self.sv4edit.setValidator(QDoubleValidator(0., 999., 1, self.sv4edit))
        self.sv5edit.setValidator(QDoubleValidator(0., 999., 1, self.sv5edit))
        self.sv6edit.setValidator(QDoubleValidator(0., 999., 1, self.sv6edit))
        self.sv7edit.setValidator(QDoubleValidator(0., 999., 1, self.sv7edit))
        self.radiosv1 = QRadioButton()
        self.radiosv2 = QRadioButton()
        self.radiosv3 = QRadioButton()
        self.radiosv4 = QRadioButton()
        self.radiosv5 = QRadioButton()
        self.radiosv6 = QRadioButton()
        self.radiosv7 = QRadioButton()
        N = aw.fujipid.PXG4["selectsv"][0]
        if N == 1:
            self.radiosv1.setChecked(True)
        elif N == 2:
            self.radiosv2.setChecked(True)
        elif N == 3:
            self.radiosv3.setChecked(True)
        elif N == 4:
            self.radiosv4.setChecked(True)
        elif N == 5:
            self.radiosv5.setChecked(True)
        elif N == 6:
            self.radiosv6.setChecked(True)
        elif N == 7:
            self.radiosv7.setChecked(True)
        tab2svbutton = QPushButton(QApplication.translate("Button","Write SV",None, QApplication.UnicodeUTF8))
        tab2cancelbutton = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton = QPushButton(QApplication.translate("Button","ON SV buttons",None, QApplication.UnicodeUTF8))
        tab2easyONsvbutton.setStyleSheet("QPushButton { background-color: 'lightblue'}")
        tab2easyOFFsvbutton = QPushButton(QApplication.translate("Button","OFF SV buttons",None, QApplication.UnicodeUTF8))
        tab2easyOFFsvbutton.setStyleSheet("QPushButton { background-color:'#ffaaff' }")
        tab2getsvbutton = QPushButton(QApplication.translate("Button","Read SV (7-0)",None, QApplication.UnicodeUTF8))
        self.connect(tab2svbutton, SIGNAL("clicked()"),self.setsv)
        self.connect(tab2getsvbutton, SIGNAL("clicked()"),self.getallsv)
        self.connect(tab2cancelbutton, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(tab2easyONsvbutton, SIGNAL("clicked()"), lambda flag=1: aw.fujipid.activateONOFFeasySV(flag))
        self.connect(tab2easyOFFsvbutton, SIGNAL("clicked()"), lambda flag=0: aw.fujipid.activateONOFFeasySV(flag))
        self.connect(self.radiosv1,SIGNAL("clicked()"), lambda sv=1: self.setNsv(sv))
        self.connect(self.radiosv2,SIGNAL("clicked()"), lambda sv=2: self.setNsv(sv))
        self.connect(self.radiosv3,SIGNAL("clicked()"), lambda sv=3: self.setNsv(sv))
        self.connect(self.radiosv4,SIGNAL("clicked()"), lambda sv=4: self.setNsv(sv))
        self.connect(self.radiosv5,SIGNAL("clicked()"), lambda sv=5: self.setNsv(sv))
        self.connect(self.radiosv6,SIGNAL("clicked()"), lambda sv=6: self.setNsv(sv))
        self.connect(self.radiosv7,SIGNAL("clicked()"), lambda sv=7: self.setNsv(sv))
        #****************   TAB 3 WIDGETS
        plabel = QLabel()
        plabel.setMargin(10)
        plabel.setStyleSheet("background-color:'#CCCCCC';")
        plabel.setText("<font color='white'><b>" + QApplication.translate("Label", "P",None, QApplication.UnicodeUTF8) + "<\b></font>")
        plabel.setMaximumSize(50, 42)
        plabel.setMinimumHeight(50)
        ilabel = QLabel()
        ilabel.setMargin(10)
        ilabel.setStyleSheet("background-color:'#CCCCCC';")
        ilabel.setText("<font color='white'><b>" + QApplication.translate("Label", "I",None, QApplication.UnicodeUTF8) + "<\b></font>")
        ilabel.setMaximumSize(50, 42)
        ilabel.setMinimumHeight(50)
        dlabel = QLabel()
        dlabel.setMargin(10)
        dlabel.setStyleSheet("background-color:'#CCCCCC';")
        dlabel.setText("<font color='white'><b>" + QApplication.translate("Label", "D",None, QApplication.UnicodeUTF8) + "<\b></font>")
        dlabel.setMaximumSize(50, 42)
        dlabel.setMinimumHeight(50)
        wlabel = QLabel()
        wlabel.setMargin(10)
        wlabel.setStyleSheet("background-color:'#CCCCCC';")
        wlabel.setText("<font color='white'><b>" + QApplication.translate("Label", "Write",None, QApplication.UnicodeUTF8) + "<\b></font>")
        wlabel.setMaximumSize(50, 42)
        wlabel.setMinimumHeight(50)
        self.p1edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p1"][0])))
        self.p2edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p2"][0])))
        self.p3edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p3"][0])))
        self.p4edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p4"][0])))
        self.p5edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p5"][0])))
        self.p6edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p6"][0])))
        self.p7edit =  QLineEdit(QString(str(aw.fujipid.PXG4["p7"][0])))
        self.i1edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i1"][0])))
        self.i2edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i2"][0])))
        self.i3edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i3"][0])))
        self.i4edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i4"][0])))
        self.i5edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i5"][0])))
        self.i6edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i6"][0])))
        self.i7edit =  QLineEdit(QString(str(aw.fujipid.PXG4["i7"][0])))
        self.d1edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d1"][0])))
        self.d2edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d2"][0])))
        self.d3edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d3"][0])))
        self.d4edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d4"][0])))
        self.d5edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d5"][0])))
        self.d6edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d6"][0])))
        self.d7edit =  QLineEdit(QString(str(aw.fujipid.PXG4["d7"][0])))
        self.p1edit.setMaximumSize(50, 42)
        self.p2edit.setMaximumSize(50, 42)
        self.p3edit.setMaximumSize(50, 42)
        self.p4edit.setMaximumSize(50, 42)
        self.p5edit.setMaximumSize(50, 42)
        self.p6edit.setMaximumSize(50, 42)
        self.p7edit.setMaximumSize(50, 42)
        self.i1edit.setMaximumSize(50, 42)
        self.i2edit.setMaximumSize(50, 42)
        self.i3edit.setMaximumSize(50, 42)
        self.i4edit.setMaximumSize(50, 42)
        self.i5edit.setMaximumSize(50, 42)
        self.i6edit.setMaximumSize(50, 42)
        self.i7edit.setMaximumSize(50, 42)
        self.d1edit.setMaximumSize(50, 42)
        self.d2edit.setMaximumSize(50, 42)
        self.d3edit.setMaximumSize(50, 42)
        self.d4edit.setMaximumSize(50, 42)
        self.d5edit.setMaximumSize(50, 42)
        self.d6edit.setMaximumSize(50, 42)
        self.d7edit.setMaximumSize(50, 42)
        #p = 0-999.9
        self.p1edit.setValidator(QDoubleValidator(0., 999., 1, self.p1edit))
        self.p2edit.setValidator(QDoubleValidator(0., 999., 1, self.p2edit))
        self.p3edit.setValidator(QDoubleValidator(0., 999., 1, self.p3edit))
        self.p4edit.setValidator(QDoubleValidator(0., 999., 1, self.p4edit))
        self.p5edit.setValidator(QDoubleValidator(0., 999., 1, self.p5edit))
        self.p6edit.setValidator(QDoubleValidator(0., 999., 1, self.p6edit))
        self.p7edit.setValidator(QDoubleValidator(0., 999., 1, self.p7edit))
        #i are int 0-3200
        self.i1edit.setValidator(QIntValidator(0, 3200, self.i1edit))
        self.i2edit.setValidator(QIntValidator(0, 3200, self.i2edit))
        self.i3edit.setValidator(QIntValidator(0, 3200, self.i3edit))
        self.i4edit.setValidator(QIntValidator(0, 3200, self.i4edit))
        self.i5edit.setValidator(QIntValidator(0, 3200, self.i5edit))
        self.i6edit.setValidator(QIntValidator(0, 3200, self.i6edit))
        self.i7edit.setValidator(QIntValidator(0, 3200, self.i7edit))
        #d 0-999.9
        self.d1edit.setValidator(QDoubleValidator(0., 999., 1, self.d1edit))
        self.d2edit.setValidator(QDoubleValidator(0., 999., 1, self.d2edit))
        self.d3edit.setValidator(QDoubleValidator(0., 999., 1, self.d3edit))
        self.d4edit.setValidator(QDoubleValidator(0., 999., 1, self.d4edit))
        self.d5edit.setValidator(QDoubleValidator(0., 999., 1, self.d5edit))
        self.d6edit.setValidator(QDoubleValidator(0., 999., 1, self.d6edit))
        self.d7edit.setValidator(QDoubleValidator(0., 999., 1, self.d7edit))
        pid1button = QPushButton(QApplication.translate("Button","pid 1",None, QApplication.UnicodeUTF8))
        pid2button = QPushButton(QApplication.translate("Button","pid 2",None, QApplication.UnicodeUTF8))
        pid3button = QPushButton(QApplication.translate("Button","pid 3",None, QApplication.UnicodeUTF8))
        pid4button = QPushButton(QApplication.translate("Button","pid 4",None, QApplication.UnicodeUTF8))
        pid5button = QPushButton(QApplication.translate("Button","pid 5",None, QApplication.UnicodeUTF8))
        pid6button = QPushButton(QApplication.translate("Button","pid 6",None, QApplication.UnicodeUTF8))
        pid7button = QPushButton(QApplication.translate("Button","pid 7",None, QApplication.UnicodeUTF8))
        pidreadallbutton = QPushButton(QApplication.translate("Button","Read All",None, QApplication.UnicodeUTF8))
        autotuneONbutton = QPushButton(QApplication.translate("Button","Autotune ON",None, QApplication.UnicodeUTF8))
        autotuneOFFbutton = QPushButton(QApplication.translate("Button","Autotune OFF",None, QApplication.UnicodeUTF8))
        cancel3button = QPushButton(QApplication.translate("Button","Cancel",None, QApplication.UnicodeUTF8))
        self.radiopid1 = QRadioButton()
        self.radiopid2 = QRadioButton()
        self.radiopid3 = QRadioButton()
        self.radiopid4 = QRadioButton()
        self.radiopid5 = QRadioButton()
        self.radiopid6 = QRadioButton()
        self.radiopid7 = QRadioButton()
        self.connect(pidreadallbutton, SIGNAL("clicked()"),self.getallpid)
        self.connect(self.radiopid1,SIGNAL("clicked()"), lambda pid=1: self.setNpid(pid))
        self.connect(self.radiopid2,SIGNAL("clicked()"), lambda pid=2: self.setNpid(pid))
        self.connect(self.radiopid3,SIGNAL("clicked()"), lambda pid=3: self.setNpid(pid))
        self.connect(self.radiopid4,SIGNAL("clicked()"), lambda pid=4: self.setNpid(pid))
        self.connect(self.radiopid5,SIGNAL("clicked()"), lambda pid=5: self.setNpid(pid))
        self.connect(self.radiopid6,SIGNAL("clicked()"), lambda pid=6: self.setNpid(pid))
        self.connect(self.radiopid7,SIGNAL("clicked()"), lambda pid=7: self.setNpid(pid))
        self.connect(pid1button, SIGNAL("clicked()"), lambda v=1: self.setpid(v))
        self.connect(pid2button, SIGNAL("clicked()"), lambda v=2: self.setpid(v))
        self.connect(pid3button, SIGNAL("clicked()"), lambda v=3: self.setpid(v))
        self.connect(pid4button, SIGNAL("clicked()"), lambda v=4: self.setpid(v))
        self.connect(pid5button, SIGNAL("clicked()"), lambda v=5: self.setpid(v))
        self.connect(pid6button, SIGNAL("clicked()"), lambda v=6: self.setpid(v))
        self.connect(pid7button, SIGNAL("clicked()"), lambda v=7: self.setpid(v))
        self.connect(cancel3button, SIGNAL("clicked()"),self, SLOT("reject()"))
        self.connect(autotuneONbutton, SIGNAL("clicked()"), lambda flag=1: self.setONOFFautotune(flag))
        self.connect(autotuneOFFbutton, SIGNAL("clicked()"), lambda flag=0: self.setONOFFautotune(flag))
        #****************************   TAB4 WIDGETS
        #table for setting segments
        self.segmenttable = QTableWidget()
        self.createsegmenttable()
        #****************************   TAB5 WIDGETS
        ETthermolabel = QLabel(QApplication.translate("Label","ET Thermocouple type",None, QApplication.UnicodeUTF8))
        BTthermolabel = QLabel(QApplication.translate("Label","BT Thermocouple type",None, QApplication.UnicodeUTF8))
        BTthermolabelnote = QLabel(QApplication.translate("Label","NOTE: BT Thermocouple type is not stored in the Artisan seetings",None, QApplication.UnicodeUTF8))
        self.ETthermocombobox = QComboBox()
        self.BTthermocombobox = QComboBox()
        self.BTthermocombobox.setStyleSheet("background-color:'lightgrey';")
        ## FUJI PXG input types
        ##0 (JPT 100'3f)
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##9 (no function)
        ##10 (no function)
        ##11 (no function)
        ##12 (N)
        ##13 (PL- 2)
        ##14 (no function)
        ##15 (0V to 5V / 0mA to 20mA
        ##16 (1V to 5V/4mA to 20mA)
        ##17 (0mV to 10V)
        ##18 (2V to 10V)
        ##19 (0mV to 100mV)
        self.PXGthermotypes = ["JPT 100",#0
                            "PT 100",    #1
                            "J",         #2
                            "K",         #3
                            "R",         #4
                            "B",         #5
                            "S",         #6
                            "T",         #7
                            "E",         #8
                            "N",         #12
                            "PL-2",      #13
                            "0V-5V/0mA-20mA", #15
                            "1V-5V/4mA-20mA", #16
                            "0mV-10V",   #17
                            "2V to 10V", #18
                            "0mV-100mV"  #19
                            ]
        self.PXGconversiontoindex = [0,1,2,3,4,5,6,7,8,12,13,15,16,17,18,19]  #converts fuji PID PXG types to indexes
        ## FUJI PXR input types
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##12 (N)
        ##13 (PL- 2)
        ##16 (1V to 5V/4mA to 20mA)
        self.PXRthermotypes = [
                            "PT 100",   #1
                            "J",        #2
                            "K",        #3
                            "R",        #4
                            "B",        #5
                            "S",        #6
                            "T",        #7
                            "E",        #8
                            "N",        #12
                            "PL-2",    #13
                            "1V to 5V/4mA to 20mA" #16
                            ]
        self.PXRconversiontoindex = [1,2,3,4,5,6,7,8,12,13,16]  #converts fuji PID PXR types to indexes
        self.ETthermocombobox.addItems(self.PXGthermotypes)
        if aw.ser.readBTpid[0] == 0:        #fuji PXG
            self.BTthermocombobox.addItems(self.PXGthermotypes)
        else:                               #fuji PXR
            self.BTthermocombobox.addItems(self.PXRthermotypes)
        if aw.fujipid.PXG4["pvinputtype"][0] in self.PXGconversiontoindex:
            self.ETthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(aw.fujipid.PXG4["pvinputtype"][0]))
        setETthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        setBTthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
        getETthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        getBTthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None, QApplication.UnicodeUTF8))
        setETthermocouplebutton.setMaximumWidth(80)
        getETthermocouplebutton.setMaximumWidth(80)
        setBTthermocouplebutton.setMaximumWidth(80)
        getBTthermocouplebutton.setMaximumWidth(80)
        self.connect(setETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.setthermocoupletype(PID))
        self.connect(setBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.setthermocoupletype(PID))
        self.connect(getETthermocouplebutton, SIGNAL("clicked()"), lambda PID="ET": self.readthermocoupletype(PID))
        self.connect(getBTthermocouplebutton, SIGNAL("clicked()"), lambda PID="BT": self.readthermocoupletype(PID))
        PointButtonET = QPushButton(QApplication.translate("Button","Set ET PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        PointButtonBT = QPushButton(QApplication.translate("Button","Set BT PID to 1 decimal point",None, QApplication.UnicodeUTF8))
        timeunitsbutton = QPushButton(QApplication.translate("Button","Set ET PID to MM:SS time units",None, QApplication.UnicodeUTF8))
        PointButtonET.setMaximumWidth(180)
        PointButtonBT.setMaximumWidth(180)
        timeunitsbutton.setMaximumWidth(180)
        pointlabel = QLabel(QApplication.translate("Label","Artisan uses 1 decimal point",None, QApplication.UnicodeUTF8))
        timelabel = QLabel(QApplication.translate("Label","Artisan Fuji PXG uses MINUTES:SECONDS units in Ramp/Soaks",None, QApplication.UnicodeUTF8))
        self.connect(PointButtonET, SIGNAL("clicked()"), lambda PID="ET": self.setpoint(PID))
        self.connect(PointButtonBT, SIGNAL("clicked()"), lambda PID="BT": self.setpoint(PID))
        self.connect(timeunitsbutton, SIGNAL("clicked()"), self.settimeunits)
        # LAYOUTS
        tab1Layout = QGridLayout() #TAB1
        tab1Layout.setSpacing(10)
        tab1Layout.setSizeConstraint(2)
        tab1Layout.addLayout(buttonRampSoakLayout1,0,0)
        tab1Layout.addLayout(buttonRampSoakLayout2,0,1)
        tab1Layout.addWidget(button_rson,1,0)
        tab1Layout.addWidget(button_rsoff,1,1)
        tab1Layout.addWidget(button_standbyOFF,2,0)
        tab1Layout.addWidget(button_standbyON,2,1)
        tab1Layout.addWidget(patternlabel,3,0)
        tab1Layout.addWidget(self.patternComboBox,3,1)
        tab1Layout.addWidget(button_getall,4,0)
        tab1Layout.addWidget(button_exit,4,1)
        tab2Layout = QGridLayout() #TAB2 
        tab2Layout.setSpacing(10)
        tab2Layout.setSizeConstraint(2)
        tab2Layout.addWidget(labelsv,0,0)
        tab2Layout.addWidget(labelsvedit,0,1)
        tab2Layout.addWidget(self.sv7edit,1,0)
        tab2Layout.addWidget(button_sv7,1,1)
        tab2Layout.addWidget(self.sv6edit,2,0)
        tab2Layout.addWidget(button_sv6,2,1)
        tab2Layout.addWidget(self.sv5edit,3,0)
        tab2Layout.addWidget(button_sv5,3,1)
        tab2Layout.addWidget(self.sv4edit,4,0)
        tab2Layout.addWidget(button_sv4,4,1)
        tab2Layout.addWidget(self.sv3edit,5,0)
        tab2Layout.addWidget(button_sv3,5,1)
        tab2Layout.addWidget(self.sv2edit,6,0)
        tab2Layout.addWidget(button_sv2,6,1)
        tab2Layout.addWidget(self.sv1edit,7,0)
        tab2Layout.addWidget(button_sv1,7,1)
        tab2Layout.addWidget(self.radiosv7,1,2)
        tab2Layout.addWidget(self.radiosv6,2,2)
        tab2Layout.addWidget(self.radiosv5,3,2)
        tab2Layout.addWidget(self.radiosv4,4,2)
        tab2Layout.addWidget(self.radiosv3,5,2)
        tab2Layout.addWidget(self.radiosv2,6,2)
        tab2Layout.addWidget(self.radiosv1,7,2)
        tab2Layout.addWidget(tab2easyOFFsvbutton,8,0)
        tab2Layout.addWidget(tab2easyONsvbutton,8,1)
        tab2Layout.addWidget(tab2getsvbutton,9,0)
        tab2Layout.addWidget(button_exit2,9,1)
        tab3Layout = QGridLayout() #TAB3
        tab3Layout.setSpacing(10)
        tab3Layoutbutton = QGridLayout()
        tab3MasterLayout = QVBoxLayout()
        tab3MasterLayout.addLayout(tab3Layout,0)
        tab3MasterLayout.addLayout(tab3Layoutbutton,1)
        tab3Layout.addWidget(plabel,0,0)
        tab3Layout.addWidget(ilabel,0,1)
        tab3Layout.addWidget(dlabel,0,2)
        tab3Layout.addWidget(wlabel,0,3)
        tab3Layout.addWidget(self.p1edit,1,0)
        tab3Layout.addWidget(self.i1edit,1,1)
        tab3Layout.addWidget(self.d1edit,1,2)
        tab3Layout.addWidget(pid1button,1,3)
        tab3Layout.addWidget(self.p2edit,2,0)
        tab3Layout.addWidget(self.i2edit,2,1)
        tab3Layout.addWidget(self.d2edit,2,2)
        tab3Layout.addWidget(pid2button,2,3)
        tab3Layout.addWidget(self.p3edit,3,0)
        tab3Layout.addWidget(self.i3edit,3,1)
        tab3Layout.addWidget(self.d3edit,3,2)
        tab3Layout.addWidget(pid3button,3,3)
        tab3Layout.addWidget(self.p4edit,4,0)
        tab3Layout.addWidget(self.i4edit,4,1)
        tab3Layout.addWidget(self.d4edit,4,2)
        tab3Layout.addWidget(pid4button,4,3)
        tab3Layout.addWidget(self.p5edit,5,0)
        tab3Layout.addWidget(self.i5edit,5,1)
        tab3Layout.addWidget(self.d5edit,5,2)
        tab3Layout.addWidget(pid5button,5,3)
        tab3Layout.addWidget(self.p6edit,6,0)
        tab3Layout.addWidget(self.i6edit,6,1)
        tab3Layout.addWidget(self.d6edit,6,2)
        tab3Layout.addWidget(pid6button,6,3)
        tab3Layout.addWidget(self.p7edit,7,0)
        tab3Layout.addWidget(self.i7edit,7,1)
        tab3Layout.addWidget(self.d7edit,7,2)
        tab3Layout.addWidget(pid7button,7,3)
        tab3Layout.addWidget(self.radiopid1,1,4)
        tab3Layout.addWidget(self.radiopid2,2,4)
        tab3Layout.addWidget(self.radiopid3,3,4)
        tab3Layout.addWidget(self.radiopid4,4,4)
        tab3Layout.addWidget(self.radiopid5,5,4)
        tab3Layout.addWidget(self.radiopid6,6,4)
        tab3Layout.addWidget(self.radiopid7,7,4)
        tab3Layoutbutton.addWidget(autotuneONbutton,0,0)
        tab3Layoutbutton.addWidget(autotuneOFFbutton,0,1)
        tab3Layoutbutton.addWidget(pidreadallbutton,1,0)
        tab3Layoutbutton.addWidget(cancel3button,1,1)
        #tab 4
        tab4layout = QVBoxLayout()
        tab4layout.addWidget(self.segmenttable)
        #tab5
        thermolayout = QGridLayout()
        thermolayout.addWidget(ETthermolabel,0,0)
        thermolayout.addWidget(self.ETthermocombobox,0,1)
        thermolayout.addWidget(getETthermocouplebutton,0,2)
        thermolayout.addWidget(setETthermocouplebutton,0,3)
        thermolayout.addWidget(BTthermolabel,1,0)
        thermolayout.addWidget(self.BTthermocombobox,1,1)
        thermolayout.addWidget(getBTthermocouplebutton,1,2)
        thermolayout.addWidget(setBTthermocouplebutton,1,3)
        tab5Layout = QVBoxLayout()
        tab5Layout.addStretch()
        tab5Layout.addLayout(thermolayout)
        tab5Layout.addWidget(BTthermolabelnote)
        tab5Layout.addStretch()
        tab5Layout.addWidget(pointlabel)
        tab5Layout.addWidget(PointButtonET)
        tab5Layout.addWidget(PointButtonBT)
        tab5Layout.addStretch()
        tab5Layout.addWidget(timelabel)
        tab5Layout.addWidget(timeunitsbutton)
        tab5Layout.addStretch()
        ############################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","RS",None, QApplication.UnicodeUTF8))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","SV",None, QApplication.UnicodeUTF8))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3MasterLayout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","PID",None, QApplication.UnicodeUTF8))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Set RS",None, QApplication.UnicodeUTF8))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Extra",None, QApplication.UnicodeUTF8))
        #incorporate layouts
        layout = QVBoxLayout()
        layout.addWidget(self.status,0)
        layout.addWidget(TabWidget,1)
        self.setLayout(layout)

    def settimeunits(self):
        try:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["timeunits"][1],1)
            r = aw.ser.sendFUJIcommand(command,8)   
            #check response from pid and update message on main window
            if r == command:                       
                message = QApplication.translate("StatusBar","Time Units successfully set to MM:SS",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting time units",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " settimeunits(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setpoint(self,PID):
        command = ""
        try:
            if PID == "ET":
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["decimalposition"][1],1)
            elif PID == "BT":
                if aw.ser.readBTpid[0] == 0:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["decimalposition"][1],1)
                elif aw.ser.readBTpid[0] == 1:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["decimalposition"][1],1)
            r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Decimal position successfully set to 1",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting decimal position",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setpoint(): %1").arg(str(e)),exc_tb.tb_lineno)

    def setthermocoupletype(self,PID):
        command = ""
        try:
            if PID == "ET":
                index = self.ETthermocombobox.currentIndex()
                value = self.PXGconversiontoindex[index]
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["pvinputtype"][1],value)
            elif PID == "BT":
                index = self.BTthermocombobox.currentIndex()
                if aw.ser.readBTpid[0] == 0:
                    value = self.PXGconversiontoindex[index]
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXG4["pvinputtype"][1],value)
                elif aw.ser.readBTpid[0] == 1:
                    value = self.PXRconversiontoindex[index]
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],6,aw.fujipid.PXR["pvinputtype"][1],value)
            r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                if PID == "ET":
                    aw.fujipid.PXG4["pvinputtype"][0] = self.PXGconversiontoindex[self.ETthermocombobox.currentIndex()]
                elif PID == "BT":
                    pass #this info is not stored
                message = QApplication.translate("StatusBar","Thermocouple type successfully set",None,QApplication.UnicodeUTF8)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting thermocouple type",None,QApplication.UnicodeUTF8),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " setthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def readthermocoupletype(self,PID):
        command = ""
        message = "empty"
        try:
            if PID == "ET":
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["pvinputtype"][1],1)
            elif PID == "BT":
                if aw.ser.readBTpid[0] == 0:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXG4["pvinputtype"][1],1)
                elif aw.ser.readBTpid[0] == 1:
                    command = aw.fujipid.message2send(aw.ser.readBTpid[1],3,aw.fujipid.PXR["pvinputtype"][1],1)  
            if command:
                Thtype = aw.fujipid.readoneword(command)
                if PID == "ET":
                    if Thtype in self.PXGconversiontoindex:
                        aw.fujipid.PXG4["pvinputtype"][0] = Thtype
                        self.ETthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(Thtype))
                        message = "ET PXG type %i: %s"%(Thtype,self.PXGthermotypes[self.PXGconversiontoindex.index(Thtype)])
                    else:
                        message = "ERR"
                elif PID == "BT":
                    if aw.ser.readBTpid[0] == 0:        #fuji PXG
                        if Thtype in self.PXGconversiontoindex:
                            message = "BT PXG type %i: %s"%(Thtype,self.PXGthermotypes[self.PXGconversiontoindex.index(Thtype)])
                            self.BTthermocombobox.setCurrentIndex(self.PXGconversiontoindex.index(Thtype))
                    elif aw.ser.readBTpid[0] == 1:      #fuji PXR
                        if Thtype in self.PXRconversiontoindex:
                            message = "BT PXR type %i: %s"%(Thtype,self.PXRthermotypes[self.PXRconversiontoindex.index(Thtype)])
                            self.BTthermocombobox.setCurrentIndex(self.PXRconversiontoindex.index(Thtype))
                self.status.showMessage(message,5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None, QApplication.UnicodeUTF8) + " readthermocoupletype(): %1").arg(str(e)),exc_tb.tb_lineno)

    def paintlabels(self):
        #read values of computer variables (not the actual pid values) to place in buttons
        str1 = "1 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment1sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment1ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment1soak"][0])))
        str2 = "2 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment2sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment2ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment2soak"][0])))
        str3 = "3 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment3sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment3ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment3soak"][0])))
        str4 = "4 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment4sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment4ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment4soak"][0])))
        str5 = "5 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment5sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment5ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment5soak"][0])))
        str6 = "6 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment6sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment6ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment6soak"][0])))
        str7 = "7 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment7sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment7ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment7soak"][0])))
        str8 = "8 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment8sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment8ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment8soak"][0])))
        str9 = "9 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment9sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment9ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment9soak"][0])))
        str10 = "10 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment10sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment10ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment10soak"][0])))
        str11 = "11 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment11sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment11ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment11soak"][0])))
        str12 = "12 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment12sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment12ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment12soak"][0])))
        str13 = "13 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment13sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment13ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment13soak"][0])))
        str14 = "14 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment14sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment14ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment14soak"][0])))
        str15 = "15 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment15sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment15ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment15soak"][0])))
        str16 = "16 [T %1] [R %2] [S %3]".arg(str(aw.fujipid.PXG4["segment16sv"][0])).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment16ramp"][0]))).arg(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment16soak"][0])))
        self.label_rs1.setText(QString(str1))
        self.label_rs2.setText(QString(str2))
        self.label_rs3.setText(QString(str3))
        self.label_rs4.setText(QString(str4))
        self.label_rs5.setText(QString(str5))
        self.label_rs6.setText(QString(str6))
        self.label_rs7.setText(QString(str7))
        self.label_rs8.setText(QString(str8))
        self.label_rs9.setText(QString(str9))
        self.label_rs10.setText(QString(str10))
        self.label_rs11.setText(QString(str11))
        self.label_rs12.setText(QString(str12))
        self.label_rs13.setText(QString(str13))
        self.label_rs14.setText(QString(str14))
        self.label_rs15.setText(QString(str15))
        self.label_rs16.setText(QString(str16))
        pattern = [[1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                  [0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                  [1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                  [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
                  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        aw.fujipid.PXG4["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][0]:
            self.label_rs1.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs1.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][1]:
            self.label_rs2.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs2.setStyleSheet("background-color:white;")
            
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][2]:
            self.label_rs3.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs3.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][3]:
            self.label_rs4.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs4.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][4]:
            self.label_rs5.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs5.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][5]:
            self.label_rs6.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs6.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][6]:
            self.label_rs7.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs7.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][7]:
            self.label_rs8.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs8.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][8]:
            self.label_rs9.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs9.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][9]:
            self.label_rs10.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs10.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][10]:
            self.label_rs11.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs11.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][11]:
            self.label_rs12.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs12.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][12]:
            self.label_rs13.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs13.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][13]:
            self.label_rs14.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs14.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][14]:
            self.label_rs15.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs15.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][15]:
            self.label_rs16.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs16.setStyleSheet("background-color:white;")

    #selects an sv   
    def setNsv(self,svn):
        # read current sv N
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectsv"][1],1)
        N = aw.fujipid.readoneword(command)
        # if current svN is different than requested svN
        if N != -1:
            if N != svn:
                string = QApplication.translate("Message","Current sv = %1. Change now to sv = %2?",None,QApplication.UnicodeUTF8).arg(str(N)).arg(str(svn))
                reply = QMessageBox.question(self,QApplication.translate("Message","Change svN",None,QApplication.UnicodeUTF8),string,
                                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    #change variable svN
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["selectsv"][1],svn)
                    r = aw.ser.sendFUJIcommand(command,8)
                    #check response from pid and update message on main window
                    if r == command:
                        aw.fujipid.PXG4["selectsv"][0] = svn
                        key = "sv" + str(svn)
                        message = QApplication.translate("StatusBar","SV%1 set to %2",None,QApplication.UnicodeUTF8).arg(str(svn)).arg(str(aw.fujipid.PXG4[key][0]))
                        aw.lcd6.display(str(aw.fujipid.PXG4[key][0]))
                        self.status.showMessage(message, 5000)
                    else:
                        self.status.showMessage(QApplication.translate("StatusBar","Problem setting SV",None,QApplication.UnicodeUTF8),5000)
                elif reply == QMessageBox.Cancel:
                    self.status.showMessage(QApplication.translate("StatusBar","Cancelled svN change",None,QApplication.UnicodeUTF8),5000)
                    #set radio button
                    if N == 1:
                        self.radiosv1.setChecked(True)
                    elif N == 2:
                        self.radiosv2.setChecked(True)
                    elif N == 3:
                        self.radiosv3.setChecked(True)
                    elif N == 4:
                        self.radiosv4.setChecked(True)
                    elif N == 5:
                        self.radiosv5.setChecked(True)
                    elif N == 6:
                        self.radiosv6.setChecked(True)
                    elif N == 7:
                        self.radiosv7.setChecked(True)
                    return 
            else:
                mssg = QApplication.translate("StatusBar","PID already using sv%1",None,QApplication.UnicodeUTF8).arg(str(N))
                self.status.showMessage(mssg,1000)
        else:
            mssg = QApplication.translate("StatusBar","setNsv(): bad response",None,QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,1000)
            aw.qmc.adderror(mssg)

    #selects an sv
    def setNpid(self,pidn):
        # read current sv N
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
        N = aw.fujipid.readoneword(command)
        if N != -1:
            aw.fujipid.PXG4["selectedpid"][0] = N
            # if current svN is different than requested svN
            if N != pidn:
                string = QApplication.translate("Message","Current pid = %1. Change now to pid =%2?",None,QApplication.UnicodeUTF8).arg(str(N)).arg(str(pidn))
                reply = QMessageBox.question(self,QApplication.translate("Message","Change svN",None,QApplication.UnicodeUTF8),string,
                                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    #change variable svN
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["selectedpid"][1],pidn)
                    r = aw.ser.sendFUJIcommand(command,8)
                    #check response from pid and update message on main window
                    if r == command:
                        aw.fujipid.PXG4["selectedpid"][0] = pidn
                        key = "sv" + str(pidn)
                        message = QApplication.translate("StatusBar","pid%1 changed to %2",None,QApplication.UnicodeUTF8).arg(str(pidn)).arg(str(aw.fujipid.PXG4[key][0]))
                        self.status.showMessage(message, 5000)
                    else:
                        mssg = QApplication.translate("StatusBar","setNpid(): bad confirmation",None,QApplication.UnicodeUTF8)
                        self.status.showMessage(mssg,1000)
                        aw.qmc.adderror(mssg)
                elif reply == QMessageBox.Cancel:
                    self.status.showMessage(QApplication.translate("StatusBar","Cancelled pid change",None,QApplication.UnicodeUTF8),5000)
                    #put back radio button
                    if N == 1:
                        self.radiosv1.setChecked(True)
                    elif N == 2:
                        self.radiosv2.setChecked(True)
                    elif N == 3:
                        self.radiosv3.setChecked(True)
                    elif N == 4:
                        self.radiosv4.setChecked(True)
                    elif N == 5:
                        self.radiosv5.setChecked(True)
                    elif N == 6:
                        self.radiosv6.setChecked(True)
                    elif N == 7:
                        self.radiosv7.setChecked(True)
                    return
            else:
                mssg = QApplication.translate("StatusBar","PID was already using pid %1",None,QApplication.UnicodeUTF8).arg(str(N))
                self.status.showMessage(mssg,1000)
        else:
            mssg = QApplication.translate("StatusBar","setNpid(): Unable to set pid %1 ",None,QApplication.UnicodeUTF8).arg(str(N))
            self.status.showMessage(mssg,1000)
            aw.qmc.adderror(mssg)

    #writes new value on sv(i)
    def setsv(self,i):
        #first get the new sv value from the correspondig edit ine
        if i == 1:
            if self.sv1edit.text() != "":
                newSVvalue = int(float(str(self.sv1edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
        elif i == 2:
            if self.sv2edit.text() != "":
                newSVvalue = int(float(str(self.sv2edit.text()))*10.)
        elif i == 3:
            if self.sv3edit.text() != "":
                newSVvalue = int(float(str(self.sv3edit.text()))*10.)
        elif i == 4:
            if self.sv4edit.text() != "":
                newSVvalue = int(float(str(self.sv4edit.text()))*10.)
        elif i == 5:
            if self.sv5edit.text() != "":
                newSVvalue = int(float(str(self.sv5edit.text()))*10.)
        elif i == 6:
            if self.sv6edit.text() != "":
                newSVvalue = int(float(str(self.sv6edit.text()))*10.)
        elif i == 7:
            if self.sv7edit.text() != "":
                newSVvalue = int(float(str(self.sv7edit.text()))*10.)
        #send command to the right sv
        svkey = "sv"+ str(i)
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[svkey][1],newSVvalue)
        r = aw.ser.sendFUJIcommand(command,8)
        #verify it went ok
        if len(r) == 8:
            if i == 1:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv1edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv1edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(1)
                aw.lcd6.display(str(self.sv1edit.text()))
            elif i == 2:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv2edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv2edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(2)
                aw.lcd6.display(str(self.sv2edit.text()))
            elif i == 3:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv3edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv3edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(3)
                aw.lcd6.display(str(self.sv3edit.text()))
            elif i == 4:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv4edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv4edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(4)
                aw.lcd6.display(str(self.sv4edit.text()))
            elif i == 5:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv5edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv5edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(5)
                aw.lcd6.display(str(self.sv5edit.text()))
            elif i == 6:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv6edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv6edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(6)
                aw.lcd6.display(str(self.sv6edit.text()))
            elif i == 7:
                aw.fujipid.PXG4[svkey][0] = float(str(self.sv7edit.text()))
                message = QApplication.translate("StatusBar","SV%1 successfully set to %2",None,QApplication.UnicodeUTF8).arg(str(i)).arg(str(self.sv7edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(7)
                aw.lcd6.display(str(self.sv7edit.text()))
            #record command as an Event 
            strcommand = "SETSV::" + str("%.1f"%(newSVvalue/10.))
            aw.qmc.DeviceEventRecord(strcommand)
        else:
            mssg = QApplication.translate("StatusBar","setsv(): Unable to set SV",None,QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    #writes new values for p - i - d
    def setpid(self,k):
        #first get the new sv value from the correspondig edit ine
        if k == 1:
            if self.p1edit.text() != "" and self.i1edit.text() != "" and self.d1edit.text() != "":
                newPvalue = int(float(str(self.p1edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i1edit.text()))*10.)
                newDvalue = int(float(str(self.d1edit.text()))*10.)
                
        elif k == 2:
            if self.p2edit.text() != "" and self.i2edit.text() != "" and self.d2edit.text() != "":
                newPvalue = int(float(str(self.p2edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i2edit.text()))*10.)
                newDvalue = int(float(str(self.d2edit.text()))*10.) 
        elif k == 3:
            if self.p3edit.text() != "" and self.i3edit.text() != "" and self.d3edit.text() != "":
                newPvalue = int(float(str(self.p3edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i3edit.text()))*10.)
                newDvalue = int(float(str(self.d3edit.text()))*10.)
        elif k == 4:
            if self.p4edit.text() != "" and self.i4edit.text() != "" and self.d4edit.text() != "":
                newPvalue = int(float(str(self.p4edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i4edit.text()))*10.)
                newDvalue = int(float(str(self.d4edit.text()))*10.) 
        elif k == 5:
            if self.p5edit.text() != "" and self.i5edit.text() != "" and self.d5edit.text() != "":
                newPvalue = int(float(str(self.p5edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i5edit.text()))*10.)
                newDvalue = int(float(str(self.d5edit.text()))*10.) 
        elif k == 6:
            if self.p6edit.text() != "" and self.i6edit.text() != "" and self.d6edit.text() != "":
                newPvalue = int(float(str(self.p6edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i6edit.text()))*10.)
                newDvalue = int(float(str(self.d6edit.text()))*10.) 
        elif k == 7:
            if self.p7edit.text() != "" and self.i7edit.text() != "" and self.d7edit.text() != "":
                newPvalue = int(float(str(self.p7edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i7edit.text()))*10.)
                newDvalue = int(float(str(self.d7edit.text()))*10.) 
        #send command to the right sv
        pkey = "p" + str(k)
        ikey = "i" + str(k)
        dkey = "d" + str(k)
        commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[pkey][1],newPvalue)
        commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[ikey][1],newIvalue)
        commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[dkey][1],newDvalue)
        p = aw.ser.sendFUJIcommand(commandp,8)
        i = aw.ser.sendFUJIcommand(commandi,8)
        d = aw.ser.sendFUJIcommand(commandd,8)
        #verify it went ok
        if len(p) == 8 and len(i)==8 and len(d) == 8:
            if k == 1:               
                aw.fujipid.PXG4[pkey][0] = float(str(self.p1edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i1edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d1edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p1edit.text())).arg(str(self.i1edit.text())).arg(str(self.d1edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(1)
            elif k == 2:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p2edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i2edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d2edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p2edit.text())).arg(str(self.i2edit.text())).arg(str(self.d2edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(2)
            elif k == 3:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p3edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i3edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d3edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p3edit.text())).arg(str(self.i3edit.text())).arg(str(self.d3edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(3)
            elif k == 4:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p4edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i4edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d4edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p4edit.text())).arg(str(self.i4edit.text())).arg(str(self.d4edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(4)
            elif k == 5:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p5edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i5edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d5edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p5edit.text())).arg(str(self.i5edit.text())).arg(str(self.d5edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(5)
            elif k == 6:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p6edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i6edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d6edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p6edit.text())).arg(str(self.i6edit.text())).arg(str(self.d6edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(6)
            elif k == 7:
                aw.fujipid.PXG4[pkey][0] = float(str(self.p7edit.text()))
                aw.fujipid.PXG4[ikey][0] = float(str(self.i7edit.text()))
                aw.fujipid.PXG4[dkey][0] = float(str(self.d7edit.text()))
                message = (QApplication.translate("StatusBar","pid #%1 successfully set to (%2,%3,%4)",None,
                                                   QApplication.UnicodeUTF8)).arg(str(k)).arg(str(self.p7edit.text())).arg(str(self.i7edit.text())).arg(str(self.d7edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(7) 
        else:
            lp = len(p)
            li = len(i)
            ld = len(d)
            mssg = QApplication.translate("StatusBar","pid command failed. Bad data at pid%1 (8,8,8): (%2,%3,%4) ",None,
                                                   QApplication.UnicodeUTF8).arg(str(k)).arg(str(lp)).arg(str(li)).arg(str(ld))
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def getallpid(self):
        for k in range(1,8):
            pkey = "p" + str(k)
            ikey = "i" + str(k)
            dkey = "dd" + str(k)
            msg = QApplication.translate("StatusBar","sending commands for p%1 i%2 d%3",None,
                                                   QApplication.UnicodeUTF8).arg(str(k)).arg(str(k)).arg(str(k))
            self.status.showMessage(msg,1000)
            commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[pkey][1],1)
            p = aw.fujipid.readoneword(commandp)/10.
            commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[ikey][1],1)
            i = aw.fujipid.readoneword(commandi)/10.
            commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[dkey][1],1)
            dd = aw.fujipid.readoneword(commandd)/10.
            if p != -1 and i != -1 and dd != -1:
                aw.fujipid.PXG4[pkey][0] = p
                aw.fujipid.PXG4[ikey][0] = i
                aw.fujipid.PXG4[dkey][0] = dd
                if k == 1:
                    self.p1edit.setText(str(p))
                    self.i1edit.setText(str(i))
                    self.d1edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd) # No translation needed here
                    self.status.showMessage(mssg,1000)
                if k == 2:
                    self.p2edit.setText(str(p))
                    self.i2edit.setText(str(i))
                    self.d2edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 3:
                    self.p3edit.setText(str(p))
                    self.i3edit.setText(str(i))
                    self.d3edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 4:
                    self.p4edit.setText(str(p))
                    self.i4edit.setText(str(i))
                    self.d4edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 5:
                    self.p5edit.setText(str(p))
                    self.i5edit.setText(str(i))
                    self.d5edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 6:
                    self.p6edit.setText(str(p))
                    self.i6edit.setText(str(i))
                    self.d6edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 7:
                    self.p7edit.setText(str(p))
                    self.i7edit.setText(str(i))
                    self.d7edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
            else:
                mssg = QApplication.translate("StatusBar","getallpid(): Unable to read pid values",None,QApplication.UnicodeUTF8)
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
                return
        #read current pidN
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
        N = aw.fujipid.readoneword(command)
        if N != -1:
            aw.fujipid.PXG4["selectedpid"][0] = N
            if N == 1:
                self.radiopid1.setChecked(True)
            elif N == 2:
                self.radiopid2.setChecked(True)
            elif N == 3:
                self.radiopid3.setChecked(True)
            elif N == 4:
                self.radiopid4.setChecked(True)
            elif N == 5:
                self.radiopid5.setChecked(True)
            elif N == 6:
                self.radiopid6.setChecked(True)
            elif N == 7:
                self.radiopid7.setChecked(True)
            mssg = QApplication.translate("StatusBar","PID is using pid = %1",None,QApplication.UnicodeUTF8).arg(str(N))
            self.status.showMessage(mssg,5000)
        else:
            mssg = QApplication.translate("StatusBar","getallpid(): Unable to read current sv",None,QApplication.UnicodeUTF8)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    def getallsv(self):
        for i in reversed(list(range(1,8))):
            svkey = "sv" + str(i)
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[svkey][1],1)
            sv = aw.fujipid.readoneword(command)/10.
            aw.fujipid.PXG4[svkey][0] = sv
            if i == 1:
                self.sv1edit.setText(str(sv))
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
            elif i == 2:
                self.sv2edit.setText(str(sv))
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
            elif i == 3:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv3edit.setText(str(sv))
            elif i == 4:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv4edit.setText(str(sv))
            elif i == 5:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv5edit.setText(str(sv))
            elif i == 6:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv6edit.setText(str(sv))
            elif i == 7:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv7edit.setText(str(sv))
        #read current svN
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectsv"][1],1)
        N = aw.fujipid.readoneword(command)
        aw.fujipid.PXG4["selectsv"][0] = N
        if N == 1:
            self.radiosv1.setChecked(True)
        elif N == 2:
            self.radiosv2.setChecked(True)
        elif N == 3:
            self.radiosv3.setChecked(True)
        elif N == 4:
            self.radiosv4.setChecked(True)
        elif N == 5:
            self.radiosv5.setChecked(True)
        elif N == 6:
            self.radiosv6.setChecked(True)
        elif N == 7:
            self.radiosv7.setChecked(True)
        mssg = QApplication.translate("StatusBar","PID is using SV = %1",None,QApplication.UnicodeUTF8).arg(str(N))
        self.status.showMessage(mssg,5000)

    def checkrampsoakmode(self):
        msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["rampsoakmode"][1],1)
        currentmode = aw.fujipid.readoneword(msg)
        aw.fujipid.PXG4["rampsoakmode"][0] = currentmode
        if currentmode == 0:
            mode = ["0",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 1:
            mode = ["1",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 2:
            mode = ["2",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 3:
            mode = ["3",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 4:
            mode = ["4",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 5:
            mode = ["5",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 6:
            mode = ["6",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 7:
            mode = ["7",
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 8:
            mode = ["8",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 9:
            mode = ["9",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 10:
            mode = ["10",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 11:
            mode = ["11",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 12:
            mode = ["12",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 13:
            mode = ["13",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        elif currentmode == 14:
            mode = ["14",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","OFF",None,QApplication.UnicodeUTF8)]
        elif currentmode == 15:
            mode = ["15",
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","STANDBY MODE",None,QApplication.UnicodeUTF8),
                    QApplication.translate("Message","ON",None,QApplication.UnicodeUTF8)]
        else:
            return -1
        string = "The rampsoak-mode tells how to start and end the ramp/soak\n\n"
        string += "Your rampsoak mode in this pid is:\n"
        string += "\nMode = " + mode[0]
        string += "\n-----------------------------------------------------------------------"
        string += "\nStart to run from PV value: " + mode[1]
        string += "\nEnd output status at the end of ramp/soak: " + mode[2]
        string += "\nOutput status while ramp/soak opearion set to OFF: " + mode[3] 
        string += "\nRepeat Operation at the end: " + mode[4]
        string += "\n-----------------------------------------------------------------------"
        string += "\n\nRecomended Mode = 0\n"
        string += "\nIf you need to change it, change it now and come back later"
        string += "\nUse the Parameter Loader Software by Fuji if you need to\n\n"
        string += "\n\n\nContinue?" 
        reply = QMessageBox.question(self,QApplication.translate("Message","Ramp Soak start-end mode",None,QApplication.UnicodeUTF8),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            return 0
        elif reply == QMessageBox.Yes:
            return 1

    def setONOFFrampsoak(self,flag):
        #warning check how it ends at "rampsoakend":[0,41081] can let pid inop till value changed    UNFINISHED
        
        # you can come out of this mode by putting the pid in standby (pid off) 
        #flag =0 OFF, flag = 1 ON, flag = 2 hold
        
        #set rampsoak pattern ON
        if flag == 1:
            check = self.checkrampsoakmode()
            if check == 0:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak operation cancelled",None,QApplication.UnicodeUTF8), 5000)
                return
            elif check == -1:
                self.status.showMessage(QApplication.translate("StatusBar","No RX data",None,QApplication.UnicodeUTF8), 5000)
            self.status.showMessage(QApplication.translate("StatusBar","RS ON",None,QApplication.UnicodeUTF8),500)
            selectedmode = self.patternComboBox.currentIndex()
            msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["rampsoakpattern"][1],1)
            currentmode = aw.fujipid.readoneword(msg)
            aw.fujipid.PXG4["rampsoakpattern"][0] = currentmode
            if currentmode != selectedmode:
                #set mode in pid to match the mode selected in the combobox
                self.status.showMessage(QApplication.translate("StatusBar","Need to change pattern mode...",None,QApplication.UnicodeUTF8),1000)
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoakpattern"][1],selectedmode)
                r = aw.ser.sendFUJIcommand(command,8)
                if len(r) == 8:
                    self.status.showMessage(QApplication.translate("StatusBar","Pattern has been changed. Wait 5 secs.",None,QApplication.UnicodeUTF8), 500)
                    aw.fujipid.PXG4["rampsoakpattern"][0] = selectedmode
                else:
                    self.status.showMessage(QApplication.translate("StatusBar","Pattern could not be changed",None,QApplication.UnicodeUTF8), 5000)
                    return
            #combobox mode matches pid mode
            #set ramp soak mode ON/OFF
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoak"][1],flag)
            r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                #record command as an Event if flag = 1
                self.status.showMessage(QApplication.translate("StatusBar","RS ON",None,QApplication.UnicodeUTF8), 5000)
                pattern =[[1,4],[5,8],[1,8],[9,12],[13,16],[9,16],[1,16]]
                start = pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][0]
                end = pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][1]+1
                strcommand = "SETRS"
                result = ""
                for i in range(start,end):
                    svkey = "segment"+str(i)+"sv"
                    rampkey = "segment"+str(i)+"ramp"
                    soakkey = "segment"+str(i)+"soak"
                    strcommand += "::" + str(aw.fujipid.PXG4[svkey][0]) + "::" + str(aw.fujipid.PXG4[rampkey][0]) + "::" + str(aw.fujipid.PXG4[soakkey][0])+"::"
                    result += strcommand
                    strcommand = "SETRS"
                result = result.strip("::")
                aw.qmc.DeviceEventRecord(result)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","RampSoak could not be changed",None,QApplication.UnicodeUTF8), 5000)
        #set ramp soak OFF
        elif flag == 0:
            self.status.showMessage(QApplication.translate("StatusBar","RS OFF",None,QApplication.UnicodeUTF8),500)
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoak"][1],flag)
            r = aw.ser.sendFUJIcommand(command,8)
            if r == command:
                self.status.showMessage(QApplication.translate("StatusBar","RS successfully turned OFF",None,QApplication.UnicodeUTF8), 5000)
                aw.fujipid.PXG4["rampsoak"][0] = flag
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp Soak could not be set OFF",None,QApplication.UnicodeUTF8), 5000)

    def setpattern(self):
        #Need to make sure that RampSoak is not ON in order to change pattern:
        onoff = self.getONOFFrampsoak()
        if onoff == 0:
            aw.fujipid.PXG4["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoakpattern"][1],aw.fujipid.PXG4["rampsoakpattern"][0])
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                patterns = ["1-4","5-8","1-8","9-12","13-16","9-16","1-16"]
                message = QApplication.translate("Message","Pattern changed to %1", None, QApplication.UnicodeUTF8).arg(patterns[aw.fujipid.PXG4["rampsoakpattern"][0]])
            else:
                message = QApplication.translate("Message","Pattern did not changed",None, QApplication.UnicodeUTF8)
            aw.sendmessage(message)
        elif onoff == 1:
            aw.sendmessage(QApplication.translate("Message","Ramp/Soak was found ON! Turn it off before changing the pattern", None, QApplication.UnicodeUTF8))
        elif onoff == 2:
            aw.sendmessage(QApplication.translate("Message","Ramp/Soak was found in Hold! Turn it off before changing the pattern", None, QApplication.UnicodeUTF8))

    def setONOFFstandby(self,flag):
        #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
        #flag = 0 standby OFF, flag = 1 standby ON (pid off)
        self.status.showMessage(QApplication.translate("StatusBar","wait...",None, QApplication.UnicodeUTF8),500)
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["runstandby"][1],flag)
        #TX and RX
        r = aw.ser.sendFUJIcommand(command,8)
        if r == command and flag == 1:
            message = QApplication.translate("StatusBar","PID set to OFF",None, QApplication.UnicodeUTF8)     #put pid in standby 1 (pid on)
            aw.fujipid.PXG4["runstandby"][0] = 1
        elif r == command and flag == 0:
            message = QApplication.translate("StatusBar","PID set to ON",None, QApplication.UnicodeUTF8)      #put pid in standby 0 (pid off)
            aw.fujipid.PXG4["runstandby"][0] = 0
        else:
            message = QApplication.translate("StatusBar","Unable",None, QApplication.UnicodeUTF8)
        if r:
            self.status.showMessage(message,5000)
        else:
            self.status.showMessage(QApplication.translate("StatusBar","No data received",None, QApplication.UnicodeUTF8),5000)

    def getsegment(self, idn):
        svkey = "segment" + str(idn) + "sv"
        svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[svkey][1],1)
        
        sv = aw.fujipid.readoneword(svcommand)
        if sv == -1:
            return -1
        aw.fujipid.PXG4[svkey][0] = sv/10.              #divide by 10 because the decimal point is not sent by the PID
        rampkey = "segment" + str(idn) + "ramp"
        rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[rampkey][1],1)
        ramp = aw.fujipid.readoneword(rampcommand)
        if ramp == -1:
            return -1
        aw.fujipid.PXG4[rampkey][0] = ramp
        soakkey = "segment" + str(idn) + "soak"
        soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4[soakkey][1],1)
        soak = aw.fujipid.readoneword(soakcommand)
        if soak == -1:
            return -1
        aw.fujipid.PXG4[soakkey][0] = soak

    #get all Ramp Soak values for all 8 segments
    def getallsegments(self):
        for i in range(1,17):
            msg = QApplication.translate("StatusBar","Reading Ramp/Soak %1 ...",None, QApplication.UnicodeUTF8).arg(str(i))
            self.status.showMessage(msg,500)
            k = self.getsegment(i)
            libtime.sleep(0.03)
            if k == -1:
                self.status.showMessage(QApplication.translate("StatusBar","problem reading Ramp/Soak",None, QApplication.UnicodeUTF8),5000)
                return
            self.paintlabels()
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading Ramp/Soak val.",None, QApplication.UnicodeUTF8),5000)
        self.createsegmenttable()

    def setONOFFautotune(self,flag):
        self.status.showMessage(QApplication.translate("StatusBar","setting autotune...",None, QApplication.UnicodeUTF8),500)
        #read current pidN
        command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
        N = aw.fujipid.readoneword(command)
        aw.fujipid.PXG4["selectedpid"][0] = N
        string = QApplication.translate("StatusBar","Current pid = %1. Proceed with autotune command?",None, QApplication.UnicodeUTF8).arg(str(N))
        reply = QMessageBox.question(self,QApplication.translate("Message","Ramp Soak start-end mode",None, QApplication.UnicodeUTF8),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            self.status.showMessage(QApplication.translate("StatusBar","Autotune cancelled",None, QApplication.UnicodeUTF8),5000)
            return 0
        elif reply == QMessageBox.Yes:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["autotuning"][1],flag)
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
            if len(r) == 8:
                if flag == 0:
                    aw.fujipid.PXG4["autotuning"][0] = 0
                    self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned OFF",None, QApplication.UnicodeUTF8),5000)
                if flag == 1:
                    aw.fujipid.PXG4["autotuning"][0] = 1
                    self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned ON",None, QApplication.UnicodeUTF8),5000) 
            else:
                self.status.showMessage(QApplication.translate("StatusBar","UNABLE to set Autotune",None, QApplication.UnicodeUTF8),5000) 

    def createsegmenttable(self):
        self.segmenttable.setRowCount(16)
        self.segmenttable.setColumnCount(4)
        self.segmenttable.setHorizontalHeaderLabels([QApplication.translate("StatusBar","SV",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("StatusBar","Ramp (MM:SS)",None, QApplication.UnicodeUTF8),
                                                     QApplication.translate("StatusBar","Soak (MM:SS)",None, QApplication.UnicodeUTF8),""])
        self.segmenttable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.segmenttable.setSelectionBehavior(QTableWidget.SelectRows)
        self.segmenttable.setSelectionMode(QTableWidget.SingleSelection)
        self.segmenttable.setShowGrid(True)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #populate table
        for i in range(16):
            #create widgets
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            svedit = QLineEdit(str(aw.fujipid.PXG4[svkey][0]))
            svedit.setValidator(QDoubleValidator(0., 999., 1, svedit))
            rampedit = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4[rampkey][0])))
            rampedit.setValidator(QRegExpValidator(regextime,self))    
            soakedit  = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4[soakkey][0])))
            soakedit.setValidator(QRegExpValidator(regextime,self))    
            setButton = QPushButton(QApplication.translate("Button","Set",None, QApplication.UnicodeUTF8))
            #add widgets to the table
            self.segmenttable.setCellWidget(i,0,svedit)
            self.segmenttable.setCellWidget(i,1,rampedit)
            self.segmenttable.setCellWidget(i,2,soakedit)
            self.segmenttable.setCellWidget(i,3,setButton)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    def setsegment(self,i):
        idn = i+1
        svedit =  self.segmenttable.cellWidget(i,0)
        rampedit = self.segmenttable.cellWidget(i,1)
        soakedit = self.segmenttable.cellWidget(i,2)
        sv = float(str(svedit.text()))
        ramp = aw.qmc.stringtoseconds(str(rampedit.text()))
        soak = aw.qmc.stringtoseconds(str(soakedit.text()))
        svkey = "segment" + str(idn) + "sv"
        svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[svkey][1],int(sv*10))
        r1 = aw.ser.sendFUJIcommand(svcommand,8)
        libtime.sleep(0.1) #important time between writings
        rampkey = "segment" + str(idn) + "ramp"
        rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[rampkey][1],ramp)
        r2 = aw.ser.sendFUJIcommand(rampcommand,8)
        libtime.sleep(0.1) #important time between writings
        soakkey = "segment" + str(idn) + "soak"
        soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[soakkey][1],soak)
        r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1) == 8 and len(r2) == 8 and len(r3) == 8:
            aw.fujipid.PXG4[svkey][0] = sv
            aw.fujipid.PXG4[rampkey][0] = ramp
            aw.fujipid.PXG4[soakkey][0] = soak
            self.paintlabels()
            self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak successfully writen",None, QApplication.UnicodeUTF8),5000) 
        else:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None, QApplication.UnicodeUTF8))

###################################################################################
##########################  FUJI PID CLASS DEFINITION  ############################
###################################################################################

# This class can work for either one Fuji PXR or one Fuji PXG. It is used for the controlling PID only.
# NOTE: There is only one controlling PID. The second pid is only used for reading BT and therefore,
# there is no need to create a second PID object since the second pid all it does is read temperature (always use the same command).
# All is needed for the second pid is its unit id number stored in aw.qmc.device[].
# The command to read T is the always the same for PXR and PXG but with the unit ID changed.

class FujiPID(object):
    def __init__(self):
        
        #refer to Fuji PID instruction manual for more information about the parameters and channels
        #dictionary "KEY": [VALUE,MEMORY_ADDRESS]
        self.PXG4={
                  ############ CH1  Selects controller modes 
                  # manual mode 0 = OFF(auto), 1 = ON(manual)
                  "manual": [0,41121],
                  #run or standby 0=OFF(during run), 1 = ON(during standby)
                  "runstandby": [0,41004],
                  #autotuning run command modes available 0=off, 1=on, 2=low
                  "autotuning": [0,41005],
                  #rampsoak command modes available 0=off, 1=run; 2=hold
                  "rampsoak": [0,41082],
                  #select SV sv1,...,sv7
                  "selectsv": [1,41221],
                  #selects PID number behaviour mode: pid1,...,pid7
                  "selectpid": [0,41222],
                  ############ CH2  Main operating pid parameters.
                  #proportional band  P0 (0% to 999.9%)
                  "p": [5,41006],
                  #integration time i0 (0 to 3200.0 sec)
                  "i": [240,41007],
                  #differential time d0 (0.0 to 999.9 sec)
                  "d": [60,41008],
                   ############ CH3 These are 7 pid storage locations
                  "sv1": [300.0,41241], "p1": [5,41242], "i1": [240,41243], "d1": [60,41244],
                  "sv2": [350.0,41251], "p2": [5,41252], "i2": [240,41253], "d2": [60,41254],
                  "sv3": [400.0,41261], "p3": [5,41262], "i3": [240,41263], "d3": [60,41264],
                  "sv4": [450.0,41271], "p4": [5,41272], "i4": [240,41273], "d4": [60,41274],
                  "sv5": [500.0,41281], "p5": [5,41282], "i5": [240,41283], "d5": [60,41284],
                  "sv6": [550.0,41291], "p6": [5,41292], "i6": [240,41293], "d6": [60,41294],
                  "sv7": [575.0,41301], "p7": [5,41302], "i7": [240,41303], "d7": [60,41304],
                  "selectedpid":[7,41225],
                  ############# CH4      Creates a pattern of temperatures (profiles) using ramp soak combination
                  #sv stands for Set Value (desired temperature value)
                  #the time to reach sv is called ramp 
                  #the time to hold the temperature at sv is called soak 
                  "timeunits": [1,41562],  #0=hh.MM (hour:min)  1=MM.SS (min:sec)                             # PXG has two time formats HH:MM (factory default) and MM:SS 
                  # Example. Dry roast phase. selects 3 or 4 minutes                                          # PXG needs to have parameter TIMU set to 1 (MM:SS)
                  "segment1sv": [270.0,41581],"segment1ramp": [180,41582],"segment1soak": [0,41583],          # See PXG Manual chapter 6: Ramp/Soak Time Units to set the parameter TIMU    
                  "segment2sv": [300.0,41584],"segment2ramp": [180,41585],"segment2soak": [0,41586],
                  "segment3sv": [350.0,41587],"segment3ramp": [180,41588],"segment3soak": [0,41589],
                  "segment4sv": [400.0,41590],"segment4ramp": [180,41591],"segment4soak": [0,41591],
                  # Example. Phase to 1C. selects 6 or 8 mins
                  "segment5sv": [530.0,41593],"segment5ramp": [180,41594],"segment5soak": [0,41595],
                  "segment6sv": [530.0,41596],"segment6ramp": [180,41597],"segment6soak": [0,41598],
                  "segment7sv": [540.0,41599],"segment7ramp": [180,41600],"segment7soak": [0,41601],
                  "segment8sv": [540.0,41602],"segment8ramp": [180,41603],"segment8soak": [0,41604],
                  "segment9sv": [550.0,41605],"segment9ramp": [180,41606],"segment9soak": [0,41607],
                  "segment10sv": [550.0,41608],"segment10ramp": [180,41609],"segment10soak": [0,41610],
                  "segment11sv": [560.0,41611],"segment11ramp": [180,41612],"segment11soak": [0,41613],
                  "segment12sv": [560.0,41614],"segment12ramp": [180,41615],"segment12soak": [0,41616],
                  # Eaxample. Finish phase. selects 3 mins for regular coffee or 5 mins for espresso
                  "segment13sv": [570.0,41617],"segment13ramp": [180,41618],"segment13soak": [0,41619],
                  "segment14sv": [570.0,41620],"segment14ramp": [180,41621],"segment14soak": [0,41622],
                  "segment15sv": [580.0,41623],"segment15ramp": [180,41624],"segment15soak": [0,41625],
                  "segment16sv": [580.0,41626],"segment16ramp": [180,41627],"segment16soak": [0,41628],
                  # "rampsoakmode" 0-15 = 1-16 IMPORTANT: Factory setting is 3 (BAD). Set it up to number 0 or it will
                  # sit on stanby (SV blinks) at the end till rampsoakmode changes. It will appear as if the PID broke (unresponsive)
                  "rampsoakmode":[0,41081],
                  "rampsoakpattern": [6,41561],  #ramp soak activation pattern 0=(1-4) 1=(5-8) 2=(1-8) 3=(9-12) 4=(13-16) 5=(9-16) 6=(1-16)
                  ################  CH5    Checks the ramp soak progress, control output, remaining time and other status functions
                  "stat":[41561], #reads only. 0=off,1=1ramp,2=1soak,3=2ramp,4=2soak,...31=16ramp,32=16soak,33=end
                  ################  CH6    Sets up the thermocouple type, input range, output range and other items for the controller
                  #input type: 0=NA,1=PT100ohms,2=J,3=K,4=R,5=B,6=S,7=T,8=E,12=N,13=PL2,15=(0-5volts),16=(1-5V),17=(0-10V),18=(2-10V),19=(0-100mV)
                  "pvinputtype": [3,41016],
                  "pvinputlowerlimit":[0,41018],
                  "pvinputupperlimit":[9999,41019],
                  "decimalposition": [1,41020],
                  "unitdisplay":[1,41345],         #0=Celsius; 1=Fahrenheit
                  #################  CH7    Assigns functions for DI (digital input), DO (digital output), LED lamp and other controls
                  "rampslopeunit":[1,41432], #0=hour,1=min
                  "controlmethod":[0,41002],  #0=pid,2=fuzzy,2=self,3=pid2
                  #################  CH8     Sets the defect conditions for each type of alarm
                  #################  CH9     Sets the station number id and communication parameters of the PID controller
                  #################  CH10    Changes settings for valve control 
                  #################  CH11    Sets passwords
                  #################  CH12    Sets the parameters mask functions to hide parameters from the user
                  ################# READ ONLY MEMORY (address starts with digit 3)
                  "pv?":[31001],"sv?":[0,31002],"alarm?":[31007],"fault?":[31008],"stat?":[31041],"mv1":[0,31042]
                  }
        # "KEY": [VALUE,MEMORY_ADDRESS]
        self.PXR = {"autotuning":[0,41005],
                    "segment1sv":[100.0,41057],"segment1ramp":[3,41065],"segment1soak":[0,41066], #PXR uses only HH:MM time format but stored as minutes in artisan
                    "segment2sv":[100.0,41058],"segment2ramp":[3,41067],"segment2soak":[0,41068],
                    "segment3sv":[100.0,41059],"segment3ramp":[3,41069],"segment3soak":[0,41070],
                    "segment4sv":[100.0,41060],"segment4ramp":[3,41071],"segment4soak":[0,41072],
                    "segment5sv":[100.0,41061],"segment5ramp":[3,41073],"segment5soak":[0,41074],
                    "segment6sv":[100.0,41062],"segment6ramp":[3,41075],"segment6soak":[0,41076],
                    "segment7sv":[100.0,41063],"segment7ramp":[3,41077],"segment7soak":[0,41078],
                    "segment8sv":[100.0,41064],"segment8ramp":[3,41079],"segment8soak":[0,41080],
                    #Tells what to do after finishing or how to start. See documentation under ramp soak pattern: 0-15 
                    "rampsoakmode":[0,41081],
                    #rampsoak command 0=OFF, 1= RUN, 2= HALTED, 3=END
                    "rampsoak":[0,41082],
                    #ramp soak pattern. 0=executes 1 to 4; 1=executes 5 to 8; 2=executes 1 to 8
                    "rampsoakpattern":[0,41083],
                    #PID=0,FUZZY=1,SELF=2
                    "controlmethod":[0,41002],
                    #sv set value
                    "sv0":[0,41003],
                    # run standby 0=RUN 1=STANDBY
                    "runstandby": [0,41004],
                    "p":[5,41006],
                    "i":[240,41007],
                    "d":[60,41008],
                    "decimalposition": [1,41020],
                    "svlowerlimit":[0,41031],
                    "svupperlimit":[0,41032],
                    "pvinputtype":[3,41016],
                    #READ ONLY
                    #current pv
                    "pv?":[0,31001],
                    #current sv on display (during ramp soak it changes)
                    "sv?":[0,31002],
                    #rampsoak current running position (1-8)
                    "segment?":[0,31009],
                    "mv1":[0,30004]   #duty cycle rx -300 to 10300  = -3.00% to 103.00% (divide by 100.)
                    }

    ##TX/RX FUNCTIONS
    #This function reads read-only memory (with 3xxxx memory we need function=4)
    #both PXR3 and PXG4 use the same memory location 31001 (3xxxx = read only)
    def gettemperature(self, stationNo):
        #we compose a message then we send it by using self.readoneword()
#        import binascii
#        try:
#            print(binascii.hexlify(bytes(self.message2send(stationNo,4,31001,1),"latin1")))
#        except Exception as ex:
#            print(ex)
        return self.readoneword(self.message2send(stationNo,4,31001,1))

    #activates the PID SV buttons in the main window to adjust the SV value. Called from the PID control pannels/SV tab
    def activateONOFFeasySV(self,flag):
        #turn off
        if flag == 0:
            aw.button_12.setVisible(False)
            aw.button_13.setVisible(False)
            aw.button_14.setVisible(False)
            aw.button_15.setVisible(False)
            aw.button_16.setVisible(False)
            aw.button_17.setVisible(False)
        #turn on
        elif flag == 1:
            A = QLabel()
            reply = QMessageBox.question(A,QApplication.translate("Message","Activate PID front buttons",None, QApplication.UnicodeUTF8),
                                         QApplication.translate("Message","Remember SV memory has a finite\nlife of ~10,000 writes.\n\nProceed?",None, QApplication.UnicodeUTF8),
                                         QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Cancel:
                return 
            elif reply == QMessageBox.Yes:
                aw.button_12.setVisible(True)
                aw.button_13.setVisible(True)
                aw.button_14.setVisible(True)
                aw.button_15.setVisible(True)
                aw.button_16.setVisible(True)
                aw.button_17.setVisible(True)

    def readcurrentsv(self):
        command = ""
        #if control pid is fuji PXG4
        if aw.ser.controlETpid[0] == 0:
            command = self.message2send(aw.ser.controlETpid[1],4,self.PXG4["sv?"][1],1)
        #or if control pid is fuji PXR
        elif aw.ser.controlETpid[0] == 1:
            command = self.message2send(aw.ser.controlETpid[1],4,self.PXR["sv?"][1],1)
        val = self.readoneword(command)/10.
        if val != -0.1:
            return val
        else:
            return -1

    def readdutycycle(self):
        command = ""
        #if control pid is fuji PXG4
        if aw.ser.controlETpid[0] == 0:
            command = self.message2send(aw.ser.controlETpid[1],4,self.PXG4["mv1"][1],1)
        #or if control pid is fuji PXR
        elif aw.ser.controlETpid[0] == 1:
            command = self.message2send(aw.ser.controlETpid[1],4,self.PXR["mv1"][1],1)
        val = self.readoneword(command)/100.
        if val != -0.01:
            return val
        else:
            return -1

    #turns ON turns OFF current ramp soak mode
    #flag =0 OFF, flag = 1 ON, flag = 2 hold
    #A ramp soak pattern defines a whole profile. They have a minimum of 4 segments.
    def setrampsoak(self,flag):
        command = ""
        #Fuji PXG 
        if aw.ser.controlETpid[0] == 0:
            command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4["rampsoak"][1],flag)
        #Fuji PXR
        elif aw.ser.controlETpid[0] == 1:
            command = self.message2send(aw.ser.controlETpid[1],6,self.PXR["rampsoak"][1],flag)
        r = aw.ser.sendFUJIcommand(command,8)
        #if OK
        if r == command:
            if flag == 1:
                aw.sendmessage(QApplication.translate("Message","RS ON", None, QApplication.UnicodeUTF8))
            elif flag == 0:
                aw.sendmessage(QApplication.translate("Message","RS OFF", None, QApplication.UnicodeUTF8))
            else:
                aw.sendmessage(QApplication.translate("Message","RS on HOLD", None, QApplication.UnicodeUTF8))
        else:
            aw.qmc.adderror(QApplication.translate("Error Message","RampSoak could not be changed",None, QApplication.UnicodeUTF8))

    #sets a new sv value
    def setsv(self,value):
        command = ""
        #Fuji PXG 
        if aw.ser.controlETpid[0] == 0: 
            #send command to the current sv (1-7)
            svkey = "sv"+ str(aw.fujipid.PXG4["selectsv"][0]) #current sv
            command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],int(value*10))
            r = aw.ser.sendFUJIcommand(command,8)
            #check response
            if r == command:
                # [Not sure the following will translate or even format properly... Need testing!]
                message = QApplication.translate("Message","PXG sv#%1 set to %2",None, QApplication.UnicodeUTF8).arg(self.PXG4["selectsv"][0]).arg("%.1f" % float(value))
                aw.sendmessage(message)
                self.PXG4[svkey][0] = value
                #record command as an Event 
                strcommand = "SETSV::" + str("%.1f"%float(value))
                aw.qmc.DeviceEventRecord(strcommand)
                aw.lcd6.display("%.1f"%float(value))
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setPXGsv()")
                return -1
        #Fuji PXR
        elif aw.ser.controlETpid[0] == 1:  
            command = self.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["sv0"][1],int(value*10))
            r = aw.ser.sendFUJIcommand(command,8)
            #check response
            if r == command:
                # [Not sure the following will translate or even format properly... Need testing!]
                message = QApplication.translate("Message","PXR sv set to %1",None, QApplication.UnicodeUTF8).arg("%.1f" % float(value))
                aw.fujipid.PXR["sv0"][0] = value
                aw.sendmessage(message)
                #record command as an Event 
                strcommand = "SETSV::" + str("%.1f"%float(value))
                aw.qmc.DeviceEventRecord(strcommand)
                aw.lcd6.display("%.1f"%float(value))
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " setPXRsv()")
                return -1

    #used to set up or down SV by diff degrees from current sv setting
    def adjustsv(self,diff):
        currentsv = self.readcurrentsv()
        if currentsv != -1:
            newsv = int((currentsv + diff)*10.)          #multiply by 10 because we use a decimal point
            #   if control pid is fuji PXG
            if aw.ser.controlETpid[0] == 0:
                # read the current svN (1-7) being used
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,self.PXG4["selectsv"][1],1)
                N = aw.fujipid.readoneword(command)
                if N != -1:
                    self.PXG4["selectsv"][0] = N
                    svkey = "sv" + str(N)
                    command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],newsv)
                    r = aw.ser.sendFUJIcommand(command,8)
                    if len(r) == 8:
                        message = QApplication.translate("Message","SV%1 changed from %2 to %3)",None, QApplication.UnicodeUTF8).arg(str(N)).arg(str(currentsv)).arg(str(newsv/10.))
                        aw.sendmessage(message)
                        self.PXG4[svkey][0] = newsv/10
                        #record command as an Event to replay (not binary as it needs to be stored in a text file)
                        strcommand = "SETSV::" + str("%.1f"%(newsv/10.))
                        aw.qmc.DeviceEventRecord(strcommand)
                        aw.lcd6.display("%.1f"%float(newsv/10.))
                    else:
                        msg = QApplication.translate("Message","Unable to set sv%1",None, QApplication.UnicodeUTF8).arg(str(N))
                        aw.sendmessage(msg)
            #   or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                command = self.message2send(aw.ser.controlETpid[1],6,self.PXR["sv0"][1],newsv)
                r = aw.ser.sendFUJIcommand(command,8)
                if len(r) == 8:
                    message = QApplication.translate("Message","SV changed from %1 to %2",None, QApplication.UnicodeUTF8).arg(str(currentsv)).arg(str(newsv/10.))                           
                    aw.sendmessage(message)
                    self.PXR["sv0"][0] = newsv/10
                    #record command as an Event to replay (not binary as it needs to be stored in a text file)
                    strcommand = "SETSV::" + str("%.1f"%(newsv/10.))
                    aw.qmc.DeviceEventRecord(strcommand)
                    aw.lcd6.display("%.1f"%float(newsv/10.))
                else:
                    aw.sendmessage(QApplication.translate("Message","Unable to set sv", None, QApplication.UnicodeUTF8))
        else:
            aw.sendmessage(QApplication.translate("Message","Unable to set new sv", None, QApplication.UnicodeUTF8))

    #format of the input string Command: COMMAND::VALUE1::VALUE2::VALUE3::ETC
    def replay(self,CommandString):
        parts = CommandString.split("::")
        command = parts[0]
        values = parts[1:]
        if command == "SETSV":
            self.setsv(float(values[0]))
            return
        elif command == "SETRS":
            self.replaysetrs(CommandString)
            return

    #example of command string with four segments (minimum for Fuji PIDs)
    # SETRS::270.0::3::0::SETRS::300.0::3::0::SETRS::350.0::3::0::SETRS::400.0::3::0
    def replaysetrs(self,CommandString):
        segments =CommandString.split("SETRS")
        if len(segments[0]) == 0:
            segments = segments[1:]          #remove first empty [""] list [[""],[etc]]
        if len(segments[-1]) == 0:
            segments = segments[:-1]          #remove last empty [""] list [[etc][""]]
        n = len(segments)
        #if parts is < 4, make it compatible with Fuji PID (4 segments needed)
        if n < 4:
            for i in range(4-n):
                #last temperature
                lasttemp = segments[-1].split("::")[1]
                #create a string with 4 segments ("SETRS" alredy removed) 
                string = "::" + lasttemp + "::0::0"   #add zero ramp time and zero soak time
                segments.append(string)
        rs = []
        changeflag = 0
        for i in range(n):
            rs.append(segments[i].split("::"))
            if len(rs[i][0]) == 0:          #remove first empty u"" [u"",u"300.5",u"3",u"0",u""] if one found
                rs[i] = rs[i][1:]
            if len(rs[i][-1]) == 0:          #remove last empty u"" [u"300.5",u"3",u"0",u""] if one found
                rs[i] = rs[i][:-1]
            if len(rs[i]) == 3:
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                if aw.ser.controlETpid[0] == 0:             #PXG4
                    if not n%4 or n > 16:
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PXG4 replaysetrs(): %1").arg(n))
                        return
                    if self.PXG4[svkey][0] != float(rs[i][0]):
                        self.PXG4[svkey][0] = float(rs[i][0])
                        changeflag = 1
                    if self.PXG4[rampkey][0] != int(rs[i][1]):
                        self.PXG4[rampkey][0] = int(rs[i][1])
                        changeflag = 1
                    if self.PXG4[soakkey][0] != int(rs[i][2]):
                        self.PXG4[soakkey][0] = int(rs[i][2])
                        changeflag = 1
                    if changeflag:
                        self.setsegment((i+1), self.PXG4[svkey][0], self.PXG4[rampkey][0] ,self.PXG4[soakkey][0])
                        changeflag = 0
                elif aw.ser.controlETpid[0] == 1:           #PXR
                    if not n%4 or n > 8:
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " PXR replaysetrs(): %1").arg(n))
                        return
                    if self.PXR[svkey][0] != float(rs[i][0]):
                        self.PXR[svkey][0] = float(rs[i][0])
                        changeflag = 1
                    if self.PXR[rampkey][0] != int(rs[i][1]):
                        self.PXR[rampkey][0] = int(rs[i][1])
                        changeflag = 1
                    if self.PXR[soakkey][0] != int(rs[i][2]):
                        self.PXR[soakkey][0] = int(rs[i][2])
                        changeflag = 1
                    if changeflag:
                        self.setsegment((i+1), self.PXR[svkey][0], self.PXR[rampkey][0] ,self.PXR[soakkey][0])
                        changeflag = 0
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None, QApplication.UnicodeUTF8) + " replaysetrs()")
                return
        #start ramp soak ON
        self.setrampsoak(1)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    #used in replaysetrs()    
    def setsegment(self,idn,sv,ramp,soak):
        svkey = "segment" + str(idn) + "sv"
        rampkey = "segment" + str(idn) + "ramp"
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.controlETpid[0] == 0:
            svcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],int(sv*10))
            rampcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[rampkey][1],ramp)
            soakcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[soakkey][1],soak)
        elif  aw.ser.controlETpid[0] == 1:
            svcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[svkey][1],int(sv*10))
            rampcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[rampkey][1],ramp)
            soakcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[soakkey][1],soak)
        r1 = aw.ser.sendFUJIcommand(svcommand,8)
        libtime.sleep(0.11) #important time between writings
        r2 = aw.ser.sendFUJIcommand(rampcommand,8)
        libtime.sleep(0.11) #important time between writings
        r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1)!=8 or len(r2)!=8 or len(r3)!=8:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None, QApplication.UnicodeUTF8))

    def dec2HexRaw(self,decimal):
        # This method converts a decimal to a raw string appropiate for Fuji serial TX
        # Used to compose serial messages
        Nbytes = []
        while decimal:
            decimal, rem = divmod(decimal, 256)
            Nbytes.append(rem)
        Nbytes.reverse()
        if not Nbytes:
            Nbytes.append(0)
        return  "".join(chr(b) for b in Nbytes)

    def message2send(self, stationNo, FunctionCode, memory, Nword):
        # This method takes the arguments to compose a Fuji serial command and returns the complete raw string with crc16 included
        # memory must be given as the Resistor Number Engineering unit (example of memory = 41057 )
        #check to see if Nword is < 257. If it is, then add extra zero pad. 2^8 = 256 = 1 byte but 2 bytes always needed to send Nword
        if Nword < 257:
            pad1 = self.dec2HexRaw(0)
        else:
            pad1 = ""
        part1 = self.dec2HexRaw(stationNo)
        part2 = self.dec2HexRaw(FunctionCode)
        _,r = divmod(memory,10000)
        part3 = self.dec2HexRaw(r - 1)
        part4 = self.dec2HexRaw(Nword)
        datastring = part1 + part2 + part3 + pad1 + part4
        # calculate the crc16 of all this data string
        crc16int = self.fujiCrc16(datastring)
        #convert crc16 to hex string to change the order of the 2 bytes from AB.CD to CD.AB to match Fuji requirements
        crc16hex= hex(crc16int)[2:]
        #we need 4 chars but sometimes we get only three or two because of abreviations by hex(). Therefore, add "0" if needed.
        ll = 4 - len(crc16hex)
        pad =["","0","00","000"]
        crc16hex = pad[ll] + crc16hex
        #change now from AB.CD to CD.AB and convert from hex string to int
        crc16end = int(crc16hex[2:]+crc16hex[:2],16)
        #now convert the crc16 from int to binary
        part5 = self.dec2HexRaw(crc16end)
        #return total sum of binary parts  (assembled message)
        return (datastring + part5)

    #input string command. Output integer (not binary string); used for example to read temperature or to obtain the value of a variable
    def readoneword(self,command):
        #takes an already formated command to read 1 word data and returns the response from the pid
        #SEND command and RECEIVE 7 bytes back
        r = aw.ser.sendFUJIcommand(command,7)
        if len(r) == 7:
            # EVERYTHINK OK: convert data part binary string to hex representation
            s1 = hex2int(r[3],r[4])
            #conversion from hex to dec
            return s1
        else:
            #bad number of RX bytes 
            errorcode = QApplication.translate("Error Message","pid.readoneword(): %1 RX bytes received (7 needed) for unit ID=%2",None, QApplication.UnicodeUTF8).arg(len(r)).arg(ord(command[0]))
            aw.qmc.adderror(errorcode)
            return -1

    #FUJICRC16 function calculates the CRC16 of the data. It expects a binary string as input and returns an int
    def fujiCrc16(self,string):
        crc16tab = (0x0000,
                    0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
                    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880,
                    0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0,
                    0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100,
                    0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,
                    0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80,
                    0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0,
                    0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200,
                    0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
                    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80,
                    0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0,
                    0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700,
                    0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,
                    0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80,
                    0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0,
                    0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400,
                    0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040)
        cr=0xFFFF 
        for j in string:
            tmp = cr ^(ord(j))
            cr =(cr >> 8)^crc16tab[(tmp & 0xff)]
        return cr

############################################################################
######################## Arduino CONTROL DIALOG ######################
############################################################################

#class ArduinoDlgControl(ArtisanDialog):
#    def __init__(self, parent = None):
#        super(ArduinoDlgControl,self).__init__(parent)
#        self.setAttribute(Qt.WA_DeleteOnClose)
#        self.setWindowTitle(QApplication.translate("Form Caption","Arduino Control",None, QApplication.UnicodeUTF8))
#        self.status = QStatusBar()
#        self.status.setSizeGripEnabled(False)
#        self.status.showMessage(QApplication.translate("StatusBar","Work in Progress",None, QApplication.UnicodeUTF8),5000)
#        reinitbutton = QPushButton(QApplication.translate("Button","Reinitialize Arduino", None, QApplication.UnicodeUTF8))
#        self.connect(reinitbutton,SIGNAL("clicked()"),self.initArduino)
#        tab1Layout = QGridLayout()
#        tab1Layout.addWidget(reinitbutton,0,0)
#        ############################
#        TabWidget = QTabWidget()
#        C1Widget = QWidget()
#        C1Widget.setLayout(tab1Layout)
#        TabWidget.addTab(C1Widget,QApplication.translate("Tab","General",None, QApplication.UnicodeUTF8))
#        mainlayout = QVBoxLayout()
#        mainlayout.addWidget(self.status,0)
#        mainlayout.addWidget(TabWidget,1)
#        self.setLayout(mainlayout)
#
#    def initArduino(self):
#        aw.ser.ArduinoIsInitialized = 0
#        message = QApplication.translate("Message","ArduinoTC4 has been reinitialized.",None, QApplication.UnicodeUTF8)
#        aw.sendmessage(message)

############################################################################
######################## DTA PID CONTROL DIALOG ######################
############################################################################

class DTApidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(DTApidDlgControl,self).__init__(parent)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Delta DTA PID Control",None, QApplication.UnicodeUTF8))
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Work in Progress",None, QApplication.UnicodeUTF8),5000)
        svlabel = QLabel(QApplication.translate("Label", "SV", None, QApplication.UnicodeUTF8))  
        self.svedit = QLineEdit(str(aw.dtapid.dtamem["sv"][0]))
        self.svedit.setValidator(QDoubleValidator(0., 999.,1, self.svedit))
        readsvbutton = QPushButton(QApplication.translate("Button","Read", None, QApplication.UnicodeUTF8))
        writesvbutton = QPushButton(QApplication.translate("Button","Write", None, QApplication.UnicodeUTF8))
        self.connect(readsvbutton,SIGNAL("clicked()"),self.readsv)
        self.connect(writesvbutton,SIGNAL("clicked()"),self.writesv)
        tab1Layout = QGridLayout()
        tab1Layout.addWidget(svlabel,0,0)
        tab1Layout.addWidget(self.svedit,0,1)
        tab1Layout.addWidget(readsvbutton,0,2)
        tab1Layout.addWidget(writesvbutton,0,3)
        ############################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","General",None, QApplication.UnicodeUTF8))
        mainlayout = QVBoxLayout()
        mainlayout.addWidget(self.status,0)
        mainlayout.addWidget(TabWidget,1)
        self.setLayout(mainlayout)

    def readsv(self):
        ### create command message2send(unitID,function,address,ndata)
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],3,aw.dtapid.dtamem["sv"][1],1)
        #read sv
        sv = aw.ser.sendDTAcommand(command)
        #update SV value 
        aw.dtapid.dtamem["sv"][0] = sv
        #update svedit
        self.svedit.setText(str(sv)) 
        #update sv LCD
        aw.lcd6.display(sv)
        #update status
        message = QApplication.translate("StatusBar","SV = %s"%(str(sv)),None, QApplication.UnicodeUTF8)
        self.status.showMessage(message,5000)

    #write uses function = 6
    def writesv(self):
        newsv = hex(int(abs(float(str(self.svedit.text())))*10.))[2:].upper()
        ### create command message2send(unitID,function,address,ndata)
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],6,aw.dtapid.dtamem["sv"][1],newsv)
        #read sv
        aw.ser.sendDTAcommand(command)

###################################################################################
##########################  ARDUINO CLASS DEFINITION  ############################
###################################################################################
class ArduinoTC4(object):
    def __init__(self):
        pass

###################################################################################
##########################  DTA PID CLASS DEFINITION  ############################
###################################################################################
# documentation
# http://www.deltaww.hu/homersekletszabalyozok/DTA_series_temperature_controller_instruction_sheet_English.pdf
class DtaPID(object):
    def __init__(self):
        #refer to Delta instruction manual for more information
        #dictionary "KEY": [VALUE,ASCII_MEMORY_ADDRESS]  note: address contains hex alpha characters
        self.dtamem={
                  "pv": [0,"4700"],             # process value (temperature reading)
                  "sv": [100.0,"4701"],           # set point
                  "p": [5,"4708"],              # p value 0-9999
                  "i": [240,"4709"],            # i value 0-9999
                  "d": [60,"470A"],             # d value 0-9999
                  "sensortype": [0,"4710"],     # 0 = K type1; 1 = K type2; 2 = J type1; 3 = J type2
                                                # 4 = T type1; 5 = T type2; 6 = E ; 7 = N; 8 = R; 9 = S; 10 = B
                                                # 11 = JPT100 type1; 12 = JPT100 type2; 13 = PT100 type1; 14 = PT100 type2
                                                # 15 = PT100 type3; 16 = L ; 17 = U; 18 = Txk
                  "controlmethod":[0,"4711"],   # 0 = pid; 1 = ON/OFF; 2 = manual
                  "units":[1,"4717"],           # units C = 1; F = 2
                  "controlsetting":[1,"4719"],  # 1=Run; 0 = Stop  
                  "error":[0,"472B"]            # note: read only memory. Values:
                                                # 0 = Normal,1 = Initial process; 2 = Initial status;
                                                # 3 = sensor not connected; 4 = sensor input error
                                                # 5 = Exceeds max temperature; 6 = Number Internal error
                                                # 7 EEPROM error
                  }
    #command  string = ID (ADR)+ FUNCTION (CMD) + ADDRESS + NDATA + LRC_CHK 
    def writeDTE(self,value,DTAaddress):
        newsv = hex(int(abs(float(str(value)))))[2:].upper()
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],6,str(DTAaddress),newsv)
        aw.ser.sendDTAcommand(command)

    def message2send(self,unitID,FUNCTION,ADDRESS, NDATA):
        #compose command
        string_unitID = str(unitID).zfill(2)
        string_FUNCTION = str(FUNCTION).zfill(2)
        string_ADDRESS = ADDRESS                 #ADDRESS is a 4 char string
        string_NDATA = str(NDATA).zfill(4)
        cmd = string_unitID + string_FUNCTION + string_ADDRESS + string_NDATA
        checksum = hex(self.DTACalcChecksum(cmd))[2:].zfill(2).upper()
        command = ":" + cmd + checksum + "\r\n"
        return command

    def DTACalcChecksum(self,string):
        def tobin(x, count=8):
            return "".join([str((x>>y)&1) for y in range(count-1, -1, -1)])
        def twoscomp(num_str):
            return tobin(-int(num_str,2),len(num_str))
        length = len(string)
        # start at index 1 because of heading ':' cmd
        count = 0
        val = 0x00
        while count < length:
            val +=  int(string[count] + string[count+1], 16)  #string[count+1] goes out of range
            count += 2
        h_bs = bin(val)[2:]
    #    print "val:", val, h_bs
        h2comp = twoscomp(h_bs)
    #    print "2comp(val):", twoscomp(h_bs), hex(int(h2comp,2))
        rval = int(h2comp,2)
    #    print "val:", rval
        if (val & 0x80) == 0:
            rval = rval | 0x80
    #    print "comp:", rval
        return rval

###########################################################################################################################################
###########################################################################################################################################

def main():
    global aw
    aw = None # this is to ensure that the variable aw is already defined during application initialization
    aw = ApplicationWindow()
    
#    db = QFontDatabase()
#    for f in db.families(6):
#        print(str(f))
        
#    md = mpl.font_manager.findSystemFonts()
    
    try:
        aw.defaultAppearance = str(aw.style().objectName()).lower()
    except:
        pass
    aw.settingsLoad()
    mpl.rcParams['font.family'] = aw.defaultFont # set default font family for the subplot annotations
    # the following does not work on OS X
    #mpl.rc('font', **{'sans-serif' : aw.defaultFont,'family' : 'sans-serif'})
    
    try:
        argv_file = sys.argv[1]
        qfile = QFileInfo(u(argv_file))
        file_suffix = u(qfile.suffix())
        if file_suffix == "alog":
            # load Artisan profile on double-click on *.alog file
            aw.loadFile(u(argv_file))
        elif file_suffix == "alrm":
            # load Artisan alarms on double-click on *.alrm file
            aw.loadAlarms(u(argv_file))
        elif file_suffix == "apal":
            # load Artisan palettes on double-click on *.apal file
            aw.loadPalettes(u(argv_file))
    except Exception:
        pass
    aw.show()
    #the following line is to trap numpy warnings that occure in the Cup Profile dialog if all values are set to 0
    with numpy.errstate(invalid='ignore'):
        app.exec_()

##############################################################################################################################################
##############################################################################################################################################
